<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>[CDI@Work]:AI &ndash; CDI and Apache DeltaSpike</title>
  <meta name="description" content="[CDI@Work]:AI, Author: Gerhard Petracek">
  <meta name="author" content="Gerhard Petracek">
  <style>
    /* ===== Reset & Base ===== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    html {
      scroll-behavior: smooth;
      font-size: 17px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.7;
      color: #2c3e50;
      background: #f8f9fa;
    }

    /* ===== Sidebar ===== */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 300px;
      height: 100vh;
      background: #1a1f36;
      color: #c8ccd4;
      overflow-y: auto;
      z-index: 100;
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .sidebar-brand {
      padding: 1.5rem 1.25rem 1rem;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      flex-shrink: 0;
    }

    .sidebar-brand h1 {
      font-size: 1.25rem;
      font-weight: 700;
      color: #fff;
      letter-spacing: -0.02em;
    }

    .sidebar-brand .subtitle {
      font-size: 0.75rem;
      color: #8892a4;
      margin-top: 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .sidebar-brand .lang-switch {
      display: inline-block;
      font-size: 0.7rem;
      color: #8892a4;
      text-decoration: none;
      margin-top: 0.5rem;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 0.2rem 0.6rem;
      border-radius: 4px;
      transition: color 0.2s, border-color 0.2s;
    }

    .sidebar-brand .lang-switch:hover {
      color: #fff;
      border-color: rgba(255,255,255,0.4);
    }

    #toc {
      flex: 1;
      overflow-y: auto;
      padding: 0.75rem 0;
    }

    .toc-header { display: none; }

    .toc-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .toc-chapter {
      margin-bottom: 0.15rem;
    }

    .toc-chapter > a.toc-h1 {
      display: block;
      padding: 0.5rem 1.25rem;
      font-size: 0.82rem;
      font-weight: 600;
      color: #e2e6ed;
      text-decoration: none;
      transition: background 0.15s, color 0.15s;
      border-left: 3px solid transparent;
    }

    .toc-chapter > a.toc-h1:hover {
      background: rgba(255,255,255,0.05);
      color: #fff;
    }

    .toc-chapter > a.toc-h1.active {
      background: rgba(99, 128, 255, 0.12);
      color: #8fa4ff;
      border-left-color: #6380ff;
    }

    .toc-sections {
      list-style: none;
      padding: 0;
      margin: 0;
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.35s ease;
    }

    .toc-chapter.expanded .toc-sections {
      max-height: 2000px;
    }

    .toc-section a.toc-h2,
    .toc-subsection a.toc-h3 {
      display: block;
      padding: 0.3rem 1.25rem 0.3rem 2rem;
      font-size: 0.76rem;
      color: #8892a4;
      text-decoration: none;
      transition: color 0.15s, background 0.15s;
    }

    .toc-subsection a.toc-h3 {
      padding-left: 2.75rem;
      font-size: 0.72rem;
    }

    .toc-section a.toc-h2:hover,
    .toc-subsection a.toc-h3:hover {
      color: #c8ccd4;
      background: rgba(255,255,255,0.03);
    }

    .toc-section a.toc-h2.active,
    .toc-subsection a.toc-h3.active {
      color: #8fa4ff;
    }

    /* ===== Main Content ===== */
    .main-content {
      margin-left: 300px;
      min-height: 100vh;
    }

    .content-wrapper {
      max-width: 800px;
      margin: 0 auto;
      padding: 2.5rem 2rem 4rem;
    }

    .sticky-disclaimer {
      position: sticky;
      top: 0;
      z-index: 90;
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 0 0 8px 8px;
      padding: 0.75em 1.5em;
      margin: -2.5rem -2rem 2em -2rem;
      font-size: 0.9em;
      color: #856404;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      opacity: 0.85;
    }

    /* ===== Mobile Hamburger ===== */
    .hamburger {
      display: none;
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 200;
      background: #1a1f36;
      color: #fff;
      border: none;
      border-radius: 8px;
      width: 44px;
      height: 44px;
      cursor: pointer;
      font-size: 1.4rem;
      line-height: 1;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      align-items: center;
      justify-content: center;
    }

    .overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 90;
    }

    /* ===== Typography ===== */
    h1 {
      font-size: 1.9rem;
      font-weight: 800;
      color: #1a1f36;
      margin: 3rem 0 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 3px solid #6380ff;
      letter-spacing: -0.02em;
      line-height: 1.3;
    }

    section:first-child h1:first-of-type {
      margin-top: 0;
    }

    h2 {
      font-size: 1.4rem;
      font-weight: 700;
      color: #2c3550;
      margin: 2.5rem 0 0.75rem;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #e0e4ea;
      line-height: 1.35;
    }

    h3 {
      font-size: 1.15rem;
      font-weight: 600;
      color: #3a4260;
      margin: 2rem 0 0.6rem;
    }

    h4 {
      font-size: 1rem;
      font-weight: 600;
      color: #4a5270;
      margin: 1.5rem 0 0.5rem;
    }

    p, .content-wrapper > br {
      margin-bottom: 0.5rem;
    }

    a {
      color: #4361ee;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
      color: #3a56d4;
    }

    .entry-number {
      color: #6380ff;
      font-weight: 700;
      margin-right: 0.4em;
    }

    /* ===== LaTeX Content Classes ===== */
    .latex-texttt {
      font-family: 'SFMono-Regular', 'Consolas', 'Liberation Mono', 'Menlo', monospace;
      font-size: 0.88em;
      background: #eef0f5;
      padding: 0.15em 0.4em;
      border-radius: 4px;
      color: #c7254e;
      word-break: break-word;
    }

    .latex-textit {
      font-style: italic;
    }

    .latex-textbf {
      font-weight: 700;
    }

    .latex-unknwown-link {
      font-style: italic;
      color: #888;
    }

    .latex-footnote-marker {
      font-weight: 700;
      color: #4361ee;
      border-bottom: 2px solid #4361ee;
      padding-bottom: 1px;
      margin-right: 0.3em;
    }

    .latex-index-anchor {
      text-decoration: none;
      color: inherit;
    }

    .latex-index-anchor:hover {
      text-decoration: none;
      color: inherit;
    }

    /* ===== Code Blocks ===== */
    .latex-begin-block {
      margin: 1.25rem 0;
    }

    .latex-begin-block pre {
      background: #1e1e2e;
      color: #cdd6f4;
      padding: 1.1rem 1.25rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.82rem;
      line-height: 1.6;
      border: 1px solid #313244;
    }

    .latex-begin-block pre code {
      font-family: 'SFMono-Regular', 'Consolas', 'Liberation Mono', 'Menlo', monospace;
      background: none;
      padding: 0;
      color: inherit;
    }

    /* ===== Tip Boxes ===== */
    .tip {
      background: #f0f4ff;
      border-left: 4px solid #4361ee;
      padding: 1rem 1.25rem;
      margin: 1.25rem 0;
      border-radius: 0 8px 8px 0;
      font-size: 0.93rem;
    }

    .tip b {
      color: #4361ee;
    }

    /* ===== Tables ===== */
    .latex-table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      font-size: 0.88rem;
    }

    .latex-table-header-cell {
      background: #2c3550;
      color: #fff;
      font-weight: 600;
      padding: 0.6rem 0.8rem;
      text-align: left;
      border: 1px solid #3a4568;
    }

    .latex-table-body-cell {
      padding: 0.5rem 0.8rem;
      border: 1px solid #e0e4ea;
    }

    .latex-table-body-row:nth-child(even) .latex-table-body-cell {
      background: #f4f6fa;
    }

    .latex-table-body-row:hover .latex-table-body-cell {
      background: #e8ecf4;
    }

    /* Hide empty header rows (LaTeX artifacts) */
    .latex-table-header-row:first-child:empty,
    .latex-table-header-row:last-child:empty {
      display: none;
    }
    .latex-table-header-row:not(:has(td)) {
      display: none;
    }

    /* ===== Spacing helpers ===== */
    /* Remove excessive blank spacers from LaTeX output */
    p[style*="margin:0"] {
      margin: 0.6rem 0 !important;
      line-height: normal !important;
    }

    /* ===== Chapter sections ===== */
    .chapter-section {
      padding-bottom: 2rem;
    }

    .chapter-section + .chapter-section {
      border-top: 1px solid #e0e4ea;
      padding-top: 1rem;
    }

    /* ===== Responsive ===== */
    @media (max-width: 900px) {
      .sidebar {
        transform: translateX(-100%);
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .hamburger {
        display: flex;
      }

      .overlay.active {
        display: block;
      }

      .main-content {
        margin-left: 0;
      }

      .content-wrapper {
        padding: 1.5rem 1rem 3rem;
        padding-top: 4rem;
      }

      .sticky-disclaimer {
        margin: -4rem -1rem 2em -1rem;
        border-radius: 0;
      }
    }

    @media (max-width: 600px) {
      html { font-size: 15px; }

      h1 { font-size: 1.5rem; }
      h2 { font-size: 1.2rem; }

      .latex-begin-block pre {
        font-size: 0.75rem;
        padding: 0.8rem;
      }

      .latex-table {
        font-size: 0.8rem;
      }
    }

    /* ===== Print Styles ===== */
    @media print {
      body {
        font-family: 'Georgia', 'Times New Roman', serif;
        font-size: 11pt;
        line-height: 1.5;
        color: #000;
        background: #fff;
      }

      .sidebar, .hamburger, .overlay, .sticky-disclaimer {
        display: none !important;
      }

      .main-content {
        margin-left: 0;
      }

      .content-wrapper {
        max-width: 100%;
        padding: 0;
      }

      h1 {
        font-size: 18pt;
        border-bottom: 2px solid #000;
        color: #000;
        page-break-after: avoid;
      }

      h2 {
        font-size: 14pt;
        border-bottom: 1px solid #666;
        color: #000;
        page-break-after: avoid;
      }

      h3 {
        font-size: 12pt;
        color: #000;
        page-break-after: avoid;
      }

      .chapter-section {
        page-break-before: always;
      }

      .chapter-section:first-child {
        page-break-before: avoid;
      }

      .entry-number { color: #000; }

      .latex-texttt {
        background: none;
        border: 1px solid #ccc;
        padding: 0 0.2em;
        color: #000;
      }

      .latex-begin-block pre {
        background: #f5f5f5;
        color: #000;
        border: 1px solid #ccc;
        border-radius: 0;
        font-size: 9pt;
        page-break-inside: avoid;
      }

      .tip {
        background: none;
        border: 1px solid #999;
        border-left: 4px solid #999;
        border-radius: 0;
        page-break-inside: avoid;
      }

      .tip b { color: #000; }

      .latex-table-header-cell {
        background: #eee;
        color: #000;
        border-color: #666;
      }

      .latex-table-body-cell {
        border-color: #999;
      }

      .latex-table-body-row:nth-child(even) .latex-table-body-cell {
        background: #f5f5f5;
      }

      .latex-footnote-marker {
        color: #000;
        border-bottom-color: #000;
      }

      a {
        color: #000;
        text-decoration: underline;
      }

      a[href^="#"]::after {
        content: "";
      }

      a[href^="http"]::after {
        content: " (" attr(href) ")";
        font-size: 0.85em;
        color: #555;
      }
    }

  </style>
</head>
<body>

  <button class="hamburger" aria-label="Menu">&#9776;</button>
  <div class="overlay"></div>

  <aside class="sidebar">
    <div class="sidebar-brand">
      <h1>[CDI@Work]:AI</h1>
      <div class="subtitle">CDI and Apache DeltaSpike</div>
      <a href="book.html" class="lang-switch">Deutsche Ausgabe</a>
    </div>
    <nav id="toc" aria-label="Table of Contents">
  <div class="toc-header">
    <h2>Contents</h2>
  </div>
  <ul class="toc-list">
    <li class="toc-chapter">
      <a href="#!idx:/introduction.html:1" class="toc-h1">1 Introduction to CDI</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.1" class="toc-h2">1.1 Context and Dependency Management</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.2" class="toc-h2">1.2 Annotations as a Central Component</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.3" class="toc-h2">1.3 Hello CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.4" class="toc-h2">1.4 The Application for This Book</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.5" class="toc-h2">1.5 Important Terms of the Specification</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/cdi_basics.html:2" class="toc-h1">2 CDI Fundamentals</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.1" class="toc-h2">2.1 Type-Safe Dependency Injection</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.2" class="toc-h2">2.2 Normal and Pseudo Scopes</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.3" class="toc-h2">2.3 CDI Standard Scopes</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.4" class="toc-h2">2.4 Qualifiers</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.5" class="toc-h2">2.5 Dynamic Usage of CDI Beans</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.6" class="toc-h2">2.6 Producer/Disposer Methods</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.7" class="toc-h2">2.7 Events</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.8" class="toc-h2">2.8 Replacing Beans</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.9" class="toc-h2">2.9 Interceptors</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.10" class="toc-h2">2.10 Decorators</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.11" class="toc-h2">2.11 Stereotypes</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.12" class="toc-h2">2.12 Explicit Typing</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/java_ee.html:3" class="toc-h1">3 CDI and Java EE</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.1" class="toc-h2">3.1 First Steps Towards Java EE</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.2" class="toc-h2">3.2 Web Applications with CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.3" class="toc-h2">3.3 JSF with CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.4" class="toc-h2">3.4 Servlets with CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.5" class="toc-h2">3.5 JAX-RS with CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.6" class="toc-h2">3.6 EJB with CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.7" class="toc-h2">3.7 JPA with CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.8" class="toc-h2">3.8 Bean Validation with CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.9" class="toc-h2">3.9 Bean Deployment Archive with Java EE</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/extensions.html:4" class="toc-h1">4 Portable CDI Extensions</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/extensions.html:4.1" class="toc-h2">4.1 The CDI Container Lifecycle</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.1" class="toc-h3">4.1.1 BeforeBeanDiscovery</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.2" class="toc-h3">4.1.2 ProcessAnnotatedType</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.3" class="toc-h3">4.1.3 AfterTypeDiscovery</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.4" class="toc-h3">4.1.4 ProcessInjectionPoint</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.5" class="toc-h3">4.1.5 ProcessInjectionTarget</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.6" class="toc-h3">4.1.6 ProcessBeanAttributes</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.7" class="toc-h3">4.1.7 ProcessProducer</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.8" class="toc-h3">4.1.8 ProcessBean</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.9" class="toc-h3">4.1.9 ProcessObserverMethod</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.10" class="toc-h3">4.1.10 AfterBeanDiscovery</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.11" class="toc-h3">4.1.11 AfterDeploymentValidation</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.12" class="toc-h3">4.1.12 BeforeShutdown</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/extensions.html:4.2" class="toc-h2">4.2 Developing Custom CDI Extensions</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/deltaspike.html:5" class="toc-h1">5 Apache DeltaSpike</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.1" class="toc-h2">5.1 All for One Core</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.2" class="toc-h2">5.2 Flexible Rules</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.3" class="toc-h2">5.3 Everything Under Control</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.4" class="toc-h2">5.4 Helping Hands</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.5" class="toc-h2">5.5 Better Safe Than Sorry</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.6" class="toc-h2">5.6 Improving Existing Code</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.7" class="toc-h2">5.7 Flexibility with Alternatives</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.8" class="toc-h2">5.8 Custom Concepts</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.9" class="toc-h2">5.9 Further Increasing Flexibility</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.10" class="toc-h2">5.10 Better Sooner Than Later</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.11" class="toc-h2">5.11 Safe Paths</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/cdi_lite.html:6" class="toc-h1">6 CDI Lite</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.1" class="toc-h2">6.1 Fewer Alternatives</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.2" class="toc-h2">6.2 From Decorators to Interceptors</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.3" class="toc-h2">6.3 Less Is More</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.4" class="toc-h2">6.4 Following Conventions</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.5" class="toc-h2">6.5 Reducing Layers</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/integration.html:7" class="toc-h1">7 CDI or Not CDI</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/integration.html:7.1" class="toc-h2">7.1 CDI Integration Through Producers</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/integration.html:7.2" class="toc-h2">7.2 Beans from Other Worlds</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/cdi_micro.html:8" class="toc-h1">8 CDI Micro</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.1" class="toc-h2">8.1 EE or Not EE</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.2" class="toc-h2">8.2 IdeaForkMicro</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.3" class="toc-h2">8.3 Modules upon Modules</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.4" class="toc-h2">8.4 Keeping Up with the Times</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.5" class="toc-h2">8.5 Project Structure</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.6" class="toc-h2">8.6 Every Start Is Simple</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.7" class="toc-h2">8.7 From Lite to Micro</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.8" class="toc-h2">8.8 Asynchronous CDI Events</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.9" class="toc-h2">8.9 Remote Yet So Close</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.10" class="toc-h2">8.10 Diversity per Module</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.11" class="toc-h2">8.11 Everything in Its Time</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.12" class="toc-h2">8.12 Integration</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.13" class="toc-h2">8.13 No Advantage Without Disadvantage</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.14" class="toc-h2">8.14 The Journey Is the Destination</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/upgrade.html:9" class="toc-h1">9 From Java EE to Jakarta EE</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.1" class="toc-h2">9.1 A New Chapter</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.2" class="toc-h2">9.2 From javax to jakarta</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.3" class="toc-h2">9.3 CDI Lite and CDI Full</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.4" class="toc-h2">9.4 Build Compatible Extensions</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.5" class="toc-h2">9.5 New Rules</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.6" class="toc-h2">9.6 DeltaSpike 2.0</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.7" class="toc-h2">9.7 The CDI Implementations</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.8" class="toc-h2">9.8 Upgrading IdeaFork</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/quarkus.html:10" class="toc-h1">10 Migration to Quarkus</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.1" class="toc-h2">10.1 A New Target</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.2" class="toc-h2">10.2 From CDI Full to ArC</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.3" class="toc-h2">10.3 Scopes in Quarkus</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.4" class="toc-h2">10.4 Configuration with MicroProfile Config</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.5" class="toc-h2">10.5 Build-Time Extensions</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.6" class="toc-h2">10.6 Replacing DeltaSpike Modules</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.7" class="toc-h2">10.7 Interceptors and Decorators</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.8" class="toc-h2">10.8 Native Images with GraalVM</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.9" class="toc-h2">10.9 Migrating IdeaFork to Quarkus</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.10" class="toc-h2">10.10 Sources</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/angular.html:11" class="toc-h1">11 From JSF to Angular</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.1" class="toc-h2">11.1 A New Frontend</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.2" class="toc-h2">11.2 From JSF Pages to Angular Components</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.3" class="toc-h2">11.3 Navigation: ViewConfig to Angular Router</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.4" class="toc-h2">11.4 Scopes and Lifecycle</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.5" class="toc-h2">11.5 Forms and Validation</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.6" class="toc-h2">11.6 Frontend Security</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.7" class="toc-h2">11.7 REST Communication</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.8" class="toc-h2">11.8 The Promotion Wizard</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.9" class="toc-h2">11.9 Migrating the IdeaFork Frontend</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.10" class="toc-h2">11.10 Sources</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/testing.html:12" class="toc-h1">12 Testing Across the Stack</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.1" class="toc-h2">12.1 A New Test Foundation</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.2" class="toc-h2">12.2 Testing CDI Beans (Weld-JUnit5)</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.3" class="toc-h2">12.3 DeltaSpike Test-Control Revisited</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.4" class="toc-h2">12.4 Arquillian: Integration Testing</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.5" class="toc-h2">12.5 @QuarkusTest and Dev Services</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.6" class="toc-h2">12.6 Testing REST Endpoints</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.7" class="toc-h2">12.7 Angular Unit Tests (TestBed)</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.8" class="toc-h2">12.8 E2E Testing with Playwright</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.9" class="toc-h2">12.9 IdeaFork Test Migration Checklist</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.10" class="toc-h2">12.10 Sources</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/security.html:13" class="toc-h1">13 Security Across the Stack</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/security.html:13.1" class="toc-h2">13.1 DeltaSpike Security — A Retrospective</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.2" class="toc-h2">13.2 Quarkus Security — Architecture</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.3" class="toc-h2">13.3 MicroProfile JWT in Depth</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.4" class="toc-h2">13.4 OIDC / OAuth2 with Keycloak</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.5" class="toc-h2">13.5 @RolesAllowed and Permissions</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.6" class="toc-h2">13.6 Angular Auth Guards in Depth</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.7" class="toc-h2">13.7 CSRF, CORS, and CSP</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.8" class="toc-h2">13.8 Securing IdeaFork — Checklist</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.9" class="toc-h2">13.9 Sources</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/cloud.html:14" class="toc-h1">14 From JAR to Cloud</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.1" class="toc-h2">14.1 Quarkus Packaging Options</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.2" class="toc-h2">14.2 Docker Multi-Stage Builds</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.3" class="toc-h2">14.3 Quarkus + Angular in a Single Image</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.4" class="toc-h2">14.4 MicroProfile Health Checks</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.5" class="toc-h2">14.5 MicroProfile Metrics / Micrometer</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.6" class="toc-h2">14.6 Distributed Tracing (OpenTelemetry)</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.7" class="toc-h2">14.7 Structured Logging</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.8" class="toc-h2">14.8 Kubernetes Deployment</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.9" class="toc-h2">14.9 Native Image in Production</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.10" class="toc-h2">14.10 IdeaFork Production Checklist</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.11" class="toc-h2">14.11 Sources</a>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>

  <main class="main-content">
    <div class="content-wrapper">
      <div class="sticky-disclaimer">
        <strong>Disclaimer:</strong> This website was automatically generated by Claude (Anthropic) based on the original online book. The original content is by the author Gerhard Petracek. Some chapters were entirely AI-generated — without review by the original author. Details can be found in the respective chapter disclaimers. The English translation was also generated automatically.
      </div>
      <section class="chapter-section" id="chapter-1">
<h1> <a class='latex-index-anchor' name='!idx:/introduction.html:1' ><span class='entry-number'>1</span> Introduction to CDI</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
        <strong>Disclaimer:</strong> The text of this chapter has been revised by Claude (Anthropic) as co-author. This revision was made without post-review by the original author. Use at your own risk.
      </div>
<a name = '!idx:/introduction.html:chap:cdi-introduction'> </a><span id='_footnote_marker_1' class='latex-footnote-marker'>IoC:</span>
                 On December 10, 2009, "Contexts and Dependency Injection for the Java EE platform" –
CDI for short – was released in its final version.
This new specification would soon have a lasting impact on the Java EE ecosystem.
Inspired by successful open-source frameworks like Spring, Seam, and Guice and
the associated years of experience, a new type-safe component model was specified
that significantly simplifies day-to-day work. But even more complex requirements are well served thanks to the
flexibility of CDI. It was precisely this flexibility that enabled portable CDI extensions,
which have been a key contributor to the success of CDI.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.0.0.1' ><span class='entry-number'>1.0.0.1</span> Goal of this book</a></h4>
 In this book you will learn step by step the fundamental concepts of CDI and
how you can successfully implement both Java SE and Java EE projects using this component model.
As with any technology, CDI also has its pitfalls.
With targeted tips and tricks, you will learn to recognize these and discover details about possible solutions.
In addition to integration with other technologies, we also cover proven CDI extensions and
show you how you can benefit from them.<br />
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> This chapter describes CDI in its original form under Java EE. Since its initial release, CDI has evolved significantly – from the migration to Jakarta EE through the split into CDI Lite and CDI Full to CDI 4.1. Details on these changes can be found in Chapter <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div>
<div class="tip"><b>Tip: </b>This book assumes basic knowledge of Java SE (version 8+), Apache Maven, and ideally initial experience with Java EE / Jakarta EE. JPA fundamentals are helpful but not strictly required.</div>
<div class="tip"><b>Tip: </b>Since its initial publication, this book has been substantially expanded: Chapter 9 covers the migration from Java EE to Jakarta EE, Chapter 10 the migration to Quarkus, and Chapter 11 the switch from JSF to Angular. Together, Chapters 1&ndash;11 form a complete migration path from CDI 1.0 to a modern Quarkus + Angular architecture.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.1' ><span class='entry-number'>1.1</span> Context and Dependency Management</a> </h2>
<span id='_footnote_marker_2' class='latex-footnote-marker'>Context-Management:</span>
                 To understand why work on CDI was started,
let us take a brief excursion into the early days of software development with Java.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Without an additional framework, you initially have only the basic language features of Java at your disposal.
When it comes to creating new instances of a class, you can use the  <span class='latex-texttt'>new</span>  keyword.
However, you also need to manage such an instance in order to reuse it at a later point in time (= Context-Management).
Similar to other programming languages, various design patterns were established for this purpose in Java as well.
But even these design patterns often led to unnecessarily complex implementations in large applications.
To manage instances more efficiently and enrich them with additional functionality, component models were introduced
that offloaded much of the complexity into configuration files. For lack of a better alternative,
XML was frequently used as the configuration format. However, this led to new challenges:
A central part of an application is no longer type-safe, and the configuration of some component models became so extensive
that it often had to be generated using generators. Over time, the component models improved and
the configuration effort was significantly reduced. However, the format of the configuration files is still based on strings,
which means many advantages of a type-safe language like Java are lost.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span id='_footnote_marker_3' class='latex-footnote-marker'>Dependency-Management:</span>
                 A second challenge in application development
is the references to other instances (= Dependency-Management). The complexity increases
as soon as beans with different lifetimes (scopes) are involved. When the container ensures
that the required references to other instances are set (= injected) automatically, this is called Dependency-Injection.
For this Dependency-Management, many component models use configuration entries that also lead to a loss of type safety.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> A container provides a component model that can be used by the application code
to implement parts of the application more easily.
Containers thus represent the link between the underlying runtime environment and the application code.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For both Context and Dependency Management, there was no alternative until JDK 5
to solve this fundamental problem more efficiently and, above all, in a type-safe manner. In 2004, annotations,
which were initially greatly underestimated, were introduced with Java 5. However, it was not until 2006 that annotations were first (officially) used for Dependency-Injection with Java EE 5.
The following year, a project called Guice refined this approach with respect to type safety.
Due to the growing popularity of type-safe component models, a specification of such concepts was a logical step.
Originally, CDI (JSR-299) was developed under the name "Web Beans",
as the primary goal was to create a bridge between the JSF and EJB specifications.
Three years later, CDI made its debut. By the time the specification reached its final version,
not only had its name changed, but several major revisions had been made.
For example, part of the specification was extracted (into JSR-330) and has since served not only as the basis for CDI,
but also for other component models. Furthermore, CDI is no longer tied to Java EE
and can also be used in Java SE applications without any issues.<br /> <div class="tip"><b>Tip: </b> JSR-330 consists of 5 annotations and one interface and specifies a minimal set of functionality
required for Dependency-Injection and the definition of custom scopes.
In addition to CDI implementations, JSR-330 is also used as a basis by other projects. </div><h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.2' ><span class='entry-number'>1.2</span> Annotations as a central component</a> </h2>
 Annotations are additional metadata and were introduced in Java 5 as an extension of the type system.
Since CDI is primarily based on annotations and creating custom annotations is part of the daily toolkit
when working with CDI, let us take a closer look at a few details.
With annotations, a fundamental distinction must be made between whether they can be queried at application runtime or not.
A well-known representative of annotations that cannot be queried at runtime is  <span class='latex-texttt'>@Override</span> ,
since  <span class='latex-texttt'>@Retention(RetentionPolicy.SOURCE)</span>  is defined here. For a component model like CDI, of course, only information that
is available at runtime is useful. Therefore, all annotations that you create in connection with CDI must always
define  <span class='latex-texttt'>@Retention(RetentionPolicy.RUNTIME)</span> . Otherwise, the CDI container will not see the annotation at runtime.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Furthermore, it must be specified where the annotation can be used.
This is expressed using  <span class='latex-texttt'>@Target</span> . Thus, we can already analyze the most commonly used annotation
called  <span class='latex-texttt'>@Inject</span>  for daily work with CDI, which is shown in Listing  <a href='#!idx:/introduction.html:fig:implementation-adinject'> Specified structure of @Inject </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/introduction.html:fig:implementation-adinject'></a>                     <pre><code>@Target({ElementType.CONSTRUCTOR,
    ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Inject {}
</code></pre>
                </div>
In the case of  <span class='latex-texttt'>@Inject</span> , the possible usage targets are constructors, methods, and fields.
Apart from the element types just mentioned, in the context of CDI,  <span class='latex-texttt'>ElementType.TYPE</span>  for annotations at the class level,
 <span class='latex-texttt'>ElementType.PARAMETER</span>  for annotations on method parameters, and  <span class='latex-texttt'>ElementType.ANNOTATION_TYPE</span> for annotations on annotations are also important. Annotating an annotation may sound somewhat unusual at first.
However, in the course of this book we will discover very useful applications for this element type.<br /> <h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.3' ><span class='entry-number'>1.3</span> Hello CDI</a> </h2>
 In its minimal form, CDI follows a few simple rules.
In the following chapters, we will additionally examine special configurations.
Please keep in mind that many of the concepts presented are optional and
thus are available but do not necessarily have to be used all the time.
An average CDI-based application can even get by with surprisingly few CDI features.
Nevertheless, it is useful to have an overview of the full feature set in case you encounter more complex use cases and
want to solve them using the elegant CDI concepts as well.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/introduction.html:fig:minimal_cdi-bean'> Minimal CDI bean </a>  shows a POJO (Plain Old Java Object), which already represents a fully functional CDI bean.
As is easy to see, neither a CDI class nor a special annotation is used here.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/introduction.html:fig:minimal_cdi-bean'></a>                     <pre><code>public class HelloWorldBean {
  public String hello() {
    return "Hello CDI";
  }
}
</code></pre>
                </div>
Based on the class alone, it cannot be determined in this case whether it is a CDI bean or not.
In order for the CDI container to even discover this class, a marker file called  <span class='latex-texttt'>beans.xml</span>  must be created per module
(in  <span class='latex-texttt'>META-INF</span>  for JAR files or  <span class='latex-texttt'>WEB-INF</span>  for WAR files).
As the term marker file suggests, this file can be empty (= 0 bytes),
since in the simplest case it simply serves to mark so-called bean archives (or Bean Deployment Archive).
This means that the entire classpath does not need to be scanned, but only the correspondingly marked archives.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Starting with CDI 4.0, the default discovery mode is <span class='latex-texttt'>annotated</span> instead of <span class='latex-texttt'>all</span>. This means that only classes with a bean-defining annotation (such as <span class='latex-texttt'>@ApplicationScoped</span>) are discovered – an empty <span class='latex-texttt'>beans.xml</span> alone is no longer sufficient to register all classes as beans. Details can be found in Chapter <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div><br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Even if the CDI container has found the class from Listing  <a href='#!idx:/introduction.html:fig:minimal_cdi-bean'> Minimal CDI bean </a> ,
this bean must be obtained from the container either implicitly via Dependency-Injection or explicitly via manual bean lookup.
If you were to manually create an instance of this class, it would not be managed by the container and the instance would not be a CDI bean either.<br /> <div class="tip"><b>Tip: </b> Starting with CDI 1.1, the beans.xml file is optional. To integrate CDI 1.0 bean modules without beans.xml,
the SPI of CDI can be used, for example. The corresponding mechanisms are presented in the chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> . </div> The first instance, which represents the entry point of a process, must always be initialized by the CDI container.
In a Java EE application server, this is typically done automatically.
Java SE applications, on the other hand, must query at least one bean manually from the CDI container or
perform manual injection so that the object graph is correctly built by the CDI container.
Before CDI 1.1, this was not possible in a Java SE application using a standardized API.
To still verify our bean using, for example, a simple unit test, we need to get slightly ahead of ourselves here and
use a JUnit test runner from a portable CDI extension called Apache DeltaSpike.
Both the test runner and many other components of DeltaSpike will be described in detail later in the chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> .
This test runner primarily ensures in the background that the CDI container is started and
CDI beans can be injected into the JUnit test class.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/introduction.html:fig:direct_bean_injection'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class HelloWorldBeanTest {
  @Inject
  private HelloWorldBean bean;

  @Test
  public void testInjectedBean() {
    Assert.assertEquals("Hello CDI", bean.hello());
  }
}
</code></pre>
                </div>
Only through  <span class='latex-texttt'>@Inject</span>  is the CDI container instructed to create an instance of the class  <span class='latex-texttt'>HelloWorldBean</span>  and
provide a reference to it. Thus, the instance can be accessed via the field annotated with  <span class='latex-texttt'>@Inject</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/introduction.html:fig:minimal_cdi-bean'> Minimal CDI bean </a>  and  <a href='#!idx:/introduction.html:fig:direct_bean_injection'> Injection of a CDI bean </a>  show how simple CDI can be.
Of course, there are many more mechanisms that will be described in detail in the following chapters.
Nevertheless, it should be noted once again at this point that an average CDI application does not need to utilize the full feature set
of CDI. In many cases the motto is: "The lower the complexity is kept,
the easier an application can be maintained." This applies not only to the business logic of an application,
but also to the selection of features used from component models like CDI.<br /> <h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.4' ><span class='entry-number'>1.4</span> The application for this book</a> </h2>
<a name = '!idx:/introduction.html:sec:ideafork_intro'> </a> The name of the example application is  <span class='latex-textit'>IdeaFork</span> . Over the course of the book, a small platform will be developed for easily managing
recipe, travel, or gift ideas, for example. Furthermore, ideas can be searched for and copied (forked).
This enables the modification and further development of existing ideas.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Please note that the example application is not intended to represent a reference design of a typical CDI application.
Instead, all fundamental CDI concepts as well as features of CDI extensions are illustrated through concrete use cases.
Naturally, some of these use cases can also be implemented without CDI.
Even with CDI, the availability of a feature does not mean it has to be used at all costs.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the first part of the book, we focus on the backend of the application.
Initially, the backend code will have no dependencies on other Java EE specifications, such as JPA.
This allows us to focus entirely on the CDI concepts.
Only afterwards will we deal with the integration of other Java EE specifications and other technologies.
The structure of the backend module is kept simple, since the illustrated CDI features are the focus and
not the creation of a specific application design.
For easier use of the module, there is only a separation between API and Impl packages.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Since CDI itself is only a written specification, we need an implementation of it.
Here we have a considerable selection. In addition to the reference implementation called Weld (from JBoss/Red Hat), there is also
OpenWebBeans (from Apache) and CanDI (from Resin). Weld and OpenWebBeans (aka OWB) are widely used.
Therefore, we will limit ourselves to these two implementations. In Java SE applications as well as web applications
deployed in a servlet container, you can choose which implementation to use.
With Java EE 6+ application servers, this decision is made for you by the server vendor,
so you do not need to manually take care of the setup.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> The versions mentioned in this chapter (OWB 1.2.x, Weld 1.1.x) reflect the state at the time of the book's original publication. Current versions have progressed significantly: Weld 6.x and OpenWebBeans 4.x implement CDI 4.1 under the <span class='latex-texttt'>jakarta</span> namespace. CanDI (Resin) is no longer actively maintained. Details on current versions can be found in Chapter <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div><br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.4.0.1' ><span class='entry-number'>1.4.0.1</span> The setup</a></h4>
 In combination with a Java EE6+ application server, the setup is minimal since only the Java EE API JAR is required during development.
For deployment, it is no longer needed and therefore only the project's own classes need to be provided.
However, since we are starting with Java SE (or JUnit tests) and CDI, we will take a closer look at the required setup for OpenWebBeans and
Weld.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Both Weld and OpenWebBeans can be used with any standards-compliant API. There are several options here.<br /> <div class='latex-begin-block'><table border=0 class='latex-table'><thead class='latex-table-header'><tr class='latex-table-header-row'></tr><tr class='latex-table-header-row'><td class='latex-table-header-cell'>[groupId:artifactId]</td><td class='latex-table-header-cell'>Version</td><td class='latex-table-header-cell'>Description</td></tr><tr class='latex-table-header-row'></tr></thead><tbody class='latex-table-body'><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>javax:javaee-web-api</span>   </td><td class='latex-table-body-cell'>    6.0    </td><td class='latex-table-body-cell'>    Official     Java     EE     6     API </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>javax:javaee-web-api</span>   </td><td class='latex-table-body-cell'>    7.0    </td><td class='latex-table-body-cell'>    Official     Java     EE     7     API </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.openejb:javaee-api</span>   </td><td class='latex-table-body-cell'>    6.0-5    </td><td class='latex-table-body-cell'>    Alternative     Java     EE     6     API </td></tbody></table><div class='latex-begin-block'> <br /> </div></div>
Table  <span class='latex-unknwown-link'> tab:ee-api </span>  shows different EE API bundles that are currently available.
Since each bundle contains the complete API, only one of these bundles is required.
However, if you are only interested in the CDI API itself, you can alternatively
include  <span class='latex-texttt'>javax.inject:javax.inject:1</span>  and  <span class='latex-texttt'>javax.enterprise:cdi-api:1.0-SP4</span> .
As another alternative, the individual API modules from Apache can be used, which are listed in Table  <span class='latex-unknwown-link'> tab:spec-apis </span> .
At Apache, these API modules are collectively hosted in the Apache Geronimo project,
however there is no dependency on the server implementation of the same name.<br /> <div class='latex-begin-block'><table border=0 class='latex-table'><thead class='latex-table-header'><tr class='latex-table-header-row'></tr><tr class='latex-table-header-row'><td class='latex-table-header-cell'>[groupId:artifactId]</td><td class='latex-table-header-cell'>Version</td><td class='latex-table-header-cell'>Description</td></tr><tr class='latex-table-header-row'></tr></thead><tbody class='latex-table-body'><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.geronimo.specs: geronimo-atinject_1.0_spec</span>   </td><td class='latex-table-body-cell'>    1.0    </td><td class='latex-table-body-cell'>    JSR-330 </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.geronimo.specs: geronimo-jcdi_1.0_spec</span>   </td><td class='latex-table-body-cell'>    1.0    </td><td class='latex-table-body-cell'>    JSR-299 </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.geronimo.specs: geronimo-interceptor_1.1_spec</span>   </td><td class='latex-table-body-cell'>    1.0    </td><td class='latex-table-body-cell'>    Part     of     JSR-318 </td></tbody></table><div class='latex-begin-block'> <br /> </div></div>
In addition to the API modules, the corresponding implementation modules are required:<br /> <div class='latex-begin-block'><table border=0 class='latex-table'><thead class='latex-table-header'><tr class='latex-table-header-row'></tr><tr class='latex-table-header-row'><td class='latex-table-header-cell'>[groupId:artifactId]</td><td class='latex-table-header-cell'>Version</td><td class='latex-table-header-cell'>Description</td></tr><tr class='latex-table-header-row'></tr></thead><tbody class='latex-table-body'><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.openwebbeans: openwebbeans-impl</span>   </td><td class='latex-table-body-cell'>    1.2.2    </td><td class='latex-table-body-cell'>    Implementation     of     JSR-299 </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.openwebbeans: openwebbeans-spi</span>   </td><td class='latex-table-body-cell'>    1.2.2    </td><td class='latex-table-body-cell'>    Separate     SPI     module     for     easier     extensibility     of     OWB </td></tbody></table><div class='latex-begin-block'> <br /> </div></div><div class='latex-begin-block'><table border=0 class='latex-table'><thead class='latex-table-header'><tr class='latex-table-header-row'></tr><tr class='latex-table-header-row'><td class='latex-table-header-cell'>[groupId:artifactId]</td><td class='latex-table-header-cell'>Version</td><td class='latex-table-header-cell'>Description</td></tr><tr class='latex-table-header-row'></tr></thead><tbody class='latex-table-body'><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.jboss.weld: weld-core-bom</span>   </td><td class='latex-table-body-cell'>    1.1.18    </td><td class='latex-table-body-cell'>    BOM     for     Weld </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.jboss.weld: weld-api</span>   </td><td class='latex-table-body-cell'>    Defined     by     BOM    </td><td class='latex-table-body-cell'>    Proprietary     API     of     Weld </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.jboss.weld: weld-core</span>   </td><td class='latex-table-body-cell'>    Defined     by     BOM    </td><td class='latex-table-body-cell'>    Implementation     of     JSR-299 </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.jboss.weld.se: weld-se</span>   </td><td class='latex-table-body-cell'>    Defined     by     BOM    </td><td class='latex-table-body-cell'>    Special     module     for     Java     SE </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.slf4j: slf4j-simple</span>   </td><td class='latex-table-body-cell'>    1.7.2    </td><td class='latex-table-body-cell'>    Logging     framework     used     by     Weld </td></tbody></table><div class='latex-begin-block'> <br /> </div></div>
In the  <span class='latex-texttt'>pom.xml</span>  of  <span class='latex-textit'>IdeaFork</span> , both the dependencies for OpenWebBeans (Table  <span class='latex-unknwown-link'> tab:owb_java-se </span> ) and
Weld (Table  <span class='latex-unknwown-link'> tab:weld_java-se </span> ) are used. At runtime, only one implementation may be active at a time.
This separation is implemented in  <span class='latex-textit'>IdeaFork</span>  using Maven profiles,
ensuring the portability of the application.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> To make it easy to start and use CDI in JUnit tests,
you will also find test dependencies for the Test-Control module of Apache DeltaSpike in the demo application,
which is described in detail in the chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> .<br /> <h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.5' ><span class='entry-number'>1.5</span> Important terms of the specification</a> </h2>
<a name = '!idx:/introduction.html:sec:cdi_terms'> </a> Before we begin with the individual fundamental concepts, let us look at the most important terms of the CDI specification.
You will encounter these terms not only frequently in the following chapters,
but also in the JavaDoc of CDI and possibly during your own research on CDI-specific topics.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.1' ><span class='entry-number'>1.5.0.1</span> Injection-Point</a></h4>
 Injection-Points are reference variables that are automatically set by the CDI container.
In the course of this book, we will learn about various possibilities for explicit and implicit Injection-Points.
An instance variable annotated with  <span class='latex-texttt'>@Inject</span>  is, for example, an explicit Injection-Point.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The SPI of CDI also contains an interface with this name.
Through this interface, the metadata of an Injection-Point can be modified during container startup.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.2' ><span class='entry-number'>1.5.0.2</span> Scope and Context</a></h4>
 The scope defines the lifetime of an instance. With  <span class='latex-texttt'>@NormalScope</span> , CDI itself defines only one type of scope.
Since CDI is based on JSR-330 and a simpler scope type is specified here through  <span class='latex-texttt'>@Scope</span> ,
one must effectively distinguish between the normal scopes of CDI (JSR-299) and the so-called pseudo-scopes of JSR-330.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For CDI-based applications, normal-scoped beans are primarily relevant. Here CDI defines  <span class='latex-texttt'>@ApplicationScoped</span> (instances are destroyed when the application shuts down),  <span class='latex-texttt'>@SessionScoped</span>  (the lifetime depends on the HTTP session),
 <span class='latex-texttt'>@RequestScoped</span>  (the lifetime is limited to a single HTTP request), and  <span class='latex-texttt'>@ConversationScoped</span>  (semi-automatically managed).
The only pseudo-scope specified by CDI is  <span class='latex-texttt'>@Dependent</span> , which from CDI's perspective is an exception in many cases.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> A scope is associated with an instance of an implementation of  <span class='latex-texttt'>javax.enterprise.context.spi.Context</span> ,
which manages the lifecycle of instances (Contextual-Instances). Whether a context is active or not
depends on the type of scope and can be evaluated dynamically.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Standard contexts specified by CDI are completely terminated. If, for example, the request scope is destroyed for the current thread,
all request-scoped beans are collectively destroyed. Manual management of individual beans is not intended for the standard contexts.
However, this is not a technical limitation of CDI.
Therefore, fine-grained management of individual beans is entirely possible with custom context implementations.<br /> <div class="tip"><b>Tip: </b> In practice,  <span class='latex-texttt'>@SessionScoped</span>  and  <span class='latex-texttt'>@RequestScoped</span>  can even be used in Java SE applications.
However, they must be managed manually. Further details on this and on the individual scopes,
as well as the definition of custom scopes, follow in the chapters  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI and Java EE </a>  and  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> . </div><h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.3' ><span class='entry-number'>1.5.0.3</span> Managed-Bean</a></h4>
 Managed-Beans, as defined by CDI, should not be confused with Java Beans.
However, even in the CDI specification itself, multiple uses of the term for different concepts can be found.
At least in this book, we use the following main definition from the CDI perspective:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> A Managed-Bean is represented by  <span class='latex-texttt'>javax.enterprise.inject.spi.Bean&lt;T&gt;</span>  and
consists of the Java class and additional metadata.
As we will see later, this metadata can be modified almost arbitrarily during container startup.
In any case, it is verified during the application startup process.
If CDI rules are not followed, the container startup is aborted and a corresponding error description is displayed.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Based on the Java class and the metadata, the container can create the so-called Contextual-Instance at runtime.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.4' ><span class='entry-number'>1.5.0.4</span> Contextual-Instance</a></h4>
 Colloquially, instead of Contextual-Instance, the term (CDI) bean is often used.
Since the term "bean" is ambiguous, we will mostly use the term Contextual-Instance in the following chapters.
As mentioned before, the Contextual-Instance is the actual instance created by the CDI container based on the Managed-Bean
(= Java class and additional metadata).
However, in many cases the container does not expose the physical reference to the instance externally, but rather a so-called Contextual-Reference.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.5' ><span class='entry-number'>1.5.0.5</span> Contextual-Reference</a></h4>
 Instead of the physical reference to a (Contextual-)Instance, the CDI container in many cases exposes a proxy instance externally.
Whether a proxy is used or not depends on the defined scope of the Managed-Bean. For normal-scoped beans, proxies are always created.
For pseudo-scoped beans, it is only required when interceptors or decorators need to be wrapped around a Contextual-Instance,
since such functionality cannot be implemented without modified bytecode.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Through the use of proxies, the so-called cross-scope injection issue is also solved.
Without proxies, for example, a session-scoped bean with an injected reference to a request-scoped bean
would, after the first request, still hold a reference to the old instance (from the first request).
Instead, the session-scoped bean should always be able to address the current request-scoped bean.
The Contextual-Reference (the proxy) ensures this, since for each method call the correct instance is resolved and
the call is then forwarded to it.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Since proxies, according to the CDI specification, are always serializable regardless of the Contextual-Instance,
the passivation (= serialization and storage of a Contextual-Instance outside the runtime environment)
of a Contextual-Instance is independent of the injected references.<br /> <div class="tip"><b>Tip: </b> The proxy overhead is already minimal in current implementations.
For example, OpenWebBeans 1.2+ generates highly optimized proxies via subclassing at the bytecode level.
Regardless of the specific implementation, however, there are limitations to be aware of:
Classes and their methods must not be final. Additionally, when using CDI on a daily basis, it should be noted
that ("empty") proxy instances are displayed in the debugger.
To see the state of the Contextual-Instance in the debugger, you must be inside that instance. </div>
<div class="tip"><b>Tip: </b><b>Reading guide based on your experience:</b><br />
&bull; <b>CDI beginners:</b> Start with Chapters 1&ndash;4 for the core concepts (injection, scopes, events, interceptors, extensions).<br />
&bull; <b>DeltaSpike users:</b> Chapters 5&ndash;8 cover the DeltaSpike modules and the IdeaFork case study with microservices.<br />
&bull; <b>Migration projects:</b> Chapters 9&ndash;11 guide you from Java EE through Jakarta EE and Quarkus to Angular &mdash; the complete modernization path.</div>
</section>
<section class="chapter-section" id="chapter-2">
<h1> <a class='latex-index-anchor' name='!idx:/cdi_basics.html:2' ><span class='entry-number'>2</span> CDI Fundamentals</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
        <strong>Disclaimer:</strong> The text of this chapter has been revised by Claude (Anthropic) as co-author. This revision was made without post-review by the original author. Use at your own risk.
      </div>
<a name = '!idx:/cdi_basics.html:chap:cdi-basics'> </a> In this chapter, we examine the fundamental concepts of CDI. By the end of this chapter, you will be familiar with the most important base functionalities that can be used for developing CDI-based applications. CDI also offers several extension capabilities that represent a central aspect of this component model. Therefore, we dedicate a separate chapter to this topic.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.1' ><span class='entry-number'>2.1</span> Type-Safe Dependency Injection</a> </h2>
 The most well-known component of CDI is arguably type-safe dependency injection.
We already encountered a simple example in the chapter  <a href='#!idx:/introduction.html:chap:cdi-introduction'>  Introduction to CDI </a> . That example was kept very simple, yet it represents one of the main use cases and conceals some interesting advantages.
In this chapter, we will additionally explore further injection variants and their properties.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> There are several ways to tell the CDI container that a Contextual-Reference should be set.
The simplest variant is "direct" injection. Here, fields, methods, or even a constructor are annotated with  <span class='latex-texttt'>@Inject</span> .
This approach is not only easy to use but also offers the advantage that the CDI container validates the Injection-Points during the startup process. All three possibilities can be combined freely.
Nevertheless, there is a defined order in which injection is performed.
First, Constructor-Injection is always executed.
Then, all fields annotated with  <span class='latex-texttt'>@Inject</span>  are populated. This is called Field-Injection.
In a final step, Method-Injection is performed.
This can involve initialization methods with any number of parameters.
As with Constructor-Injection, each parameter represents its own Injection-Point, which is populated by the CDI container.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> If no valid Managed-Bean is found for an Injection-Point, an  <span class='latex-texttt'>UnsatisfiedResolutionException</span>  is thrown.
If, on the other hand, multiple valid candidates are found, an  <span class='latex-texttt'>AmbiguousResolutionException</span>  is thrown.
We will examine the  <span class='latex-texttt'>AmbiguousResolutionException</span>  more closely later in connection with qualifiers.
In both cases, the container startup is aborted, allowing you to detect early on whether there is a fundamental problem in your application.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The example application named  <span class='latex-textit'>IdeaFork</span>  described in the chapter  <a href='#!idx:/introduction.html:sec:ideafork_intro'>  The Application for This Book </a>  requires a central entity, which we give the obvious name  <span class='latex-texttt'>Idea</span> .
Equivalent to Listing 1.2, we could simply inject an instance of the class into our beans, provided all CDI rules are satisfied. This is widely referred to as business injection (aka Business-Injection).<br /> <div class="tip"><b>Tip: </b> Business injection must be handled with great care. If we later add JPA, for example, it is important that an instance is managed by only one container. There are many recommendations in this area for structuring an application.
We follow the recommendation that entities should not be managed by CDI.
Since we still want to centralize the creation of  <span class='latex-texttt'>Idea</span>  instances, we introduce an  <span class='latex-texttt'>IdeaManager</span>  that will later fulfill additional tasks. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.1.0.1' ><span class='entry-number'>2.1.0.1</span> Field-Injection</a></h4>
 Listing  <a href='#!idx:/cdi_basics.html:fig:minimal_idea-entity'> Idea Entity </a>  shows details of the  <span class='latex-texttt'>Idea</span>  entity. For now, it is a simple POJO with 3 properties, 2 of which are required for creating an instance.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:minimal_idea-entity'></a>                     <pre><code>public class Idea {
  private String topic;
  private String category;
  private String description;

  Idea(String topic, String category) {
    this.topic = topic;
    this.category = category;
  }
  //+ Getter- und Setter-Methoden
}
</code></pre>
                </div>
Since the constructor restricts creation to within the same package,
we place the  <span class='latex-texttt'>IdeaManager</span>  class in the same package.
Listing  <a href='#!idx:/cdi_basics.html:fig:minimal_factory'> CDI Bean as a Simple Factory </a>  shows the implementation of  <span class='latex-texttt'>IdeaManager</span> .
For now, we omit the explicit definition of a scope.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:minimal_factory'></a>                     <pre><code>public class IdeaManager {
  public Idea createIdeaFor(String topic, String category) {
    return new Idea(topic, category);
  }
}
</code></pre>
                </div>
With Listing  <a href='#!idx:/cdi_basics.html:fig:minimal_idea-entity'> Idea Entity </a>  and  <a href='#!idx:/cdi_basics.html:fig:minimal_factory'> CDI Bean as a Simple Factory </a> , we have all the components for creating a unit test to test the creation of an  <span class='latex-texttt'>Idea</span>  instance.
In this test (see Listing  <a href='#!idx:/cdi_basics.html:fig:test_field-injection'> Unit Test with Field-Injection </a> ), we create a private field of type  <span class='latex-texttt'>IdeaManager</span>  and annotate it with  <span class='latex-texttt'>@Inject</span> , thereby defining an Injection-Point for CDI.
At runtime, the CDI container populates the field (the Injection-Point) with a Contextual-Reference through which the Contextual-Instance can be accessed.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test_field-injection'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class FieldInjectionTest {
  @Inject
  private IdeaManager ideaManager;

  @Test
  public void ideaCreation() {
    String topic = "Learn CDI";
    String category = "Education";
    String description = "Hello Injection!";

    Idea newIdea = this.ideaManager.createIdeaFor(topic, category);
    newIdea.setDescription(description);

    Assert.assertEquals(topic, newIdea.getTopic());
    Assert.assertEquals(category, newIdea.getCategory());
    Assert.assertEquals(description, newIdea.getDescription());
  }
}
</code></pre>
                </div> This first step could also be implemented without dependency injection.
Instead of the  <span class='latex-texttt'>@Inject</span>  annotation, we would have to use the  <span class='latex-texttt'>new</span>  keyword for manual instantiation.
Manually created instances are still possible, but they are not managed by the CDI container, and therefore many CDI-based functionalities would not be available or would only be usable through workarounds. In the next step, we will learn about the first advantage of managed instances.<br />
 <div class="tip"><b>Tip: </b> The previously mentioned advantage that the demonstrated (direct) Field-Injection is validated at container startup simultaneously prevents the use of optional beans. An example of this is the optional implementation of an interface.
To solve such use cases, we need an indirection, for which there are several options.
Details on such programmatic lookups will be covered in the chapters  <a href='#!idx:/cdi_basics.html:sec:lookup_via_instance'> [ Indirection with Instance] </a>  and  <a href='#!idx:/cdi_basics.html:sec:lookup_via_bm'> [ Finding Beans via BeanManager] </a> . </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.1.0.2' ><span class='entry-number'>2.1.0.2</span> Constructor-Injection</a></h4>
 An alternative to Field-Injection is Constructor-Injection.
Here, a parameterized constructor is annotated with  <span class='latex-texttt'>@Inject</span> .
Whenever a proxy is required for referencing a Contextual-Instance, a default constructor must be provided.
Otherwise, an  <span class='latex-texttt'>UnproxyableResolutionException</span>  is thrown during container startup.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In our application, we can add an  <span class='latex-texttt'>IdeaValidator</span>  that is set in  <span class='latex-texttt'>IdeaManager</span>  via Constructor-Injection.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:bean_with_constructor-injection'></a>                     <pre><code>public class IdeaManager {
  private final IdeaValidator ideaValidator;

  @Inject
  protected IdeaManager(IdeaValidator ideaValidator) {
    this.ideaValidator = ideaValidator;
  }

  public Idea createIdeaFor(String topic, String category) {
    Idea result = new Idea(topic, category);
    if (!ideaValidator.checkIdea(result)) {
      throw new IllegalArgumentException(
        "Please try it harder next time!");
    }
    return result;
  }
}
</code></pre>
                </div>
From a technical perspective, there are no advantages of Constructor-Injection over the other variants in CDI, since only fully initialized beans are made available by the container.
In many cases, Constructor-Injection is primarily used when the Injection-Point is not directly assigned to an instance variable.
Instead, a value is often only queried through the Injection-Point and then assigned to an instance variable or evaluated directly in the constructor.<br /> <div class="tip"><b>Tip: </b> In Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_constructor-injection'> Constructor-Injection </a> , no default constructor is required.
This changes as soon as a bean is normal-scoped or has an interceptor/decorator. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.1.0.3' ><span class='entry-number'>2.1.0.3</span> Method-Injection</a></h4>
 Similar to Constructor-Injection, methods can also be annotated with  <span class='latex-texttt'>@Inject</span> .
Each parameter represents an Injection-Point that is injected by the CDI container.
Since parameters are optional, 0 to n parameters can be specified.
However, init methods without parameters are typically annotated with  <span class='latex-texttt'>@PostConstruct</span> .
For the Contextual-Instance, there is technically no significant difference, but  <span class='latex-texttt'>@PostConstruct</span>  is more expressive and, like  <span class='latex-texttt'>@PreDestroy</span> , is supported by CDI.
As mentioned at the beginning, Method-Injection is performed after Constructor- and Field-Injection and represents the final injection step.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/cdi_basics.html:fig:test_method-injection'> Unit Test with Method-Injection </a> , the Method-Injection concept just described is applied instead of Field-Injection.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test_method-injection'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class MethodInjectionTest {
  private IdeaManager ideaManager;

  @Inject
  protected void init(IdeaManager ideaManager) {
    this.ideaManager = ideaManager;
  }

  @Test(expected = IllegalArgumentException.class)
  public void invalidIdeaCreation() {
    this.ideaManager.createIdeaFor(null, null);
  }

  //...
}
</code></pre>
                </div>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.2' ><span class='entry-number'>2.2</span> Normal and Pseudo Scopes</a> </h2>
 As described in the chapter  <a href='#!idx:/introduction.html:sec:cdi_terms'>  Important Specification Terms </a> , Contextual-Instances are created based on the underlying bean metadata.
A component of this metadata is the scope of the bean, which defines the lifetime of the Contextual-Instance.
If a Contextual-Instance is not yet available, it is typically created automatically, provided the scope is active.
The exact behavior is defined by the scope and its context implementation.
Even in the CDI specification, there is a special case with the Conversation-Scope, since it must be explicitly started.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> This is not the only exception in the CDI specification.
A fundamental distinction is made between "Pseudo-Scopes" and "Normal-Scopes", with Pseudo-Scopes being rather rare.
As this chapter shows, both scope types follow different rules. Their usage, however, is consistent.
You select the appropriate scope for a Managed-Bean and annotate the bean class (or producer) with the corresponding scope annotation.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.2.0.1' ><span class='entry-number'>2.2.0.1</span> Pseudo-Scopes</a></h4>
 JSR-330 already contains an annotation ( <span class='latex-texttt'>@Scope</span> ) with which custom scope annotations can be created.
In the CDI specification, corresponding scopes are referred to as "Pseudo-Scope" because  <span class='latex-texttt'>@Scope</span>  is practically undefined.
This is the reason why two similar scopes exist ( <span class='latex-texttt'>@javax.inject.Singleton</span>  from JSR-330 and
 <span class='latex-texttt'>@javax.enterprise.context.ApplicationScoped</span>  from CDI).
Even with the much more concretely defined  <span class='latex-texttt'>@ApplicationScoped</span> , there are still subtleties that led to different interpretations.<br />
<div class="tip"><b>Tip: </b>The package names <span class='latex-texttt'>javax.inject</span> and <span class='latex-texttt'>javax.enterprise</span> used in this chapter were renamed to <span class='latex-texttt'>jakarta.inject</span> and <span class='latex-texttt'>jakarta.enterprise</span> with Jakarta EE 10. The concepts and APIs remain identical &mdash; only the namespace changes. See Chapter <a href='#!idx:/upgrade.html:9'>9</a> for migration details.</div>
<h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.2.0.2' ><span class='entry-number'>2.2.0.2</span> Normal-Scopes</a></h4>
 With passivation and its associated rules, the CDI specification defines a very practical mechanism.
 <span class='latex-texttt'>@Scope</span>  from JSR-330 is, however, too simplistic and therefore lacks a way to specify passivation.
An additional annotation could have overcome this limitation.
The CDI Expert Group instead chose to introduce a better-defined scope type that allows specifying the passivation capability of the scope. This scope type is called "Normal-Scope".
Accordingly, scope annotations are annotated with  <span class='latex-texttt'>@NormalScope</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> A key difference between both scope types is that the Contextual-Reference to a normal-scoped Contextual-Instance is always a proxy.
In contrast, for pseudo-scoped beans this is only required when an interceptor/decorator is defined for the corresponding bean, since this is technically only possible with modified bytecode. As already mentioned in the chapter  <a href='#!idx:/introduction.html:chap:cdi-introduction'>  Introduction to CDI </a> ,
normal-scoped beans are much more convenient because we do not need to worry about many technical details, such as Cross-Scope-Injection.<br />
<div class="tip"><b>Tip: </b><b>Common mistake &mdash; Proxy vs. direct reference:</b> For normal-scoped beans (<span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@RequestScoped</span>, etc.), CDI injects a proxy, not the actual instance. Direct access via <span class='latex-texttt'>new</span> or static methods bypasses the proxy and thus the scope mechanism. Always use <span class='latex-texttt'>@Inject</span> to obtain correctly managed references.</div>
<h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3' ><span class='entry-number'>2.3</span> CDI Standard Scopes</a> </h2>
 Since the original goal of CDI was to bridge JSF and EJBs,
all JSF scopes were redefined as CDI Normal-Scopes in the CDI specification.
Thus, CDI provides  <span class='latex-texttt'>@ApplicationScoped</span> ,  <span class='latex-texttt'>@SessionScoped</span> , and  <span class='latex-texttt'>@RequestScoped</span>  by default.
Additionally, a new Conversation-Scope was introduced. In this chapter, we limit ourselves to a summary of the standard scopes.
Concrete examples of web scopes will be analyzed in the chapters  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI and Java EE </a>  (JSF) and
 <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a>  (DS Test-Control).<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.1' ><span class='entry-number'>2.3.0.1</span> @ApplicationScoped</a></h4>
 As the name suggests, application-scoped Contextual-Instances exist from the first access until the end of the application.
Thus, it is an application-wide singleton.<br /> <div class="tip"><b>Tip: </b> The term "application" is not precisely defined.
Even after more than 100 comments on specification ticket CDI-129, no fully accepted definition has emerged.
At this point, it is only clear that Weld and OpenWebBeans define the application concept differently when the application is packaged in an EAR file. OpenWebBeans adheres to the referenced behavior of the Servlet specification, whereas Weld follows the EJB world.
Therefore, with Weld, an application-scoped Contextual-Instance is valid across all web applications within an EAR, provided it can be accessed. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In our application, as shown in Listing  <a href='#!idx:/cdi_basics.html:fig:application-scoped_bean'> Using Scopes </a> ,
we can annotate  <span class='latex-texttt'>IdeaManager</span>  with  <span class='latex-texttt'>@ApplicationScoped</span> , for example.
The rest of the application remains unchanged. The change at runtime is only visible in the debugger in this case.
Since this class is implemented in a stateless manner, there is no immediately noticeable impact on the application, and the unit tests do not need to be adjusted. In the debugger, however, you can observe that the reference variables populated by the CDI container with a Contextual-Reference to  <span class='latex-texttt'>IdeaManager</span>  no longer point directly to the Contextual-Instance at runtime as before, but instead to a corresponding proxy.
As expected, only one Contextual-Instance is created (per container start).<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:application-scoped_bean'></a>                     <pre><code>@ApplicationScoped
public class IdeaManager {
  private IdeaValidator ideaValidator;

  protected IdeaManager() {
    //needed by proxy-libs
  }

  @Inject
  protected IdeaManager(IdeaValidator ideaValidator) {
    this.ideaValidator = ideaValidator;
  }
  //...
}
</code></pre>
                </div>
 <div class="tip"><b>Tip: </b> In Listing  <a href='#!idx:/cdi_basics.html:fig:application-scoped_bean'> Using Scopes </a> , Constructor-Injection is used.
Since the Contextual-Reference for normal-scoped beans is a proxy at runtime, it must be possible to create a proxy instance for this class. In Java, this is only feasible with the default constructor.
The parameterized constructor is only used later for creating the Contextual-Instance.
How often the default constructor may be called is not specified.
Initialization logic should therefore be moved to a method annotated with  <span class='latex-texttt'>@PostConstruct</span> . This additionally offers the advantage that all Injection-Points are already populated and thus available for use. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.2' ><span class='entry-number'>2.3.0.2</span> @SessionScoped</a></h4>
 In terms of lifetime, the CDI Session-Scope is equivalent to the validity of the current HTTP session.
Consequently, a session-scoped Contextual-Instance is a so-called session singleton.
Across multiple user sessions, there can be multiple Contextual-Instances of a Managed-Bean.
Within a single user session, by definition only one Contextual-Instance per Managed-Bean is possible.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> To enable mechanisms such as session replication, this scope is defined as passivating.
In scope annotations such as  <span class='latex-texttt'>javax.enterprise.context.SessionScoped</span> , this is indicated by  <span class='latex-texttt'>@NormalScope(passivating = true)</span> .
Therefore, bean classes must (in)directly implement the  <span class='latex-texttt'>java.io.Serializable</span>  interface.
Referenced CDI beans do not need to be serializable themselves if they are normal-scoped beans.
At runtime, the CDI container ensures that the proxies are serializable.
Because only these proxies (Contextual-References), and not the referenced Contextual-Instances themselves, are stored with a passivating bean. CDI proxies always work the same regardless of passivation.
Using a unique (internal) bean ID, the currently valid instance is looked up or created as needed, and then the desired method is invoked on the Contextual-Instance.<br /> <div class="tip"><b>Tip: </b> To avoid unexpected problems at runtime,
CDI requires the implementation of  <span class='latex-texttt'>java.io.Serializable</span>  for beans with a passivating scope.
This rule always applies, even if passivation of beans never actually occurs in an application.
Therefore, this rule must always be checked by the CDI container at application startup.
In case of an error, the startup process is aborted and an appropriate error message is displayed. </div>
<div class="tip"><b>Tip: </b><b>Common mistake &mdash; Serialization:</b> Normal-scoped beans in passivating scopes (e.g., <span class='latex-texttt'>@SessionScoped</span>) must implement <span class='latex-texttt'>Serializable</span>. Forgetting this causes container startup or runtime errors. This also applies to all non-transient fields of the bean class.</div>
<h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.3' ><span class='entry-number'>2.3.0.3</span> @RequestScoped</a></h4>
 Equivalent to the scope definitions described so far, request-scoped beans are singletons per (HTTP) request and therefore valid only for the current request. Request-scoped beans are not passivating, since an HTTP request itself cannot be stored on an external storage medium and reactivated at a later point in time.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.4' ><span class='entry-number'>2.3.0.4</span> @ConversationScoped</a></h4>
 The Conversation-Scope was primarily specified for JSF-based applications.
It is comparable to a session per browser window/tab (including passivation capability).
However, the current conversation must be manually started and ended.
If a conversation is not started, it is a transient conversation that must be destroyed by the CDI container at the end of the request.
To avoid this,  <span class='latex-texttt'>javax.enterprise.context.Conversation</span>  can be injected and the  <span class='latex-texttt'>begin</span>  method called.
This makes all conversation-scoped CDI beans available until  <span class='latex-texttt'>end</span>  is explicitly called on the injected conversation.
This is where the special integration with JSF comes into play. A conversation is not ended immediately but only after the next rendering process.
This rule makes the end of the conversation independent of the chosen type of JSF navigation (forward vs. redirect).<br /> <div class="tip"><b>Tip: </b> Unfortunately, CDI standard conversations are very limited and not suitable for many use cases, both technically and from a business perspective.
For this reason, we recommend using (Grouped-)Conversations instead, which were introduced with CODI and adopted in DeltaSpike (see chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> ).
The limitations and weaknesses of CDI standard conversations were specifically addressed there.
We will go into further details about (Grouped-)Conversations in the chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> . </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.5' ><span class='entry-number'>2.3.0.5</span> @Dependent</a></h4>
<span class='latex-texttt'>@Dependent</span>  is currently the only Pseudo-Scope in the CDI specification and is also the default scope for CDI beans.
In  <span class='latex-textit'>IdeaFork</span> , for example, no scope is explicitly specified for  <span class='latex-texttt'>IdeaValidator</span> .
Internally, the CDI container treats such beans as if they were explicitly annotated with  <span class='latex-texttt'>@Dependent</span> .
In our application,  <span class='latex-texttt'>IdeaValidator</span>  is injected into  <span class='latex-texttt'>IdeaManager</span> .
The instance injected into  <span class='latex-texttt'>IdeaManager</span>  therefore exists as long as the Contextual-Instance of  <span class='latex-texttt'>IdeaManager</span> .
In this specific case, the instance of  <span class='latex-texttt'>IdeaManager</span>  exists until the application stops.
When the  <span class='latex-texttt'>IdeaManager</span>  instance is destroyed, the injected  <span class='latex-texttt'>IdeaValidator</span>  instance is also destroyed by the CDI container, since  <span class='latex-texttt'>IdeaValidator</span>  is implicitly dependent-scoped.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> It follows that the lifetime of a dependent-scoped Contextual-Instance is bound to the lifetime of the Contextual-Instance into which it is injected. Thus, the lifetime of dependent-scoped beans corresponds to normal objects created with the  <span class='latex-texttt'>new</span>  keyword and assigned to an instance variable.
With dependent-scoped beans, however, the CDI container takes over the creation (including any interceptors, etc.) and, in the case of direct injection, also the destruction of the dependent-scoped Contextual-Instance.<br /> <div class="tip"><b>Tip: </b> When using the CDI scope annotations  <span class='latex-texttt'>@ApplicationScoped</span> ,  <span class='latex-texttt'>@SessionScoped</span> , and  <span class='latex-texttt'>@RequestScoped</span> , it is important to pay attention to the packages. If you accidentally import  <span class='latex-texttt'>javax.faces.bean</span>  instead of  <span class='latex-texttt'>javax.enterprise.context</span> ,
you are using an invalid scope annotation from the CDI container's perspective, and consequently the  <span class='latex-texttt'>Dependent</span>  scope is used.
Portable extensions such as DeltaSpike translate JSF annotations for the CDI container, thereby eliminating this common source of errors in a straightforward manner. </div>
<div class="tip"><b>Tip: </b><b>Common mistake &mdash; Scope mismatch:</b> When a <span class='latex-texttt'>@Dependent</span> bean is injected into an <span class='latex-texttt'>@ApplicationScoped</span> bean, the <span class='latex-texttt'>@Dependent</span> instance lives as long as the target bean &mdash; i.e., the entire application lifetime. This can lead to unexpected state behavior. When encountering unexpected side effects, always verify that the scope combination of the involved beans is correct.</div>
<h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.6' ><span class='entry-number'>2.3.0.6</span> Manual Scope Control</a></h4>
 In a Java SE application, web scopes are of limited usefulness.
Nevertheless, it may be necessary to use a portable CDI extension that uses one or more of these scopes, for example to cache values for the current request.
If you use CDI in a Java SE application, you can still use beans with web scopes.
However, the scopes must be explicitly started and stopped.
In web applications, this is done automatically by the container, provided there is a current HTTP request or an active HTTP session.
If you implement a batch job, for example, that is deployed as part of a web application, you must take over scope control manually.
This way, the batch job can run in the background without a real HTTP request, for example, and still access beans with web scopes.
We will go into technical details on manual control of standard scopes in the chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> .<br /> <div class="tip"><b>Tip: </b> A scope is associated with a  <span class='latex-texttt'>Context</span>  instance that manages all Contextual-Instances of the scope and decides whether the scope is active at a given point in time.
Since there is only one  <span class='latex-texttt'>Context</span>  instance per scope per application (within a JVM), it is responsible for providing the correct Contextual-Instance of the respective bean for the current thread.
Conversely, this means that within a thread, only one Contextual-Instance is available for a bean.
A simple analogy for this is a Map. For each key (Managed-Bean), a value (Contextual-Instance) can be stored.
Depending on the scope definition, there can be one or more such maps.
In the case of the Application-Scope, for example, there is one map for the entire application.
In contrast, for the Request-Scope, there is one map per (HTTP) request.
If the context is not active, a  <span class='latex-texttt'>ContextNotActiveException</span>  is thrown when a Contextual-Instance in this context is accessed. </div><h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.4' ><span class='entry-number'>2.4</span> Qualifiers</a> </h2>
 So far, we had simple constellations where we had exactly one bean for a task.
In such cases, direct type-safe injection is not a problem, since the desired type is specified at the Injection-Point.
In real applications, we typically encounter more extensive requirements.
As a concrete example, we introduce an  <span class='latex-texttt'>ObjectConverter</span>  interface in  <span class='latex-textit'>IdeaFork</span> .
Implementations of the interface can convert objects to an external text format and vice versa.
To support different export formats, for example, different implementations of the interface are required.
In the application, however, development should only be done against the interface.
Consequently, we need a mechanism to identify the concrete implementations at the Injection-Point without specifying the implementation class itself. In CDI, this is covered by qualifier annotations.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span> , we want to support XML and JSON as external formats.
For XML, we initially use JAXB, and for JSON, a library called Gson (http://code.google.com/p/google-gson/).
We start with simple "marker qualifiers". Similar to marker interfaces, they serve as additional markers.
For creating the qualifier annotations  <span class='latex-texttt'>@XML</span>  and  <span class='latex-texttt'>@JSON</span> , we need to consider where these annotations should be used.
In a first step, we want to annotate the implementation classes ( <span class='latex-texttt'>ElementType.TYPE</span> ).
Later, we will learn about producer methods, for which  <span class='latex-texttt'>ElementType.METHOD</span>  would be required.
For possible Injection-Points, we can support fields ( <span class='latex-texttt'>ElementType.FIELD</span> )
as well as method (and constructor) parameters ( <span class='latex-texttt'>ElementType.PARAMETER</span> ).
For the CDI container to recognize custom annotations as qualifiers, we must annotate our annotations with  <span class='latex-texttt'>javax.inject.Qualifier</span> .
Listing  <a href='#!idx:/cdi_basics.html:fig:marker-qualifier-annotation'> Simple Qualifier Annotation as Marker </a>  shows the complete implementation of  <span class='latex-texttt'>@JSON</span> .
 <span class='latex-texttt'>@XML</span>  differs only by the name of the annotation.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:marker-qualifier-annotation'></a>                     <pre><code>@Target({TYPE, FIELD})
@Retention(RUNTIME)
@Qualifier
public @interface JSON {}
</code></pre>
                </div>
With the qualifier annotations  <span class='latex-texttt'>@JSON</span>  and  <span class='latex-texttt'>@XML</span> , we can identify both implementations.
As shown in Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_qualifier'> Bean Class with Qualifier </a> , we annotate the implementation classes with the corresponding qualifier.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:bean_with_qualifier'></a>                     <pre><code>@JSON
@ApplicationScoped
public class JSONConverter implements ObjectConverter {
  @Override
  public &lt;T&gt; T toObject(String value, Class&lt;T&gt; type) {
    return new Gson().fromJson(value, type);
  }

  @Override
  public String toString(Object entity) {
    return new Gson().toJson(entity);
  }
}
</code></pre>
                </div>
Since the implementation in Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_qualifier'> Bean Class with Qualifier </a>  is stateless,
we could also use the  <span class='latex-texttt'>Dependent</span>  scope, in which case no longer needed instances would have to be continuously cleaned up by the garbage collector.
The proxy overhead is minimal nowadays, so there is no "right" or "wrong" choice here.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> To test the export logic of our JSON converter, for example, we can use it in a unit test.
In Listing  <a href='#!idx:/cdi_basics.html:fig:injection-point_with_qualifier'> Injection-Point with Qualifier </a> , we inject the converter using our general  <span class='latex-texttt'>ObjectConverter</span>  interface in combination with  <span class='latex-texttt'>@JSON</span>  as a qualifier.
Without qualifier annotations, we could never inject an interface with multiple implementations and would have to specify the implementation class directly at the Injection-Point.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> If no qualifier is specified at the Injection-Point,
the CDI container uses  <span class='latex-texttt'>javax.enterprise.inject.Default</span>  as the default qualifier.
If we omit  <span class='latex-texttt'>@JSON</span>  in our example, no matching CDI bean can be found, since we have not yet annotated any implementation explicitly or implicitly with the  <span class='latex-texttt'>Default</span>  qualifier.
In such cases, the container startup is aborted with an  <span class='latex-texttt'>UnsatisfiedResolutionException</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> If we were to completely omit qualifiers and still use the interface type at the Injection-Point,
an  <span class='latex-texttt'>AmbiguousResolutionException</span>  would be the reason for the container startup abort, since multiple implementations with the implicit  <span class='latex-texttt'>Default</span>  qualifier would be available.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:injection-point_with_qualifier'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class QualifierTest {
  private String topic = "Learn CDI-Qualifiers";
  private String category = "Education";

  @Inject
  @JSON
  private ObjectConverter objectConverterJSON;

  @Inject
  private IdeaManager ideaManager;

  @Test
  public void jsonConversion() {
    Idea exportedIdea = ideaManager.createIdeaFor(topic, category);

    String jsonString =
      objectConverterJSON.toString(exportedIdea);

    Idea importedIdea =
      objectConverterJSON.toObject(jsonString, Idea.class);

    Assert.assertTrue(exportedIdea.equals(importedIdea));
  }
}
</code></pre>
                </div>
In large projects, we would quickly end up with a multitude of qualifier annotations if we needed an annotation for each implementation.
For this reason, it is possible to include arbitrary additional information in a qualifier annotation.
In our case, instead of  <span class='latex-texttt'>@XML</span>  and  <span class='latex-texttt'>@JSON</span> , we can use a qualifier named  <span class='latex-texttt'>@ExternalFormat</span> .
To continue distinguishing between XML and JSON, we add an  <span class='latex-texttt'>enum</span> .
Listing  <a href='#!idx:/cdi_basics.html:fig:qualifier-annotation_with_member'> Qualifier with Annotation Attribute </a>  shows the implementation of  <span class='latex-texttt'>@ExternalFormat</span>  and
Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_qualifier_with_member'> Using Qualifiers with Annotation Attribute </a>  the changed usage at the implementation and an Injection-Point.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:qualifier-annotation_with_member'></a>                     <pre><code>@Target({TYPE, METHOD, FIELD, PARAMETER})
@Retention(RUNTIME)
@Qualifier
public @interface ExternalFormat {
  TargetFormat value();

  enum TargetFormat {
    XML, JSON
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:bean_with_qualifier_with_member'></a>                     <pre><code>@ExternalFormat(ExternalFormat.TargetFormat.JSON)
@ApplicationScoped
public class JSONConverter implements ObjectConverter {
    //...
}

@RunWith(CdiTestRunner.class)
public class QualifierTest {

  @Inject
  @ExternalFormat(JSON)
  private ObjectConverter objectConverterJSON;

  //...
}
</code></pre>
                </div>
In various use cases, it may be necessary to provide information that should be ignored by CDI. For such cases, annotation attributes can be annotated with  <span class='latex-texttt'>@Nonbinding</span> .
In Listing  <a href='#!idx:/cdi_basics.html:fig:qualifier_with_nonbinding'> Excluded Annotation Attribute </a> ,  <span class='latex-texttt'>@ExternalFormat</span>  is extended with an optional description that is not used by the CDI container for qualifier logic.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:qualifier_with_nonbinding'></a>                     <pre><code>@Target({TYPE, FIELD})
@Retention(RUNTIME)
@Qualifier
public @interface ExternalFormat {
  TargetFormat value();

  @Nonbinding
  String description() default "";

  enum TargetFormat {
    XML, JSON
  }
}
</code></pre>
                </div>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5' ><span class='entry-number'>2.5</span> Dynamic Usage of CDI Beans</a> </h2>
 So far, we have used "direct" injection. There was always an explicit Injection-Point that is automatically populated by the CDI container at runtime with a Contextual-Reference.
These Injection-Points are validated for their validity during container startup, since there must be exactly one Managed-Bean for each such Injection-Point.
However, there are cases where we need optional or even multiple Managed-Beans.
For such use cases, beans must be looked up dynamically.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.1' ><span class='entry-number'>2.5.0.1</span> Indirection with Instance</a></h4>
<a name = '!idx:/cdi_basics.html:sec:lookup_via_instance'> </a> In the previous chapter, we directly injected the  <span class='latex-texttt'>ObjectConverter</span>  in combination with the qualifier for JSON or XML.
Listing  <a href='#!idx:/cdi_basics.html:fig:injection_with_instance'> Dynamic Injection with Instance </a>  shows the direct equivalent via dynamic injection using  <span class='latex-texttt'>javax.enterprise.inject.Instance</span> .
This interface extends  <span class='latex-texttt'>javax.inject.Provider</span> , which defines the  <span class='latex-texttt'>get</span>  method.
The lookup is only performed when this method is called.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:injection_with_instance'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  //...

  @Inject
  @ExternalFormat(JSON)
  private Instance&lt;ObjectConverter&gt; objectConverterJSONInstance;

  @Test
  public void jsonConversion() {
    //...
    String jsonString =
      objectConverterJSONInstance.get().toString(exportedIdea);
    //...
  }
}
</code></pre>
                </div>
Before calling  <span class='latex-texttt'>get</span> , you can use the  <span class='latex-texttt'>isUnsatisfied</span>  method to check whether the lookup would return a result or lead to an  <span class='latex-texttt'>UnsatisfiedResolutionException</span> .
Through this mechanism, optional beans are possible.
For example, we can extend our  <span class='latex-texttt'>ExternalFormat</span>  qualifier with an additional format (CSV).
However, we do not provide an implementation, thereby obtaining an optional bean.
A plug-in for the application could subsequently add such an implementation.
This concept is often used for simple interfaces (without qualifier annotations) with only one optional implementation.
Listing  <a href='#!idx:/cdi_basics.html:fig:dynamic_injection_with_optional_beans'> Dynamic Injection for Optional Beans </a>  shows a corresponding unit test.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:dynamic_injection_with_optional_beans'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  @ExternalFormat(CSV)
  private Instance&lt;ObjectConverter&gt; objectConverterCSVInstance;

  @Test(expected = UnsatisfiedResolutionException.class)
  public void optionalConverter() {
    Assert.assertTrue(objectConverterCSVInstance.isUnsatisfied());
    objectConverterCSVInstance.get();
  }
}
</code></pre>
                </div>
Another possibility is using multiple beans of the same type.
Before calling  <span class='latex-texttt'>get</span> , you can check with  <span class='latex-texttt'>isAmbiguous</span>  whether the method call would result in multiple beans and thus an  <span class='latex-texttt'>AmbiguousResolutionException</span> .
For this purpose, we can, for example, perform a lookup on all implementations of the type  <span class='latex-texttt'>ObjectConverter</span> .
CDI provides a "virtual" qualifier named  <span class='latex-texttt'>javax.enterprise.inject.Any</span>  for such a lookup.
Listing  <a href='#!idx:/cdi_basics.html:fig:dynamic_injection_with_multiple_beans_and_get'> Dynamic Injection with Multiple Beans </a>  shows a corresponding unit test.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:dynamic_injection_with_multiple_beans_and_get'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  @Any
  private Instance&lt;ObjectConverter&gt; converterInstance;

  @Test(expected = AmbiguousResolutionException.class)
  public void ambiguousConverter() {
    Assert.assertTrue(converterInstance.isAmbiguous());
    converterInstance.get();
  }
}
</code></pre>
                </div>
However, there are also use cases where multiple beans of the same type are needed.
An example of this are plug-ins. In such cases, the  <span class='latex-texttt'>get</span>  method cannot be used.
However,  <span class='latex-texttt'>Instance</span>  also extends the  <span class='latex-texttt'>Iterable</span>  interface, and therefore the injected  <span class='latex-texttt'>Instance</span>  can be used in a loop, for example.
Listing  <a href='#!idx:/cdi_basics.html:fig:dynamic_injection_with_multiple_beans_and_iterator'> Dynamic Injection with Multiple Beans </a>  illustrates this using an automated test of all  <span class='latex-texttt'>ObjectConverter</span>  beans.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:dynamic_injection_with_multiple_beans_and_iterator'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  @Any
  private Instance&lt;ObjectConverter&gt; converterInstance;

  @Inject
  private IdeaManager ideaManager;

  @Test
  public void allConverters() {
    Assert.assertTrue(converterInstance.isAmbiguous());
    Assert.assertFalse(converterInstance.isUnsatisfied());

    for (ObjectConverter converter : converterInstance) {
      Idea idea = ideaManager.createIdeaFor(...);
      String exported = converter.toString(idea);
      Assert.assertTrue(
        converter.toObject(exported, Idea.class).equals(idea));
    }
  }
}
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.2' ><span class='entry-number'>2.5.0.2</span> Finding Beans via BeanManager</a></h4>
<a name = '!idx:/cdi_basics.html:sec:lookup_via_bm'> </a> The  <span class='latex-texttt'>BeanManager</span>  serves for interaction with the CDI container.
Through it, you can, for example, check whether an annotation is a qualifier, fire events, manually look up beans, and much more.
A reference to the  <span class='latex-texttt'>BeanManager</span>  can be injected or retrieved via JNDI, for example.
Normally, it is not necessary to obtain Contextual-References using the  <span class='latex-texttt'>BeanManager</span> .
In many cases, such a manual lookup is used in classes that are not managed by the CDI container.
Without  <span class='latex-texttt'>CdiTestRunner</span> , this would be one of the options for implementing unit tests without special CDI support.
Listing  <a href='#!idx:/cdi_basics.html:fig:manual_bean-lookup'> Manual Lookup via BeanManager </a>  shows the steps to obtain a Contextual-Reference to  <span class='latex-texttt'>IdeaManager</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:manual_bean-lookup'></a>                     <pre><code>Set&lt;Bean&lt;?&gt;&gt; beans = this.beanManager.getBeans(IdeaManager.class);
Bean&lt;?&gt; bean = beanManager.resolve(beans);
CreationalContext&lt;?&gt; creationalContext =
  beanManager.createCreationalContext(bean);
this.ideaManager = (IdeaManager)this.beanManager.getReference(
  bean, IdeaManager.class, creationalContext);
</code></pre>
                </div>
In the first step, the result is a set of beans, since it may contain, for example, alternative beans that we will learn about later.
Only by calling  <span class='latex-texttt'>resolve</span>  in the second step is a valid result returned.
Even if in many cases the set contains only one entry, you must not skip the second step and always use the first bean in the set, as this can lead to unexpected side effects later.
Based on the Managed-Bean definition, the so-called  <span class='latex-texttt'>CreationalContext</span>  can be created.
Together with the bean and the expected target type, this must be passed to  <span class='latex-texttt'>getReference</span>  to finally obtain a Contextual-Reference.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.3' ><span class='entry-number'>2.5.0.3</span> Dependent-Scoped Beans</a></h4>
 Even with dynamic injection or a manual lookup, dependent-scoped beans occupy a special position.
Because the bean is created by the CDI container and provided externally for each of these dynamic calls.
It follows that the container no longer manages the Contextual-Instance afterwards and is therefore no longer responsible for its destruction.
Even if a manual assignment to an instance variable of a normal-scoped bean is performed in a subsequent step, it remains a manually managed instance, since this instance variable is not a regular Injection-Point.
In such special cases, destruction must be performed manually.
For this, you must save the  <span class='latex-texttt'>CreationalContext</span>  instance and the Managed-Bean definition to later correctly destroy the dependent-scoped bean via  <span class='latex-texttt'>bean.destroy(contextualInstance, creationalContext)</span> .
Manual bean lookups should therefore always remain the exception and be implemented with care.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.4' ><span class='entry-number'>2.5.0.4</span> Literals</a></h4>
 Annotations in Java are static metadata that cannot be manually instantiated.
In the previous chapter, we saw that there are qualifier annotations with attributes.
In combination with direct injection, we encounter no limitations.
However, for dynamically finding a bean with a qualifier, we need instances of an annotation so that we can provide the desired values.
To create instances of annotations despite this Java limitation, CDI uses a trick.
By creating an  <span class='latex-texttt'>Annotation-Literal</span>  class, a manually created instance of the corresponding annotation can be provided to the JVM.
Listing  <a href='#!idx:/cdi_basics.html:fig:annotation-literal'> Annotation Literal for ExternalFormat </a>  shows a literal for  <span class='latex-texttt'>ExternalFormat</span> .
For this, you must extend  <span class='latex-texttt'>javax.enterprise.util.AnnotationLiteral</span>  and implement the annotation type.
As with an interface, all annotation methods must be implemented.
Typically, literal values do not change, and therefore the desired values can be passed directly via a parameterized constructor.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:annotation-literal'></a>                     <pre><code>public class ExternalFormatLiteral
  extends AnnotationLiteral&lt;ExternalFormat&gt;
  implements ExternalFormat {
    private final TargetFormat value;

    public ExternalFormatLiteral(TargetFormat value) {
      this.value = value;
    }

    @Override
    public TargetFormat value() {
      return this.value;
    }

    @Override
    public String description() {
      return "";
    }
}
</code></pre>
                </div> Equipped with the literal class, we can use the  <span class='latex-texttt'>select</span>  method of Instance to narrow the search with a qualifier.
At the Injection-Point of  <span class='latex-texttt'>Instance</span> , in such cases  <span class='latex-texttt'>@Any</span>  is normally used, since the effective qualifier is defined dynamically later.
Listing  <a href='#!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_instance'> Using Annotation Literal with Instance </a>  illustrates the use of our annotation literal in combination with  <span class='latex-texttt'>Instance</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_instance'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  @Any
  private Instance&lt;ObjectConverter&gt; converterInstance;

  @Inject
  private IdeaManager ideaManager;

  @Test
  public void xmlConversion() {
    Idea exportedIdea = ideaManager.createIdeaFor(...);

    Assert.assertTrue(converterInstance.isAmbiguous());
    Assert.assertFalse(converterInstance.isUnsatisfied());

    String xmlString = converterInstance.select(
      new ExternalFormatLiteral(XML)).get()
      .toString(exportedIdea);

    //...
  }
}
</code></pre>
                </div>
We can of course also use our annotation literal for the lookup via  <span class='latex-texttt'>BeanManager</span> .
Listing  <a href='#!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_bean-manager'> Using Annotation Literal with BeanManager </a>  extends Listing  <a href='#!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_instance'> Using Annotation Literal with Instance </a> with a second bean lookup via  <span class='latex-texttt'>BeanManager</span>  instead of via  <span class='latex-texttt'>Instance</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_bean-manager'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  private BeanManager beanManager;

  @Inject
  @Any
  private Instance&lt;ObjectConverter&gt; converterInstance;

  @Inject
  private IdeaManager ideaManager;

  @Test
  public void xmlConversion() {
    Idea exportedIdea = ideaManager.createIdeaFor(...);

    Assert.assertTrue(converterInstance.isAmbiguous());
    Assert.assertFalse(converterInstance.isUnsatisfied());

    String xmlString = converterInstance.select(
      new ExternalFormatLiteral(XML)).get()
      .toString(exportedIdea);

    Set&lt;Bean&lt;?&gt;&gt; beans = beanManager.getBeans(
      ObjectConverter.class, new ExternalFormatLiteral(XML));
    Bean&lt;?&gt; bean = beanManager.resolve(beans);
    CreationalContext&lt;?&gt; creationalContext =
      beanManager.createCreationalContext(bean);

    ObjectConverter xmlConverter =
      (ObjectConverter)this.beanManager.getReference(
        bean, ObjectConverter.class, creationalContext);

    Idea importedIdea =
      xmlConverter.toObject(xmlString, Idea.class);
    Assert.assertTrue(exportedIdea.equals(importedIdea));
  }
}
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.5' ><span class='entry-number'>2.5.0.5</span> Type-Literal</a></h4>
 A comparable helper exists for parameterized classes and is called Type-Literal.
The use cases for this are rather rare, however. Should you encounter one, you can use  <span class='latex-texttt'>TypeLiteral</span>  similarly to annotation literals.
An example of this is:  <span class='latex-texttt'>new TypeLiteral&lt;MyBean&lt;MyType&gt;&gt;(){}</span> .<br />
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6' ><span class='entry-number'>2.6</span> Producer/Disposer Methods</a> </h2>
 In most cases, it is sufficient to use a simple Java class as a CDI bean.
The CDI container instantiates the class and performs various additional functionalities such as dependency injection.
Special initialization logic can be implemented in a method annotated with  <span class='latex-texttt'>@javax.annotation.PostConstruct</span> , and before the instance is destroyed, a method annotated with  <span class='latex-texttt'>@javax.annotation.PreDestroy</span>  can be used to ensure that the necessary cleanup tasks are performed.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> However, there are use cases with more complex requirements, or where classes must be used that require special initialization logic or cleanup tasks.
One of these use cases is the type-safe configuration of applications.
Many applications are customizable through configured values.
These values are either shipped in configuration files or loaded from a central source such as a database.
Typos, for example, can lead to failures or severe errors in the application.
In some cases, such errors are only discovered late, especially when configured values are read and converted only on demand.
To counteract such errors, in the next step we will create a type-safe application configuration and a producer method for the manual initialization of the configuration object.<br /> <div class="tip"><b>Tip: </b> Type-safe configurations can be simple POJOs that are usable as CDI beans.
CDI extensions such as CODI and DeltaSpike provide type-safe configurations through this simple concept.
The default values of the configuration are often hardcoded.
Through alternative implementations, which we will examine more closely in the chapter  <a href='#!idx:/cdi_basics.html:sec:cdi-alternatives'> [ Replacing Beans] </a> , the predefined values can be easily customized. </div> In  <span class='latex-textit'>IdeaFork</span> , we initially want to connect a simple configuration file and make its values available in a type-safe manner within the application.
The configured values are stored in a property file as key/value pairs.
We can read them using  <span class='latex-texttt'>java.util.ResourceBundle</span> .
In our configuration class named  <span class='latex-texttt'>ApplicationConfig</span> , we only pass a  <span class='latex-texttt'>ResourceBundle</span>  instance in the constructor and load information such as the application name.
We want to extract the logic for creating the  <span class='latex-texttt'>ResourceBundle</span>  instance into a producer.
To better illustrate type safety, we additionally add a custom  <span class='latex-texttt'>ApplicationVersion</span>  type.
In Listing  <a href='#!idx:/cdi_basics.html:fig:producer-method'> Producer Method </a> , the producer method creates an application-scoped bean of type  <span class='latex-texttt'>ApplicationConfig</span> .
This implementation is kept very simple.
Additionally, bean validation could be used, for example, to also validate the loaded and converted values.
Furthermore, producers also optionally support qualifier annotations.
We will take advantage of this benefit later for the dynamic selection of a default implementation.<br />which are not required in simple use cases like this one.<br /> <div class="tip"><b>Tip: </b> If only the  <span class='latex-texttt'>@Produces</span>  annotation were used,
we would create a producer for an implicitly dependent-scoped bean with  <span class='latex-texttt'>Default</span>  qualifier. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Without using a qualifier, however, we again face the problem of having two Managed-Beans with the same type.
Since we want to use the result of the producer method as the Managed-Bean for  <span class='latex-texttt'>ApplicationConfig</span>  and
not the  <span class='latex-texttt'>ApplicationConfig</span>  class itself, we must signal to the CDI container
not the  <span class='latex-texttt'>ApplicationConfig</span>  class itself, we need to signal to the CDI container
that the  <span class='latex-texttt'>ApplicationConfig</span>  class should not be used.
As we will learn later, this is possible through a veto of the bean.
For this we need to either create a CDI extension or use an existing one.
Only starting with CDI 1.1 can such a veto be used via the  <span class='latex-texttt'>@Vetoed</span>  annotation without additional requirements.
With CDI 1.0 there is still a simple trick without the previously mentioned extensions.
The annotation  <span class='latex-texttt'>@Typed</span>  enables explicit typing.
If, for example, a CDI bean class implements two interfaces,  <span class='latex-texttt'>@Typed</span>  can be used to specify
that this bean class only receives one of the two types for the injection process.
This annotation can also be used without specifying a type, which makes the Managed-Bean invisible for type-safe injection.
If we therefore annotate the  <span class='latex-texttt'>ApplicationConfig</span>  class with  <span class='latex-texttt'>@Typed()</span> , we take one of the two beans out of the equation, and
thus only the producer method with the type  <span class='latex-texttt'>ApplicationConfig</span>  remains.
Listing  <a href='#!idx:/cdi_basics.html:fig:custom_type-safe_config'> Class for a type-safe configuration </a>  shows an excerpt of the  <span class='latex-texttt'>ApplicationConfig</span>  class and
Listing  <a href='#!idx:/cdi_basics.html:fig:producer-method'> Producer method </a>  the producer method.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:custom_type-safe_config'></a>                     <pre><code>@Typed()
public class ApplicationConfig {
  private String applicationName;
  private ApplicationVersion applicationVersion;

  protected ApplicationConfig() {
    //needed for creating a proxy
  }

  public ApplicationConfig(ResourceBundle config) {
    applicationName = config.getString("name");
    applicationVersion =
      new ApplicationVersion(config.getString("version"));
  }
  //+ Getter-Methods

  public static class ApplicationVersion {
    //...
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:producer-method'></a>                     <pre><code>@Produces
@ApplicationScoped
public ApplicationConfig exposeConfig() {
  ResourceBundle config = ResourceBundle.getBundle("app-config");
  return new ApplicationConfig(config);
}
</code></pre>
                </div>
As we already know, a proxy is created for normal-scoped beans.
Since the producer method in Listing  <a href='#!idx:/cdi_basics.html:fig:producer-method'> Producer method </a>  defines a normal-scoped bean,
there must consequently be a default constructor in the  <span class='latex-texttt'>ApplicationConfig</span>  class.<br /> <div class="tip"><b>Tip: </b> To use classes outside of CDI archives as CDI beans,
there are various options besides using producer methods (or fields),
which are presented in the chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> .
More complex initialization logic, however, can only be implemented with a producer method. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6.0.1' ><span class='entry-number'>2.6.0.1</span> Manual Injection</a></h4>
 CDI beans created via a producer have a few limitations.
The CDI container does not perform dependency injection on the created object, and no interceptors are added either,
since the creation and initialization of the Contextual-Instance is done manually in the producer, and
interceptors intercept the producer method rather than being applied to the result of the producer.
With the trick from Listing  <a href='#!idx:/cdi_basics.html:fig:manual_injection'> Manual field and method injection trick </a>  you can trigger field and method injection manually.
In the code excerpt,  <span class='latex-texttt'>unmanagedBean</span>  represents the manually created instance.
Note, however, that while you can inject dependent-scoped beans,
due to the missing  <span class='latex-texttt'>CreationalContext</span>  of the injected beans, you cannot destroy them correctly.
However, the primary effect is that dependent-scoped beans in combination with such manual injection
cannot use  <span class='latex-texttt'>@PreDestroy</span>  annotated methods. With the appropriate detailed knowledge about these beans,
the callback methods can be called manually in the (optional) disposer method if needed.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:manual_injection'></a>                     <pre><code>CreationalContext creationalContext =
  this.beanManager.createCreationalContext(null);
AnnotatedType annotatedType = this.beanManager
  .createAnnotatedType(unmanagedBean.getClass());
InjectionTarget injectionTarget = this.beanManager
  .createInjectionTarget(annotatedType);
injectionTarget.inject(unmanagedBean, creationalContext);
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6.0.2' ><span class='entry-number'>2.6.0.2</span> Disposer Methods</a></h4>
 The optional counterpart to the producer method is the disposer method.
As already mentioned, beans created with a producer do not support lifecycle callbacks.
The task of  <span class='latex-texttt'>@PostConstruct</span>  is taken over by the producer itself, and
instead of  <span class='latex-texttt'>@PreDestroy</span>  a so-called disposer method can be used.
As Listing  <a href='#!idx:/cdi_basics.html:fig:disposer-method'> Disposer method </a>  shows, this is a method with at least one parameter.
The type and qualifiers must match those of the producer method.
Additionally, the first mandatory parameter must be annotated with  <span class='latex-texttt'>@Disposes</span> .
Only through this annotation does the CDI container recognize the method as a disposer.
Since  <span class='latex-texttt'>ApplicationConfig</span>  is application-scoped, the disposer method is executed before every application shutdown.
In our simple example, we log the version of the application that is being shut down.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:disposer-method'></a>                     <pre><code>public void onDispose(@Disposes
  ApplicationConfig applicationConfig) {
    LOGGER.info("shutting down v"
      + applicationConfig.getApplicationVersion());
}
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6.0.3' ><span class='entry-number'>2.6.0.3</span> Selecting Beans with Producer Methods</a></h4>
 Producer methods can also be used, for example, to select a default implementation.
Let us first start with the simplest possible producer method.
We have neither explicitly nor implicitly used the  <span class='latex-texttt'>Default</span>  qualifier with the  <span class='latex-texttt'>ObjectConverter</span>  implementations.
Therefore, we do not need to define a new qualifier but can fall back on the  <span class='latex-texttt'>Default</span>  qualifier.
Listing  <a href='#!idx:/cdi_basics.html:fig:simple_selection_via_producer-method'> Simple selection via producer </a>  shows the minimal variant.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:simple_selection_via_producer-method'></a>                     <pre><code>public class CurrentObjectConverterProducer {
  @Produces
  protected ObjectConverter defaultConverter (
    @ExternalFormat(JSON) ObjectConverter objectConverter) {
      return objectConverter;
  }
}
</code></pre>
                </div>
The  <span class='latex-texttt'>Default</span>  qualifier and the  <span class='latex-texttt'>Dependent</span>  scope do not need to be specified explicitly.
We could, of course, manually instantiate the corresponding implementation instead of using an Injection-Point.
As mentioned earlier, we would forgo some CDI functionalities by doing so.
Listing  <a href='#!idx:/cdi_basics.html:fig:simple_selection_via_producer-method'> Simple selection via producer </a>  additionally illustrates that producer methods can optionally use parameters.
Each parameter represents its own (implicit) Injection-Point, which the CDI container injects automatically as usual.
In this simple producer, we select the desired implementation through the Injection-Point and
make it available unchanged with a different qualifier -- in our example, the implicit  <span class='latex-texttt'>Default</span>  qualifier.
If the default implementation is to be used in the application, it can therefore be injected as expected.
A later switch of the default implementation is now easily possible,
since only the Injection-Point of the producer method needs to be adjusted.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Of course, we can make the producer a bit more flexible.
For this, we can extend  <span class='latex-texttt'>ApplicationConfig</span>  with an entry for the default format, for example.
Then we evaluate this new configuration entry in the previously created producer.
With this approach, the implementation of the producer does not need to be changed
when the default format is to be changed to an already supported format.
Listing  <a href='#!idx:/cdi_basics.html:fig:extended_custom_type-safe_config'> Extended ApplicationConfig </a>  shows the extended implementation of  <span class='latex-texttt'>ApplicationConfig</span>  and
Listing  <a href='#!idx:/cdi_basics.html:fig:configurable_default_config'> Configurable default implementation </a>  the usage in the producer method.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:extended_custom_type-safe_config'></a>                     <pre><code>@Typed()
public class ApplicationConfig {
  //...
  private ExternalFormat.TargetFormat defaultExternalFormat;

  protected ApplicationConfig() {
    //needed for creating a proxy
  }

  public ApplicationConfig(ResourceBundle config) {
    //...
    this.defaultExternalFormat =
      ExternalFormat.TargetFormat.valueOf(
      config.getString("defaultExternalFormat"));
  }

  public ExternalFormat.TargetFormat getDefaultExternalFormat() {
    return defaultExternalFormat;
  }
  //...
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:configurable_default_config'></a>                     <pre><code>@ApplicationScoped
public class CurrentObjectConverterProducer {
  @Produces
  @Default
  @Dependent
  protected ObjectConverter defaultConverter(
    @ExternalFormat(XML) ObjectConverter objectConverterXml,
    @ExternalFormat(JSON) ObjectConverter objectConverterJson,
    ApplicationConfig applicationConfig) {

      switch (applicationConfig.getDefaultExternalFormat()) {
        case JSON:
          return objectConverterJson;
        default:
          return objectConverterXml;
      }
  }
}
</code></pre>
                </div>
The use of  <span class='latex-texttt'>@ApplicationScoped</span>  in Listing  <a href='#!idx:/cdi_basics.html:fig:configurable_default_config'> Configurable default implementation </a>  is optional in our case and ensures
that the CDI container does not need to create a new  <span class='latex-texttt'>CurrentObjectConverterProducer</span>  instance for each call to the producer method.
Since the producer is implemented in a stateless manner,
the result does not change compared to Listing  <a href='#!idx:/cdi_basics.html:fig:simple_selection_via_producer-method'> Simple selection via producer </a> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The  <span class='latex-texttt'>Default</span>  qualifier is also optional at Injection-Points. This means that we have always used it implicitly so far.
You only need to consider whether you want to allow such implicit usage in an application
when you annotate every concrete implementation with a qualifier.
In some projects, explicit qualifiers are used to reduce the probability of errors, and
the approach presented above would undermine this.
If you want to enforce the explicit specification of a qualifier,
you can define your own qualifier instead of the  <span class='latex-texttt'>Default</span>  qualifier.
Popular names for such qualifiers are  <span class='latex-texttt'>@Current</span>  and  <span class='latex-texttt'>@Active</span> .<br /> <div class="tip"><b>Tip: </b> CDI 1.0 specifies the additional qualifier  <span class='latex-texttt'>@New</span>  for Injection-Points,
which has been marked as deprecated since CDI 1.1.
With this qualifier, the CDI container always injects a dependent-scoped Contextual-Instance of a bean
regardless of the explicitly specified scope of the corresponding Managed-Bean.
This was initially used more often for various tricks in combination with producer methods,
but is generally not recommended due to the higher complexity. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6.0.4' ><span class='entry-number'>2.6.0.4</span> Producer Fields</a></h4>
 Apart from producer methods, producer fields can also be used.
As we will see later, producer fields in combination with resource injection in an EE server can save a few lines of code.
Equivalent to producer methods, producer fields are annotated with  <span class='latex-texttt'>@Produces</span> .
For most producers, producer fields are not recommended.
The difference between a simple method and a field is minimal in practice.
However, debugging in combination with producer fields is significantly more complex, and
furthermore, producer fields give us a stateful producer class,
whereby the chosen scope can lead to different results.
Such an effect is possible when, for example, an instance variable in an application-scoped CDI bean is initialized only once,
but is used as a producer for another bean with a shorter scope.
Normally, you would want to always get a new instance here that should be stored in the specified scope.
Due to the described effect, the instance variable in the application-scoped bean is created only once and
can therefore lead to unexpected results. Whether this actually causes side effects depends on the specific constellation.
In combination with resource injection from Java EE, this is not a problem, for example, since proxy instances are also used here.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.7' ><span class='entry-number'>2.7</span> Events</a> </h2>
 In a specification on the topic of dependency injection and context management, the definition of an event system is unexpected for many.
However, the events specified by CDI are only possible through the combination of some of the CDI concepts presented so far.
In summary, CDI events are a decoupled implementation of the observer design pattern.
Accordingly, CDI events are currently only processed synchronously, making them equivalent to sequential method calls.
The advantage is the decoupling of event producer and event consumer.
Due to the extremely elegant implementation, it is pleasing that CDI events are additionally used for the container lifecycle.
We will look at such container events more closely in the chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> .<br /> <div class="tip"><b>Tip: </b> Asynchronous distribution is currently not supported by the specification and is therefore implementation-dependent.
For example, it is possible for OpenWebBeans to implement a corresponding add-on.
Regardless of whether it is proprietary asynchronous CDI events or manually triggered asynchronous processing,
all status-relevant information must be passed directly with the event instance.
This is because a new thread is started for asynchronous processing, which receives, for example, a new request, session, ... scope.
We will analyze in detail later how this works exactly and what you need to consider. </div><div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Since CDI 2.0 (Java EE 8), the specification natively supports asynchronous events. With <span class='latex-texttt' style='color:#2e7d32;'>@ObservesAsync</span> and the <span class='latex-texttt' style='color:#2e7d32;'>fireAsync()</span> method, events can be processed in separate threads without relying on proprietary solutions. Details on the evolution of CDI can be found in Chapter <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div><div class="tip"><b>Tip: </b>The practical application of asynchronous events with <span class='latex-texttt'>@ObservesAsync</span> is demonstrated in Chapter <a href='#!idx:/cdi_usecases.html:8'>8</a> as part of <span class='latex-textit'>IdeaForkMicro</span>. There, events are used for loose coupling between microservice modules.</div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Before we can meaningfully use CDI events in  <span class='latex-textit'>IdeaFork</span> , we need to add additional application logic.
We create a simple in-memory repository implementation with which we can save, load, and delete ideas.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the background, a simple map is used to store  <span class='latex-texttt'>Idea</span>  instances.
The only notable aspect is the simulation of detached entities, which we will get automatically with JPA in a later step.
For our simple in-memory implementation, we can simulate this effect using a simple clone method,
which is used before an entity is returned or stored.
This avoids unexpected effects
that can occur when the reference to the entity is used for further modifications after the repository call.
As a key, we use a generated ID that we initially add to the  <span class='latex-texttt'>Idea</span>  class itself.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> With this new functionality in  <span class='latex-textit'>IdeaFork</span> , we can add a meaningful CDI event.
For example, we can create an event as soon as an  <span class='latex-texttt'>Idea</span>  instance has been saved.
To achieve this, we inject  <span class='latex-texttt'>javax.enterprise.event.Event</span>  into our newly created  <span class='latex-texttt'>IdeaRepository</span>  class and
type the event to our own event type. Any class can be used as an event type.
For simple use cases, the entity class itself can be used.
Listing  <a href='#!idx:/cdi_basics.html:fig:fire_cdi-event'> Firing CDI events </a>  illustrates such a simple usage.
Later we will introduce a dedicated event class, since this is more expressive in real applications and
allows additional information to be passed along.
In the second part of Listing  <a href='#!idx:/cdi_basics.html:fig:fire_cdi-event'> Firing CDI events </a> , the injected event instance is used to fire an event.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:fire_cdi-event'></a>                     <pre><code>public class IdeaRepository {
  @Inject
  private Event&lt;Idea&gt; ideaSavedEvent;

  private Map&lt;String, Idea&gt; entityMap =
    new ConcurrentHashMap&lt;String, Idea&gt;();

  public void save(Idea entity) {
    entityMap.put(entity.getId(), clone(entity));
    ideaSavedEvent.fire(entity);
  }
  //...
}
</code></pre>
                </div>
CDI qualifiers can also be used in combination with CDI events. They can be specified at the Injection-Point of the event.
As an alternative, it is possible to specify qualifiers dynamically using literals.
This is again possible with the corresponding  <span class='latex-texttt'>select</span>  methods.
The usage is equivalent to the concepts
we learned about with  <span class='latex-texttt'>javax.enterprise.inject.Instance</span>  in the previous chapter.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In CDI-based frameworks, there are events that are not reacted to within the framework itself.
We will monitor such events later in  <span class='latex-textit'>IdeaFork</span> .
Application-specific events are, by definition, only meaningful when they are processed in the application.
For this, we need to add a method with at least one parameter to any CDI bean.
The parameter type and explicit/implicit qualifiers must match those of the event source.
In our case, the  <span class='latex-texttt'>Idea</span>  class is the parameter type. Listing  <a href='#!idx:/cdi_basics.html:fig:observe_cdi-event'> Observing CDI events </a>  shows
that we do not need to specify an explicit qualifier, since we used the implicit  <span class='latex-texttt'>Default</span>  qualifier when firing the event.
For the CDI container to register the method as an observer method, this parameter must be annotated with  <span class='latex-texttt'>@Observes</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:observe_cdi-event'></a>                     <pre><code>@ApplicationScoped
public class IdeaSavedObserver {
  private static final Logger LOGGER =
    Logger.getLogger(IdeaSavedObserver.class.getName());

  private boolean isIdeaLoggingEnabled;

  @PostConstruct
  protected void init() {
    isIdeaLoggingEnabled = LOGGER.isLoggable(Level.FINE);
  }

  public void onIdeaSavedEvent(@Observes Idea savedIdea) {
    if (isIdeaLoggingEnabled) {
      LOGGER.fine("saved idea: " + savedIdea.getId());
    }
  }
}
</code></pre>
                </div>
Observers are in many cases stateless and perform the required evaluations before executing the actual logic.
Nevertheless, it is useful and above all possible to store immutable information during initialization
so that the execution time of the observer method can be minimized.
In our simple example, this information could be stored statically.
Normally, it is not exclusively static information,
which is why a method annotated with  <span class='latex-texttt'>@PostConstruct</span>  is useful for initialization.
In application-scoped beans, such as  <span class='latex-texttt'>IdeaSavedObserver</span> ,
such evaluations are therefore performed only once and not with every call to the observer method(s).
This is because the observer method is called on the effective Contextual-Instance, as if it were a manual method call on the CDI bean.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Events are primarily useful when we want to trigger potentially multiple independent actions in the system.
Stateless observers are often defined as dependent-scoped.
For each event, by definition, a Contextual-Instance of the observer class is created and the observer method is called.
Depending on the effective logic of the observer method, such methods are somewhat harder to test,
since the dependent-scoped bean is destroyed again after the observer method call.
With regard to event delivery, you must rely on the CDI container in such cases.
Whether an event is actually fired can be verified if needed with a custom test observer.
Such test observers are placed in the test directory and must not be dependent-scoped.
The parameters of the observer test methods should match those of the real observer method
to allow a meaningful assertion. The implementation, however, is trivial in every case, since you only need to record
whether the observer method was called after a certain point.
Listing  <a href='#!idx:/cdi_basics.html:fig:test_event_delivery'> Testing CDI event delivery </a>  shows a simple test case and Listing  <a href='#!idx:/cdi_basics.html:fig:test-observer'> Test observer </a>  the corresponding test observer.
Before saving the newly created  <span class='latex-texttt'>Idea</span>  instance, the injected  <span class='latex-texttt'>TestIdeaSavedObserver</span>  is checked.
Up to this point, our event must not have occurred yet.
After saving, the state of  <span class='latex-texttt'>TestIdeaSavedObserver</span>  is checked again,
because the event has already been created and delivered by the CDI container.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> To prevent the event from having already been triggered by another test and recorded by  <span class='latex-texttt'>TestIdeaSavedObserver</span> ,
we define  <span class='latex-texttt'>TestIdeaSavedObserver</span>  as a request-scoped bean.<br /> <div class="tip"><b>Tip: </b> As mentioned in the chapter  <a href='#!idx:/introduction.html:chap:cdi-introduction'>  Introduction to CDI </a> , the CDI request scope is independent of a physical HTTP request,
provided that the scope is manually started and stopped for the current thread.
In unit tests without CDI support, we would have to do this manually.
In our case,  <span class='latex-texttt'>CdiTestRunner</span>  handles this for each test method. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test_event_delivery'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class EventTest {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private IdeaRepository ideaRepository;

  @Inject
  private TestIdeaSavedObserver ideaSavedObserver;

  @Test
  public void eventDelivery() {
    Idea newIdea = ideaManager.createIdeaFor(...);

    Assert.assertFalse(ideaSavedObserver.isEventObserved());
    ideaRepository.save(newIdea);
    Assert.assertTrue(ideaSavedObserver.isEventObserved());
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test-observer'></a>                     <pre><code>@RequestScoped
public class TestIdeaSavedObserver {
  private boolean isEventObserved;

  protected void onIdeaSavedEvent(@Observes Idea savedIdea) {
    isEventObserved = true;
  }

  public boolean isEventObserved() {
    return isEventObserved;
  }
}
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.7.0.1' ><span class='entry-number'>2.7.0.1</span> Execution Order</a></h4>
 Together with the test observer, we now have multiple observer methods for our  <span class='latex-texttt'>Idea</span>  event.
The execution order of these methods is neither controllable nor defined by a rule.
If one of the observer methods throws an exception, the subsequent observer methods are no longer executed.
A multi-stage execution of an event and
an associated defined order can only be achieved manually using different qualifiers.
In most cases, this is not necessary and would mainly lead to a more complex implementation, and
the result comes close to manual method calls.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.7.0.2' ><span class='entry-number'>2.7.0.2</span> Conditional Observation of Events</a></h4>
 If no Contextual-Instance of a Managed-Bean with an observer method exists yet,
one is created as soon as the event is fired. This makes pure observer beans possible.
For some use cases, however, it is necessary that an observer method is only called
when a Contextual-Instance of the Managed-Bean already exists. An example of this is UI controllers
that observe a specific UI event. If the same event is used for different views,
it is normally not useful to create all UI controllers of the entire application
that have an observer method for this event and call the corresponding observer method.
In  <span class='latex-textit'>IdeaFork</span>  we are still far from such specialized use cases, and
so Listing  <a href='#!idx:/cdi_basics.html:fig:observe_if_exists'> Conditional test observer </a>  illustrates the basic concept using a simple example.
The newly added class  <span class='latex-texttt'>TestIdeaSavedConditionalObserver</span>  is almost identical to the implementation of  <span class='latex-texttt'>TestIdeaSavedObserver</span> .
The only difference is the specification of  <span class='latex-texttt'>Reception.IF_EXISTS</span> .
Since in Listing  <a href='#!idx:/cdi_basics.html:fig:test_delivery_if_exists'> Testing conditional CDI event delivery </a>   <span class='latex-texttt'>TestIdeaSavedConditionalObserver</span>  is not used before saving the idea,
the conditional observer method is not executed.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:observe_if_exists'></a>                     <pre><code>@RequestScoped
public class TestIdeaSavedObserver {
  private boolean isEventObserved;

  protected void onIdeaSavedEvent(
    @Observes(notifyObserver = Reception.IF_EXISTS)
    Idea savedIdea) {
      isEventObserved = true;
  }

  public boolean isEventObserved() {
    return isEventObserved;
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test_delivery_if_exists'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class EventTest {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private IdeaRepository ideaRepository;

  @Inject
  private TestIdeaSavedObserver ideaSavedObserver;

  @Inject
  private TestIdeaSavedConditionalObserver conditionalObserver;

  @Test
  public void conditionalEventDelivery() {
    Idea newIdea = ideaManager.createIdeaFor(...);

    Assert.assertFalse(ideaSavedObserver.isEventObserved());

    ideaRepository.save(newIdea);

    Assert.assertTrue(ideaSavedObserver.isEventObserved());
    Assert.assertFalse(conditionalObserver.isEventObserved());

    ideaRepository.save(newIdea);
    Assert.assertTrue(conditionalObserver.isEventObserved());
  }
}
</code></pre>
                </div>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8' ><span class='entry-number'>2.8</span> Replacing Beans</a> </h2>
<a name = '!idx:/cdi_basics.html:sec:cdi-alternatives'> </a> In some cases, it can be useful to modify existing implementations.
If you use an external CDI-based framework or if several of your applications share CDI-based modules,
situations can arise in which an existing implementation needs to be extended or replaced.
Furthermore, unit tests may have additional requirements for individual beans.
For these and some other use cases, CDI provides two approaches with  <span class='latex-texttt'>@Alternative</span>  and  <span class='latex-texttt'>@Specializes</span> .<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8.0.1' ><span class='entry-number'>2.8.0.1</span> Nothing Is Perfect</a></h4>
 CDI is a predominantly good and well-thought-out specification. Unfortunately, like any specification or technology, there are pitfalls.
In the case of CDI, the most notable problems are hidden in the BDAs (= Bean Deployment Archives),
which we will discuss later. The effects become especially visible with alternative implementations,
which we will deal with in this chapter. Even in the definition of the two annotations, there are conflicting views.
For example,  <span class='latex-texttt'>javax.enterprise.inject.Instance</span>  in combination with
 <span class='latex-texttt'>@Alternative</span>  works differently with OpenWebBeans than with Weld.
In Weld, the iterator returns both the original and the alternative bean as results.
Consequently,  <span class='latex-texttt'>isAmbiguous</span>  returns  <span class='latex-texttt'>"true"</span> .
However, the  <span class='latex-texttt'>get</span>  method here does not lead to an  <span class='latex-texttt'>AmbiguousResolutionException</span>  as expected,
since only the alternative bean is returned. OpenWebBeans implements this consistently and
uses only the alternative bean in both cases, so  <span class='latex-texttt'>isAmbiguous</span>  returns  <span class='latex-texttt'>"false"</span>  as expected.
In combination with faulty integrations of CDI in some application servers,
both annotations can only be used in a very limited way.
Instead of covering all the rules of the specification and the existing implementation errors or inconsistencies in the individual versions of the CDI implementations, we will focus on the most important use cases, which are portable and work in most cases.<br /> <div class="tip"><b>Tip: </b> If you want to spare your nerves, the following recommendations can make life with CDI 1.0 easier.
Limit the use of  <span class='latex-texttt'>@Alternative</span>  and  <span class='latex-texttt'>@Specializes</span>  to the absolute minimum.
Prefer  <span class='latex-texttt'>@Specializes</span> , and only when this annotation does not work or is not possible for your use case,
try  <span class='latex-texttt'>@Alternative</span> . Test the alternative implementations exceptionally well.
If neither  <span class='latex-texttt'>@Alternative</span>  nor  <span class='latex-texttt'>@Specializes</span>  works,
you can in many cases fall back on a feature of Apache DeltaSpike called "global alternatives". </div>
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Since CDI 1.1, <span class='latex-texttt' style='color:#2e7d32;'>@Alternative</span> beans can also be globally activated via the <span class='latex-texttt' style='color:#2e7d32;'>@Priority</span> annotation, without requiring an entry in <span class='latex-texttt' style='color:#2e7d32;'>beans.xml</span>. This greatly simplifies working with alternatives. Further details can be found in Chapter <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div>
<h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8.0.2' ><span class='entry-number'>2.8.0.2</span> Replacing Implementations with @Specializes</a></h4>
 We begin with  <span class='latex-texttt'>@Specializes</span>  because it is the simplest way to replace a default implementation.
The specialized implementation extends the original bean class as expected and
is annotated with  <span class='latex-texttt'>@Specializes</span> . If the original class implements an interface,
it is not sufficient to only implement the same interface; you must always extend the original class.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  we created  <span class='latex-texttt'>TestIdeaSavedObserver</span>
to test whether the  <span class='latex-texttt'>Idea</span>  event is fired at the right time, and
we did not want to modify the original implementation for this purpose.
The adjustment for the unit test was very easily possible in our simple example.
In more complex cases, however, this may not be so easily possible.
Here you can use  <span class='latex-texttt'>@Specializes</span>  to help.
Instead of using an additional bean, we can have  <span class='latex-texttt'>TestIdeaSavedObserver</span>  extend  <span class='latex-texttt'>IdeaSavedObserver</span>  and
adjust it accordingly. Since we have  <span class='latex-texttt'>TestIdeaSavedObserver</span>  in the test directory,
this implementation is only active in our unit tests.
In the effective application, the test code of  <span class='latex-texttt'>TestIdeaSavedObserver</span>  can never become active,
because the final application will not contain this test class and therefore automatically uses  <span class='latex-texttt'>IdeaSavedObserver</span> .
Listing  <a href='#!idx:/cdi_basics.html:fig:specialized_bean'> Specialized implementations </a>  shows that in our simple case, we override the observer method.
The new implementation delegates in the first step to the original implementation of the superclass and
then adds the required test code.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:specialized_bean'></a>                     <pre><code>@Specializes
@RequestScoped
public class TestIdeaSavedObserver extends IdeaSavedObserver {
  private boolean isEventObserved;

  @Override
  protected void onIdeaSavedEvent(@Observes Idea savedIdea) {
    super.onIdeaSavedEvent(savedIdea);
    this.isEventObserved = true;
  }

  public boolean isEventObserved() {
    return isEventObserved;
  }
}
</code></pre>
                </div>
In our case,  <span class='latex-texttt'>IdeaSavedObserver</span>  is defined as an application-scoped bean.
Through the specialization, we have not only extended the implementation but also changed the scope of the bean.
For a specialized implementation, specifying a scope is only required when the scope of the bean
is to be changed, as with  <span class='latex-texttt'>TestIdeaSavedObserver</span> .
If no scope is specified on the specialized class, the scope annotation is inherited,
provided it is annotated with  <span class='latex-texttt'>@java.lang.annotation.Inherited</span> .
Since this is a recommendation of the CDI specification, all scope annotations of the specification are annotated with  <span class='latex-texttt'>@Inherited</span>  and
are automatically inherited.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In many cases, it is not necessary to change the scope.
If we recall, we annotated  <span class='latex-texttt'>TestIdeaSavedObserver</span>  with  <span class='latex-texttt'>@RequestScoped</span>
because we want to use a new instance per test method.
Before you change the scope of the original implementation, make sure
that you understand the implications and that you do not violate important aspects or assumptions of the original implementation,
thereby triggering unexpected effects.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8.0.3' ><span class='entry-number'>2.8.0.3</span> Alternative Implementations with @Alternative</a></h4>
 Compared to the previously presented specialized implementations with  <span class='latex-texttt'>@Specializes</span> ,
alternative implementations with  <span class='latex-texttt'>@Alternative</span>  are somewhat more complex. The annotation itself is only the first step.
As with  <span class='latex-texttt'>@Specializes</span> , you can extend the original implementation and annotate it with  <span class='latex-texttt'>@Alternative</span> .
In many use cases, however, you only have an interface that you can/want to implement for the alternative bean.
This represents the main use case for  <span class='latex-texttt'>@Alternative</span> ,
because with  <span class='latex-texttt'>@Specializes</span> , implementing only an interface is not possible.
Another difference is that implementations annotated with  <span class='latex-texttt'>@Alternative</span>  are not automatically active,
since they must be configured via  <span class='latex-texttt'>beans.xml</span> . Here lurks one of the pitfalls of the specification.
According to the specification, alternative implementations must be configured in the same (bean deployment) archive.
The definition of a (bean deployment) archive and its boundaries is very controversial.
In the most restrictive case, you must assume that the smallest module unit, such as a JAR file, is meant.
We will analyze this concept and the associated limitations more closely in the chapter  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI and Java EE </a> .
Since we do not have multiple applications sharing CDI-based modules and
will discuss the customization of a CDI-based framework later, we will not notice any limitations at this point.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span class='latex-texttt'>@Alternative</span>  gives you the ability to try out multiple implementations in parallel.
If none of the alternative implementations is activated via  <span class='latex-texttt'>beans.xml</span> , the original bean remains active.
You can annotate any number of alternative implementations with  <span class='latex-texttt'>@Alternative</span> .
Only when you activate one of them via  <span class='latex-texttt'>beans.xml</span>  will it be used at runtime.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  it is a good opportunity to implement alternative beans for the  <span class='latex-texttt'>ObjectConverter</span>  interface.
As an alternative to JAXB and Gson, we can integrate Jackson (http://fasterxml.com) into the project and
test corresponding implementations for the JSON and XML converters.
Listing  <a href='#!idx:/cdi_basics.html:fig:alternative_bean_implementation'> Alternative implementation </a>  shows this using the example of a Jackson converter for JSON.
Listing  <a href='#!idx:/cdi_basics.html:fig:alternative_bean_configuration'> Activating an alternative implementation </a>  illustrates the corresponding configuration in the  <span class='latex-texttt'>beans.xml</span>  file.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:alternative_bean_implementation'></a>                     <pre><code>@Alternative
@ExternalFormat(ExternalFormat.TargetFormat.JSON)
@ApplicationScoped
public class JSONConverterJackson implements ObjectConverter {
  @Override
  public &lt;T&gt; T toObject(String value, Class&lt;T&gt; targetType) {
    try {
      return new ObjectMapper().readValue(value, targetType);
    } catch (Exception e) {
      throw new IllegalArgumentException(e);
    }
  }

  @Override
  public String toString(Object entity) {
    try {
      return new ObjectMapper().writeValueAsString(entity);
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(e);
    }
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:alternative_bean_configuration'></a>                     <pre><code>&lt;beans&gt;
  &lt;alternatives&gt;
    &lt;class&gt;[package-name].JSONConverterJackson&lt;/class&gt;
  &lt;/alternatives&gt;
&lt;/beans&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8.0.4' ><span class='entry-number'>2.8.0.4</span> Alternative Producer/Disposer</a></h4>
 Producers and disposers have a special status with regard to alternative implementations.
You achieve the highest portability of your beans if, as in Listing  <a href='#!idx:/cdi_basics.html:fig:specialized_bean_with_producer'> Specialized bean with producer and disposer </a>, you override both the producer and the disposer including all metadata in the derived class,
even if you make no changes at these points and only delegate to the original implementation.
In our example, we customize the producer for  <span class='latex-texttt'>ApplicationConfig</span> ,
since in the next chapter we will configure different values for unit tests.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:specialized_bean_with_producer'></a>                     <pre><code>@Specializes
public class TestConfigProducer extends ConfigProducer {
  @Override
  @Produces
  @ApplicationScoped
  public ApplicationConfig exposeConfig() {
    return super.exposeConfig();
  }

  @Override
  public void onDispose(@Disposes ApplicationConfig config) {
    super.onDispose(config);
  }

  @Override
  protected String getConfigBaseName() {
    return "test-" + super.getConfigBaseName();
  }
}
</code></pre>
                </div>
Furthermore, there are differences between CDI implementations.
With OpenWebBeans, you can use both  <span class='latex-texttt'>@Specializes</span>  and  <span class='latex-texttt'>@Alternative</span> .
With Weld, however, you are limited to  <span class='latex-texttt'>@Specializes</span>  to provide alternative producers.<br />
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.9' ><span class='entry-number'>2.9</span> Interceptors</a> </h2>
 Interceptors enable the implementation of cross-cutting concerns such as logging, security, monitoring, and much more,
independently of the concrete behavior of the beans for which they are used.
Compared to other interceptor solutions or AOP, CDI interceptors are kept simple and elegant.
Comparable to servlet filters, a nested chain of 2-n instances is created.
The smallest chain consists of one interceptor and the actual Contextual-Instance.
The interceptor can delegate to the next instance in the chain at any point in its logic.
As the last link in the chain, the method of the Contextual-Instance is called.
Afterwards, as with nested method calls, the chain is traversed in the reverse direction.
You can easily decide which interceptor logic should run before and
after the call to the effective method of the Contextual-Instance.
For exceptions, you do not need an additional interceptor type, since you can use the classic  <span class='latex-texttt'>try/catch/finally block</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  we introduce an interceptor with which we can record slow method calls.
We can use this interceptor for any beans.
For now, we will monitor  <span class='latex-texttt'>IdeaManager</span> ,  <span class='latex-texttt'>IdeaRepository</span> , and all  <span class='latex-texttt'>ObjectConverter</span>  implementations
with this interceptor.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> To implement an interceptor, we need to define a custom annotation.
Similar to qualifiers, we need to consider where we want to or are allowed to use the interceptor.
The CDI specification allows usage on individual methods as well as at the class level,
whereby all (business) methods of the class receive the interceptor.
Therefore, in Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-annotation'> Interceptor annotation </a>   <span class='latex-texttt'>ElementType.METHOD</span>  and  <span class='latex-texttt'>ElementType.TYPE</span>  are used.
Only through the annotation  <span class='latex-texttt'>@javax.interceptor.InterceptorBinding</span>  do we mark our new annotation as a so-called interceptor binding.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-annotation'></a>                     <pre><code>@InterceptorBinding

@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface Monitored {}
</code></pre>
                </div> With this annotation, we can annotate our Managed-Bean classes or individual methods.
Listing  <a href='#!idx:/cdi_basics.html:fig:intercepted_bean'> Using the interceptor annotation </a>  illustrates this representatively with the class  <span class='latex-texttt'>IdeaRepository</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:intercepted_bean'></a>                     <pre><code>@Monitored
public class IdeaRepository {
  //...
}
</code></pre>
                </div>
Since annotations are only metadata, we need a second part of the interceptor binding: the interceptor implementation itself.
For this, we create the class  <span class='latex-texttt'>MonitoredInterceptor</span>  and annotate it with  <span class='latex-texttt'>@javax.interceptor.Interceptor</span>
to mark the class as an interceptor implementation.
The name  <span class='latex-texttt'>MonitoredInterceptor</span>  is composed of the name of the interceptor binding annotation and
the word Interceptor, and follows an optional but widely used naming convention.
However, we still need to define the connection between our interceptor binding and the interceptor implementation.
For this reason, we annotate the interceptor implementation with our interceptor binding annotation.
So far, we only have an empty class annotated with metadata.
In Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-implementation'> Interceptor implementation </a>  it is evident that we need an interceptor method
annotated with  <span class='latex-texttt'>@javax.interceptor.AroundInvoke</span> .
This method can have any name, but must use a parameter of type  <span class='latex-texttt'>InvocationContext</span> ,
define  <span class='latex-texttt'>Object</span>  as the return type, and provide the ability to throw exceptions.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-implementation'></a>                     <pre><code>@Monitored
@Interceptor
public class MonitoredInterceptor implements Serializable {

  @Inject
  private ApplicationConfig applicationConfig;

  @AroundInvoke
  public Object intercept(InvocationContext ic) throws Exception {
    long start = System.currentTimeMillis();

    try {
      return ic.proceed();
    } finally {
      if (isSlowInvocation(start)) {
        //...
      }
    }
  }

  private boolean isSlowInvocation(long start) {
    return System.currentTimeMillis() - start &gt;
      applicationConfig.getMethodInvocationThreshold();
  }
}
</code></pre>
                </div>
An interceptor instance adopts the scope of the corresponding Contextual-Instance.
Thus, the same rules apply to interceptor instances as for a dependent-scoped bean.
Since you normally do not know which bean the interceptor will be applied to,
interceptors should always implement  <span class='latex-texttt'>Serializable</span> .
The minimum requirements for an interceptor implementation do not mandate implementation of the  <span class='latex-texttt'>Serializable</span>  interface,
but you must assume that at runtime an interceptor instance could be serialized together with the Contextual-Instance.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In a final step, we must activate the interceptor via  <span class='latex-texttt'>beans.xml</span> ,
as done in Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor_configuration'> Activating an interceptor implementation </a> .
The order of nesting multiple interceptors is not defined by the order of the interceptor annotations,
but by the listing order in the configuration file.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor_configuration'></a>                     <pre><code>&lt;beans&gt;
  &lt;interceptors&gt;
    &lt;class&gt;[package-name].MonitoredInterceptor&lt;/class&gt;
  &lt;/interceptors&gt;
&lt;/beans&gt;
</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Since CDI 1.1 (Java EE 7), the <span class='latex-texttt'>@Priority</span> annotation offers a portable alternative to interceptor configuration in <span class='latex-texttt'>beans.xml</span>. Interceptors with <span class='latex-texttt'>@Priority</span> are globally activated &mdash; without an entry in the configuration file. Execution order is determined by the numeric value: lower values execute first. Example: <span class='latex-texttt'>@Priority(Interceptor.Priority.APPLICATION + 100)</span>.</div>
<div class="tip"><b>Tip: </b>In Quarkus (Chapter <a href='#!idx:/quarkus.html:10'>10</a>), interceptors are fully supported by ArC &mdash; activation via <span class='latex-texttt'>@Priority</span> is in fact the only possible method, as ArC does not support <span class='latex-texttt'>beans.xml</span>-based configuration. However, decorators are not supported by ArC &mdash; an important distinction during migration.</div>
Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-implementation'> Interceptor implementation </a>  has furthermore shown that an interceptor implementation can define Injection-Points.
Through this capability, we can work around a limitation of interceptors.
Namely, it is not possible to replace interceptor implementations
as is possible with CDI beans through  <span class='latex-texttt'>@Alternative</span>  or  <span class='latex-texttt'>@Specializes</span> .
We could hard-code a different implementation in the configuration,
but we will see in this chapter as well as in the chapter on portable CDI extensions
that a more flexible approach brings comparatively many advantages.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The trick is that we can inject an implementation through an Injection-Point
that can be customized as usual with  <span class='latex-texttt'>@Alternative</span>  or  <span class='latex-texttt'>@Specializes</span> .
Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-strategy'> Interceptor strategy </a>  illustrates the implementation.
The separated bean implements the  <span class='latex-texttt'>Serializable</span>  interface equivalently to the interceptor implementation.
Since the extracted implementation is dependent-scoped,
no proxy is created and the overhead primarily consists of the initial injection into the interceptor instance, and
is thus minimal.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  we can use this trick to replace a preconfigured interceptor for unit tests.
The alternative implementation of the interceptor strategy can contain additional code for better testability and
be extracted into the test module. We do not want to burden a production implementation with test code.
In our case, we could annotate a test bean with this interceptor and create a correspondingly slow test method.
A special interceptor implementation that can be controlled accordingly is simpler in many cases.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Let us begin by extracting the interceptor logic itself. For this, we introduce an interface named  <span class='latex-texttt'>MonitoredInterceptorStrategy</span> .
When defining the method signature, we follow the rules for interceptor methods.
Only the  <span class='latex-texttt'>@AroundInvoke</span>  annotation can be omitted at this point.
Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-strategy'> Interceptor strategy </a>  shows the new interface and the default implementation with our previous interceptor logic.
In Listing  <a href='#!idx:/cdi_basics.html:fig:injected_interceptor-strategy'> Using the interceptor strategy </a>  we see the adapted interceptor implementation
that delegates to the active  <span class='latex-texttt'>MonitoredInterceptorStrategy</span> .<br /> <div class="tip"><b>Tip: </b> We adopt the term  <span class='latex-texttt'>InterceptorStrategy</span>  from popular CDI extensions
that we will learn about in subsequent chapters. It is a naming convention
that is not prescribed by the CDI specification. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-strategy'></a>                     <pre><code>public interface MonitoredInterceptorStrategy
  extends Serializable {
    Object intercept(InvocationContext ic) throws Exception;
}

@Dependent
public class DefaultMonitoredInterceptorStrategy
  implements MonitoredInterceptorStrategy {
    @Inject
    private ApplicationConfig applicationConfig;

    public Object intercept(InvocationContext ic)
      throws Exception {
        long start = System.currentTimeMillis();

        try {
          return ic.proceed();
        } finally {
          if (isSlowInvocation(start)) {
            //...
          }
        }
    }

    protected boolean isSlowInvocation(long s) {
      return System.currentTimeMillis() - s &gt;
        applicationConfig.getMethodInvocationThreshold();
    }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:injected_interceptor-strategy'></a>                     <pre><code>@Monitored
@Interceptor
public class MonitoredInterceptor implements Serializable {

  @Inject
  private MonitoredInterceptorStrategy interceptorStrategy;

  @AroundInvoke
  public Object intercept(InvocationContext ic) throws Exception {
    return this.interceptorStrategy.intercept(ic);
  }
}
</code></pre>
                </div>
In the course of the refactoring, we defined the method  <span class='latex-texttt'>isSlowInvocation</span>  as  <span class='latex-texttt'>protected</span> .
In the next step, as shown in Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-test-strategy'> Interceptor test strategy </a> ,
we can introduce a specialized implementation for a corresponding unit test.
Listing  <a href='#!idx:/cdi_basics.html:fig:control_interceptor-test-strategy'> Controlling the interceptor test strategy </a>  shows
that in a unit test the result of the overridden method can easily be controlled.
For our simple test, a simple static variable in  <span class='latex-texttt'>TestMonitoredInterceptorStrategy</span>  is sufficient.
For more complex cases, it may be necessary to work with a  <span class='latex-texttt'>ThreadLocal</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-test-strategy'></a>                     <pre><code>@Specializes
@Dependent
public class TestMonitoredInterceptorStrategy
  extends DefaultMonitoredInterceptorStrategy {
    private static boolean slowInvocationSimulationModeActive;

    @Override
    protected boolean isSlowInvocation(long start) {
      return slowInvocationSimulationModeActive;
    }

    static void activateTestMode(boolean newValue) {
      ControllableMonitoredInterceptorStrategy
        .slowInvocationSimulationModeActive = newValue;
    }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:control_interceptor-test-strategy'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class InterceptorTest {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private MonitoredStorage monitoredStorage;

  @After
  public void resetInvocationMode() {
    TestMonitoredInterceptorStrategy.activateTestMode(false);
  }

  @Test
  public void normalMethodInvocation() {
    ideaManager.createIdeaFor("", "");
    Assert.assertTrue(monitoredStorage.getSlowMethods().isEmpty());
  }

  @Test
  public void slowMethodInvocation() {
    TestMonitoredInterceptorStrategy.activateTestMode(true);
    Assert.assertTrue(monitoredStorage.getSlowMethods().isEmpty());
    ideaManager.createIdeaFor("", "");
    Assert.assertFalse(monitoredStorage.getSlowMethods().isEmpty());
  }
}
</code></pre>
                </div>
 <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.9.0.1' ><span class='entry-number'>2.9.0.1</span> Interceptors with Additional Information</a></h4>
 Equivalent to qualifiers, interceptor annotations can also be provided with annotation attributes.
Without  <span class='latex-texttt'>@Nonbinding</span> , annotation attributes are used, just as with qualifiers,
to find the matching interceptor implementation.
Additionally, it is possible to provide an interceptor implementation with multiple interceptor binding annotations.
Through this mechanism, you can bind an interceptor implementation to a specific interceptor combination.
In practice, the use cases for both concepts are very rare.
For interceptors, the usage possibilities of the  <span class='latex-texttt'>@Nonbinding</span>  annotation are much more interesting.
It enables, for example, overriding global configurations with inline configurations.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  we inject  <span class='latex-texttt'>ApplicationConfig</span>  into  <span class='latex-texttt'>DefaultMonitoredInterceptorStrategy</span>
to read a configured value.
In the specific case, we define via configuration the maximum expected execution time of an average method.
If a method call exceeds this value, it is recorded with the help of  <span class='latex-texttt'>MonitoredStorage</span> .
Of course, there can be exceptions for which we know
that this average value will always be exceeded or the maximum duration should be set lower.
For cases like this, we can add an annotation attribute annotated with  <span class='latex-texttt'>@Nonbinding</span>
to specify a different value for such exceptional cases.
Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-annotation_with_metadata'> Interceptor with additional information </a>  shows the extension of the interceptor binding annotation and
 <a href='#!idx:/cdi_basics.html:fig:extract_interceptor_metadata'> Simple evaluation of interceptor information </a>  the evaluation of this additional information.
The simple evaluation shown here assumes that the interceptor annotation is physically available either on the intercepted method or
its class. As we will see in the chapter  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI Extensions </a> ,
metadata such as interceptors can be dynamically added during container startup if needed.
For this, we would need to look up the Managed-Bean definition via the  <span class='latex-texttt'>BeanManager</span> ,
since it contains the effective bean definition at runtime.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-annotation_with_metadata'></a>                     <pre><code>@InterceptorBinding

@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface Monitored {
  @Nonbinding
  int maxThreshold() default -1;
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:extract_interceptor_metadata'></a>                     <pre><code>public class DefaultMonitoredInterceptorStrategy
  implements MonitoredInterceptorStrategy {
    //...
    @Inject
    private ApplicationConfig applicationConfig;

    @Override
    public Object intercept(InvocationContext ic) throws Exception {
      long start = System.currentTimeMillis();

      try {
        return ic.proceed();
      } finally {
        Monitored monitored = extractMonitoredAnnotation(ic);
        int maxThreshold = monitored.maxThreshold();

        if (maxThreshold &lt; 1) {
          maxThreshold = applicationConfig.getMethodInvocationThreshold();
        }
        if (isSlowInvocation(start, maxThreshold)) {
          //...
        }
      }
    }
  }
  private Monitored extractMonitoredAnnotation(InvocationContext ic) {
    Monitored result = ic.getMethod().getAnnotation(Monitored.class);

    if (result == null) {
      result = ic.getTarget().getClass()
        .getAnnotation(Monitored.class);
    }
    if (result == null) {
      result = ic.getTarget().getClass().getSuperclass()
        .getAnnotation(Monitored.class);
    }
    return result;
  }
  protected boolean isSlowInvocation(long start, int maxThreshold) {
    return System.currentTimeMillis() - start &gt; maxThreshold;
  }
}
</code></pre>
                </div>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.10' ><span class='entry-number'>2.10</span> Decorators</a> </h2>
 Apart from generic cross-cutting concerns, which were explained with interceptors in the previous chapter,
CDI makes it possible to create tailored business-level interceptors.
In applications, so-called decorators are found rather rarely compared to interceptors.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> To illustrate the potential advantage of decorators more clearly,
we will extend <span class='latex-textit'>IdeaFork</span> before implementing our first decorator.
Except for the typing on <span class='latex-texttt'>Idea</span>, the implementation of <span class='latex-texttt'>IdeaRepository</span> is generic.
A truly generic variant could be reused for other entities.
So far in <span class='latex-textit'>IdeaFork</span> we do not have an entity representing a user, so we add an entity with the same name.
With generics and corresponding interfaces and abstract classes
we can reduce redundant implementations (see <a href='#!idx:/cdi_basics.html:fig:refactoring_02'> Repository Refactoring in IdeaFork </a>).
Thus we introduce, among other things, the abstract class <span class='latex-texttt'>BaseEntity</span> and the interface <span class='latex-texttt'>GenericRepository</span>.
Listing <a href='#!idx:/cdi_basics.html:fig:refactoring_01'> Base Entity in IdeaFork </a> illustrates
that in the class <span class='latex-texttt'>BaseEntity</span> we also add a new field for the version of the entity,
since we will use it in the next step.
The entities <span class='latex-texttt'>Idea</span> and <span class='latex-texttt'>User</span> extend this new base class and add their respective properties.
In <span class='latex-textit'>IdeaFork</span> we want to reference an author of type <span class='latex-texttt'>User</span>.
For this reason we need to add JAXB annotations so that our existing <span class='latex-texttt'>ObjectConverter</span> tests continue to work.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:refactoring_01'></a>                     <pre><code>public abstract class BaseEntity implements Serializable {
  protected String id;
  protected Long version;

  public BaseEntity() {
    this.id = UUID.randomUUID().toString();
  }

  public void increaseVersion() {
    if (version == null) {
      version = 0L;
    } else {
      version++;
    }
  }
  //...
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:refactoring_02'></a>                     <pre><code>public interface GenericRepository&lt;T extends BaseEntity&gt;
  extends Serializable {
    void save(T entity);
    void remove(T entity);
    T loadById(String id);
}

public interface IdeaRepository extends GenericRepository&lt;Idea&gt; {}

public abstract class GenericInMemoryRepository&lt;T extends BaseEntity&gt;
  implements GenericRepository&lt;T&gt; {
    protected Map&lt;String, T&gt; entityMap =
      new ConcurrentHashMap&lt;String, T&gt;();

    public void save(T entity) {
      entity.increaseVersion();
      this.entityMap.put(entity.getId(), clone(entity));
    }
    public void remove(T entity) {
      this.entityMap.remove(entity.getId());
    }
    public T loadById(String id) {
      T originalEntity = this.entityMap.get(id);
      T detachedEntity = null;

      if (originalEntity != null) {
        detachedEntity = clone(originalEntity);
      }
      return detachedEntity;
  }
  public static &lt;T&gt; T clone(T source) { /*...*/ }
}

@Monitored
public class IdeaInMemoryRepository extends GenericInMemoryRepository&lt;Idea&gt;
  implements IdeaRepository {}
</code></pre>
                </div>
Since we only temporarily used <span class='latex-texttt'>Idea</span> as an event type and this is no longer sensible at this point at the latest,
we create the class <span class='latex-texttt'>EntityChangedEvent</span>, which can be seen in Listing <a href='#!idx:/cdi_basics.html:fig:custom_event-class'> Explicit Event Class </a>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:custom_event-class'></a>                     <pre><code>public abstract class EntityChangedEvent &lt;T extends BaseEntity&gt; {
  private final T entity;
  private final long creationTimestamp;

  public EntityChangedEvent(T entity) {
    this.entity = entity;
    this.creationTimestamp = System.currentTimeMillis();
  }

  public T getEntity() {
    return entity;
  }

  public long getCreationTimestamp() {
    return creationTimestamp;
  }
}

public class UserChangedEvent extends EntityChangedEvent&lt;User&gt; {
  public UserChangedEvent(User createdEntity) {
    super(createdEntity);
  }
}
</code></pre>
                </div>
With this state we are ready to create a meaningful decorator.
<span class='latex-texttt'>GenericInMemoryRepository</span> now only contains the effective logic for managing entities and
no longer the generation of events.
This is the reason why at this point of our refactoring the tests in <span class='latex-texttt'>EventTest</span> fail.
We will extract the event handling into a decorator in the next step.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Thanks to the new interface <span class='latex-texttt'>GenericRepository</span> we can create an abstract class <span class='latex-texttt'>GenericRepositoryDecorator</span>,
since we need an interface as a basis.
The abstract class can be used as a base class for all <span class='latex-texttt'>GenericRepository</span> decorators.
For this we implement the interface to be decorated ourselves and add the required decorator logic at the appropriate places.
In our case we implement a basic check with the method <span class='latex-texttt'>checkEntity</span>,
which we execute before delegating to the decorated instance.
This allows us to separate rudimentary technical checks from the repository implementation.
Additionally, after a successful save we call the abstract method <span class='latex-texttt'>fireEntityChangedEvent</span>.
Concrete decorator implementations provide this method and can thus fire the respectively needed event.
With the help of the abstract method <span class='latex-texttt'>getDelegate</span> we can access the decorated instance in the generic implementation,
which must be provided by a concrete decorator.
The most important parts of <span class='latex-texttt'>GenericRepositoryDecorator</span> are shown in Listing <a href='#!idx:/cdi_basics.html:fig:generic_repository-decorator'> Generic Decorator Logic </a>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:generic_repository-decorator'></a>                     <pre><code>public abstract class GenericRepositoryDecorator
  &lt;T extends BaseEntity&gt; implements GenericRepository&lt;T&gt; {

    protected abstract GenericRepository&lt;T&gt; getDelegate();

    protected abstract void fireEntityChangedEvent(T entity);

    @Override
    public void save(T entity) {
      checkEntity(entity);
      getDelegate().save(entity);
      fireEntityChangedEvent(entity);
    }

    @Override
    public void remove(T entity) {
      checkEntity(entity);
      getDelegate().remove(entity);
    }

    @Override
    public T loadById(String id) {
      if (id == null) {
        throw new IllegalArgumentException("...");
      }
      return getDelegate().loadById(id);
    }

    private void checkEntity(T entity) {
      //...
    }
}
</code></pre>
                </div>
Listing <a href='#!idx:/cdi_basics.html:fig:repository-decorator_implementation'> Decorator Implementation </a> shows an example of a concrete decorator implementation.
Equivalent to interceptors there is a marker annotation called <span class='latex-texttt'>@Decorator</span>,
which signals to the CDI container that this class is a decorator implementation.
Through <span class='latex-texttt'>@Delegate</span> in combination with <span class='latex-texttt'>@Inject</span> we can inject the next instance in the chain.
Normally the type of the injected delegate must match the decorator type.
If we want to decorate <span class='latex-texttt'>IdeaRepository</span>, for example, the decorator must implement <span class='latex-texttt'>IdeaRepository</span>.
Since <span class='latex-texttt'>GenericRepositoryDecorator</span> and our repositories implement <span class='latex-texttt'>GenericRepository</span> in this case,
this is already sufficient from a technical perspective, since the correct decorator is identified via generics.
Although implementing the concrete repository interface is technically not required in this case,
it should be done because this is the only way we can decorate methods
that are defined by a concrete <span class='latex-texttt'>Repository</span> interface and not by the <span class='latex-texttt'>GenericRepository</span> interface.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:repository-decorator_implementation'></a>                     <pre><code>@Decorator
public class IdeaRepositoryDecorator
  extends GenericRepositoryDecorator&lt;Idea&gt;
  implements IdeaRepository /*optional here*/ {

    @Inject
    @Delegate
    private IdeaRepository delegate;

    @Inject
    private Event&lt;IdeaChangedEvent&gt; changedEvent;

    protected IdeaRepository getDelegate() {
      return delegate;
    }

    @Override
    protected void fireEntityChangedEvent(Idea entity) {
        changedEvent.fire(new IdeaChangedEvent(entity));
    }
}
</code></pre>
                </div>
Listing <a href='#!idx:/cdi_basics.html:fig:decorator_configuration'> Activating a Decorator Implementation </a> represents the last step in implementing a decorator.
Equivalent to interceptors, decorators must be activated in the <span class='latex-texttt'>beans.xml</span> file.
If there are multiple decorators for a bean,
the nesting order can be defined by the order in which they are listed.
In order for the tests in <span class='latex-texttt'>EventTest</span> to work again,
we of course need to switch our observer methods from <span class='latex-texttt'>Idea</span> to <span class='latex-texttt'>IdeaChangedEvent</span>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:decorator_configuration'></a>                     <pre><code>&lt;decorators&gt;
  &lt;class&gt;[package-name].IdeaRepositoryDecorator&lt;/class&gt;
&lt;/decorators&gt;
</code></pre>
                </div>
Another advantage that we gain through the separation of repository logic
will become apparent when we create alternative JPA repository implementations in the chapter <a href='#!idx:/java_ee.html:chap:cdi-java_ee'> CDI and Java EE </a>.
These will also use the decorator implementations we just created and
will not need to redundantly implement the basic checks and the event logic.
This is of course intended only as an example, since in practice often only one repository implementation is created.
Therefore, you should carefully evaluate in your projects when the additional complexity introduced by decorators is worthwhile.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.10.0.1' ><span class='entry-number'>2.10.0.1</span> Abstract Decorators</a></h4>
 In many cases there is no decorator logic for every method.
Decorator methods without additional logic would simply forward the call manually.
Therefore CDI allows the use of abstract decorator classes.
Methods that are not implemented by an abstract decorator are automatically forwarded to the next instance in the chain.
In <span class='latex-textit'>IdeaFork</span> we can add <span class='latex-texttt'>EntityChangeRepository</span> to archive changes to entities.
Listing <a href='#!idx:/cdi_basics.html:fig:abstract-decorator'> Abstract Decorator </a> illustrates
that only one method is implemented and equipped with decorator logic in the corresponding abstract decorator.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:abstract-decorator'></a>                     <pre><code>@Decorator
public abstract class EntityChangeRepositoryDecorator
  implements EntityChangeRepository {
    @Inject
    @Delegate
    private EntityChangeRepository delegate;

    @Override
    public void save(EntityChange entity) {
      checkEntity(entity);
      this.delegate.save(entity);
    }

    private void checkEntity(EntityChange ec) {
      //...
    }
}
</code></pre>
                </div>
<span class='latex-texttt'>EntityChangeRepository</span> also defines the method <span class='latex-texttt'>findRevision</span>,
which searches for the corresponding archived state of the entity using the ID of an entity and the version number.
The individual states of the entity can be automatically saved using an observer.
Listing <a href='#!idx:/cdi_basics.html:fig:rev-history_observer'> Observer for Storing Revisions </a> shows the observer implementation in the class <span class='latex-texttt'>IdeaHistoryProcessor</span>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:rev-history_observer'></a>                     <pre><code>@ApplicationScoped
public class IdeaHistoryProcessor {
  @Inject
  private ObjectConverter currentObjectConverter;

  @Inject
  private EntityChangeRepository entityChangeRepository;

  public void onIdeaCreated(
    @Observes IdeaChangedEvent changedEvent) {
      Idea entity = changedEvent.getEntity();
      String ideaSnapshot = currentObjectConverter.toString(entity);
      EntityChange entityChange =
        new EntityChange(
            entity.getId(),
            entity.getVersion(),
            ideaSnapshot,
            changedEvent.getCreationTimestamp());
      entityChangeRepository.save(entityChange);
  }
}
</code></pre>
                </div>
So far we have not assigned a scope to our repository implementations.
Since we have always only injected and accessed the Contextual-Instance in our unit tests,
the associated limitations have not been noticed until now.
<span class='latex-texttt'>EntityChangeRepository</span>, on the other hand, is used in the class <span class='latex-texttt'>IdeaHistoryProcessor</span> and Listing <a href='#!idx:/cdi_basics.html:fig:check_observer-logic'> Verifying the Observer Logic </a> illustrates an excerpt from a unit test,
which represents the second usage. For this reason <span class='latex-texttt'>EntityChangeInMemoryRepository</span> must receive an explicit scope.
In our case we choose the application scope.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:check_observer-logic'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class DecoratorTest {
  //...

  @Test
  public void passingGenericDecoratorCheck() {
    //...
    Idea newIdea = ideaManager.createIdeaFor(...);
    ideaRepository.save(newIdea);

    Idea savedIdea = ideaRepository.loadById(newIdea.getId());

    EntityChange revision = entityChangeRepository.findRevision(
      savedIdea.getId(), savedIdea.getVersion());

    Assert.assertNotNull(revision);

    Idea archivedIdea = objectConverter.toObject(
      revision.getEntityState(), Idea.class);
    Assert.assertEquals(savedIdea, archivedIdea);
  }
}
</code></pre>
                </div>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.11' ><span class='entry-number'>2.11</span> Stereotypes</a> </h2>
 In the previous chapter we discovered that our repository implementations should have a scope.
In the current state of <span class='latex-textit'>IdeaFork</span>, however, we have an inconsistency.
<span class='latex-texttt'>EntityChangeRepository</span> is application-scoped and
the other repository implementations are only annotated with <span class='latex-texttt'>@Monitored</span> and thus implicitly dependent-scoped.
With CDI stereotypes it is possible to resolve such inconsistencies centrally and to use annotations more expressively and efficiently.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Comparable to UML stereotypes, CDI stereotypes can express the roles of a Managed-Bean.
Additionally, stereotypes allow encapsulating information.
Instead of annotating similar Managed-Beans with multiple and above all always identical annotations,
we can define a stereotype annotation that encapsulates these annotations.
The annotation should be named after the artifact type.
In our case we create a stereotype annotation called <span class='latex-texttt'>@Repository</span> and annotate it,
as in Listing <a href='#!idx:/cdi_basics.html:fig:stereotype-annotation'> Custom Stereotype Annotation </a>, with <span class='latex-texttt'>@ApplicationScoped</span> and <span class='latex-texttt'>@Monitored</span>.
In order for the CDI container to recognize our stereotype annotation as such, it must be annotated with <span class='latex-texttt'>@Stereotype</span>.
We do not use producers for repository implementations in <span class='latex-textit'>IdeaFork</span> and therefore <span class='latex-texttt'>ElementType.TYPE</span> is sufficient for <span class='latex-texttt'>@Target</span>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:stereotype-annotation'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Stereotype
@ApplicationScoped
@Monitored
public @interface Repository {}
</code></pre>
                </div> Listing <a href='#!idx:/cdi_basics.html:fig:bean_with_stereotype'> Using a Custom Stereotype Annotation </a> shows the simplified implementation of <span class='latex-texttt'>EntityChangeInMemoryRepository</span>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:bean_with_stereotype'></a>                     <pre><code>@Repository
public class EntityChangeInMemoryRepository
  extends GenericInMemoryRepository&lt;EntityChange&gt;
  implements EntityChangeRepository {

    @Override
    public EntityChange findRevision(
      String entityId, long entityVersionToFind) {
        for (EntityChange current : entityMap.values()) {
          if (current.getEntityId().equals(entityId) &&
              current.getEntityVersion() == entityVersionToFind) {
                return current;
          }
        }
        return null;
    }
}
</code></pre>
                </div>
Naturally we annotate the other repository implementations with our new stereotype annotation as well.
Future changes, such as changing the scope,
can be made centrally for all implementations through the stereotype annotation.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Stereotypes can, as in Listing <a href='#!idx:/cdi_basics.html:fig:stereotype-annotation'> Custom Stereotype Annotation </a>, specify the default scope of a Managed-Bean.
This can be overridden in concrete implementations for special cases
by explicitly specifying the scope at the implementation level.
Something similar applies to the name of a bean. <span class='latex-texttt'>@javax.enterprise.inject.Model</span> is a stereotype
defined in the CDI specification. This stereotype annotation is annotated with <span class='latex-texttt'>@RequestScoped</span> and <span class='latex-texttt'>@Named</span>.
Beans annotated with <span class='latex-texttt'>@Model</span> automatically receive a name based on the default naming convention.
If a bean annotated with <span class='latex-texttt'>@Model</span> should receive a different name,
the default name can be overridden by explicitly using <span class='latex-texttt'>@Named</span>.
More details about naming Managed-Beans will be covered in the chapter <a href='#!idx:/java_ee.html:chap:cdi-java_ee'> CDI and Java EE </a>.<br /> <div class="tip"><b>Tip: </b> In the previous chapter we manually searched for the interceptor annotation.
Since we moved <span class='latex-texttt'>@Monitored</span> into <span class='latex-texttt'>@Repository</span>,
we need to extend the logic for finding the annotation accordingly and analyze all annotations.
In <span class='latex-textit'>IdeaFork</span> a simple implementation is illustrated.
If you want to support more extensive constellations, such as stereotype annotations annotated with one or more other stereotype annotation(s),
the search logic must be implemented more elaborately. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.11.0.1' ><span class='entry-number'>2.11.0.1</span> Alternative Stereotypes</a></h4>
 When using alternative implementations, we have so far activated each class separately in the <span class='latex-texttt'>beans.xml</span> file.
In large applications with many alternative beans this can become very tedious and error-prone.
For this reason CDI provides a simple and expressive mechanism based on stereotypes.
A custom annotation that is annotated at least with <span class='latex-texttt'>@Stereotype</span> and <span class='latex-texttt'>@Alternative</span>
enables the activation of all alternatives that are annotated with this stereotype annotation.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> A frequently encountered use case is the activation of mock or test classes for unit tests.
For a change, we start with a different use case.
In <span class='latex-textit'>IdeaFork</span> we want to be able to activate/deactivate all Jackson converters with a single configuration entry.
The annotation <span class='latex-texttt'>@JacksonConverter</span>, which can be seen in Listing <a href='#!idx:/cdi_basics.html:fig:alternative-stereotype-annotation'> Alternative Stereotype Annotation </a>,
also receives the <span class='latex-texttt'>@Monitored</span> interceptor-binding annotation, as well as <span class='latex-texttt'>@ApplicationScoped</span> as the default scope.
Listing <a href='#!idx:/cdi_basics.html:fig:alternative-stereotype_configuration'> Activating Alternative Beans via Stereotype </a> illustrates the activation of all Jackson converter implementations
with just one entry in the <span class='latex-texttt'>beans.xml</span> file.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:alternative-stereotype-annotation'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Alternative
@Stereotype
@ApplicationScoped
@Monitored
public @interface JacksonConverter {}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:alternative-stereotype_configuration'></a>                     <pre><code>&lt;beans&gt;
  &lt;alternatives&gt;
    &lt;stereotype&gt;[package-name].JacksonConverter&lt;/stereotype&gt;
  &lt;/alternatives&gt;
&lt;/beans&gt;
</code></pre>
                </div>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.12' ><span class='entry-number'>2.12</span> Explicit Typing</a> </h2>
 Direct type-safe dependency injection means that there can only be one Managed-Bean per type.
We have already learned about qualifiers as an extension of the type system and the possibility of dynamic lookups.
With these concepts it is possible to somewhat extend the limitations of type-safe dependency injection.
However, there are cases in which a bean can have multiple types from Java's perspective and
should only retain a subset of them for the CDI injection process, for example to prevent type collisions with other beans.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In <span class='latex-textit'>IdeaFork</span> we can, for example, reduce the number of required injection points
if we turn <span class='latex-texttt'>IdeaManager</span> and <span class='latex-texttt'>UserManager</span> into a facade.
Both classes can implement the corresponding repository interfaces and
delegate the respective methods to the appropriate repository.
If, for example, <span class='latex-texttt'>IdeaManager</span> implements the interface <span class='latex-texttt'>IdeaRepository</span>,
we have two Managed-Beans of type <span class='latex-texttt'>IdeaRepository</span> in the application.
Ambiguities like this lead to a failed application startup and an <span class='latex-texttt'>AmbiguousResolutionException</span> is the result.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For an injection point of type <span class='latex-texttt'>IdeaRepository</span>, the CDI container does not know due to our desired change
whether <span class='latex-texttt'>IdeaManager</span> or <span class='latex-texttt'>IdeaInMemoryRepository</span> should be injected.
In our case we want to inject <span class='latex-texttt'>IdeaInMemoryRepository</span>,
since <span class='latex-texttt'>IdeaManager</span> also uses it for delegating method calls.
Such ambiguities can be elegantly resolved with the <span class='latex-texttt'>@Typed</span> annotation.
It allows specifying arbitrary types of a Managed-Bean
that should be used by the CDI container for the injection process.
With <span class='latex-texttt'>@Typed()</span> a class can even be made invisible to CDI's type system.
The Managed-Bean itself continues to exist in the background,
but from the CDI container's perspective it has no type and therefore cannot be found.
Only <span class='latex-texttt'>@Named</span> could still ensure that such a Managed-Bean can be found by its name.
We have already used this trick with <span class='latex-texttt'>ApplicationConfig</span>,
so that we do not need an additional qualifier for the producer method.
Apart from completely removing the type information, it is also possible to explicitly define 1 to n types.
Only these types will be used by the CDI container for the Managed-Bean.
For our manager facade we can, as shown in Listing <a href='#!idx:/cdi_basics.html:fig:explicit_typing'> Explicit Typing </a>, specify the manager class itself.
Our type-safe injection points thus become unambiguous again.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:explicit_typing'></a>                     <pre><code>@ApplicationScoped
@Typed(IdeaManager.class)
public class IdeaManager implements IdeaRepository {
  //...
}
</code></pre>
                </div>
<span class='latex-texttt'>@Typed</span> can therefore be used for more complex constellations with multiple interfaces or a base class and
enables the use of complex type hierarchies when needed.
<div class="tip"><b>Tip: </b><b>CDI then and now &mdash; Key changes:</b><br />
&bull; <b>Bean Discovery:</b> CDI 1.0 uses <span class='latex-texttt'>bean-discovery-mode="all"</span> as the default. From CDI 4.0, <span class='latex-texttt'>"annotated"</span> is the default &mdash; only explicitly annotated classes are discovered.<br />
&bull; <b>Namespace:</b> <span class='latex-texttt'>javax.enterprise</span> becomes <span class='latex-texttt'>jakarta.enterprise</span> (from Jakarta EE 10).<br />
&bull; <b>Empty beans.xml:</b> CDI 1.0 requires a <span class='latex-texttt'>beans.xml</span>. From CDI 1.1 it is optional, from CDI 4.0 <span class='latex-texttt'>bean-discovery-mode="annotated"</span> becomes the default even without the file.<br />
&bull; <b>@Priority:</b> From CDI 1.1, alternatives and interceptors can be activated via <span class='latex-texttt'>@Priority</span> &mdash; configuration in <span class='latex-texttt'>beans.xml</span> is no longer mandatory.<br />
&bull; <b>Async Events:</b> From CDI 2.0, <span class='latex-texttt'>@ObservesAsync</span> and <span class='latex-texttt'>fireAsync()</span> are natively supported.</div>
</section>
<section class="chapter-section" id="chapter-3">
<h1> <a class='latex-index-anchor' name='!idx:/java_ee.html:3' ><span class='entry-number'>3</span> CDI and Java EE</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> The text of this chapter has been revised by Claude (Anthropic) as co-author. This revision was made without post-review by the original author. Use at your own risk.
</div>
<a name = '!idx:/java_ee.html:chap:cdi-java_ee'> </a> CDI was first released with Java EE6 as an integral part of the Java EE platform.
Initially CDI was primarily intended as a bridge between JSF and EJB.
This is also the origin of the original name of the specification (Web-Beans).
But CDI very quickly became a full-fledged component model that is far more than just a bridge.
Although this was not foreseen in the first revision of the specification,
both Apache OpenWebBeans and JBoss Weld can be used in Java SE applications
with the help of proprietary APIs.
Since CDI 1.1 this is supported by the specification itself.
In the chapter <a href='#!idx:/deltaspike.html:chap:deltaspike'> Apache DeltaSpike </a> we will examine compatibility with Java SE more closely.
In this chapter we focus on the standard integration in Java EE6 and EE7.<br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.1' ><span class='entry-number'>3.1</span> First Steps Towards Java EE</a> </h2>
 In Java EE6 some fundamental integration points were defined directly in the CDI and platform specifications.
As a general rule, in every managed instance of a class where resource injection was already possible with Java EE5,
CDI-based injection via <span class='latex-texttt'>@Inject</span> can also be used. Through this rule, CDI injection can be supported in artifacts
that are not explicitly listed in the platform specification.
Furthermore, EE servers support injection points for predefined EE artifacts. These include <span class='latex-texttt'>UserTransaction</span>,
<span class='latex-texttt'>javax.validation.ValidationFactory</span>, <span class='latex-texttt'>javax.validation.Validator</span> and <span class='latex-texttt'>javax.security.Principal</span>.<br />Due to the tight integration of CDI, EJB and JSF, in many cases one only reaches the limits of the integration points at a late stage.
In subsequent revisions of Java EE these limits are pushed further.
Thanks to the strongly increasing adoption of CDI, since EE7 the integration with CDI is also being expanded in other EE specifications.
But already EE6 itself offers many integration points.
Some of them we will examine more closely in the following parts of this chapter.
Before we create a web interface for <span class='latex-textit'>IdeaFork</span> and extend its functionality,
let us take a look at the restructuring possibilities in CDI-based applications.
In <span class='latex-textit'>IdeaFork</span> we can, for example, move all classes to a different package.
Every modern Java IDE supports such changes in a few steps.
Through Java's type safety the result is verified at the latest by the compiler.
In many projects the configuration file <span class='latex-texttt'>beans.xml</span> is used as a simple marker,
which means no further changes are required for CDI. In <span class='latex-textit'>IdeaFork</span>, however, we use some configuration options.
Some IDEs provide first-class CDI support, which means even these configuration entries are updated automatically.
If this is not the case and one or more entries are no longer up-to-date after restructuring,
this will be verified and detected as an error by the CDI container at the latest during the next application startup.
The startup process will be aborted in such a case with a corresponding error message.
Technical errors that only occur after the deployment of the application are thereby reduced to an absolute minimum.
Here primarily dynamic bean lookups must be considered, which are only recommended in exceptional cases or in combination with the EL (Expression Language).<br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.2' ><span class='entry-number'>3.2</span> Web Applications with CDI</a> </h2>
 Both JSF and JAX-RS are based on servlets.
For servlet-based technologies the same rules apply regarding the configuration of CDI.
The <span class='latex-texttt'>beans.xml</span> file could be placed in the <span class='latex-texttt'>META-INF</span> directory as before.
In web applications <span class='latex-texttt'>WEB-INF</span> is additionally supported as a configuration directory.
Some EE servers do not correctly support <span class='latex-texttt'>META-INF/beans.xml</span> in web applications.
For this reason we use the <span class='latex-texttt'>WEB-INF</span> directory.
After we have created <span class='latex-texttt'>WEB-INF/beans.xml</span> as an empty marker file, CDI is activated in the web module of our application and
we can implement the first functionalities.<br /> <div class="tip"><b>Tip: </b> Our primary runtime environment is Apache TomEE 1.7+.
Additionally, <span class='latex-textit'>IdeaFork</span> is also tested with other EE6 servers such as JBoss AS7 and Oracle Glassfish 3.
A fundamental compatibility exists, however, with any server that supports Java EE6 in a specification-compliant manner. </div> The central topic for stateful web applications in the Java EE environment in connection with CDI
is the handling of server-side scopes.
The request scope as well as the session scope are relevant for all servlet-based technologies.
The correct handling of both scopes is ensured by the CDI container.
Thus no additional integrations in the other specifications are required here.
Application developers can annotate CDI beans with the corresponding scope annotations and
the CDI container takes care of the correct management of beans as usual.
So that we can reuse our existing implementation independently,
we create a new Java EE6 specific web module.
In this module we define the Java EE6 API and our existing module as dependencies.<br /> <div class="tip"><b>Tip: </b> Since EE6 the use of Enterprise Archives (EARs) compared to simple Web Archives (WARs) offers only few advantages,
but in many application servers the different interpretation of Bean Deployment Archive (BDA) rules introduces
unnecessary disadvantages. In <span class='latex-textit'>IdeaFork</span> there is no need for EARs and therefore we can increase portability by using a web archive. </div><h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.3' ><span class='entry-number'>3.3</span> JSF with CDI</a> </h2>
 In Java EE6 the CDI integration with JSF is primarily defined by the CDI specification.
Since JSF beans according to the EE6 platform specification are components that must support injection,
CDI beans can be injected into JSF beans without problems in an EE server.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Injection in other JSF artifacts, such as phase listeners, is not yet supported in EE6, however.
Besides Java classes, the so-called View Declaration Languages (VDL) play a central role in JSF.
Both JSP and the more modern alternative called Facelets use the Expression Language (EL) to access beans.
Through <span class='latex-texttt'>@Named</span> (from JSR-330) CDI beans can be addressed by their name in an EL expression.
As is customary in JSF, this is internally implemented with a dedicated EL resolver.
CDI implementations register this EL resolver automatically, which means the integration is activated without manual configuration steps.
This resolver is responsible for finding the corresponding Contextual-Reference or returning <span class='latex-texttt'>null</span>.
Dependent-scoped beans again take a special position, however.
In this context they exist for the evaluation time of a complete EL expression,
even if they are referenced multiple times within the expression.
Only after the complete evaluation of the EL expression are dependent-scoped beans destroyed.
In addition to dependent-scoped beans, beans with any CDI scope can be accessed directly via EL expressions,
provided the corresponding scope is active at the time of evaluation.
In this context the CDI conversation scope takes a special position,
since a special rule has been defined for it in connection with JSF.
Details about the conversation scope will be examined more closely in the chapter <a href='#!idx:/deltaspike.html:chap:deltaspike'> Apache DeltaSpike </a>,
where we will also learn about alternative conversation concepts.
Thus we have already theoretically learned about the most important integration points between CDI and JSF and
it is time to extend <span class='latex-textit'>IdeaFork</span> with a simple web interface.
In our web application we create, besides a simple XHTML file for JSF, the configuration file <span class='latex-texttt'>WEB-INF/web.xml</span> and
configure the Faces servlet for JSF. In our case we additionally define the just-created XHTML file as the entry point.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the next step we use Twitter Bootstrap (http://getbootstrap.com) to make our page template visually more appealing.
For this we primarily use HTML tags. Only in places where it is essential do we use standard JSF components.
Thus in <span class='latex-textit'>IdeaFork</span> we remain independent of an additional component library for JSF.
You can of course use any JSF component library of your choice,
since the integration with CDI starts at an independent extension point.
This first step is independent of CDI and therefore we will skip the details.
In the Git repository of <span class='latex-textit'>IdeaFork</span> the required changes are summarized in a single commit and
can be easily followed.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Regardless of the layout, one of the first steps should be adding a "Messages" component,
so that messages such as error messages can be displayed.
In <span class='latex-textit'>IdeaFork</span> we want to visually improve the message area and display global messages in a message panel.
For this we embed the standard component <span class='latex-texttt'>h:messages</span> in a panel that is formatted using Twitter Bootstrap.
So that we do not display an empty panel when there are no messages, we can hide this area by default.
In Listing <a href='#!idx:/java_ee.html:fig:access_cdi-bean_via_el'> Accessing a CDI Bean via EL Expression </a> it becomes clear that we use the <span class='latex-texttt'>rendered</span> attribute for this purpose.
Within the panel group, besides some formatting tags, the <span class='latex-texttt'>h:messages</span> component can also be found.
The crucial part for us here, however, is the content of <span class='latex-texttt'>rendered</span>.
The EL expression <span class='latex-texttt'>#{messageController.globalMessageAvailable}</span> does not yet reveal
that <span class='latex-texttt'>messageController</span> references a CDI bean. Only through Listing <a href='#!idx:/java_ee.html:fig:named_request_scoped_bean'> CDI Bean with Name </a> does this become clear.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:access_cdi-bean_via_el'></a>                     <pre><code>&lt;h:panelGroup layout="block" class="panel"
  rendered="#{messageController.globalMessageAvailable}"&gt;
    &lt;!-- message panel content --&gt;
&lt;/h:panelGroup&gt;
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:named_request_scoped_bean'></a>                     <pre><code>@javax.enterprise.inject.Model
public class MessageController {
  public boolean isGlobalMessageAvailable() {
    return !FacesContext.getCurrentInstance()
      .getMessageList(null).isEmpty();
  }
}
</code></pre>
                </div> <br />Through the stereotype annotation <span class='latex-texttt'>@Model</span> we define in Listing <a href='#!idx:/java_ee.html:fig:named_request_scoped_bean'> CDI Bean with Name </a> a <span class='latex-texttt'>@javax.inject.Named</span> and <span class='latex-texttt'>@javax.enterprise.context.RequestScoped</span> CDI bean.
The naming convention corresponds to that of classic JSF managed beans.
The EL expression <span class='latex-texttt'>#{messageController.globalMessageAvailable}</span> thus references a CDI bean
that provides the method <span class='latex-texttt'>isGlobalMessageAvailable </span>. Through this method we can evaluate
whether there are global Faces messages or not, and accordingly show or hide the associated message panel.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Next we want to bring our menu to life. For this we replace the HTML links that served as placeholders
with <span class='latex-texttt'>h:commandLink</span> components. These menu links use a CDI bean called <span class='latex-texttt'>menuBean</span>,
which is annotated with <span class='latex-texttt'>@Model</span> equivalently to <span class='latex-texttt'>messageController</span>.
In our case, however, the Java class is called <span class='latex-texttt'>MenuController</span>.
In order to still use the name <span class='latex-texttt'>menuBean</span> and thus customize the default naming convention,
we must change the name specified by <span class='latex-texttt'>@Model</span> by explicitly using <span class='latex-texttt'>@Named(''menuBean'')</span>.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/java_ee.html:fig:customized_name'> CDI Bean with Customized Name </a> shows
that at some places we need to check or
reset the logged-in <span class='latex-texttt'>User</span> so that the menu behaves as expected.
We store the logged-in <span class='latex-texttt'>User</span> in the session-scoped <span class='latex-texttt'>ActiveUserHolder</span> bean,
which we inject into and use in the <span class='latex-texttt'>MenuController</span> bean.
The class <span class='latex-texttt'>ActiveUserHolder</span> itself is annotated with <span class='latex-texttt'>@Model</span>. Additionally we override the scope
specified by <span class='latex-texttt'>@Model</span> by explicitly using <span class='latex-texttt'>@javax.enterprise.context.SessionScoped</span>.<br /> <div class="tip"><b>Tip: </b> Customizations of <span class='latex-texttt'>@Model</span> significantly reduce the advantages of this stereotype,
since the number of annotations is not reduced. The examples shown are primarily intended to illustrate
that such customizations are fundamentally possible.
The explicit use of <span class='latex-texttt'>@Named</span> can reduce the effort during refactoring,
since the name of the bean at least initially remains unchanged and yet the class name can still change.
As a rule, overriding the bean name and scope is more meaningful with custom stereotype annotations,
since a stereotype annotation defines the primary properties of the respective "bean category" or role and
ideally increases expressiveness.
In exceptional cases these defaults can be overridden for individual beans.
Nevertheless, at least the advantage of greater expressiveness remains. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:customized_name'></a>                     <pre><code>@Named("menuBean")
@Model
public class MenuController {
  @Inject
  private ActiveUserHolder userHolder;

  public String home() {
    return "/pages/index.xhtml";
  }

  public String login() {
    return "/pages/user/login.xhtml";
  }

  public String logout() {
    userHolder.setAuthenticatedUser(null);
    return "/pages/user/login.xhtml";
  }

  public String start() {
    if (userHolder.isLoggedIn()) {
      return "/pages/idea/overview.xhtml";
    }
    return "/pages/user/login.xhtml";
  }

  public String register() {
    return "/pages/user/registration.xhtml";
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:active_user-holder_bean'></a>                     <pre><code>@Named
@SessionScoped
public class ActiveUserHolder implements Serializable {
  private User authenticatedUser;

  public void setAuthenticatedUser(User authenticatedUser) {
    this.authenticatedUser = authenticatedUser;
  }

  public boolean isLoggedIn() {
    return authenticatedUser != null && !authenticatedUser.isTransient();
  }

  public User getAuthenticatedUser() {
    return authenticatedUser;
  }
}
</code></pre>
                </div> <br />The method <span class='latex-texttt'>isTransient</span> is newly added in <span class='latex-texttt'>BaseEntity</span> and evaluates whether the version number is already set.
This will become especially relevant later in combination with JPA, since we only want to accept persistent <span class='latex-texttt'>User</span> entities for login.
In the class <span class='latex-texttt'>MenuController</span> we already reference pages as navigation targets that do not yet exist.
Therefore in the next step we create the pages <span class='latex-texttt'>login.xhtml</span> and <span class='latex-texttt'>registration.xhtml</span>.
For each page we use a dedicated controller that is responsible exactly for that page.
For now most of our controllers are request-scoped and must, as mentioned earlier, be annotated with <span class='latex-texttt'>@Named</span>,
so they can be addressed in an EL expression. We could also use <span class='latex-texttt'>@Model</span> here instead of these two annotations.
However, a custom stereotype named <span class='latex-texttt'>@ViewController</span> is much more expressive.
Apart from that, this stereotype annotation is a content-wise copy of <span class='latex-texttt'>@Model</span>.
Listing <a href='#!idx:/java_ee.html:fig:cdi-beans_as_view-controller'> CDI Beans as View Controllers </a> shows the controller implementations <span class='latex-texttt'>LoginViewCtrl</span> for <span class='latex-texttt'>login.xhtml</span>,
as well as <span class='latex-texttt'>RegistrationViewCtrl</span> for <span class='latex-texttt'>registration.xhtml</span>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:cdi-beans_as_view-controller'></a>                     <pre><code>@ViewController
public class LoginViewCtrl {
  @Inject
  private UserService userService;

  @Inject
  private ActiveUserHolder userHolder;

  private String email;
  private String password;

  public String login() {
    userService.login(email, password);

    final String message;
    final String navigationTarget;
    FacesMessage.Severity severity = FacesMessage.SEVERITY_INFO;
    if (userHolder.isLoggedIn()) {
      message = "Welcome " +
        userHolder.getAuthenticatedUser().getNickName() + "!";
      navigationTarget = "/pages/idea/overview.xhtml";
    } else {
      message = "Login failed!";
      severity = FacesMessage.SEVERITY_ERROR;
      navigationTarget = null;
    }

    FacesContext.getCurrentInstance()
      .addMessage(null, new FacesMessage(severity, message, message));
    return navigationTarget;
  }

  //+ getter and setter
}

@ViewController
public class RegistrationViewCtrl {
  @Inject
  private UserService userService;

  private User newUser = new User();

  public String register() {
    User registeredUser = userService.registerUser(this.newUser);

    final String message;
    final String targetPage;
    FacesMessage.Severity severity = FacesMessage.SEVERITY_INFO;
    if (registeredUser != null) {
      message = "Registration successful!";
      targetPage = "/pages/user/login.xhtml";
    } else {
      message = "Registration failed!";
      severity = FacesMessage.SEVERITY_ERROR;
      targetPage = null;
    }

    FacesContext.getCurrentInstance()
      .addMessage(null, new FacesMessage(severity, message, message));
    return targetPage;
  }

  public User getNewUser() {
    return newUser;
  }
}
</code></pre>
                </div> <br />The logic implemented here is kept very simple. Currently we are still using our in-memory repositories.
Once we add EJBs this will change. As preparation for this change we create the class <span class='latex-texttt'>UserService</span>,
which is responsible for registration and login and combines various methods from <span class='latex-texttt'>UserManager</span>,
as well as computing the password hash and comparing it with the stored value using a newly added <span class='latex-texttt'>PasswordManager</span>.
Additionally we extend our existing implementations and tests.
The entity <span class='latex-texttt'>User</span> is extended with a password field and <span class='latex-texttt'>UserRepository</span> with the method <span class='latex-texttt'>loadByEmail</span>.
Accordingly the method <span class='latex-texttt'>createUserFor</span> of <span class='latex-texttt'>UserManager</span> must be extended.
The corresponding implementations and changes are clearly summarized in a single commit in the Git repository and
can be easily followed with the knowledge acquired so far.<br /> <div class="tip"><b>Tip: </b> Although <span class='latex-texttt'>UserService</span> uses an injected field, the implementation is implicitly stateless,
since only a Contextual-Reference is injected as a proxy.
The proxy instance itself is thread-safe and can be de-/serialized or
if necessary restored through manual injection at any time.
If thread safety is relevant, it must also be ensured in all injected beans.
If we were to inject a session-scoped bean at this point, only <span class='latex-texttt'>UserService</span> including the Contextual-Reference would be thread-safe.
A session-scoped bean would have to take its own measures to ensure its methods work in a thread-safe manner. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:cdi-bean_as_stateless_service'></a>                     <pre><code>@ApplicationScoped
public class UserService {
  @Inject
  private UserManager userManager;

  @Inject
  private ActiveUserHolder userHolder;

  public User registerUser(User newUser) {
    if (userManager.loadByEmail(newUser.getEmail()) == null) {
      User result = userManager.createUserFor(
        newUser.getNickName(), newUser.getEmail(), newUser.getPassword());
      userManager.save(result);
      return userManager.loadById(result.getId());
    }
    return null;
  }

  public void login(String email, String password) {
    User registeredUser = userManager.loadByEmail(email);

    if (registeredUser != null) {
      if (password.equals(registeredUser.getPassword())) {
        userHolder.setAuthenticatedUser(registeredUser);
        return;
      }
    }

    userHolder.setAuthenticatedUser(null);
  }
}
</code></pre>
                </div> <br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.4' ><span class='entry-number'>3.4</span> Servlets with CDI</a> </h2>
<span class='latex-textit'>IdeaFork</span> in its current stage consists of a CDI-based base module
that can be used independently of a specific UI technology for various user interfaces.
In the previous section we developed the first part of a JSF/CDI application.
JSF is indeed based on servlets, however this is primarily implemented internally.
Even in JSF applications there continue to be use cases where servlets can be utilized.
One such example is file upload.
In <span class='latex-textit'>IdeaFork</span> we want to use this functionality to import ideas via file upload.
So that we can reuse our page template here as well, we create another JSF page called <span class='latex-texttt'>upload.xhtml</span>.
As shown in Listing <a href='#!idx:/java_ee.html:fig:upload_form'> HTML Form for Idea Import </a>, we can use a normal HTML form in this case.
As the <span class='latex-texttt'>action</span> we enter the path to the upload servlet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:upload_form'></a>                     <pre><code>&lt;form method="post" enctype="multipart/form-data"
      action="#{jsf.contextPath}/idea/import "&gt;
  &lt;!-- ... --&gt;
&lt;/form&gt;
</code></pre>
                </div> <br />Listing <a href='#!idx:/java_ee.html:fig:servlet_with_injection-points'> Injection in a Servlet </a> illustrates
that CDI-based injection can also be used in servlets in an EE6+ server.
<span class='latex-texttt'>IdeaImportServlet</span> uses the already familiar session-scoped bean <span class='latex-texttt'>ActiveUserHolder</span>,
as well as an application-scoped <span class='latex-texttt'>FileUploadService</span>, which delegates to <span class='latex-texttt'>IdeaManager</span> and
stores the result (success or failure) of the import in a request-scoped bean (<span class='latex-texttt'>ImportSummary</span>).
This once again demonstrates the advantage of Contextual-References. Since only proxies are used for the injection points,
the CDI container can always redirect to the correct Contextual-Instance and we do not need to worry about the scopes of beans,
as is the case, for example, with JSF managed beans. After the import we redirect to the page <span class='latex-texttt'>summary.xhtml</span>,
on which we display the result. For this we can create a JSF page as before,
which accesses a CDI bean, in this case <span class='latex-texttt'>ImportSummary</span>. Once a CDI bean can be used,
it is therefore possible to use it as a kind of intermediate or transfer store for data.<br /> <div class="tip"><b>Tip: </b> Only with asynchronous processing, as has been possible with servlets since version 3.0, must more care be taken.
If a new thread is not managed by the EE server, only scopes can be used
that are independent of a thread (and thus a request). Alternatively it is possible via proprietary container APIs
to manually start and stop scopes.
Even if the container starts the new thread and thus takes over the correct handling of scopes,
all required information must be passed via parameters, since there is no automatism in this area
that, for example, transfers data from the original request context to the new one. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:servlet_with_injection-points'></a>                     <pre><code>@WebServlet("/idea/import ")
@MultipartConfig
public class IdeaImportServlet extends HttpServlet {
  @Inject
  private ActiveUserHolder userHolder;

  @Inject
  private FileUploadService fileUploadService;

  protected void doPost(HttpServletRequest request,
                        HttpServletResponse response)
        throws ServletException, IOException {

    fileUploadService.storeUploadedFiles(
      request.getParts(), userHolder.getAuthenticatedUser());
    request.getRequestDispatcher("/pages/import/summary.xhtml")
      .forward(request, response);
  }
}
</code></pre>
                </div> <br />CDI beans can also be injected into servlet filters. We can create a simple filter (<span class='latex-texttt'>UserAwareFilter</span>)
to secure individual areas or various actions. Listing <a href='#!idx:/java_ee.html:fig:servlet-filter_with_injection-points'> Injection in a Servlet Filter </a> shows
that with the help of <span class='latex-texttt'>ActiveUserHolder</span>, we can perform a simple check of whether the current user is already logged in.
If this is not or no longer the case, instead of the actual target, the user is redirected to the login page (<span class='latex-texttt'>login.xhtml</span>).<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:servlet-filter_with_injection-points'></a>                     <pre><code>@WebFilter(urlPatterns = {"/pages/import/*", "/idea/import"})
public class UserAwareFilter implements Filter {
  @Inject
  private ActiveUserHolder userHolder;

  @Override
  public void doFilter(ServletRequest request,
                       ServletResponse response,
                       FilterChain chain)
      throws IOException, ServletException {
    if (userHolder.isLoggedIn()) {
      chain.doFilter(request, response);
    } else {
      request.getRequestDispatcher("/pages/user/login.xhtml")
        .forward(request, response);
    }
  }
  //...
}
</code></pre>
                </div> <br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.5' ><span class='entry-number'>3.5</span> JAX-RS with CDI</a> </h2>
 The EE specification for RESTful services (JAX-RS) is primarily used for applications
that want to provide REST (Representational State Transfer) based communication with the outside world.
In <span class='latex-textit'>IdeaFork</span> we use JAX-RS for exporting ideas in JSON format.
Through the general rule mentioned at the beginning, EE6 servers already support CDI-based injection in JAX-RS resources,
even though the JAX-RS specification itself in version 1.1 does not mention CDI.
As is customary with JAX-RS, we begin in Listing <a href='#!idx:/java_ee.html:fig:jax-rs_application'> Configuration of JAX-RS Application </a> with the registration of a base path and
the configuration of resources.
As the base path we choose <span class='latex-texttt'>public</span>. Additionally we provide a class (<span class='latex-texttt'>IdeaExporter</span>).<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jax-rs_application'></a>                     <pre><code>@ApplicationPath("/public")
public class RestApplicationConfig extends Application {
  @Override
  public Set&lt;Class&lt;?&gt;&gt; getClasses() {
    return new HashSet&lt;Class&lt;?&gt;&gt;() {{
      add(IdeaExporter.class);
    }};
  }
}
</code></pre>
                </div> <br />Listing <a href='#!idx:/java_ee.html:fig:jax-rs_resource_with_injection-points'> JAX-RS Resource with CDI Injection Points </a> illustrates
that besides JAX-RS specific injection via <span class='latex-texttt'>@Context</span> we can also use CDI-based injection.
However, we must distinguish which injection points use <span class='latex-texttt'>@Context</span> and which use <span class='latex-texttt'>@Inject</span>.
If you accidentally use <span class='latex-texttt'>@Inject</span> instead of <span class='latex-texttt'>@Context</span> for JAX-RS artifacts such as <span class='latex-texttt'>HttpServletResponse</span>,
you will notice this at the latest during the next application startup,
which will be aborted with an <span class='latex-texttt'>UnsatisfiedResolutionException</span>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jax-rs_resource_with_injection-points'></a>                     <pre><code>@Path("/idea/")
@Produces(APPLICATION_JSON)
public class IdeaExporter {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private UserManager userManager;

  @Inject
  private ActiveUserHolder userHolder;

  @Context
  private HttpServletResponse response;

  @GET
  @Path("/export/all")
  public Response allIdeasOfCurrentUser() {
    User authenticatedUser = userHolder.getAuthenticatedUser();

    if (authenticatedUser == null) {
      try {
        return Response.temporaryRedirect(
          UriBuilder.fromPath("../pages/user/login.xhtml").build())
          .build();
      } catch (Exception e) {
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
          .build();
      }
    }
    return Response.ok(ideaManager.loadAllOfAuthor(authenticatedUser))
      .header(/*...*/)
      .build();
  }

  @GET
  @Path("/export/{nickname}")
  public List&lt;Idea&gt; allIdeasOfUser(
    @PathParam("nickname") String nickName) {
      response.setHeader(/*...*/);
      User loadedUser = userManager.loadByNickName(nickName);
      return ideaManager.loadAllOfAuthor(loadedUser);
  }
}
</code></pre>
                </div> <br /><span class='latex-texttt'>IdeaExporter</span> defines two endpoints.
Via <span class='latex-texttt'>/public/idea/export/all</span> all ideas of the currently logged-in user are loaded with the help of <span class='latex-texttt'>IdeaManager</span> and
passed as a response to the JAX-RS container, which takes care of the conversion to JSON.
If this endpoint is called from an anonymous source, a temporary redirect to the login page (<span class='latex-texttt'>login.xhtml</span>) is initiated.
Here too we can rely on <span class='latex-texttt'>ActiveUserHolder</span> as before. The second endpoint is independent of a prior login.
With this endpoint all ideas of a specific user can be queried.
For this the endpoint address (<span class='latex-texttt'>/public/idea /export/{nickname}</span>) only needs to be parameterized with a valid username.
This is forwarded to <span class='latex-texttt'>IdeaManager</span>, which returns a corresponding result list.
This result list is then converted to JSON again by the JAX-RS container.
For an export, however, we do not want to include all internal information completely in the result.
Instead of manual post-processing we can use a data projection.
This is, however, not supported by JAX-RS itself. Therefore we must resort to the proprietary functionality of Jackson.
For this we extend the existing <span class='latex-texttt'>ObjectConverter</span> with a method.
Listing <a href='#!idx:/java_ee.html:fig:json_conversion_with_data-view'> JSON Conversion with View </a> shows an excerpt of the modified converter.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:json_conversion_with_data-view'></a>                     <pre><code>@ExternalFormat(ExternalFormat.TargetFormat.JSON)
@JacksonConverter
public class JSONConverterJackson implements ObjectConverter {
  //...

  @Override
  public String toString(Object entity, Class typeSafeDataView) {
    try {
      ObjectMapper objectMapper = new ObjectMapper();
      if (typeSafeDataView != null) {
        objectMapper.configure(
          MapperFeature.DEFAULT_VIEW_INCLUSION, false);

        return objectMapper.writerWithView(typeSafeDataView)
          .writeValueAsString(entity);
      }
      return objectMapper.writeValueAsString(entity);
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(e);
    }
  }
}
</code></pre>
                </div> <br />In order for this <span class='latex-texttt'>ObjectConverter</span> to also be used by JAX-RS, we must provide an adapter.
Listing <a href='#!idx:/java_ee.html:fig:message-body_writer_with_injection-points'> Manual CDI Injection in Message Body Writer </a> shows the required <span class='latex-texttt'>MessageBodyWriter</span> for JAX-RS.
As a view for the data projection we pass the self-created marker class <span class='latex-texttt'>ExportView.Public.class</span> to the <span class='latex-texttt'>ObjectConverter</span>.
To use only a subset of the data during export, we must mark the corresponding getter methods in the classes <span class='latex-texttt'>Idea</span> and <span class='latex-texttt'>User</span> with <span class='latex-texttt'>@JsonView(ExportView.Public.class)</span>.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:message-body_writer_with_injection-points'></a>                     <pre><code>@Provider
@Produces(MediaType.APPLICATION_JSON)
public class CustomJsonWriter implements MessageBodyWriter&lt;Object&gt; {
  @Inject
  @ExternalFormat(JSON)
  private ObjectConverter objectConverter;

  @Override
  public boolean isWriteable(Class&lt;?&gt; rawType,
                             Type genericType,
                             Annotation[] annotations,
                             MediaType mediaType) {
    return true;
  }

  @Override
  public void writeTo(Object o,
                      Class&lt;?&gt; rawType,
                      Type genericType, Annotation[] annotations,
                      MediaType mediaType,
                      MultivaluedMap&lt;String, Object&gt; httpHeaders,
                      OutputStream entityStream) throws IOException {
    entityStream.write(
      objectConverter.toString(o, ExportView.Public.class).getBytes());
  }

  @Override
  public long getSize(Object o,
                      Class&lt;?&gt; rawType,
                      Type genericType,
                      Annotation[] annotations,
                      MediaType mediaType) {
    return -1;
  }
}
</code></pre>
                </div> <br /><span class='latex-texttt'>CustomJsonWriter</span> defines an injection point for <span class='latex-texttt'>ObjectConverter</span>, as we have used before.
However, since <span class='latex-texttt'>MessageBodyWriter</span> implementations do not support injection points, we must initiate this ourselves.
We can arrange this in <span class='latex-texttt'>RestApplicationConfig</span>.
Listing <a href='#!idx:/java_ee.html:fig:extended_jax-rs_application'> Extended JAX-RS Application (not portable) </a> shows, as an excerpt of <span class='latex-texttt'>RestApplicationConfig </span>, the method <span class='latex-texttt'>getSingletons</span>.
In this method a new instance of the class <span class='latex-texttt'>CustomJsonWriter</span> is manually created and
then passed to the helper method <span class='latex-texttt'>injectFields</span>,
in which the manual injection is performed. Finally the instance is added to the result set,
which is later used unchanged by the JAX-RS container.
The minimal implementation illustrated in <a href='#!idx:/java_ee.html:fig:extended_jax-rs_application'> Extended JAX-RS Application (not portable) </a> is, however, not fully portable.
In the Git repository of <span class='latex-textit'>IdeaFork</span> the result is therefore cached in a <span class='latex-texttt'>Set</span>.
This trick works for the tested EE servers.
Full portability is not guaranteed, since JAX-RS in version 1.1 does not account for such a use case.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:extended_jax-rs_application'></a>                     <pre><code>@Override
public Set&lt;Object&gt; getSingletons() {
  final CustomJsonWriter jsonWriter = new CustomJsonWriter();
  CdiUtils.injectFields(jsonWriter); //not portable at this point
  return new HashSet&lt;Object&gt;() {{
    add(jsonWriter);
  }};
}
</code></pre>
                </div> <br />The helper method <span class='latex-texttt'>injectFields</span> just mentioned can also be implemented by us in a few steps.
An EE container must make the <span class='latex-texttt'>BeanManger</span> available via JNDI under <span class='latex-texttt'>java:comp/BeanManager</span>.
This lookup is only necessary when we are in an area of the application that is not managed by the CDI container.
With the help of the <span class='latex-texttt'>BeanManger</span> we manually create an instance of type <span class='latex-texttt'>InjectionTarget</span>,
through which we can finally delegate the manual injection to the CDI container using the <span class='latex-texttt'>inject</span> method.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:manual_injection'></a>                     <pre><code>public class CdiUtils {
  public static &lt;T&gt; T injectFields(T instance) {
    if (instance == null) {
      return null;
    }

    BeanManager beanManager = resolveBeanManagerViaJndi();

    if (beanManager == null) {
      return instance;
    }

    CreationalContext creationalContext =
      beanManager.createCreationalContext(null);

    AnnotatedType annotatedType =
      beanManager.createAnnotatedType(instance.getClass());
    InjectionTarget injectionTarget =
      beanManager.createInjectionTarget(annotatedType);
    injectionTarget.inject(instance, creationalContext);
    return instance;
  }

  private static BeanManager resolveBeanManagerViaJndi() {
    try {
      return (BeanManager) new InitialContext()
        .lookup("java:comp/BeanManager");
    } catch (NamingException e) {
      return null;
    }
  }
}
</code></pre>
                </div> <br /> <div class="tip"><b>Tip: </b> The implementation of <span class='latex-texttt'>injectFields</span> is portable and complete.
However, this approach cannot be used portably at all points of an application.
Different EE servers and sometimes even different versions of a server behave very differently when called from within
<span class='latex-texttt'>getSingletons</span>.
Among other things, it is not guaranteed that a valid CDI container is available at this point.
This is, however, not due to CDI itself, but to the integration of different EE specifications in the servers.
This example illustrates
that even correct implementations do not always lead to the desired result directly in exceptional cases.
In a real application, with such a limitation it would be simpler to fall back on <span class='latex-texttt'>CdiUtils#getContextualReference</span>,
since this accesses the CDI container only at the latest possible moment. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The implementation and manual initialization of a <span class='latex-texttt'>MessageBodyWriter</span> is thus complete.
In the next step we can address one of the endpoints directly in a JSF page.
For this the simple HTML link shown in Listing <a href='#!idx:/java_ee.html:fig:link_to_jax-rs_endpoint'> HTML Link to JAX-RS Endpoint </a> is sufficient.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:link_to_jax-rs_endpoint'></a>                     <pre><code>&lt;a href="#{jsf.contextPath}/public/idea/export/all" class="btn"&gt;
  &lt;span class="glyphicon glyphicon-import"/&gt; Export My Ideas
&lt;/a&gt;
</code></pre>
                </div> <br />If we were to start the server at this point, the export would already work.
However, we would not get the same result on every EE server. The reason for this are the so-called
BDA rules, which we will learn about in detail later in this chapter.BDA rules, which we will explore in detail later in this chapter.
Some details of these rules are not clearly defined or are highly controversial.
For us, this means for now that we need to duplicate a configuration entry so that our application remains portable.
Specifically, we must activate the alternative stereotype @JacksonConverter in  <span class='latex-texttt'>WEB-INF/beans.xml</span>  again,
so that the alternative implementations are also active in the web application.
We will look at further details on this topic in  <a href='#!idx:/java_ee.html:sec:bda-rules'> [ Bean Deployment Archive with Java EE] </a> .<br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.6' ><span class='entry-number'>3.6</span> EJB with CDI</a> </h2>
 From the J2EE era, EJBs still have a tarnished reputation to this day.
However, since Java EE6 at the latest, this is hardly justified anymore.
EE6 servers themselves are almost consistently very fast at startup.
Long waiting times during development are thus a thing of the past.
The programming model has also become significantly more efficient.
By now, in the simplest case, a single annotation is sufficient
to turn a POJO into an EJB.
EJBs can be compared to CDI beans with additional services, such as transactions.
In  <span class='latex-textit'>IdeaFork</span>  we can begin converting our services to EJBs.
So far we have defined  <span class='latex-texttt'>FileUploadService</span>  and  <span class='latex-texttt'>UserService</span>  as application-scoped CDI beans.
The equivalent EJB type is a Singleton EJB.
Therefore, we can replace  <span class='latex-texttt'>@ApplicationScoped</span>  with  <span class='latex-texttt'>@javax.ejb.Singleton</span> .
With this change, we not only get transactional beans by default,
which we will benefit from later, but also all additional functionalities defined for  <span class='latex-texttt'>@Singleton</span> .
However, there is also a pitfall hidden here.
One of these additional functionalities is the synchronization of method calls,
which can become an unwanted bottleneck in the application.
To avoid this, we also need to add  <span class='latex-texttt'>@ConcurrencyManagement(ConcurrencyManagementType.BEAN)</span> .
In our case, we can do without the synchronization
because we do not manage any state in the bean instances.
This is because Contextual References to CDI beans are only set by the CDI container and
do not change after the bean has been created.
The injected proxy instance itself can of course handle parallel method calls without any restrictions.
Only in the referenced Contextual Instance must attention be paid
to whether parallel calls need to be handled specially.
In our case, this does not apply, and therefore no further changes are required.
Listing  <a href='#!idx:/java_ee.html:fig:ejb_with_cdi_injection-points'> EJB with CDI Injection Points </a>  shows that we can continue to use CDI-based injection.
In our previous application-scoped CDI beans, the methods could also be called in parallel without any problems.
This aspect therefore does not change with our conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_with_cdi_injection-points'></a>                     <pre><code>@Singleton
@ConcurrencyManagement(BEAN)
public class FileUploadService {
    private static final Charset UTF8 = Charset.forName("UTF-8");

    @Inject
    private IdeaManager ideaManager;

    @Inject
    private ImportSummary importSummary;

    public void storeUploadedFiles(Collection&lt;Part&gt; parts, User user) {
      for (Part part : parts) {
        String fileName = getFileName(part);
        try {
          BufferedReader bufferedReader = new BufferedReader(
            new InputStreamReader(part.getInputStream(), UTF8));
          String ideaToImportString = bufferedReader.readLine();

          while (ideaToImportString != null) {
            try {
              Idea importedIdea =
                ideaManager.importIdea(user, ideaToImportString);
              importSummary.addImportedIdea(importedIdea);
            } catch (Exception e) {
              importSummary.addFailedImport(ideaToImportString);
            }
            ideaToImportString = bufferedReader.readLine();
          }
        } catch (Exception e) {
          //...
        }
      }
    }
    //...
}
</code></pre>
                </div> <br />If a CDI scope is to be used for an EJB,
this is possible with the annotation  <span class='latex-texttt'>@Stateful</span>  (instead of  <span class='latex-texttt'>@Singleton</span> ).
The EJB container creates the instance and hands it over to the CDI container for further management.
In  <span class='latex-textit'>IdeaFork</span>  we next add the page  <span class='latex-texttt'>create.xhtml</span>  to create a new idea.
As a view controller, we can directly use an EJB.
As Listing  <a href='#!idx:/java_ee.html:fig:ejb_with_cdi-stereotype'> EJB with CDI Stereotype </a>  shows, we can add
 <span class='latex-texttt'>@javax.ejb.Stateful</span>  to the existing  <span class='latex-texttt'>@ViewController</span>  annotation.
The resulting EJB is, as expected, request-scoped due to this combination and can be referenced in EL expressions,
in our case in  <span class='latex-texttt'>create.xhtml</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_with_cdi-stereotype'></a>                     <pre><code>@Stateful
@ViewController
public class IdeaCreateViewCtrl implements Serializable {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private ActiveUserHolder userHolder;

  private String topic;
  private String category;
  private String description;

  public String save() {
    Idea ideaToSave = ideaManager.createIdeaFor(
      topic, category, userHolder.getAuthenticatedUser());
    ideaToSave.setDescription(description);
    ideaManager.save(ideaToSave);
    return "/pages/idea/overview.xhtml";
  }
  //+ Getter- and Setter-Methods
}
</code></pre>
                </div> <br />The method  <span class='latex-texttt'>#save</span>  is in this case a classic JSF action method,
which is used in  <span class='latex-texttt'>create.xhtml</span>  as usual by a command component and
delegates to the corresponding methods of the injected  <span class='latex-texttt'>IdeaManager</span> .
Since we get a transactional view controller through this approach,
the entire execution of the action method(s), as well as every getter and setter method, runs within a transaction.
In our case, this is unproblematic;
however, in more complex scenarios, even a transactional action method is often undesirable
when multiple independent operations need to be performed.
Furthermore, without restriction via  <span class='latex-texttt'>@javax.ejb.TransactionAttribute</span>  and
 <span class='latex-texttt'>@javax.ejb.Lock</span> , unnecessary overhead is incurred when accessing getter and setter methods.
For these reasons, EJBs are normally used primarily for services.
Technically, however, it is perfectly possible to use EJBs as view controllers.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the next step, we create the page  <span class='latex-texttt'>list.xhtml</span> .
As the page name already suggests, the ideas of the logged-in user are displayed in an overview list.
For this page as well, we use an EJB as a view controller.
To do this, we create the class  <span class='latex-texttt'>IdeaListViewCtrl</span>  and annotate it, in addition to  <span class='latex-texttt'>@javax.ejb.Stateful</span> , with
our stereotype annotation  <span class='latex-texttt'>@ViewController</span> , which as before specifies  <span class='latex-texttt'>@javax.enterprise.context.RequestScoped</span>  as the scope.
However, we override this default scope and thereby obtain a  <span class='latex-texttt'>@javax.enterprise.context.SessionScoped</span>  EJB.
The method  <span class='latex-texttt'>#onPreRenderView</span>  is used in  <span class='latex-texttt'>list.xhtml</span>  as a callback for the  <span class='latex-texttt'>PreRenderView</span>  event and
is responsible, as shown in Listing  <a href='#!idx:/java_ee.html:fig:ejb_as_backing-bean_with_callback'> EJB as Backing Bean with Callback </a> ,
for ensuring that the current list is always displayed in the subsequent rendering process of  <span class='latex-texttt'>list.xhtml</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_as_backing-bean_with_callback'></a>                     <pre><code>@Stateful
@SessionScoped
@ViewController
//can be optimized via @TransactionAttribute and @Lock
public class IdeaListViewCtrl implements Serializable {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private ActiveUserHolder userHolder;

  private List&lt;Idea&gt; ideaList;

  public void onPreRenderView() {
    ideaList = ideaManager.loadAllOfAuthor(
      userHolder.getAuthenticatedUser());
  }

  public void deleteIdea(Idea currentIdea) {
    this.ideaManager.remove(currentIdea);
  }

  public List&lt;Idea&gt; getIdeaList() {
    return ideaList;
  }
}
</code></pre>
                </div> <br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_with_cdi-stereotype_and_overrule_scope'></a>                     <pre><code>@Stateful
@SessionScoped
@ViewController
//can be optimized via @TransactionAttribute and @Lock
public class IdeaEditViewCtrl implements Serializable {
  @Inject
  private IdeaManager ideaManager;

  private Idea currentIdea;

  public String editIdea(Idea currentIdea) {
    this.currentIdea = currentIdea;
    return "/pages/idea/edit.xhtml";
  }

  public String save() {
    ideaManager.save(currentIdea);
    return "/pages/idea/list.xhtml";
  }

  public Idea getCurrentIdea() {
    return currentIdea;
  }
}
</code></pre>
                </div> <br />The same applies to  <span class='latex-texttt'>IdeaDetailsViewCtrl</span>  and  <span class='latex-texttt'>IdeaForkViewCtrl</span>  in Listing
 <a href='#!idx:/java_ee.html:fig:cdi-bean_with_stereotype_and_overrule_scope'> CDI Bean with Stereotype and Overridden Scope </a>  and  <a href='#!idx:/java_ee.html:fig:cdi-bean_as_backing-bean_with_injection-point_to_other_backing-bean'> CDI Bean as Backing Bean with Injection Point to Another Backing Bean </a> ,
although these beans are regular CDI beans used as view controllers.
This also represents the classic case
where primarily view controller logic is implemented and the rest is delegated to injected beans.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:cdi-bean_with_stereotype_and_overrule_scope'></a>                     <pre><code>@SessionScoped
@ViewController
public class IdeaDetailsViewCtrl implements Serializable {
  @Inject
  private IdeaManager ideaManager;

  private Idea currentIdea;

  private Stack&lt;Idea&gt; displayedIdeas = new Stack&lt;Idea&gt;();

  public String showIdea(Idea currentIdea) {
    this.currentIdea = currentIdea;
    return "/pages/idea/details.xhtml";
  }

  public void showOriginal() {
    displayedIdeas.push(currentIdea);
    currentIdea = ideaManager.loadById(currentIdea.getBaseIdeaId());
  }

  public String back() {
    if (displayedIdeas.empty()) {
      return "/pages/idea/list.xhtml";
    }
    currentIdea = displayedIdeas.pop();
    return null;
  }

  public Idea getCurrentIdea() {
     return currentIdea;
  }
}
</code></pre>
                </div> <br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:cdi-bean_as_backing-bean_with_injection-point_to_other_backing-bean'></a>                     <pre><code>@SessionScoped
@ViewController
public class IdeaForkViewCtrl implements Serializable {
  @Inject
  private IdeaEditViewCtrl ideaEditViewCtrl;

  @Inject
  private IdeaManager ideaManager;

  @Inject
  private ActiveUserHolder userHolder;

  public String forkIdea(Idea currentIdea) {
    Idea forkedIdea = ideaManager.forkIdea(
      currentIdea, userHolder.getAuthenticatedUser());
    ideaEditViewCtrl.editIdea(forkedIdea);
    return "/pages/idea/edit.xhtml";
  }
}
</code></pre>
                </div> <br />Apart from CDI-based injection and CDI scopes, EJBs can also contain observer methods for CDI events.
In combination with  <span class='latex-texttt'>@javax.ejb.Asynchronous</span> , an interesting advantage arises,
since the actual logic in such an observer method is executed asynchronously.
In Listing  <a href='#!idx:/java_ee.html:fig:ejb_with_asynchronous_cdi-observer_method'> EJB with Asynchronous CDI Observer Method </a>  we use this advantage
to asynchronously record login and logout events per user.
The asynchronous observer method  <span class='latex-texttt'>#onUserAction</span>  delegates directly to
the synchronously implemented  <span class='latex-texttt'>UserActionRepository</span> .
Since the entire method  <span class='latex-texttt'>#onUserAction</span>  is executed in a separate thread,
the processing is asynchronous from the perspective of the event source.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_with_asynchronous_cdi-observer_method'></a>                     <pre><code>@Stateless
public class StatisticService {
  @Inject
  private UserActionRepository userActionRepository;

  @Asynchronous
  public void onUserAction(@Observes UserActionEvent userActionEvent) {
    userActionRepository.save(userActionEvent.getUserAction());
  }

  //...
}
</code></pre>
                </div> <div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Since CDI 2.0 (Java EE 8), the specification natively supports asynchronous events via <span class='latex-texttt' style='color:#2e7d32;'>@ObservesAsync</span> and <span class='latex-texttt' style='color:#2e7d32;'>fireAsync()</span>. The EJB <span class='latex-texttt' style='color:#2e7d32;'>@Asynchronous</span> workaround shown here is no longer necessary. With Quarkus and CDI Lite, the EJB dependency is eliminated entirely — services are implemented as pure CDI beans. See Chapters <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a> and <a href='#!idx:/quarkus.html:10' style='color:#2e7d32;'>10</a> for details.</div><br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.7' ><span class='entry-number'>3.7</span> JPA with CDI</a> </h2>
 In Java EE6, there is no built-in integration of CDI with JPA yet.
Only Java EE7 defines a rudimentary feature set for entity listeners.
Entity listeners are still not directly managed by CDI,
but injection of CDI beans as well as lifecycle callbacks ( <span class='latex-texttt'>PostConstruct</span>  and
 <span class='latex-texttt'>PreDestroy</span> ) are available.
One option that has been available since EE6 is, of course, manual lookup or
manual injection. We have already seen both approaches and
implemented them with the  <span class='latex-texttt'>CdiUtils</span>  implementation.
Nevertheless, we can use CDI to simplify parts of JPA, and thus the next step consists of
converting  <span class='latex-textit'>IdeaFork</span>  to JPA.
We can continue to use the existing in-memory repositories for our unit tests.
To do this, we move them into the test directory of the module and
annotate them with the custom alternative stereotype  <span class='latex-texttt'>MockedRepository</span> ,
which we activate in the  <span class='latex-texttt'>beans.xml</span>  configuration file of the test module.
This is equivalent to the alternative stereotype  <span class='latex-texttt'>JacksonConverter</span>  that we have already created.
The new JPA-based repositories, on the other hand, are annotated as usual with our stereotype  <span class='latex-texttt'>@Repository</span> .
Since we want to adopt the same definitions for  <span class='latex-texttt'>MockedRepository</span>  from Listing  <a href='#!idx:/java_ee.html:fig:alternative_stereotype_annotated_with_stereotype'> Stereotype Annotation Annotated with Stereotype </a> , we can also annotate this stereotype annotation with the  <span class='latex-texttt'>@Repository</span>  annotation.
All these changes are based on the knowledge acquired so far.
Therefore, we will not go into further detail on these points here.
In the Git repository of  <span class='latex-textit'>IdeaFork</span> , the required changes are consolidated in a single commit and
can be easily traced.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:alternative_stereotype_annotated_with_stereotype'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Alternative

@Stereotype
@Repository
public @interface MockedRepository {
}
</code></pre>
                </div> A central component of JPA is the  <span class='latex-texttt'>EntityManager</span> . Since Java EE6, CDI simplifies its usage.
With Java EE5, it still had to be injected everywhere via  <span class='latex-texttt'>@PersistenceContext</span> .
This meant that this annotation with all its required parameters for injection was scattered across multiple classes of the application.
An elegant alternative is the use of a CDI producer, as we have already seen in the chapter  <a href='#!idx:/cdi_basics.html:chap:cdi-basics'>  CDI Basic Concepts </a> .
When describing the basic concept, we learned
that producer fields in combination with resource injection in an EE server can save a few lines of code.
Listing  <a href='#!idx:/java_ee.html:fig:jpa_entity-manager_producer-field'> Entity Manager Producer Field </a>  shows such a resource injection via  <span class='latex-texttt'>@PersistenceContext</span> .
At the same time, this resource injection point is a CDI producer through the use of  <span class='latex-texttt'>@Produces</span> .
After the class has been instantiated, the EE server injects an  <span class='latex-texttt'>EntityManager</span>  proxy.
From this point on, the CDI container can use this proxy as a Contextual Instance through the producer.
Since the EE server already creates a proxy, we do not need to define an additional scope for the  <span class='latex-texttt'>EntityManager</span>
to enable meaningful usage.
In Listing  <a href='#!idx:/java_ee.html:fig:jpa_entity-manager_producer-method'> Entity Manager Producer Method </a> , the same functionality is shown with a producer method.
Here too, a dependent-scoped bean is defined.
In both cases,  <span class='latex-texttt'>EntityManagerProducer</span>  is an application-scoped bean.
This definition ensures that the instance is only created once and the  <span class='latex-texttt'>EntityManager</span>  proxy also only needs to be injected once.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jpa_entity-manager_producer-field'></a>                     <pre><code>@ApplicationScoped
public class EntityManagerProducer {
  @Produces
  @PersistenceContext(name = "ideaForkPU")
  private EntityManager entityManager;
}
</code></pre>
                </div> Compared to the producer field, the producer method offers the advantage of simplifying the debugging process.
The additional method required for this should not be a concern, since it only needs to be implemented once in a central location.
For these reasons,  <span class='latex-textit'>IdeaFork</span>  also uses the following variant with the producer method.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jpa_entity-manager_producer-method'></a>                     <pre><code>@ApplicationScoped
public class EntityManagerProducer {
  @PersistenceContext(name = "ideaForkPU")
  private EntityManager entityManager;

  @Produces
  protected EntityManager exposeEntityManagerProxy() {
    return entityManager;
  }
}
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span>  we inject the  <span class='latex-texttt'>EntityManager</span>  created this way into the base class of our JPA repositories,
which is shown in excerpt form in Listing  <a href='#!idx:/java_ee.html:fig:jpa_generic-repository'> Generic JPA Repository </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jpa_generic-repository'></a>                     <pre><code>public abstract class GenericJpaRepository&lt;T extends BaseEntity&gt;
  implements GenericRepository&lt;T&gt; {

    //...

    @Inject
    protected EntityManager entityManager;

    @Override
    public void save(T entity) {
      if (entity.isTransient()) {
        entityManager.persist(entity);
      } else {
        entityManager.merge(entity);
      }
    }

    //...
}
</code></pre>
                </div> <br /> <div class="tip"><b>Tip: </b> Worth mentioning in connection with JPA is the separation of CDI beans and JPA entities.
Instances of a class should only be managed by one container (JPA or CDI)
to avoid technical problems caused by the involved proxy libraries.
Technically, we could easily work around limitations in this area
by only using dependent-scoped beans for entities
that do not use interceptors or decorators. This would allow us to simply inject entity instances.
To prevent this aspect from being forgotten,
we do not use such domain-level injection in  <span class='latex-textit'>IdeaFork</span> .
Instead, we use the classic  <span class='latex-texttt'>new</span>  keyword. </div><h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.8' ><span class='entry-number'>3.8</span> Bean Validation with CDI</a> </h2>
 The EE specifications discussed so far and
their integration with CDI already cover a large portion of use cases in business applications.
However, one important aspect is still missing -- validation.
The Bean Validation specification (JSR 303) made its debut, like CDI itself, in EE6.
As already briefly mentioned, Contextual References to
 <span class='latex-texttt'>javax.validation.ValidationFactory</span>  and  <span class='latex-texttt'>javax.validation.Validator</span>  can be injected via  <span class='latex-texttt'>@Inject</span> .
In many cases, manual usage of these artifacts is not necessary.
For example, both JSF and JPA integrated the then-new specification from the very beginning.
In the normal case, only the desired Bean Validation constraints need to be used for the actual validation.
Most commonly, it may become necessary to use a CDI bean in a constraint validator,
for example to query values from the database for validation. However, this is only supported out of the box starting with EE7.
With EE6, this functionality can be implemented very easily on your own. We could, of course, always look up CDI beans manually.
However, we would have to do this again in every constraint validator.
Instead, we want to delegate the creation of constraint validators to the CDI container at a central location,
provided that the container knows a bean with the corresponding type.
In the chapter  <a href='#!idx:/cdi_basics.html:chap:cdi-basics'>  CDI Basic Concepts </a>  we have already seen how to manually look up beans.
In a first step, we extend  <span class='latex-texttt'>CdiUtils</span>  with the method  <span class='latex-texttt'>getContextualReference</span> .
Listing  <a href='#!idx:/java_ee.html:fig:integration_of_bv_and_cdi'> Manual Integration of Bean Validation and CDI </a>  illustrates that  <span class='latex-texttt'>null</span>  is returned
when no corresponding bean is found by the CDI container.
We can use this new method in our own implementation of  <span class='latex-texttt'>javax.validation.ConstraintValidatorFactory</span> .
The implementation in Listing  <a href='#!idx:/java_ee.html:fig:integration_of_bv_and_cdi'> Manual Integration of Bean Validation and CDI </a>  delegates to  <span class='latex-texttt'>defaultFactory</span>
when the CDI container does not find a corresponding bean for a constraint validator.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:integration_of_bv_and_cdi'></a>                     <pre><code>public class BeanAwareConstraintValidatorFactory
  implements ConstraintValidatorFactory {
    private final ConstraintValidatorFactory defaultFactory;

    public BeanAwareConstraintValidatorFactory() {
      defaultFactory = Validation.byDefaultProvider().configure()
        .getDefaultConstraintValidatorFactory();
    }

    @Override
    public &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T getInstance(
      Class&lt;T&gt; validatorClass) {
        T managedConstraintValidator =
          CdiUtils.getContextualReference(validatorClass);

        if (managedConstraintValidator == null) {
          managedConstraintValidator = this.defaultFactory
            .getInstance(validatorClass);
        }
        return managedConstraintValidator;
    }
}
</code></pre>
                </div> <br />In order for  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span>  to become active,
we still need to register the fully qualified class in the  <span class='latex-texttt'>validation.xml</span>  file.
Listing  <a href='#!idx:/java_ee.html:fig:bv_config'> Activation of the Validator Factory </a>  illustrates the configuration used in  <span class='latex-textit'>IdeaFork</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:bv_config'></a>                     <pre><code>&lt;validation-config&gt;
  &lt;constraint-validator-factory&gt;at.irian.cdiatwork.ideafork.infrastructure
    .BeanAwareConstraintValidatorFactory&lt;/constraint-validator-factory&gt;
&lt;/validation-config&gt;
</code></pre>
                </div> <br />In  <span class='latex-textit'>IdeaFork</span>  we use this new functionality in the constraint validator  <span class='latex-texttt'>UniqueUserNameValidator</span> ,
which validates a newly added constraint named  <span class='latex-texttt'>@UserName</span> .
In our case, the constraint validator in Listing  <a href='#!idx:/java_ee.html:fig:constraint-validator_as_cdi-bean'> Constraint Validator as CDI Bean </a>  delegates the main work to
the injected  <span class='latex-texttt'>UserRepository</span> .
When using  <span class='latex-texttt'>@UserName</span> , we only need to take into account
that we must use a special validation group,
since otherwise the validation would also be performed during login.
Apart from that, the rest follows the conventional rules
defined by the Bean Validation specification.
Specifically, we annotate the property  <span class='latex-texttt'>nickName</span>  with
 <span class='latex-texttt'>@UserName(groups = UniqueUserName.class)</span>  and
extend the component  <span class='latex-texttt'>formGroup.xhtml</span>  with an optional attribute
to parameterize the newly added  <span class='latex-texttt'>f:validateBean</span>  tag from the outside.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:constraint-validator_as_cdi-bean'></a>                     <pre><code>@ApplicationScoped
public class UniqueUserNameValidator
  implements ConstraintValidator&lt;UserName, String&gt; {
    @Inject
    private UserRepository userRepository;

    public void initialize(UserName differentName) {
    }

    public boolean isValid(
      String userName,
      ConstraintValidatorContext constraintValidatorContext) {
        return this.userRepository.loadByNickName(userName) == null;
    }
}
</code></pre>
                </div> <br />We could also solve the validation logic in  <span class='latex-texttt'>UserService#loadByEmail</span>  with a Bean Validation constraint.
However, it is not always necessary to implement all consistency checks via Bean Validation,
since the additional validation groups also increase the complexity of the constraint logic.
An advantage of validation logic with Bean Validation constraints is
that JSF triggers the constraint validation in the validation phase and,
in the case of an error, displays it directly next to the input component
rather than in the general message area as before.<br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.9' ><span class='entry-number'>3.9</span> Bean Deployment Archive with Java EE</a> </h2>
<a name = '!idx:/java_ee.html:sec:bda-rules'> </a> One of the few downsides of CDI 1.0 is the definition of Bean Deployment Archives (BDAs) and
their implementation across different servers.
Even EE servers with the same CDI implementation do not always behave consistently,
because central aspects in this area can be defined by the integration code of the EE server.
This means that even when migrating from one Weld-based server to another, subtle differences can occur
if the application is not implemented in a fully portable manner.
The concept of Bean Deployment Archives was introduced to define module boundaries for beans and configurations.
In the most restrictive case, CDI beans and configurations via  <span class='latex-texttt'>beans.xml</span>  are only valid for the current archive.
At first glance, this may sound reasonable.
However, as soon as modules such as JARs are not under your own control or
are used for modularizing your own application,
various use cases can only be implemented with additional effort or not at all.
Depending on the specific scenario, in severe cases this can even affect injection across module boundaries,
as well as customization of default implementations of a module
where an alternative implementation is to be provided outside the module.
Furthermore, interceptors must be configured anew for each archive.
Since the definition of BDA rules leaves much room for interpretation and has already caused lengthy discussions,
alternative approaches have been created in some cases.
Some application servers, for example, grant a special status to the  <span class='latex-texttt'>beans.xml</span>  file
when it is placed in the  <span class='latex-texttt'>WEB-INF</span>  directory.
The exact implementation is, however, not covered by the CDI specification and
the concrete behavior can even differ between individual versions of a server.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In enterprise archives (EARs), the situation becomes more severe,
since it can depend on the exact structure of the application
whether and how various configurations work.
Because in some server versions there can even be side effects between beans of multiple web archives (WARs)
in combination with classes in a shared module of an EAR,
it is advisable, at least in EE6 and EE7, to avoid EARs whenever possible.
Since EE6, EARs fortunately play only a minor role,
which means that this limitation is barely noticeable or not at all in many cases.
Apache OpenWebBeans in standalone mode (= manually configured for Java SE or a servlet container)
even deactivates the BDA rules completely by default,
which means that many limitations and hurdles do not arise.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Even with a manageable application like  <span class='latex-textit'>IdeaFork</span> , the BDAs must be structured differently for GlassFish 3 than for AS7, for example,
even though both servers use Weld as their CDI implementation.
Only through different Maven build profiles, which are visible in detail in the Git repository,
can the same runtime behavior be achieved.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Since CDI 1.1, which is part of EE7,
this issue has been partially resolved through a new annotation named  <span class='latex-texttt'>@Priority</span> .
Artifacts are activated for the entire application once they are annotated with  <span class='latex-texttt'>@Priority</span> .
For alternative beans, the specified priority determines which bean is effectively active, and
for decorators and interceptors, it defines their ordering.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In summary, this means that when modularizing and
when choosing the archive type, one should start with the simplest variant possible.
The more complex the structuring of the application becomes, the more likely are limitations
caused by BDA or classloading rules.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> With CDI 4.0 (Jakarta EE 10), bean discovery was fundamentally simplified. The new default mode <span class='latex-texttt' style='color:#2e7d32;'>annotated</span> no longer requires a <span class='latex-texttt' style='color:#2e7d32;'>beans.xml</span> — only explicitly annotated classes are recognized as beans. In Quarkus, BDA rules are eliminated entirely, as ArC resolves all beans at build time. See Chapters <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a> and <a href='#!idx:/quarkus.html:10' style='color:#2e7d32;'>10</a> for details.</div>
</section>
<section class="chapter-section" id="chapter-4">
<h1> <a class='latex-index-anchor' name='!idx:/extensions.html:4' ><span class='entry-number'>4</span> Portable CDI Extensions</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> The text of this chapter has been revised by Claude (Anthropic) as co-author. This revision was made without post-review by the original author. Use at your own risk.
</div>
<a name = '!idx:/extensions.html:chap:cdi-extensions'> </a> In December 2009, the time had come and CDI was available in a first version as part of Java EE6.
The previous chapter has shown that CDI was integrated very early on with other Java EE6 specifications
such as JSF, EJB, and many more.
However, there is room for improvement in some areas of the standard integration.
This was recognized quickly in some cases and addressed at the next opportunity, the release of Java EE7.
Beyond that, certain functionalities such as the integration of other frameworks
can only be covered with difficulty or not at all by specifications.
So that these limitations do not become a limiting factor in daily work,
the SPI (Service Provider Interface) of CDI was kept very flexible.
This makes it possible to implement so-called portable CDI extensions
to extend the standard API of CDI and close potential gaps.
By now, there are many such extensions.
In this chapter, you will gain foundational knowledge that will help you extend CDI relatively easily.
Furthermore, this foundation enables the analysis and possible improvement of existing CDI extensions.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In a broader sense, portable CDI extensions are add-ons for CDI
that are implemented solely on the basis of the API and SPI of CDI.
Provided that a few subtleties of the CDI implementations are observed,
such an add-on is compatible with every specification-compliant implementation.
Ideally, this also applies to deployment in Java EE6+ servers.
Here, however, the deep integration of CDI and
the different interpretations of parts of the specification can pose an additional challenge.
With the BDA rules, we already briefly encountered different interpretations in the chapter  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI and Java EE </a> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> A portable extension in the narrower sense refers to an implementation of
the marker interface  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span> ,
used for example to modify or extend the default behavior during the application startup process.
This marker interface is only needed
to configure the corresponding implementations for the  <span class='latex-texttt'>ServiceLoader</span>  mechanism ( <span class='latex-texttt'>java.util.ServiceLoader</span> ).
Implementations of this interface can contain any number of CDI observer methods
that monitor predefined phases of the container lifecycle.
Depending on the lifecycle phase, you can extend the standard concepts of CDI with your own mechanisms
to support additional use cases as conveniently as possible.<br /> <h2><a class='latex-index-anchor' name='!idx:/extensions.html:4.1' ><span class='entry-number'>4.1</span> The CDI Container Lifecycle</a> </h2>
 Before we begin with a concrete extension, let us look at the container lifecycle in detail,
since it forms the basis for the successful implementation of extension classes.
The lifecycle fundamentally consists of two main parts. At the beginning is the container startup, also known as the bootstrapping process,
and at the end is the container shutdown. During container startup, bean definitions can optionally be modified, added, or removed.
This enables integration with virtually any frameworks that do not provide explicit CDI support themselves.
In the following section, we will learn about all the events of the lifecycle.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> As mentioned at the beginning, the CDI container notifies active implementations of  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>  through CDI events.
For the configuration and thus the activation of custom  <span class='latex-texttt'>Extension</span>  classes, the service loader concept,
which was introduced with JDK6, is used.
With the help of the class  <span class='latex-texttt'>java.util.ServiceLoader</span> , in the case of CDI all configured implementations of the
marker interface  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>  are queried by the CDI container,
which are configured in one or more files named  <span class='latex-texttt'>/META-INF/services/javax.enterprise.inject.spi.Extension</span> .
Per archive, for example a JAR file, one such configuration file with any number of entries is possible.
An entry consists of the fully qualified class name of an implementation of the aforementioned marker interface.
For each of these entries, the CDI container creates an instance that is valid for the entire application.
This is a fixed requirement. The explicit specification of a scope is therefore not intended.
As the term marker interface already suggests,
no method signatures are prescribed by  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span> ,
which means that a method does not need to be provided for every lifecycle event.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI events of the container lifecycle can be monitored in active  <span class='latex-texttt'>Extension</span>  classes using observer methods.
Some of the lifecycle events are fired once by the CDI container, while others are fired for each discovered artifact such as beans.
Most of these events have been available since CDI 1.0.
CDI 1.1 introduces three additional events with  <span class='latex-texttt'>AfterTypeDiscovery</span> ,  <span class='latex-texttt'>ProcessInjectionPoint</span>  and  <span class='latex-texttt'>ProcessBeanAttributes</span> ,
which are also discussed in the following section.<br /> <div class="tip"><b>Tip: </b> Even  <span class='latex-texttt'>Extension</span> s themselves are injectable into other CDI beans later.
Through this approach, it is possible to collect information during application startup
in order to use it at a later point in time. </div> In the following section, you will learn more about the individual lifecycle events and their areas of application.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.1'><span class='entry-number'>4.1.1</span> BeforeBeanDiscovery</a> </h3>
 Before processing of the bean candidates begins,
the CDI container fires the  <span class='latex-texttt'>BeforeBeanDiscovery</span>  event.
Through this event, qualifier, scope, stereotype, and interceptor annotations can be added
that do not fulfill all the requirements of the CDI specification.
Furthermore, it is even possible to create a so-called  <span class='latex-texttt'>AnnotatedType</span> ,
the precursor to managed beans, for classes outside of BDAs (Bean Deployment Archive) and add them through this event.
The beans that later result from this differ only slightly from beans that are regularly contained in a BDA.
However, there is a small difference here as well due to BDAs.
For such bean candidates, no  <span class='latex-texttt'>beans.xml</span>  file exists,
which means that only global (interceptor, ...) configurations, available since CDI 1.1, can be used for the final beans.
Apart from the limitation in combination with BDAs, the manual registration of  <span class='latex-texttt'>AnnotatedType</span> s
enables integration of any archives and configuration formats to extend the standard search for bean candidates.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.2'><span class='entry-number'>4.1.2</span> ProcessAnnotatedType</a> </h3>
 After the manual registrations via  <span class='latex-texttt'>BeforeBeanDiscovery</span> , the CDI container performs a scan of all BDAs and
creates a so-called  <span class='latex-texttt'>AnnotatedType</span>  for each potential bean class,
which is fired via an event named  <span class='latex-texttt'>ProcessAnnotatedType</span> .
This event is the most frequently used event in the bootstrapping process,
since portable CDI extensions can modify or remove bean definitions through this event.
In  <span class='latex-textit'>IdeaFork</span>  we use this to deactivate certain types for the CDI container in the second part of this chapter.
Such deactivation of bean candidates is possible by calling the  <span class='latex-texttt'>AnnotatedType</span>  method  <span class='latex-texttt'>#veto</span> in an observer method for the  <span class='latex-texttt'>ProcessAnnotatedType</span>  event.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.3'><span class='entry-number'>4.1.3</span> AfterTypeDiscovery</a> </h3>
 This lifecycle event has been available since CDI 1.1 and is fired once all types have been registered.
The methods  <span class='latex-texttt'>#getAlternatives</span> ,  <span class='latex-texttt'>#getInterceptors</span>  and   <span class='latex-texttt'>#getDecorators</span> return lists of the globally activated classes.
Both the order and the content of the lists can still be modified at this point.
Global activations have been standardized since CDI 1.1 with the help of the  <span class='latex-texttt'>@Priority</span>  annotation.
If, for example, an interceptor is only activated for a BDA via  <span class='latex-texttt'>beans.xml</span> , it is not included here.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> With  <span class='latex-texttt'>#addAnnotatedType</span>  it is possible to add additional custom types.
After this, the CDI container knows all definitions for which bean definitions are actually to be created.
All types excluded via  <span class='latex-texttt'>#veto</span>  are no longer present in the internal data structures of the CDI container by this point at the latest.
With  <span class='latex-texttt'>ProcessBeanAttributes</span> , which we will discuss in more detail a little later,
such a veto is also possible since CDI 1.1 based on the final bean metadata.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.4'><span class='entry-number'>4.1.4</span> ProcessInjectionPoint</a> </h3>
 This event, also introduced with CDI 1.1, is called for each injection point of a managed resource.
This includes not only CDI beans but also artifacts such as EJBs.
This lifecycle event represents, since CDI 1.1, the first step in the phase for defining the final managed bean metadata.
Before that, this was the following event named  <span class='latex-texttt'>ProcessInjectionTarget</span> .
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span class='latex-texttt'>ProcessInjectionPoint</span>  is generated not only for injection points in registered types,
but also for injection points of active observer methods and producers.
Via  <span class='latex-texttt'>#getInjectionPoint</span>  and  <span class='latex-texttt'>#setInjectionPoint</span> you can, in special cases, inspect or replace/decorate the respective injection point.
If an invalid definition (for the application) is found during inspection,
the application startup can be aborted by calling  <span class='latex-texttt'>#addDefinitionError(Throwable)</span> .<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.5'><span class='entry-number'>4.1.5</span> ProcessInjectionTarget</a> </h3>
 The  <span class='latex-texttt'>ProcessInjectionTarget</span>  event is typed to the component type and
is generated for each component (including Java EE components) that supports injection.
 <span class='latex-texttt'>javax.enterprise.inject.spi.InjectionTarget</span>  is responsible for the entire creation and
destruction, including the population of injection points,
as well as invocations of callback methods (post-construct and pre-destroy callbacks).
Since a custom implementation of  <span class='latex-texttt'>InjectionTarget</span> ,
or a wrapper for the default implementation, can be set through this event,
it is possible in a straightforward manner to extend or customize the aforementioned processes.
However, these are very specialized and deep-reaching interventions that are only required in rare cases.
Somewhat more interesting is the evaluation of the associated  <span class='latex-texttt'>AnnotatedType</span>  instance,
which is available via  <span class='latex-texttt'>#getAnnotatedType</span> .
Through this instance, custom validations can be performed and,
in case of errors, you can abort the container startup via  <span class='latex-texttt'>#addDefinitionError(Throwable)</span> .<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.6'><span class='entry-number'>4.1.6</span> ProcessBeanAttributes</a> </h3>
 This lifecycle event represents the last event introduced with CDI 1.1 in our description of the lifecycle.
It is fired for every bean, as well as interceptors and decorators, and
allows you to inspect the existing metadata using  <span class='latex-texttt'>#getBeanAttributes</span>  and  <span class='latex-texttt'>#getAnnotated</span> .
If needed, it is possible to report an error by calling  <span class='latex-texttt'>#addDefinitionError(Throwable)</span> ,
which, as usual, aborts the container startup.
In rare cases, it may be necessary to modify the existing bean attributes with  <span class='latex-texttt'>#setBeanAttributes</span>  or
to deactivate the entire bean by calling  <span class='latex-texttt'>#veto</span> .<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.7'><span class='entry-number'>4.1.7</span> ProcessProducer</a> </h3>
 For every CDI producer, both producer methods and producer fields, this lifecycle event is fired.
The interface of this event allows validation of the producer and,
if needed, the application startup can be aborted by calling  <span class='latex-texttt'>#addDefinitionError(Throwable)</span> .
Furthermore, the producer can also be modified.
Modifications should, however, only be made with a wrapper
that at least partially delegates calls to the original instance.
To avoid errors such as memory leaks,
it is advisable to implement a complete implementation of the  <span class='latex-texttt'>Producer</span>  interface with caution.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.8'><span class='entry-number'>4.1.8</span> ProcessBean</a> </h3>
 Before an active bean is effectively registered, the CDI container fires the  <span class='latex-texttt'>ProcessBean</span>  event.
This represents the last point before the registration of the corresponding bean.
At this point, the final managed bean definition (an instance of  <span class='latex-texttt'>javax.enterprise.inject.spi.Bean&lt;T&gt;</span> ) already exists.
Thus, there is an opportunity to inspect the final representation of the managed bean metadata
and, if necessary, abort the container startup via  <span class='latex-texttt'>#addDefinitionError(Throwable)</span> .
If you are only interested in a specific managed bean type,
it is possible to specify the concrete subtypes  <span class='latex-texttt'>ProcessManagedBean</span> ,  <span class='latex-texttt'> ProcessProducerMethod </span>  and
 <span class='latex-texttt'>ProcessProducerField</span> . With  <span class='latex-texttt'>ProcessBean</span>  itself, you can observe all subtypes of the event.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.9'><span class='entry-number'>4.1.9</span> ProcessObserverMethod</a> </h3>
 For observer methods, there is a separate event named  <span class='latex-texttt'>ProcessObserverMethod</span> ,
since different metadata is required for the validation of such methods.
In addition to the bean class and the qualifier annotations, all information about the method itself is also available.
The basic concept corresponds to that of  <span class='latex-texttt'>ProcessBean</span> .<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.10'><span class='entry-number'>4.1.10</span> AfterBeanDiscovery</a> </h3>
 Once the CDI container has finished the processing, including the validation of active managed beans,
the  <span class='latex-texttt'>AfterBeanDiscovery</span>  event is fired.
In addition to the already familiar method  <span class='latex-texttt'>#addDefinitionError(Throwable)</span> , this event provides methods for the manual registration
of custom managed beans, observer methods, and CDI context implementations.
If a custom managed bean is added using the method  <span class='latex-texttt'>#addBean</span> ,
the previously introduced  <span class='latex-texttt'>ProcessBean</span>  event is fired before the bean is effectively added.
It should be noted that these are not full-fledged managed beans,
since, for example, interceptors are not supported.
Such beans are therefore more comparable to producers and enable, for example, the integration of other bean containers.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.11'><span class='entry-number'>4.1.11</span> AfterDeploymentValidation</a> </h3>
<span class='latex-texttt'>AfterDeploymentValidation</span>  represents the last event before the CDI container is fully started.
At this point, all validations for which the container is responsible must be completed.
If you detect an invalid situation in the application in an observer for this event,
you can use the method  <span class='latex-texttt'>#addDeploymentProblem</span>  to prevent the successful deployment of the application
even at this point.<br /> <div class="tip"><b>Tip: </b> The  <span class='latex-texttt'>AfterDeploymentValidation</span>  event is often used for the manual implementation of a startup event.
However, this only works in a limited way and therefore does not enable a fully portable implementation.
For this reason, the annotation  <span class='latex-texttt'>@Initialized</span>  was introduced with CDI 1.1.
Since CDI 1.1, the preferred approach for implementing portable initialization logic is an observer
with the qualifier  <span class='latex-texttt'>@Initialized(ApplicationScoped.class)</span> . </div><h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.12'><span class='entry-number'>4.1.12</span> BeforeShutdown</a> </h3>
 This lifecycle event is fired before the CDI container is stopped and
enables, for example, the explicit release of open resources before the application is terminated.<br /> <div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> With CDI 4.0 (Jakarta EE 10), a second type of extension was introduced: Build Compatible Extensions. These use annotations like <span class='latex-texttt' style='color:#2e7d32;'>@Discovery</span>, <span class='latex-texttt' style='color:#2e7d32;'>@Enhancement</span>, and <span class='latex-texttt' style='color:#2e7d32;'>@Registration</span> instead of observer methods on <span class='latex-texttt' style='color:#2e7d32;'>Extension</span> classes, and are particularly relevant for build-time frameworks like Quarkus. See Chapter <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a> for details.</div>
<h2><a class='latex-index-anchor' name='!idx:/extensions.html:4.2' ><span class='entry-number'>4.2</span> Developing Custom CDI Extensions</a> </h2>
 To develop a custom portable CDI extension, it is not necessary to observe every one of the previously introduced events.
The strength of CDI events, the absolute decoupling between producer and observer methods, is also leveraged here
to keep CDI extensions as lightweight as possible.
<div class="tip"><b>Tip: </b><b>Do you really need a CDI extension?</b> Before implementing a Portable Extension, check if simpler mechanisms suffice:<br />
&bull; Want to provide beans dynamically? &rarr; <span class='latex-texttt'>@Produces</span> method<br />
&bull; Want to swap an implementation? &rarr; <span class='latex-texttt'>@Alternative</span> with <span class='latex-texttt'>@Priority</span><br />
&bull; Want to bundle annotations? &rarr; <span class='latex-texttt'>@Stereotype</span><br />
&bull; Need to influence bean discovery or the container lifecycle? &rarr; Then an extension is the right approach.</div>
In  <span class='latex-textit'>IdeaFork</span>  we want to use the  <span class='latex-texttt'>ProcessAnnotatedType</span>  event to deactivate JPA entities for the CDI container.
As already mentioned in the chapter  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI and Java EE </a> , instances of a class should only be managed by one container,
since side effects with the various proxy libraries can otherwise occur.
We can identify JPA entities by the  <span class='latex-texttt'>@Entity</span>  annotation.
We take advantage of this circumstance to make entity classes invisible to the CDI container.
To do this, we create the class  <span class='latex-texttt'>EntityVetoExtension</span>  and
implement the marker interface  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span> .
In order for an extension class to be found and used by the CDI container,
you must specify it fully qualified in a file named  <span class='latex-texttt'>/META-INF/services/javax.enterprise.inject.spi.Extension</span> . Listing  <a href='#!idx:/extensions.html:fig:activation_of_a_portable_cdi_extension'> Activation of a Portable CDI Extension </a>  shows this for our  <span class='latex-texttt'>EntityVetoExtension</span> .
 <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/extensions.html:fig:activation_of_a_portable_cdi_extension'></a>                     <pre><code>//content of /META-INF/services/javax.enterprise.inject.spi.Extension
at.irian.cdiatwork.ideafork.core.impl.infrastructure.EntityVetoExtension

</code></pre>
                </div> For now, we are only interested in the  <span class='latex-texttt'>ProcessAnnotatedType</span>  event and therefore add a corresponding observer method.
As Listing  <a href='#!idx:/extensions.html:fig:veto'> Excluding a Class from CDI </a>  illustrates, it is possible to keep the implementation very simple.
Via  <span class='latex-texttt'>ProcessAnnotatedType#getAnnotatedType#getJavaClass</span>  we can directly access the underlying class.
In our case, however, we take a shortcut via  <span class='latex-texttt'>ProcessAnnotatedType#getAnnotatedType#isAnnotationPresent</span> .
As soon as we find the  <span class='latex-texttt'>@Entity</span>  annotation,
we deactivate the associated  <span class='latex-texttt'>AnnotatedType</span>  by calling  <span class='latex-texttt'>ProcessAnnotatedType#veto</span> .
The subsequent container lifecycle events are therefore no longer fired for this  <span class='latex-texttt'>AnnotatedType</span> .
The entity classes are also no longer injectable via  <span class='latex-texttt'>@Inject</span>  into other beans,
since the CDI container no longer knows them after the call to the  <span class='latex-texttt'>#veto</span>  method.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/extensions.html:fig:veto'></a>                     <pre><code>public class EntityVetoExtension implements Extension {
    protected void excludeEntityClasses(
      @Observes ProcessAnnotatedType pat) {
        if (pat.getAnnotatedType().isAnnotationPresent(Entity.class)) {
            pat.veto();
        }
    }
}
</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The <span class='latex-texttt'>EntityVetoExtension</span> pattern shown here is a CDI 1.0 solution. More elegant alternatives are available in later versions: DeltaSpike offers <span class='latex-texttt'>@Exclude</span> (see Chapter <a href='#!idx:/extensions.html:chap:cdi-extensions'>5</a>), and since CDI 1.1 the standardized <span class='latex-texttt'>@Vetoed</span> annotation directly excludes a class from bean discovery. This example remains valuable for understanding the Extension SPI.</div>
As previously mentioned, we can also implement bean validations with the help of CDI extensions.
The combination possibilities of CDI, EJBs, and JSF shown in the chapter  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI and Java EE </a>  are diverse.
A few of the mentioned pitfalls are not immediately recognizable or may only manifest themselves in production operation and
sometimes require good detailed knowledge.
To counteract problematic constellations and at the same time ensure a somewhat more uniform application structure,
we validate application-specific guidelines with the help of an additional CDI extension.
There are virtually no limits to the scope of validation rules for implementation details.
All mechanisms provided by the standard Reflection API
can be used to validate the application structure.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  we limit ourselves to checking view controller beans and the package for services.
In the previous chapter, we partially used EJBs as view controllers.
This meant that in those cases, we did not need a separate transactional service.
In more complex applications, however, it is often necessary that only part of the JSF action method(s) is executed transactionally.
For this and other reasons already mentioned in the chapter  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI and Java EE </a> ,
our first validation rule should therefore ensure that EJBs are not simultaneously annotated with  <span class='latex-texttt'>@ViewController</span> .
Every rule violation should be recorded.
At the end of the bootstrapping process, we want to abort the application startup in case of errors and
report all violations collectively as the reason for the deployment problem.<br />Since we want to validate the effective bean metadata, we use in Listing  <a href='#!idx:/extensions.html:fig:validate_view_controller'> Validating Application Rules </a> an observer for the  <span class='latex-texttt'>ProcessManagedBean</span>  event.
The method  <span class='latex-texttt'>#getAnnotatedBeanClass</span>  does not directly return the class itself,
but rather an instance of the type  <span class='latex-texttt'>AnnotatedType</span> .
Through this instance, we can inspect not only physically available metadata,
but also potentially dynamically added metadata that will later be effectively visible to the CDI container.
If, on the other hand, only the physical class itself and its metadata are to be inspected,
you can use the  <span class='latex-texttt'>#getJavaClass</span>  method of  <span class='latex-texttt'>AnnotatedType</span> .
We collect rule violations as error messages in a list.
In a second observer, this time for the  <span class='latex-texttt'>AfterDeploymentValidation</span>  event,
we evaluate the violations found.
Although we could also abort the startup process via  <span class='latex-texttt'>ProcessManagedBean</span> ,
a collected output of all rule violations would not be possible there.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/extensions.html:fig:validate_view_controller'></a>                     <pre><code>public class AppStructureValidationExtension implements Extension {
  private static final Logger LOG = Logger.getLogger(/*...*/);
  private List&lt;String&gt; violations = new ArrayList&lt;String&gt;();

  public void validateArtifacts(
    @Observes ProcessManagedBean pmb) {
      if (pmb.getAnnotatedBeanClass()
        .isAnnotationPresent(ViewController.class)) {
          validateViewController(pmb.getAnnotatedBeanClass());
      }
  }

  private void validateViewController(AnnotatedType annotatedType) {
    for (Annotation annotation : annotatedType.getAnnotations()) {
      if (annotation.annotationType()
        .getPackage().getName().equals("javax.ejb")) {
          this.violations.add(/*...*/); //violation message
      }
    }
  }

  public void checkAndAddViolations(
    @Observes AfterDeploymentValidation afterDeploymentValidation) {
      if (this.violations.isEmpty()) {
        LOG.info(/*...*/); //success message
        return;
      }

      StringBuilder violationMessage = new StringBuilder();

      for (String violation : this.violations) {
        violationMessage.append(violation);
      }
      this.violations.clear();
      afterDeploymentValidation.addDeploymentProblem(
        new IllegalStateException(violationMessage.toString()));
  }
}
</code></pre>
                </div> With a second rule, we want to ensure that all beans in a service package are implemented as  <span class='latex-texttt'>@Stateless</span>  EJBs.
Additionally, we check beans annotated with  <span class='latex-texttt'>@javax.ejb.Singleton</span>  and log a warning,
since singleton EJBs with  <span class='latex-texttt'>ConcurrencyManagementType.CONTAINER</span>  can quickly become an unwanted bottleneck in the application,
and beans with  <span class='latex-texttt'>ConcurrencyManagementType.BEAN</span>  are only truly needed in rare cases.
A warning should also be logged when view controller beans do not conform to a prescribed naming convention.
Listing  <a href='#!idx:/extensions.html:fig:validate_naming_and_ejbs'> Validating Extended Application Rules </a>  shows the required changes compared to  <a href='#!idx:/extensions.html:fig:validate_view_controller'> Validating Application Rules </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/extensions.html:fig:validate_naming_and_ejbs'></a>                     <pre><code>public class AppStructureValidationExtension implements Extension {
  //...
  public void validateArtifacts(
    @Observes ProcessManagedBean pmb) {
      //...
      if (pmb.getAnnotatedBeanClass().getJavaClass()
        .getPackage().getName().endsWith(".service")) {
          validateService(pmb.getAnnotatedBeanClass());
      }
      if (pmb.getAnnotatedBeanClass()
        .isAnnotationPresent(Singleton.class)) {
          validateSingletonEjb(pmb.getAnnotatedBeanClass());
      }
  }

  private void validateViewController(AnnotatedType annotatedType) {
    //...
    if (!annotatedType.getJavaClass().getName().endsWith("ViewCtrl")) {
      LOG.warning(/*...*/);
    }
  }

  private void validateService(AnnotatedType annotatedType) {
    if (!annotatedType.isAnnotationPresent(Stateless.class)) {
      this.violations.add(/*...*/);
    }
  }

  private void validateSingletonEjb(AnnotatedType annotatedType) {
    ConcurrencyManagement cmAnnotation =
      annotatedType.getAnnotation(ConcurrencyManagement.class);

    if (cmAnnotation == null ||
      ConcurrencyManagementType.CONTAINER == cmAnnotation.value()) {
        LOG.warning(/*...*/);
    } else if (ConcurrencyManagementType.BEAN == cmAnnotation.value()) {
      LOG.warning(/*...*/);
    }
  }
}
</code></pre>
                </div> The application guidelines we just defined result in two warnings and five violations with the current state of  <span class='latex-textit'>IdeaFork</span> . The required adjustments are very straightforward.
In addition to replacing individual annotations
with equivalent annotations, which were also introduced in the chapter  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI and Java EE </a> ,
an additional EJB named  <span class='latex-texttt'>IdeaService</span>  is primarily needed.
All changes from this conversion, as well as the activation of  <span class='latex-texttt'>AppStructureValidationExtension</span> , are consolidated in a single commit in the Git repository of  <span class='latex-textit'>IdeaFork</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> There are only a few limits to the extension possibilities, which means that CDI can be extended with virtually any concepts.
The following chapter, on the topic of  <a href='#!idx:/deltaspike.html:chap:deltaspike'>  Apache DeltaSpike </a> , illustrates further possibilities for how CDI can be portably extended.
</section>
<section class="chapter-section" id="chapter-5">
<h1> <a class='latex-index-anchor' name='!idx:/deltaspike.html:5' ><span class='entry-number'>5</span> Apache DeltaSpike</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> The text of this chapter has been revised by Claude (Anthropic) as co-author. This revision was made without post-review by the original author. Use at your own risk.
</div>
<a name = '!idx:/deltaspike.html:chap:deltaspike'> </a> In the previous chapters we got to know various CDI concepts using the example application  <span class='latex-textit'>IdeaFork</span> .
Before we reduce  <span class='latex-textit'>IdeaFork</span>  to an efficient minimum in the next chapter, we will further expand the current state of  <span class='latex-textit'>IdeaFork</span> in this chapter. For this we use a popular portable CDI extension called Apache DeltaSpike,
which was founded at the end of 2011 as the successor to Apache MyFaces CODI and JBoss Seam3.
A large portion of all CDI-based applications at that time relied on one of these two extensions
in order to benefit from additional concepts.
CODI originated from requirements of large applications and was characterized by high stability and
good performance combined with innovative concepts. Seam3, similar to CODI, offered several modules
that improved CDI and integrated it with other technologies.
Although CODI provided fewer modules, the framework was preferred in many CDI-based JSF applications,
since the framework considerably facilitated daily work, especially with CDI and JSF.
Nearly two years after CODI was founded, the community was offered a merger with Seam3,
which ultimately led to the top-level project Apache DeltaSpike under the umbrella of the Apache Software Foundation (ASF).<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The beginning was somewhat sluggish, as partially overlapping aspects had to be unified into a consistent API.
With version 1.0, DeltaSpike finally covered the most successful concepts of CODI,
making migration of a CODI-based application feasible in many cases within just a few hours.
In almost all areas, however, a complete reimplementation of the known functionalities was carried out,
in order to provide them even more conveniently and at the same time more flexibly.
In addition, extra mechanisms and modules were added, which among other things could be implemented more easily through parts that originally came from Seam3.
After some discussions and compromises, however, only a few implementations from Seam3 were adopted,
meaning the migration effort for a Seam3 application can be more extensive, depending on the parts used.
Some of the Seam3 modules were moved to third-party projects.
These modules are primarily the CDI integration of the respective projects,
which in the future will be further developed and maintained by the projects themselves.
DeltaSpike itself thus primarily ensures the direct improvement of CDI and other Java EE specifications and
additionally enables the portable use of CDI 1.x in Java SE projects.
The practical extension of Java EE, but also of CDI itself, is the recipe for DeltaSpike's success.
This helped the project gain a diverse community and even a "Duke's Choice Award" in 2014.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Another success factor is the tested portability, which has played a central role since the beginning of the project.
With the help of JBoss Arquillian, an extensive set of tests was built up.
For releases of OpenWebBeans and Weld, a separate build job is created in the Continuous Integration cluster of the Apache Software Foundation.
This enables automated tests that ensure the compatibility of DeltaSpike with as many configurations as possible.
In addition to OpenWebBeans and Weld themselves, the test suite is also regularly run in combination with several open-source servers.
These include various versions of Apache TomEE, JBoss AS7 and WildFly, as well as Oracle GlassFish.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> By now, DeltaSpike is so extensive that describing all of its components would go beyond the scope of this book.
In the following sections, we will therefore look at the most central components and a few of the extension possibilities.
For this, we start from our CDI-based JSF example application named  <span class='latex-textit'>IdeaFork</span>  and convert parts of it.<br />
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1' ><span class='entry-number'>5.1</span> All for One Core</a> </h2>
 DeltaSpike consists of several largely independent modules that are built on top of DeltaSpike-Core.
The use of individual modules is optional.
If a CDI-based application is to be improved with DeltaSpike, then at least DeltaSpike-Core must be added.
In addition to various utilities for CDI, DeltaSpike-Core contains additional functionalities
that are useful in both CDI-based Java SE and Java EE applications.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Before we enrich  <span class='latex-textit'>IdeaFork</span>  with mechanisms from DeltaSpike,
we need to add DeltaSpike-Core as a dependency of  <span class='latex-textit'>IdeaFork</span> .
Normally, it is sufficient to define Core-API as a  <span class='latex-texttt'>compile</span> -dependency and Core-Impl as a  <span class='latex-texttt'>runtime</span> -dependency.
Both are shown in Listing  <a href='#!idx:/deltaspike.html:fig:ds-core_dependencies'> Maven Configuration for DeltaSpike Core </a>  and are parameterized here with the separately defined Maven property
 <span class='latex-texttt'>${ds.version}</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-core_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.core&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-core-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.core&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-core-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> In addition to DeltaSpike-Core, we will examine the following modules in excerpts in this book:<br /> <div class='latex-begin-block'><ul><li class='latex-list'>  DeltaSpike Bean-Validation
 </li><li class='latex-list'>  DeltaSpike Data
 </li><li class='latex-list'>  DeltaSpike JPA
 </li><li class='latex-list'>  DeltaSpike JSF
 </li><li class='latex-list'>  DeltaSpike Scheduler
 </li><li class='latex-list'>  DeltaSpike Servlet
 </li><li class='latex-list'>  DeltaSpike Test-Control
 </li></ul></div> The DeltaSpike modules Security, Partial-Bean and Proxy are partially required for functionalities of the previously listed modules.
All three modules can also be used independently.
However, we will primarily look at their use in combination with other components of DeltaSpike.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div class="tip"><b>Tip: </b><b>DeltaSpike modules and their modern equivalents:</b><br />
&bull; <b>Core (Config):</b> MicroProfile Config (Chapter <a href='#!idx:/quarkus.html:10.4'>10.4</a>)<br />
&bull; <b>Security:</b> Jakarta Security + <span class='latex-texttt'>@RolesAllowed</span> (Chapter <a href='#!idx:/quarkus.html:10.6'>10.6</a>)<br />
&bull; <b>Data:</b> Quarkus Panache (Chapter <a href='#!idx:/quarkus.html:10.6'>10.6</a>)<br />
&bull; <b>JSF:</b> Angular (Chapter <a href='#!idx:/angular.html:11'>11</a>)<br />
&bull; <b>Scheduler:</b> Quarkus Scheduler (<span class='latex-texttt'>quarkus-scheduler</span>)<br />
&bull; <b>Servlet:</b> Quarkus HTTP / Vert.x Web<br />
Details for each migration can be found in the corresponding chapters.</div>
With the help of DeltaSpike-Core and the various modules, we will improve  <span class='latex-textit'>IdeaFork</span>  step by step.
Since some mechanisms can primarily be illustrated meaningfully in combination with others, we will not examine each module in isolation,
but rather convert  <span class='latex-textit'>IdeaFork</span>  thematically by combining different parts of DeltaSpike.
Before we begin converting  <span class='latex-textit'>IdeaFork</span> , let us take an overview of the available modules and their Maven configuration.<br /> <h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.1' ><span class='entry-number'>5.1.0.1</span> DeltaSpike Bean-Validation</a></h4>
 In Java EE6, a rudimentary integration between Bean-Validation and CDI is defined.
In particular, constraint validators managed by CDI are not supported.
This limitation was resolved with Java EE7.
In  <span class='latex-textit'>IdeaFork</span>  we implemented this manually in  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span> .
Such an integration is also provided by the module shown in Listing  <a href='#!idx:/deltaspike.html:fig:ds-bv_dependencies'> Maven Configuration for DeltaSpike Bean-Validation </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-bv_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-bean-validation-module-api&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-bean-validation-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><div class="tip"><b>Tip: </b> All DeltaSpike modules consist of an API and an Impl part.
The BeanValidation module follows this convention to avoid confusion.
However, currently no API is required, so the Impl dependency alone would suffice. </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.2' ><span class='entry-number'>5.1.0.2</span> DeltaSpike Data</a></h4>
 The Data module allows a more efficient use of simple JPQL (Java Persistence Query Language) queries.
Behind the scenes, the corresponding JPQL query is generated based on the method signature or optionally based on additional metadata.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/deltaspike.html:fig:ds-data_dependencies'> Maven Configuration for DeltaSpike Data </a>  shows the entries for the Maven configuration.
As transitive dependencies, DeltaSpike-Data includes the JPA, Partial-Bean and Proxy modules.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-data_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-data-module-api&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-data-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.3' ><span class='entry-number'>5.1.0.3</span> DeltaSpike JPA</a></h4>
 If EJBs are not an option in a CDI-based application or if pure CDI beans are preferred,
then this module offers an alternative transaction handling.
In addition to various strategies for handling transactions that can be used in Java SE and EE applications,
this module defines, for example, a CDI context that limits the lifetime of corresponding CDI beans to the current transaction.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The entries shown in Listing  <a href='#!idx:/deltaspike.html:fig:ds-jpa_dependencies'> Maven Configuration for DeltaSpike JPA </a>  must be specified
when this module is not used in combination with DeltaSpike Data.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-jpa_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jpa-module-api&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jpa-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.4' ><span class='entry-number'>5.1.0.4</span> DeltaSpike JSF</a></h4>
 The build dependencies from Listing  <a href='#!idx:/deltaspike.html:fig:ds-jsf_ee6_dependencies'> Maven Configuration for DeltaSpike JSF (EE6) </a>  are required
when a JSF application is to be developed even more efficiently.
Some concepts of this module enable higher type safety, which can reduce maintenance effort.
The integration with other parts of DeltaSpike additionally allows the uniform use of various mechanisms of the framework.
For this purpose, in addition to the Proxy module, the Security module is particularly required as a transitive dependency.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-jsf_ee6_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jsf-module-api&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jsf-module-impl-ee6&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> The regular JSF module is compatible with both EE6 and EE7.
However, some EE6 servers log an error at application startup.
The reason for this is the deactivation of optional classes of the JSF module that are needed for EE7 support.
The application is nevertheless functional.
To avoid potential confusion, an EE6-specific module can be used instead.
Therefore, for EE6-based applications it is also possible to use the build dependencies from Listing  <a href='#!idx:/deltaspike.html:fig:ds-jsf_dependencies'> Maven Configuration for DeltaSpike JSF </a> .
With this approach, the feature set does not change and the maintenance effort of the modules can be minimized.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-jsf_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jsf-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jsf-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.5' ><span class='entry-number'>5.1.0.5</span> DeltaSpike Partial-Bean</a></h4>
 Partial-Beans are interfaces or abstract classes for which a generic handling can be provided.
The build dependencies listed in Listing  <a href='#!idx:/deltaspike.html:fig:ds-partial-bean_dependencies'> Maven Configuration for DeltaSpike Partial-Bean </a>  enable
such decoupling through special bindings.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> This concept is, among other things, the basis for the Data module.
The generation of JPQL queries is implemented generically in the Data module,
so the application does not need to contain any logic for this.
JPA repositories of an application can thereby be reduced to interfaces or abstract classes.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-partial-bean_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-partial-bean-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-partial-bean-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> This module requires proxies for its functionality, which is why DeltaSpike's Proxy module is defined as a transitive dependency.<br /> <h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.6' ><span class='entry-number'>5.1.0.6</span> DeltaSpike Proxy</a></h4>
 The Proxy module decouples the use of proxy functionalities from a concrete implementation and is,
as shown in Listing  <a href='#!idx:/deltaspike.html:fig:ds-proxy_dependencies'> Maven Configuration for DeltaSpike Proxy </a> , configured slightly differently.
Currently, the ASM5 module is the only implementation.
In the future, there may be additional implementations to support, for example, new JDK versions.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-proxy_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-proxy-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-proxy-module-impl-asm5&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.7' ><span class='entry-number'>5.1.0.7</span> DeltaSpike Scheduler</a></h4>
 This module allows integration with schedulers that support task/job configuration with cron expressions.
Since DeltaSpike CDI-Control is additionally needed, for example to start and stop the request context per task/job,
this module is not compatible with all EE servers.
Modern EE servers that use current versions of OpenWebBeans or Weld are typically not affected by this limitation.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Build dependencies for integration with Quartz are shown in Listing  <a href='#!idx:/deltaspike.html:fig:ds-scheduler_dependencies'> Maven Configuration for DeltaSpike Scheduler </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-scheduler_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-scheduler-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-scheduler-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
  &lt;artifactId&gt;quartz&lt;/artifactId&gt;
  &lt;version&gt;${quartz.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.8' ><span class='entry-number'>5.1.0.8</span> DeltaSpike Security</a></h4>
 The Security module from Listing  <a href='#!idx:/deltaspike.html:fig:ds-security_dependencies'> Maven Configuration for DeltaSpike Security </a>  is not a complete security framework.
Instead, this module enables existing security frameworks to be integrated with CDI beans in a simple way.
In combination with the JSF module, JSF pages can additionally be secured with the same concepts.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-security_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-security-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-security-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.9' ><span class='entry-number'>5.1.0.9</span> DeltaSpike Servlet</a></h4>
 Similar to Bean-Validation, a full CDI integration for Servlets was only implemented in Java EE7.
The dependencies contained in Listing  <a href='#!idx:/deltaspike.html:fig:ds-servlet_dependencies'> Maven Configuration for DeltaSpike Servlet </a>
primarily provide these functionalities for Java EE6-based applications as well.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-servlet_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-servlet-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-servlet-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.10' ><span class='entry-number'>5.1.0.10</span> DeltaSpike Test-Control</a></h4>
 We have been using this CDI integration for JUnit for the examples in this book since the first commit in the Git repository of  <span class='latex-textit'>IdeaFork</span> .
In addition to DeltaSpike-Core, DeltaSpike CDI-Control is also required
so that the test dependencies from Listing  <a href='#!idx:/deltaspike.html:fig:ds-test-control_dependencies'> Maven Configuration for DeltaSpike Test-Control </a> can be used for simple tests of CDI-based applications.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-test-control_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-test-control-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-test-control-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.11' ><span class='entry-number'>5.1.0.11</span> DeltaSpike CDI-Control</a></h4>
 DeltaSpike CDI-Control should be seen alongside DeltaSpike-Core,
since this part of DeltaSpike does not build on DeltaSpike-Core, but
is the basis for DeltaSpike-Scheduler and DeltaSpike-Test-Control.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Originally designed for Java SE, CDI-Control also works with modern Java EE servers.
For this purpose, DeltaSpike provides implementations for OpenWebBeans, OpenEJB and Weld.
Through this approach, a CDI-based application can avoid the direct use of proprietary container APIs.
CDI-Control hides these calls behind a uniform API.
The only difference at runtime is the respective implementation module that is included.
The same applies to the manual control of CDI's standard scopes.
Implementations of the  <span class='latex-texttt'>ContextControl</span>  interface can start and stop the underlying contexts
via proprietary container APIs.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Depending on the intended use, the API module from Listing  <a href='#!idx:/deltaspike.html:fig:ds-cdi-control_dependencies'> Maven Configuration for DeltaSpike CDI-Control </a>  can be included as a
 <span class='latex-texttt'>compile</span>  or  <span class='latex-texttt'>test</span> -dependency.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-cdi-control_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-cdictrl-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;...&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> By definition, there are multiple implementation modules for the CDI-Control API module,
which are shown in the Listings
 <a href='#!idx:/deltaspike.html:fig:ds-cdi-control_owb_dependencies'> Maven Configuration for DeltaSpike OWB-Control </a> ,  <a href='#!idx:/deltaspike.html:fig:ds-cdi-control_weld_dependencies'> Maven Configuration for DeltaSpike Weld-Control </a>  and  <a href='#!idx:/deltaspike.html:fig:ds-cdi-control_openejb_dependencies'> Maven Configuration for DeltaSpike OpenEJB/TomEE-Control </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-cdi-control_owb_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-cdictrl-owb&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;...&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-cdi-control_weld_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-cdictrl-weld&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;...&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-cdi-control_openejb_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-cdictrl-openejb&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;...&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div>
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.2' ><span class='entry-number'>5.2</span> Flexible Rules</a> </h2>
 As a first step, we begin with the use of  <span class='latex-texttt'>@Exclude</span> ,
to replace the CDI extension named  <span class='latex-texttt'>EntityVetoExtension</span>  that we have been using so far.
The goal of  <span class='latex-texttt'>EntityVetoExtension</span>  is to veto all JPA entities
so that they are not available as CDI beans.
In  <span class='latex-textit'>IdeaFork</span>  we can achieve the same result by annotating the class  <span class='latex-texttt'>BaseEntity</span>  with  <span class='latex-texttt'>@Exclude</span> .
For  <span class='latex-textit'>IdeaFork</span>  this works because all JPA entities extend this base class.
Nevertheless, both solutions are not fully equivalent,
since we now allow JPA entities as CDI beans as long as they do not extend  <span class='latex-texttt'>BaseEntity</span>  and
are not explicitly marked with  <span class='latex-texttt'>@Exclude</span> .
In  <span class='latex-textit'>IdeaFork</span> , however, we achieve the same result and can thereby dispense with our own extension.
At the same time, we increase the readability of the application through the explicit use of  <span class='latex-texttt'>@Exclude</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:exclude_jpa-entities'> Excluding Classes from CDI with @Exclude </a>  shows the simple usage of  <span class='latex-texttt'>@Exclude</span>  just described.
Apart from this addition, in  <span class='latex-textit'>IdeaFork</span>  the class  <span class='latex-texttt'>EntityVetoExtension</span>  is deleted and
the corresponding configuration entry is removed.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:exclude_jpa-entities'></a>                     <pre><code>@Exclude
@MappedSuperclass
public abstract class BaseEntity implements Serializable {
  //...
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> For CDI itself, DeltaSpike serves as a kind of idea pool.
For example, part of  <span class='latex-texttt'>@Exclude</span>  was adopted in CDI 1.1 and has been available under the name  <span class='latex-texttt'>@Vetoed</span>  since that version.
 <span class='latex-texttt'>@Exclude</span>  remains useful, however,
since this annotation supports the use of additional conditions for deactivating CDI beans. </div> Conditions can also be used to deactivate CDI beans.
An example of this are the Project-Stages, which are also provided by DeltaSpike.
In Java EE, the concept of Project-Stages is only available for JSF.
DeltaSpike picks up the basic idea and provides it with a type-safe and
simultaneously extensible mechanism for all parts of an application.
Each Project-Stage represents a different step in application development.
Should the predefined stages
 <span class='latex-texttt'>UnitTest</span> ,  <span class='latex-texttt'>Development</span> ,  <span class='latex-texttt'>SystemTest</span> ,  <span class='latex-texttt'>IntegrationTest</span> ,  <span class='latex-texttt'>Staging</span>  and  <span class='latex-texttt'>Production</span> not be sufficient for an application, then custom types can be registered.
When using stages, there is no difference between the predefined and custom-defined stages.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The combination of Project-Stages with the  <span class='latex-texttt'>@Exclude</span>  annotation enables the deactivation of CDI beans in certain stages.
Listing  <a href='#!idx:/deltaspike.html:fig:conditional_exclude'> Conditional Exclusion of CDI Beans with @Exclude </a>  shows the simplest variant of such a combination.
In this case, we deactivate  <span class='latex-texttt'>IdeaSavedObserver</span>  for all stages except  <span class='latex-texttt'>Development</span>  and  <span class='latex-texttt'>UnitTest</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:conditional_exclude'></a>                     <pre><code>@ApplicationScoped
@Exclude(exceptIfProjectStage =
  {ProjectStage.Development.class, ProjectStage.UnitTest.class})
public class IdeaSavedObserver {
  //...
}
</code></pre>
                </div> If this concept is additionally combined, for example, with CDI beans annotated with  <span class='latex-texttt'>@Alternative</span> ,
alternative implementations can be activated for different stages without creating special versions of the application.
In  <span class='latex-textit'>IdeaFork</span>  we will add a mail service a little later,
for which we will implement a mocked alternative implementation.
Additionally, we could annotate this alternative implementation with  <span class='latex-texttt'>@Exclude</span> ,
to use this mocked implementation only during development and for unit tests.
If the alternative CDI bean is later deactivated at Project-Stage  <span class='latex-texttt'>Production</span>  through such a condition,
then the original CDI bean automatically becomes active.<br /> <div class="tip"><b>Tip: </b> The CDI TestControl module activates the Project-Stage  <span class='latex-texttt'>UnitTest</span>  by default.
This default behavior can be explicitly overridden per test method or test class with the optional annotation  <span class='latex-texttt'>@TestControl</span> . </div> The configuration of the current Project-Stage can be performed through DeltaSpike's configuration mechanism.
For this, the corresponding name of a stage must be activated for the key  <span class='latex-texttt'>org.apache.deltaspike.ProjectStage</span> .
Additionally, a rudimentary integration with JSF Project-Stages is available,
provided the JSF Project-Stage is configured via JNDI and one of the standard keys
( <span class='latex-texttt'>javax.faces.PROJECT_STAGE</span>  or  <span class='latex-texttt'>faces.PROJECT_STAGE</span> ).<br /> <div class="tip"><b>Tip: </b> If the JSF Project-Stage is configured with an entry in the  <span class='latex-texttt'>web.xml</span>  file,
then it is intentionally ignored by DeltaSpike, because this configuration variant has often led to problems in practice.
From time to time it happens that such an entry is forgotten or accidentally changed and
applications were thereby not deployed with Project-Stage Production on a production system.
Since DeltaSpike's configuration mechanism is extensible,
this deliberately chosen restriction can be circumvented if needed with the help of a custom implementation of
 <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span> . </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> DeltaSpike's configuration mechanism is very versatile.
In combination with the qualifier  <span class='latex-texttt'>@ConfigProperty</span> , configured values can be injected into CDI beans.
A simple example is illustrated in Listing  <a href='#!idx:/deltaspike.html:fig:simple_config_injection'> Injecting Configurations with @ConfigProperty </a> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Originally, in  <span class='latex-texttt'>CurrentObjectConverterProducer</span>  we used our own type-safe configuration.
In simple cases, this is certainly an elegant approach.
However, we had to load the value manually for this.
To avoid this, we can use  <span class='latex-texttt'>@ConfigProperty</span>  instead.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:simple_config_injection'></a>                     <pre><code>@ApplicationScoped
public class CurrentObjectConverterProducer {
  @Produces
  @Default
  @Dependent
  protected ObjectConverter defaultConverter(
      @ExternalFormat(XML) ObjectConverter objectConverterXml,
      @ExternalFormat(JSON) ObjectConverter objectConverterJson,
      @ConfigProperty(name = "defaultExternalFormat")
        String defaultExternalFormat) {
    switch (ExternalFormat.TargetFormat.valueOf(defaultExternalFormat)) {
      case JSON:
        return objectConverterJson;
      default:
        return objectConverterXml;
    }
  }
}
</code></pre>
                </div> By default, DeltaSpike evaluates various configuration sources.
System properties are queried before environment variables and before a JNDI lookup.
As a last source, DeltaSpike loads all configurations with the name  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> .
Values from a config source with a higher priority override values from subsequent sources.<br /> <div class="tip"><b>Tip: </b> The predefined order can be adjusted, since the priority of a config source can be changed.
If, for example, JNDI should have the highest priority, then the key deltaspike_ordinal must be set using the configuration source itself,
in this case as a JNDI entry, with the highest ordinal value of the activated configuration sources.
Specifically, for example deltaspike_ordinal=500 would need to be defined via JNDI configuration. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Normally, we want to use our own configuration file for the configuration of an application.
In  <span class='latex-textit'>IdeaFork</span> , configured values are also stored in a separate file named  <span class='latex-texttt'>app-config.properties</span> .
Strictly speaking, DeltaSpike only knows the abstract concept of configuration sources and
ships implementations for sources such as  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> .
The extensibility of the configuration mechanism enables the integration of other configuration sources
through implementations of the interface  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For custom property files, DeltaSpike provides an even simpler integration.
Listing  <a href='#!idx:/deltaspike.html:fig:integrate_custom_config'> Including Custom Properties Files </a>  shows the use of the base class  <span class='latex-texttt'>PropertyFileConfig</span> .
In addition to the name itself, it must be explicitly specified whether it is an optional configuration file.
DeltaSpike searches for implementations of  <span class='latex-texttt'>org.apache.deltaspike.core.api.config.PropertyFileConfig</span>  during application startup and
registers them automatically in the bootstrapping phase  <span class='latex-texttt'>AfterDeploymentValidation</span> .
Therefore, values configured this way are only available at the end of the container startup.<br /> <div class="tip"><b>Tip: </b> If a configured value should be available already during the bootstrapping phase,
then an implementation of the interface  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span>  is required.
The activation of an implementation of this interface follows the standard Service-Loader rules and is therefore independent of CDI. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:integrate_custom_config'></a>                     <pre><code>public class IdeaForkConfigFile implements PropertyFileConfig {
  @Override
  public String getPropertyFileName() {
    return "app-config.properties";
  }

  @Override
  public boolean isOptional() {
    return false;
  }
}
</code></pre>
                </div><span class='latex-texttt'>IdeaForkConfigFile</span>  enables us to also inject values from the configuration file  <span class='latex-texttt'>app-config.properties</span> using the qualifier annotation  <span class='latex-texttt'>@ConfigProperty</span> .
Values injected in this way have no lifecycle of their own.
In many cases, these are strings and primitive data types,
which means DeltaSpike itself cannot provide an automatic reload mechanism for such values.
However, we can fall back on CDI's built-in mechanisms here.
In Listing  <a href='#!idx:/deltaspike.html:fig:cached_config'> Injecting and Caching Configured Values </a> , a request-scoped bean is used to read the configured value once per request.
This is of course a certain overhead, which we will minimize in the next section through a custom scope.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:cached_config'></a>                     <pre><code>@RequestScoped
public class MonitoringConfig {
  @Inject
  @ConfigProperty(name = "methodInvocationThreshold")
  private Integer methodInvocationThreshold;

  public Integer getMethodInvocationThreshold() {
    return methodInvocationThreshold;
  }
}
</code></pre>
                </div> The CDI bean from Listing  <a href='#!idx:/deltaspike.html:fig:cached_config'> Injecting and Caching Configured Values </a>  can then be injected and used at any point
to access the current values.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> If, on the other hand, a configured value is to be injected directly at multiple points in the application,
it is possible to create a custom qualifier
to increase type safety and encapsulate the string for the configuration key in a central location.
Listing  <a href='#!idx:/deltaspike.html:fig:config_qualifier'> Config Qualifier for Type-Safe Injection </a>  shows such a qualifier.
Apart from the annotations for CDI qualifiers, such a qualifier is annotated with  <span class='latex-texttt'>@ConfigProperty</span> .
This means that in this example,  <span class='latex-texttt'>@ConfigProperty(name = "name")</span>  is centrally encapsulated in the annotation  <span class='latex-texttt'>@ApplicationName</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:config_qualifier'></a>                     <pre><code>@ConfigProperty(name = "name")
@Target({METHOD, FIELD, PARAMETER})
@Retention(RUNTIME)
@Qualifier
public @interface ApplicationName {
}
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_config_injection'> Type-Safe Injection of Configuration Values </a>  shows the corresponding injection point,
where instead of  <span class='latex-texttt'>@ConfigProperty</span>  the qualifier from Listing  <a href='#!idx:/deltaspike.html:fig:config_qualifier'> Config Qualifier for Type-Safe Injection </a>  is used.
Since we use a custom qualifier at the injection point,
we must also provide a corresponding producer.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_config_injection'></a>                     <pre><code>@Inject
@ApplicationName
private String applicationName;
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:producer_for_typesafe_config'> Producer for Type-Safe Configuration Values </a>  illustrates the required producer implementation,
which can be kept very simple through the use of  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer</span> .
In the concrete example, it only needs to delegate to  <span class='latex-texttt'>BaseConfigPropertyProducer#getStringPropertyValue</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:producer_for_typesafe_config'></a>                     <pre><code>@ApplicationScoped
public class ConfigProducer extends BaseConfigPropertyProducer {
  @Produces
  @ApplicationName
  public String applicationName(InjectionPoint injectionPoint) {
    return getStringPropertyValue(injectionPoint);
  }

  //...
}
</code></pre>
                </div> Of course, such a simple delegation is not possible in every case.
Listing  <a href='#!idx:/deltaspike.html:fig:producer_for_typesafe_config_with_defaults'> Default Values for Type-Safe Configuration </a>  shows, for example, another producer method in the same class,
which subsequently processes the loaded result.
The qualifier required for this is specified in Listing  <a href='#!idx:/deltaspike.html:fig:config_qualifier_with_default_value'> Config Qualifier for Type-Safe Injection with Default Value </a> .
The annotation attribute  <span class='latex-texttt'>defaultValue</span>  is manually evaluated in the method  <span class='latex-texttt'>ConfigProducer#maxNumberOfHighestRatedCategories</span>
and must therefore be marked with  <span class='latex-texttt'>@Nonbinding</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:config_qualifier_with_default_value'></a>                     <pre><code>@ConfigProperty(name = "maxNumberOfHighestRatedCategories")
@Target({METHOD, PARAMETER, FIELD})
@Retention(RUNTIME)
@Qualifier
public @interface MaxNumberOfHighestRatedCategories {
  @Nonbinding
  int defaultValue() default 15;
}
</code></pre>
                </div> Additionally, Listing  <a href='#!idx:/deltaspike.html:fig:producer_for_typesafe_config_with_defaults'> Default Values for Type-Safe Configuration </a>  shows
that custom qualifiers also offer an additional possibility by allowing custom annotation attributes to be used.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:producer_for_typesafe_config_with_defaults'></a>                     <pre><code>@ApplicationScoped
public class ConfigProducer extends BaseConfigPropertyProducer {
  //...

  @Produces
  @MaxNumberOfHighestRatedCategories
  public Integer maxNumberOfHighestRatedCategories(
      InjectionPoint injectionPoint) {

    String configuredValue = getStringPropertyValue(injectionPoint);

    if (configuredValue == null || configuredValue.length() == 0) {
      return getAnnotation(
        injectionPoint, MaxNumberOfHighestRatedCategories.class)
        .defaultValue();
    }

    return Integer.parseInt(configuredValue);
  }
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> Since we must evaluate information from the injection point,
we can only produce dependent-scoped beans in the previous examples according to the CDI rules. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For injection points with the qualifier  <span class='latex-texttt'>@MaxNumberOfHighestRatedCategories</span> , the default value can even be changed if needed.
Normally, however, this is not required,
which means the usage of the qualifier at an injection point as shown in Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_config_injection_with_default_value'> Type-Safe Injection of Configuration Values with Default Values </a> is usually sufficient.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_config_injection_with_default_value'></a>                     <pre><code>@Repository
public class IdeaJpaRepository
  extends GenericJpaRepository&lt;Idea&gt;
  implements IdeaRepository {

    @Inject
    @MaxNumberOfHighestRatedCategories
    private Integer maxNumberOfHighestRatedCategories;

    //...
}
</code></pre>
                </div> Behind the scenes,  <span class='latex-texttt'>BaseConfigPropertyProducer</span>  delegates to the  <span class='latex-texttt'>ConfigResolver</span>  class of DeltaSpike,
which can of course also be used manually.
Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_config_without_config-property'> Type-Safe Configuration without @ConfigProperty </a>  shows a conventional producer method without  <span class='latex-texttt'>@ConfigProperty</span>  and
without analysis of the injection point.
Instead,  <span class='latex-texttt'>ConfigResolver#getPropertyValue</span>  is used in combination with a fixed key and
the loaded result is provided as a structured object through the class  <span class='latex-texttt'>ApplicationVersion</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_config_without_config-property'></a>                     <pre><code>@ApplicationScoped
public class ConfigProducer extends BaseConfigPropertyProducer {
  //...

  @Produces
  @Dependent
  public ApplicationVersion applicationVersion() {
    String configuredValue = ConfigResolver.getPropertyValue("version");
    return new ApplicationVersion(configuredValue);
  }
}

public class ApplicationVersion {
  private final boolean released;
  private final String versionString;

  public ApplicationVersion(String versionString) {
    this.released = !versionString.contains("SNAPSHOT");
    this.versionString = versionString;
  }

  public boolean isReleased() {
    return released;
  }

  @Override
  public String toString() {
    return versionString;
  }
}
</code></pre>
                </div><span class='latex-texttt'>ApplicationVersion</span>  from Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_config_without_config-property'> Type-Safe Configuration without @ConfigProperty </a>  can thus be injected into other beans as usual.
<div class="tip"><b>Tip: </b>The DeltaSpike ConfigResolver was a forerunner for standardized configuration in Java. MicroProfile Config (Chapter <a href='#!idx:/quarkus.html:10.4'>10.4</a>) was directly inspired by this mechanism and uses the same ordinal concept for prioritizing configuration sources. For modern Quarkus projects, MicroProfile Config is the preferred solution.</div>
Listing  <a href='#!idx:/deltaspike.html:fig:using_project-stage_manually'> Project-Stage Dependent Logic </a>  processes the information from  <span class='latex-texttt'>ApplicationVersion</span> if a certain Project-Stage is active.
The Project-Stages introduced in the previous section can also be evaluated manually.
The active Project-Stage can be injected and checked with  <span class='latex-texttt'>==</span>  or  <span class='latex-texttt'>#equals</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:using_project-stage_manually'></a>                     <pre><code>@Named
public class ApplicationInfo {
  private String versionText = "Public";

  @Inject
  public ApplicationInfo(ApplicationVersion appVersion,
                         ProjectStage projectStage) {

    if (projectStage == Staging) {
      if (appVersion.isReleased()) {
        versionText = "Release ";
      }
      versionText += "v" + appVersion.toString();
    }
  }

  public String getVersionText() {
    return versionText;
  }
}
</code></pre>
                </div> So far, we have stored the version number of  <span class='latex-textit'>IdeaFork</span>  as a fixed value in our configuration file and
used it only to illustrate type-safe configuration classes.
To use Project-Stage-based logic in combination with methods such as  <span class='latex-texttt'>#isReleased</span>  more meaningfully,
it is natural to use the version number from the build configuration.
As with any configuration file in a project with a Maven build, the placeholder  <span class='latex-texttt'>${project.version}</span>  can be used for this purpose.
This makes it possible in Listing  <a href='#!idx:/deltaspike.html:fig:using_project-stage_manually'> Project-Stage Dependent Logic </a>  to display the exact build version at Project-Stage  <span class='latex-texttt'>Staging</span>
without maintaining it manually.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the XHTML template of  <span class='latex-textit'>IdeaFork</span> , a simple EL expression,
in our case  <span class='latex-texttt'>#{applicationInfo.versionText}</span> , can therefore be used
to display different information depending on the current Project-Stage.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> As already mentioned in the previous section, the current Project-Stage can be configured with the key
 <span class='latex-texttt'>org.apache.deltaspike.ProjectStage</span> .
Since VM parameters are one of the configuration sources supported by default,
we can display the version of  <span class='latex-textit'>IdeaFork</span>  by using  <span class='latex-texttt'>-Dorg.apache.deltaspike.ProjectStage=Staging</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> DeltaSpike's Project-Stage mechanism is not only type-safe but also extensible.
To define an additional stage, the interface  <span class='latex-texttt'>org.apache.deltaspike.core.api.projectstage.ProjectStageHolder</span> must be implemented.
Then we must configure this class in the file
 <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.core.api.projectstage.ProjectStageHolder</span> according to the standard Service-Loader rules.
As shown in Listing  <a href='#!idx:/deltaspike.html:fig:custom_project-stage_value'> Custom Project-Stage Value </a> ,
the implementation must provide an initialized (public static final) variable.
The type of the variable is the added stage, which must extend  <span class='latex-texttt'>org.apache.deltaspike.core.api.projectstage.ProjectStage</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_project-stage_value'></a>                     <pre><code>public class CustomProjectStage implements ProjectStageHolder {
  public static final class Debugging extends ProjectStage {
    private static final long serialVersionUID = -2626602281649294170L;
  }

  public static final Debugging Debugging = new Debugging();
}
</code></pre>
                </div> We can use our new Debugging stage, for example, in a DeltaSpike exception handler
from Listing  <a href='#!idx:/deltaspike.html:fig:custom_project-stage_in_exception_handler'> Custom Project-Stage in an Exception Handler </a> ,
to write IO exceptions to the log only when the Debugging stage is activated.
DeltaSpike's exception handler mechanism allows explicitly firing an  <span class='latex-texttt'>ExceptionToCatchEvent</span>  via CDI's event API.
Listing  <a href='#!idx:/deltaspike.html:fig:custom_project-stage_in_exception_handler'> Custom Project-Stage in an Exception Handler </a>  shows a corresponding observer,
which, however, is not built on CDI's observer API,
since among other things a custom DeltaSpike concept allows optionally specifying the processing order of handler methods.
This and other aspects require a somewhat different implementation.
As a first step, the handler class must be marked with  <span class='latex-texttt'>@ExceptionHandler</span>
so that an exception handler is registered as such in the first place.
When defining a handler method itself, we can follow the rules for CDI observer methods.
However, instead of  <span class='latex-texttt'>@Observes</span>  we must use  <span class='latex-texttt'>@Handles</span> .
The event type with ExceptionEvent is also different,
since with a CDI observer the original event type ( <span class='latex-texttt'>ExceptionToCatchEvent</span> ) would be expected.
 <span class='latex-texttt'>ExceptionEvent</span>  must additionally be parameterized with the exception type to be monitored and
provides additional methods for controlling the exception flow.
Since  <span class='latex-texttt'>LoggingExceptionHandler</span>  is only supposed to log exceptions,  <span class='latex-texttt'>ExceptionEvent#throwOriginal</span>  is called at the end.
If no subsequent handler method calls  <span class='latex-texttt'>#handled</span> ,
then the original exception will be re-thrown after all responsible exception handlers have been invoked.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_project-stage_in_exception_handler'></a>                     <pre><code>@ApplicationScoped
@ExceptionHandler
public class LoggingExceptionHandler {
  private static final Logger LOG =
    Logger.getLogger(LoggingExceptionHandler.class.getName());

  public void onUnhandledException(
      @Handles ExceptionEvent&lt;IOException&gt; exceptionEvent,
      ProjectStage projectStage) {

    if (projectStage == CustomProjectStage.Debugging) {
      LOG.log(Level.FINE,
        "exception detected", exceptionEvent.getException());
    }

    exceptionEvent.throwOriginal();
  }
}
</code></pre>
                </div> DeltaSpike does not automatically invoke exception handlers when an exception occurs.
Instead, the previously mentioned  <span class='latex-texttt'>ExceptionToCatchEvent</span>  must be fired via CDI's event API.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ExceptionToCatchEvent'> Usage of ExceptionToCatchEvent </a>  shows the usage in  <span class='latex-texttt'>CustomJsonWriter</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ExceptionToCatchEvent'></a>                     <pre><code>@Provider
@Produces(MediaType.APPLICATION_JSON)
public class CustomJsonWriter implements MessageBodyWriter&lt;Object&gt; {
  //...

  @Inject
  private BeanManager beanManager;

  @Override
  public void writeTo(Object o, Class&lt;?&gt; rawType,
                      Type genericType,
                      Annotation[] annotations,
                      MediaType mediaType,
                      MultivaluedMap&lt;String, Object&gt; httpHeaders,
                      OutputStream entityStream) throws IOException {
    //...

    try {
      //...
    } catch (IOException e) {
      ExceptionToCatchEvent exceptionToCatchEvent =
        new ExceptionToCatchEvent(e);

      beanManager.fireEvent(exceptionToCatchEvent);
    }
  }

  //...
}
</code></pre>
                </div> Since processing can be aborted without throwing an exception using methods such as  <span class='latex-texttt'>ExceptionEvent#abort</span> ,
 <span class='latex-texttt'>ExceptionToCatchEvent</span>  provides the method  <span class='latex-texttt'>#isHandled</span> .
Thus, after firing  <span class='latex-texttt'>ExceptionToCatchEvent</span> , it can be checked
whether processing was aborted or whether the exception was actually handled by a handler.
Furthermore,  <span class='latex-texttt'>ExceptionToCatchEvent</span>  can be marked as optional before firing,
to notify the exception handlers but suppress the automatic throwing of the exception
if it has not been handled after the last handler was invoked.<br /> <div class="tip"><b>Tip: </b> DeltaSpike offers further extensive possibilities for dealing with exceptions.
These should be used judiciously, as exception handling can otherwise become confusing. </div>
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.3' ><span class='entry-number'>5.3</span> Everything Under Control</a> </h2>
 In the previous section, we used a request-scoped bean for caching and updating configured values.
In practice, this can cause an unnecessarily high overhead.
Configured values are normally valid for a certain period of time and do not need to be reloaded constantly.
However, it may become necessary to reload such values at certain points in time or upon certain events.
We could use one of the available scopes that has the desired properties for storing configuration values.
If such a scope does not yet exist, then we can define and implement our own.
Here too, DeltaSpike helps with the abstract class  <span class='latex-texttt'>org.apache.deltaspike.core.util.context.AbstractContext</span> .
For  <span class='latex-textit'>IdeaFork</span>  we can, for example, implement a custom config scope that can be reset manually.
If we want to use a corresponding annotation with the name  <span class='latex-texttt'>@ConfigScoped</span> ,
we must define it based on the CDI rules for normal scopes.
The result is shown in Listing  <a href='#!idx:/deltaspike.html:fig:custom_scope-annotation'> Custom Scope Annotation </a> .
Since we do not need a passivatable context, it is sufficient to use the  <span class='latex-texttt'>@NormalScope</span>  annotation without modifications.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_scope-annotation'></a>                     <pre><code>@NormalScope
@Target({TYPE, METHOD, FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface ConfigScoped {}
</code></pre>
                </div> An annotation alone is of course not sufficient, so in the next step we implement the corresponding context.
Listing  <a href='#!idx:/deltaspike.html:fig:custom_context'> Custom Context Implementation </a>  illustrates
that a custom implementation can be implemented very easily through the use of  <span class='latex-texttt'>AbstractContext</span> .
The method  <span class='latex-texttt'>#getScope</span>  returns the class of our newly created annotation,
thereby linking the context implementation with it.
 <span class='latex-texttt'>ContextualStorage</span>  is a pre-built data structure for storing beans,
which can be initialized in a simple manner in the constructor of the context implementation.
We primarily need to decide through the second parameter whether the internal data structure should synchronize parallel accesses
to correctly support concurrent access.
In our case we want this, so we use the value  <span class='latex-texttt'>true</span> .
Through the predefined getter method named  <span class='latex-texttt'>#getContextualStorage</span> , the  <span class='latex-texttt'>AbstractContext</span>  implementation
can finally access the currently valid  <span class='latex-texttt'>ContextualStorage</span>  instance.
The method  <span class='latex-texttt'>#isActive</span>  in our case always returns  <span class='latex-texttt'>true</span> , since the context should always be active.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> No further methods are prescribed by  <span class='latex-texttt'>javax.enterprise.context.spi.Context</span>  or
 <span class='latex-texttt'>org.apache.deltaspike.core.util.context.AbstractContext</span>  and can therefore be chosen freely.
Our config context should provide a method for a complete reset,
which can be called manually at any point in time.
In Listing  <a href='#!idx:/deltaspike.html:fig:custom_context'> Custom Context Implementation </a> , the method  <span class='latex-texttt'>#reset</span>  delegates for this purpose to the static helper method
 <span class='latex-texttt'>AbstractContext#destroyAllActive</span> , to which the currently valid  <span class='latex-texttt'>ContextualStorage</span>  must be passed
in order to reset its contents.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_context'></a>                     <pre><code>public class ConfigContext extends AbstractContext {
  private final ContextualStorage contextualStorage;

  public ConfigContext(BeanManager beanManager) {
    super(beanManager);
    contextualStorage =
      new ContextualStorage(beanManager, true, isPassivatingScope());
  }

  @Override
  protected ContextualStorage getContextualStorage(
      Contextual&lt;?&gt; contextual, boolean createIfNotExist) {

    return this.contextualStorage;
  }

  @Override
  public Class&lt;? extends Annotation&gt; getScope() {
    return ConfigScoped.class;
  }

  @Override
  public boolean isActive() {
    return true;
  }

  public void reset() {
    AbstractContext.destroyAllActive(this.contextualStorage);
  }
}
</code></pre>
                </div> Like every CDI context, the implementation from Listing  <a href='#!idx:/deltaspike.html:fig:custom_context'> Custom Context Implementation </a>  must be registered with the help of a CDI extension.
Listing  <a href='#!idx:/deltaspike.html:fig:register_custom_context'> Registering a Custom Context Implementation </a>  illustrates this mechanism.
In an observer method for the  <span class='latex-texttt'>AfterBeanDiscovery</span>  event, the  <span class='latex-texttt'>BeanManager</span>  is additionally injected,
which is then passed to the constructor of  <span class='latex-texttt'>ConfigContext</span> .
The context instance created this way is finally registered through the method  <span class='latex-texttt'>AfterBeanDiscovery#addContext</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:register_custom_context'></a>                     <pre><code>public class ConfigContextExtension implements Extension {
  public void registerDeltaSpikeContexts(
      @Observes AfterBeanDiscovery afterBeanDiscovery,
      BeanManager beanManager) {

    ConfigContext configContext = new ConfigContext(beanManager);
    afterBeanDiscovery.addContext(configContext);
  }

  public void shutdownConfigContext(
      @Observes BeforeShutdown beforeShutdown,
      BeanManager beanManager) {

    ((ConfigContext)beanManager.getContext(ConfigScoped.class)).reset();
  }
}
</code></pre>
                </div> As is customary with CDI, CDI extensions must be registered with their fully qualified name in the file  <span class='latex-texttt'>META-INF/services/javax.enterprise.inject.spi.Extension</span> .
For the present CDI extension, the new content of the configuration file is:
 <span class='latex-texttt'>at.irian.cdiatwork.ideafork.core.impl.config.context.ConfigContextExtension</span><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_custom-scope_annotation'> Using a Custom Scope Annotation </a> , the scope annotation of the hereby registered CDI context
can consequently be used for our configuration cache named  <span class='latex-texttt'>MonitoringConfig</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_custom-scope_annotation'></a>                     <pre><code>@ConfigScoped
public class MonitoringConfig {
  @Inject
  @ConfigProperty(name = "methodInvocationThreshold")
  private Integer methodInvocationThreshold;

  public Integer getMethodInvocationThreshold() {
    return methodInvocationThreshold;
  }
}
</code></pre>
                </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:register_custom_context'> Registering a Custom Context Implementation </a> , the  <span class='latex-texttt'>#reset</span>  method of  <span class='latex-texttt'>ConfigContext</span> is called in the observer method for the  <span class='latex-texttt'>BeforeShutdown</span>  event,
in order to invoke any existing  <span class='latex-texttt'>@PreDestroy</span>  callbacks of the stored beans.
If this were the only invocation of the reset method,
then our newly implemented context would behave like CDI's standard application context.
In  <span class='latex-textit'>IdeaFork</span> , the config context should be resettable through various mechanisms.
In this section, we want to use JMX for this purpose.
DeltaSpike-Core allows CDI beans to be automatically registered as JMX beans through the use of the  <span class='latex-texttt'>@MBean</span>  annotation.
Specifying a bean name and a category for JMX is optional.
Listing  <a href='#!idx:/deltaspike.html:fig:jmx_integration'> Activating a CDI Bean as a JMX Bean </a>  illustrates how we can explicitly specify both pieces of information.
This makes the CDI bean visible, for example, in the JMX console called  <span class='latex-textit'>jconsole</span> .
The class  <span class='latex-texttt'>ConfigReloader</span>  defines only one method, which is additionally annotated with  <span class='latex-texttt'>@JmxManaged</span> .
This annotation marks methods that should be invokable via JMX.
In the method implementation, we obtain our custom-implemented context through the injected  <span class='latex-texttt'>BeanManager</span>
in order to call the  <span class='latex-texttt'>#reset</span>  method.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:jmx_integration'></a>                     <pre><code>@ApplicationScoped
@MBean(name = "ConfigReloader", category = "IdeaFork")
public class ConfigReloader {
  @Inject
  private BeanManager beanManager;

  @JmxManaged
  public void reloadConfig() {
    ((ConfigContext)beanManager.getContext(ConfigScoped.class))
      .reset();
  }
}
</code></pre>
                </div> As a result, it is now possible to reset the cache for configured values via JMX at any time,
causing all values stored in a  <span class='latex-texttt'>@ConfigScoped</span>  CDI bean to be reloaded upon the next access.<br />
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.4' ><span class='entry-number'>5.4</span> Helping Hands</a> </h2>
 DeltaSpike-Core provides not only base classes but also some static helper methods.
In  <span class='latex-textit'>IdeaFork</span>  we implemented, for example, two static methods in  <span class='latex-texttt'>CdiUtils</span>  that we can replace.
The first of these two methods is called  <span class='latex-texttt'>#injectFields</span>  and
is used in  <span class='latex-texttt'>CustomJsonWriter</span> ,  <span class='latex-texttt'>IdeaExporter</span>  and  <span class='latex-texttt'>RestApplicationConfig</span>
to manually populate injection points of the current instance.
An equivalent method is provided by DeltaSpike's  <span class='latex-texttt'>BeanProvider</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:manual_injection'> Manual Injection </a>  shows the usage in the class  <span class='latex-texttt'>IdeaExporter</span> .
The conversion itself is very simple, as only the class name needs to be changed from  <span class='latex-texttt'>CdiUtils</span>  to  <span class='latex-texttt'>BeanProvider</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:manual_injection'></a>                     <pre><code>private synchronized void init() {
  if (ideaManager == null) {
    BeanProvider.injectFields(this);
  }
}
</code></pre>
                </div> The  <span class='latex-texttt'>BeanProvider</span>  class provides many more helper methods beyond this.
The second method named  <span class='latex-texttt'>#getContextualReference</span> ,
which we have manually implemented in  <span class='latex-texttt'>CdiUtils</span>  so far,
can likewise be replaced by a method of the same name from  <span class='latex-texttt'>BeanProvider</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:manual_lookup'> Manual Lookup </a>  shows the conversion in  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span> to an optional lookup via  <span class='latex-texttt'>BeanProvider</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:manual_lookup'></a>                     <pre><code>@Override
public &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T
    getInstance(Class&lt;T&gt; validatorClass) {

  T managedConstraintValidator =
    BeanProvider.getContextualReference(validatorClass, true);

  if (managedConstraintValidator == null) {
    managedConstraintValidator =
      this.defaultFactory.getInstance(validatorClass);
  }
  return managedConstraintValidator;
}
</code></pre>
                </div> The method  <span class='latex-texttt'>#getContextualReference</span>  is overloaded multiple times in  <span class='latex-texttt'>BeanProvider</span> ,
allowing different parameter combinations to be used.
In addition to optional qualifiers, such a lookup can also be performed using the name of a bean, provided one was defined.
Nevertheless, a type-safe lookup should be preferred.
Manual lookups should, however, be used with great care.
Normal-scoped beans are unproblematic in this regard,
because only the contextual reference and not the contextual instance is exposed by the CDI container.
For dependent-scoped beans, however, this does not apply, and therefore separate lookup methods are available under the name  <span class='latex-texttt'>#getDependent</span> .
The result is wrapped in a data structure called  <span class='latex-texttt'>DependentProvider</span> ,
so that a correct manual destruction of the dependent-scoped instance is possible at a later point in time.
If a dependent-scoped bean were injected into a normal-scoped bean,
then the CDI container would destroy the dependent-scoped bean as soon as the corresponding normal-scoped bean is destroyed.
The CDI container cannot automatically fulfill this task when directly looking up a dependent-scoped bean, and
therefore it is necessary to trigger this process explicitly.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the class  <span class='latex-texttt'>ActiveUserHolder</span> , we fire a  <span class='latex-texttt'>UserActionEvent</span>  in the  <span class='latex-texttt'>@PreDestroy</span>  callback upon a session timeout.
Since no (HTTP) request is active at this point, request-scoped beans, for example, cannot be used.
Originally,  <span class='latex-texttt'>MonitoringConfig</span>  was a request-scoped bean and would not have been usable for such a use case,
since it would have resulted in a  <span class='latex-texttt'>ContextNotActiveException</span> .
Through the use of  <span class='latex-texttt'>@ConfigScoped</span> , we would currently not need to consider this case in  <span class='latex-textit'>IdeaFork</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Since session timeouts and their consequences are often neglected during application testing,
we can nevertheless take precautions in  <span class='latex-texttt'>ActiveUserHolder</span>
to ensure that no problems can arise at a later point.
Listing  <a href='#!idx:/deltaspike.html:fig:manual_lookup_of_dependent-scoped_beans'> Manual Usage of Dependent-Scoped Beans </a>  contains several aspects at once that are interesting in such and similar cases.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Instead of injecting the  <span class='latex-texttt'>BeanManager</span> ,
it can in a first step also be obtained via DeltaSpike's  <span class='latex-texttt'>BeanManagerProvider</span> .
This is particularly suitable for use in static methods, as well as for use in instances
that are not managed by the CDI container.
With the help of the  <span class='latex-texttt'>BeanManager</span>  and  <span class='latex-texttt'>BeanProvider#getDependent</span> , in the next step a dependent-scoped bean of type  <span class='latex-texttt'>ContextControl</span>  is retrieved.
This interface is not contained in DeltaSpike-Core, but in a separate part of DeltaSpike called CDI-Control.
Strictly speaking, the detour via  <span class='latex-texttt'>DependentProvider</span>  would not be necessary,
since the available implementations do not use  <span class='latex-texttt'>@PreDestroy</span>  callbacks.
Nevertheless, the usage shown in Listing  <a href='#!idx:/deltaspike.html:fig:manual_lookup_of_dependent-scoped_beans'> Manual Usage of Dependent-Scoped Beans </a>  is advisable,
since DeltaSpike would otherwise write warnings to the log.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> After the lookup via  <span class='latex-texttt'>BeanProvider#getDependent</span> , the contextual instance itself
can be accessed through  <span class='latex-texttt'>DependentProvider#get</span> .
In our case, we start the request context before  <span class='latex-texttt'>UserActionEvent</span>  is fired and
stop it before we destroy the dependent-scoped instance of  <span class='latex-texttt'>ContextControl</span>  using  <span class='latex-texttt'>DependentProvider#destroy</span> .<br /> <div class="tip"><b>Tip: </b> Behind the scenes, a mocked request is associated with the current thread,
allowing any request-scoped CDI beans to be reused until the request context is stopped.
Through concepts like these, all standard contexts can also be used in a CDI-based Java SE application or in unit tests.
Indirectly, we have been using this advantage since the first example, as the Test-Control module also uses CDI-Control internally
to start and stop the CDI container and to control the standard contexts as needed. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:manual_lookup_of_dependent-scoped_beans'></a>                     <pre><code>public void onLogout(User user, boolean manualLogout) {
  if (manualLogout) {
    userActionEvent
      .fire(new UserActionEvent(new UserAction(LOGOUT, user)));
  } else {
    BeanManager beanManager =
      BeanManagerProvider.getInstance().getBeanManager();

    DependentProvider&lt;ContextControl&gt; contextControlProvider =
      BeanProvider.getDependent(beanManager, ContextControl.class);

    try {
      contextControlProvider.get().startContext(RequestScoped.class);

      userActionEvent
        .fire(new UserActionEvent(new UserAction(AUTO_LOGOUT, user)));
    } finally {
      contextControlProvider.get().stopContext(RequestScoped.class);
      contextControlProvider.destroy();
    }
  }
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> Since version 1.1, CDI provides a replacement for the  <span class='latex-texttt'>BeanManagerProvider</span>  with  <span class='latex-texttt'>CDI.current().getBeanManager()</span> . </div> In addition to these very CDI-specific tools, DeltaSpike-Core also contains more general utilities such as
 <span class='latex-texttt'>ProxyUtils</span>  and  <span class='latex-texttt'>AnnotationUtils</span> .
In  <span class='latex-textit'>IdeaFork</span>  we have so far performed proxy class detection manually.
Listing  <a href='#!idx:/deltaspike.html:fig:manual_assessments'> Manual Evaluations </a>  shows the previous approach in  <span class='latex-texttt'>DefaultMonitoredInterceptorStrategy</span> ,
which can be replaced in Listing  <a href='#!idx:/deltaspike.html:fig:utility_methods'> Utility Methods from DeltaSpike </a>  through the use of  <span class='latex-texttt'>ProxyUtils#getUnproxiedClass</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:manual_assessments'></a>                     <pre><code>private Monitored extractMonitoredAnnotation(InvocationContext ic) {
  Monitored result = ic.getMethod().getAnnotation(Monitored.class);

  if (result != null) {
    return result;
  }

  Class&lt;?&gt; targetClass = ic.getTarget().getClass();

  if (targetClass.getName()
        .startsWith(targetClass.getSuperclass().getName()) &&
      targetClass.getName().contains("$$")) {

    targetClass = targetClass.getSuperclass();
  }

  result = targetClass.getAnnotation(Monitored.class);

  if (result == null) {
    return findAnnotation(
      beanManager, targetClass.getAnnotations(), Monitored.class);
  }

  return result;
}

private static &lt;T extends Annotation&gt; T findAnnotation(
    BeanManager beanManager,
    Annotation[] annotations,
    Class&lt;T&gt; targetAnnotationType) {

  for (Annotation annotation : annotations) {
    if (targetAnnotationType.equals(annotation.annotationType())) {
      return (T) annotation;
    }
    if (beanManager.isStereotype(annotation.annotationType())) {
      T result = findAnnotation(
        beanManager,
        annotation.annotationType().getAnnotations(),
        targetAnnotationType);
      if (result != null) {
        return result;
      }
    }
  }
  return null;
}
</code></pre>
                </div> Another helper class used in Listing  <a href='#!idx:/deltaspike.html:fig:utility_methods'> Utility Methods from DeltaSpike </a>  is  <span class='latex-texttt'>AnnotationUtils</span> .
In  <span class='latex-texttt'>DefaultMonitoredInterceptorStrategy</span> , the manually implemented method
 <span class='latex-texttt'>#findAnnotation</span>  can be replaced with  <span class='latex-texttt'>AnnotationUtils#findAnnotation</span> .
An additional advantage of  <span class='latex-texttt'>AnnotationUtils#findAnnotation</span>  is the support for CDI stereotypes.
This is also the reason why the  <span class='latex-texttt'>BeanManager</span>  must be passed as the first parameter.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:utility_methods'></a>                     <pre><code>private Monitored extractMonitoredAnnotation(InvocationContext ic) {
  Monitored result = ic.getMethod().getAnnotation(Monitored.class);

  if (result != null) {
    return result;
  }

  Class&lt;?&gt; targetClass = ic.getTarget().getClass();

  targetClass = ProxyUtils.getUnproxiedClass(targetClass);

  result = targetClass.getAnnotation(Monitored.class);

  if (result == null) {
    return AnnotationUtils.findAnnotation(
      beanManager, targetClass.getAnnotations(), Monitored.class);
  }

  return result;
}
</code></pre>
                </div> DeltaSpike-Core contains many interesting utilities like these.
A look at the package  <span class='latex-texttt'>org.apache.deltaspike.core.util</span>  is highly recommended.
Even for utilities that are not directly related to CDI itself.<br />
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.5' ><span class='entry-number'>5.5</span> Better Safe Than Sorry</a> </h2>
 In addition to utilities related to CDI, DeltaSpike also provides new concepts for other specifications such as JSF,
to facilitate application development through additional type safety and to improve maintainability.
An example of this is the View-Config. This mechanism allows the type-safe configuration of (JSF) pages.<br /> <div class="tip"><b>Tip: </b> View-Configs are currently implemented specifically for JSF.
The concept itself, however, is independent of JSF, and therefore DeltaSpike-Core contains most of the interfaces and annotations.
This means implementations for other UI frameworks based on DeltaSpike-Core are also possible.
DeltaSpike's JSF module provides an implementation for JSF and
additionally enables the use of the optional annotations  <span class='latex-texttt'>@View</span>  and  <span class='latex-texttt'>@Folder</span> . </div> As described at the beginning, we now add the JSF module to  <span class='latex-textit'>IdeaFork</span> ,
so that we can create a type-safe view config for any JSF page.
Listing  <a href='#!idx:/deltaspike.html:fig:minimal_view-config'> Minimal View-Config </a>  illustrates the simplest variant without additional metadata.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_view-config'></a>                     <pre><code>public class Index implements ViewConfig {
}
</code></pre>
                </div>
Without any additional usage in the application, the configuration
from Listing  <a href='#!idx:/deltaspike.html:fig:minimal_view-config'> Minimal View-Config </a>  only results in a path validation.
The page configuration shown above defines the file path  <span class='latex-texttt'>/index.xhtml</span> .
In  <span class='latex-textit'>IdeaFork</span> , however, this file does not exist.
If an application with an invalid page configuration is started,
DeltaSpike aborts the startup process and reports an invalid configuration.
The file  <span class='latex-texttt'>index.xhml</span>  is in our case located in the  <span class='latex-texttt'>pages</span>  directory.
Accordingly, the view config shown in Listing  <a href='#!idx:/deltaspike.html:fig:minimal_view-config_in_directory'> Minimal View-Config in a Directory </a>  is required.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_view-config_in_directory'></a>                     <pre><code>public interface Pages {
  class Index implements ViewConfig {}
}
</code></pre>
                </div>
Directories are represented by nestable interfaces and concrete pages by classes that directly or
indirectly implement the  <span class='latex-texttt'>ViewConfig</span>  interface.
When converting to a JSF view ID, the first letter is converted to lowercase in each case and
a suffix is added for JSF pages,
resulting in the path  <span class='latex-texttt'>/pages/index.xhtml</span>  in the case of Listing  <a href='#!idx:/deltaspike.html:fig:minimal_view-config_in_directory'> Minimal View-Config in a Directory </a> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Apart from the automatic validation of paths,
this type-safe configuration can already be used meaningfully even without additional metadata.
View-Configs can additionally be used for type-safe JSF navigation.
Listing  <a href='#!idx:/deltaspike.html:fig:minimal_typesafe_jsf-navigation'> Minimal Type-Safe JSF Navigation </a>  illustrates this using an action method
that, in contrast to a conventional action method, does not use a String as the return type.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_typesafe_jsf-navigation'></a>                     <pre><code>public Class&lt;? extends ViewConfig&gt; onJsfAction() {
  //...
  return Pages.Index.class;
}
</code></pre>
                </div>
DeltaSpike automatically converts  <span class='latex-texttt'>Pages.Index.class</span>  to  <span class='latex-texttt'>/pages/index.xhtml</span> ,
so the JSF implementation receives a normal view ID as the navigation target and
thus behaves as with standard implicit JSF navigation, which has been supported by the specification since JSF 2.0.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The view config concept becomes truly useful in combination with additional metadata.
Listing  <a href='#!idx:/deltaspike.html:fig:folder_structure_with_view-configs'> Directory Hierarchy with View-Configs </a>  shows a configuration as it is often used in practice.
With  <span class='latex-texttt'>@View</span> , JSF-specific information such as the navigation mode can be specified and explicit names can be assigned.
 <span class='latex-texttt'>@View</span>  does not need to be redefined for each page, however, but can be inherited through the inheritance hierarchy.
Since a page only needs to indirectly implement  <span class='latex-texttt'>ViewConfig</span> ,
in Listing  <a href='#!idx:/deltaspike.html:fig:folder_structure_with_view-configs'> Directory Hierarchy with View-Configs </a>   <span class='latex-texttt'>Pages</span>  is derived from  <span class='latex-texttt'>ViewConfig</span> ,
so that all other configurations do not need a direct connection to any DeltaSpike interfaces.
Through the inheritance hierarchy,  <span class='latex-texttt'>@View</span>  is inherited by all page configurations
that directly or indirectly implement the  <span class='latex-texttt'>Pages</span>  interface.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Specifying  <span class='latex-texttt'>REDIRECT</span>  as the navigation mode changes the generated navigation strings.
For example,  <span class='latex-texttt'>/pages/index.xhtml</span>  becomes  <span class='latex-texttt'>/pages/index.xhtml?faces-redirect=true</span> .
The same applies to all other pages with the exception of  <span class='latex-texttt'>Pages.User.Login.class</span> ,
since only this page configuration does not implement the  <span class='latex-texttt'>Pages</span>  interface.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span class='latex-texttt'>Pages.User.Login.class</span>  instead extends the class  <span class='latex-texttt'>org.apache.deltaspike.core.api.config.view.DefaultErrorView</span> .
This marker class for the error page of an application may only be extended by one configuration class.
DeltaSpike needs this marker to generically navigate to the default error page of an application
if an unhandled error occurs in the application.
If a different page should be used as the error page at a later point in time,
then only the affected configuration classes need to be adjusted accordingly.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:folder_structure_with_view-configs'> Directory Hierarchy with View-Configs </a>  it is also evident
that  <span class='latex-texttt'>User</span>  is nested as an interface within the  <span class='latex-texttt'>Pages</span>  interface.
This is always required when there is a subdirectory in the file system.
Thus, the structure of the file system is reflected in the configuration.
If we were to later rename only one of the directories without updating the type-safe configuration accordingly,
then the next application startup would end with an exception.
Since the view config for path configuration consists of interfaces and classes, updating is very straightforward.
All modern Java IDEs can automatically update class or interface names across the entire project.
At the latest, the Java compiler verifies whether all references were correctly changed.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:folder_structure_with_view-configs'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  class Index implements Pages {}

  interface User extends Pages {
    class Login extends DefaultErrorView {}

    class Registration implements User {}

    class Profile implements User {}
  }
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> The naming convention described above can be customized.
We will look at a simple customization in the next section of this chapter. </div>
Listing  <a href='#!idx:/deltaspike.html:fig:page-config_for_ideafork'> Page Configurations for IdeaFork </a>  shows the page configuration of  <span class='latex-textit'>IdeaFork</span>  for the existing JSF pages.
We would not necessarily need to create a view config for every page,
but for every configuration class, the corresponding JSF page must exist.
Therefore, it is fundamentally possible to forgo the configuration of concrete pages.
If only directories are configured, it is possible, for example, to define security constraints for entire folders.
In  <span class='latex-textit'>IdeaFork</span>  we will use a combination as one of the next steps,
defining security constraints at the folder level and specifying additional metadata for certain pages.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:page-config_for_ideafork'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  class Index implements Pages {}

  interface User extends Pages {
    class Login extends DefaultErrorView {}

    class Registration implements User {}

    class Profile implements User {}
  }

  interface Idea extends Pages {
    class Overview implements Idea {}

    class Create implements Idea {}
    class Edit implements Idea {}

    class List implements Idea {}
    class Details implements Idea {}
  }

  interface Search extends Pages {
    class Fork implements Search {}
  }

  interface Import extends Pages {
    class Upload implements Import {}
    class Summary implements Import {}
  }
}
</code></pre>
                </div>
Since directories are represented by interfaces and thus have their own type,
the navigation target can even be constrained by the return type of action methods.
Listing  <a href='#!idx:/deltaspike.html:fig:restrict_navigation-target'> Constraining Navigation Target via Return Type </a>  shows one of the converted action methods of  <span class='latex-textit'>IdeaFork</span> .
Instead of  <span class='latex-texttt'>Class&lt;? extends ViewConfig&gt;</span> ,  <span class='latex-texttt'>Class&lt;? extends Pages.Idea&gt;</span>  is used.
Since our own interfaces are used here, the implementation becomes more readable and additionally the Java compiler ensures
that the navigation target must lie in the  <span class='latex-texttt'>/pages/idea</span>  directory.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:restrict_navigation-target'></a>                     <pre><code>@ViewController
public class IdeaCreateViewCtrl implements Serializable {
  //...

  public Class&lt;? extends Pages.Idea&gt; save() {
    //...
    ideaService.save(ideaToSave);
    return Pages.Idea.Overview.class;
  }
}
</code></pre>
                </div>
Technically, combinations are also possible.
Listing  <a href='#!idx:/deltaspike.html:fig:possible_return_types'> Possible Return Types </a>  presents the correspondingly adapted version of the class  <span class='latex-texttt'>MenuController</span> .
Here it becomes apparent that, as with the method  <span class='latex-texttt'>#home</span> , by specifying  <span class='latex-texttt'>Class&lt;? extends Pages&gt;</span> the top-level base directory can be set as the navigation target.
The navigation itself can go to a page in this directory or to a page in one of the subdirectories.
Alternatively, the complete path can already be predetermined by the return type.
This is implemented, for example, in the method  <span class='latex-texttt'>#login</span> .
In contrast to this are the methods  <span class='latex-texttt'>#logout</span>  and  <span class='latex-texttt'>#start</span> ,
where navigation can go to any valid view config configuration.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:possible_return_types'></a>                     <pre><code>@Named("menuBean")
@Model
public class MenuController {
  @Inject
  private ActiveUserHolder userHolder;

  public Class&lt;? extends Pages&gt; home() {
    return Pages.Index.class;
  }

  public Class&lt;Pages.User.Login&gt; login() {
    return Pages.User.Login.class;
  }

  public Class&lt;? extends ViewConfig&gt; logout() {
    userHolder.setAuthenticatedUser(null);
    return Pages.User.Login.class;
  }

  public Class&lt;? extends ViewConfig&gt; start() {
    if (userHolder.isLoggedIn()) {
      return Pages.Idea.Overview.class;
    }
    return Pages.User.Login.class;
  }

  public Class&lt;? extends Pages.User&gt; register() {
    return Pages.User.Registration.class;
  }
}
</code></pre>
                </div>
Apart from JSF action methods, type-safe folder and page configurations can also be used outside of JSF,
for example, for type-safe navigation.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_view-config-resolver'> Usage of ViewConfigResolver </a>  illustrates how  <span class='latex-texttt'>IdeaImportServlet</span>  in  <span class='latex-textit'>IdeaFork</span> can benefit from this concept.
Compared to the previous implementation of this servlet, a  <span class='latex-texttt'>ViewConfigResolver</span>  can be injected.
Through the method  <span class='latex-texttt'>#getViewConfigDescriptor</span> , we can query the corresponding configuration including all metadata
using either a path as a string or a class of type  <span class='latex-texttt'>ViewConfig</span> .
In our case, we retrieve the configuration for  <span class='latex-texttt'>Pages.Import.Summary.class</span>  and
call the method  <span class='latex-texttt'>#getViewId</span>  on the resulting descriptor to obtain the path as a string.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_view-config-resolver'></a>                     <pre><code>@WebServlet("/idea/import")
@MultipartConfig
public class IdeaImportServlet extends HttpServlet {
  @Inject
  private ActiveUserHolder userHolder;

  @Inject
  private FileUploadService fileUploadService;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  protected void doPost(HttpServletRequest request,
                        HttpServletResponse response)
        throws ServletException, IOException {

    fileUploadService.storeUploadedFiles(
      request.getParts(), userHolder.getAuthenticatedUser());

    ViewConfigDescriptor viewConfigDescriptor =
      viewConfigResolver.getViewConfigDescriptor(
        Pages.Import.Summary.class);

    request.getRequestDispatcher(viewConfigDescriptor.getViewId())
      .forward(request, response);
  }
}
</code></pre>
                </div>
In future refactorings, we thus no longer need to manually update a fixed string.
Furthermore, modern Java IDEs simplify not only the refactoring itself,
but also the search for references to specific pages.
In the Git repository of  <span class='latex-textit'>IdeaFork</span> , all changes on this topic are summarized in one commit and
the entire application is thus converted to view configs.<br /> <div class="tip"><b>Tip: </b> Inherited metadata can be overridden or extended.
For example, it is possible to use  <span class='latex-texttt'>@View</span>  on a concrete page configuration
to customize the behavior for individual pages or to extend the inherited information with additional details. </div> The previously defined error page has not yet been explicitly used in  <span class='latex-textit'>IdeaFork</span> .
An obvious use case is the error handling of certain exceptions.
We already got to know DeltaSpike's exception handling concept in a brief example.
In the next step, we want to combine these and other mechanisms
to display the configured error page when unhandled exceptions of type  <span class='latex-texttt'>IllegalStateException</span>  occur.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:exception-handler_and_navigation'> Exception Handler with Navigation to DefaultErrorView </a> , unhandled exceptions of type
 <span class='latex-texttt'>IllegalStateException</span>  are marked as handled.
Additionally, in the request-scoped exception handler, the flag  <span class='latex-texttt'>exceptionDetected</span>  is set to  <span class='latex-texttt'>true</span>  in such a case.
The null check for the  <span class='latex-texttt'>FacesContext</span>  is required
because request-scoped CDI beans can also be activated outside of a JSF request.
Finally,  <span class='latex-texttt'>@Handles(ordinal = Integer.MIN_VALUE)</span>  ensures that the handler method is called at the end of the handler chain.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In a further step, the class  <span class='latex-texttt'>ErrorViewAwareExceptionHandler</span>  receives a CDI observer
with the qualifier  <span class='latex-texttt'>@BeforePhase(JsfPhaseId.RENDER_RESPONSE)</span>  for the event type  <span class='latex-texttt'>PhaseEvent</span> .
If the flag  <span class='latex-texttt'>exceptionDetected</span>  was set to  <span class='latex-texttt'>true</span>  in the current request,
then  <span class='latex-texttt'>ViewNavigationHandler#navigateTo</span>  in combination with a configuration class can be used
to navigate to a JSF page.
However, we do not want to navigate to a fixed page, but rather to the currently configured error page.
For this reason,  <span class='latex-texttt'>DefaultErrorView.class</span>  is passed as the argument.
Since DeltaSpike knows this marker, it searches behind the scenes for the page configuration that extends this marker class.
If such a page configuration exists,
the path represented by the configuration is used internally for the actual navigation.<br /> <div class="tip"><b>Tip: </b> DeltaSpike defines two qualifiers with  <span class='latex-texttt'>@BeforePhase</span>  and  <span class='latex-texttt'>@AfterPhase</span> ,
which can be used in combination with any phase of the JSF request lifecycle. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:exception-handler_and_navigation'></a>                     <pre><code>@RequestScoped
@ExceptionHandler
public class ErrorViewAwareExceptionHandler {
  private boolean exceptionDetected = false;

  public void onUnhandledException(
      @Handles(ordinal = Integer.MIN_VALUE)
      ExceptionEvent&lt;IllegalStateException&gt; exceptionEvent) {

    FacesContext facesContext = FacesContext.getCurrentInstance();

    if (facesContext == null) {
      return;
    }

    if (!exceptionEvent.isMarkedHandled()) {
      exceptionEvent.handled();
      exceptionDetected = true;
    }
  }

  protected void navigateOnDetectedException(
      @Observes @BeforePhase(JsfPhaseId.RENDER_RESPONSE)
      PhaseEvent phaseEvent,
      ViewNavigationHandler viewNavigationHandler) {

    if (exceptionDetected) {
      viewNavigationHandler.navigateTo(DefaultErrorView.class);
    }
  }
}
</code></pre>
                </div>
In addition to the metadata for view configs presented so far, the JSF module also integrates the  <span class='latex-texttt'>@Secured</span>  annotation
of DeltaSpike's Security module.
Fundamentally, this is a type of interceptor that can be used to annotate classes or individual methods.
This interceptor requires at least one implementation of  <span class='latex-texttt'>AccessDecisionVoter</span>  to be specified,
which is used to check access to the method being executed.
In combination with the View-Config concept, it is not a method call that is secured,
but rather the respectively configured directory or individual pages.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:protect_pages'> Securing Pages with @Secured </a> , an additional marker interface
named  <span class='latex-texttt'>SecuredPages</span>  is added to the view config of  <span class='latex-textit'>IdeaFork</span> .
 <span class='latex-texttt'>SecuredPages</span>  looks like a directory configuration.
In reality, however, it is an interface for collecting metadata.
Technically, this interface could also be defined separately.
In our case,  <span class='latex-texttt'>SecuredPages</span>  extends the Pages interface in order to inherit its metadata.
Additionally,  <span class='latex-texttt'>SecuredPages</span>  is annotated with the  <span class='latex-texttt'>@Secured</span>  annotation.
All directory configurations that extend  <span class='latex-texttt'>SecuredPages</span>  are secured by the  <span class='latex-texttt'>UserAwareAccessDecisionVoter</span> ,
since it is specified in  <span class='latex-texttt'>@Secured</span>  and accordingly inherited.
If classes for page configuration exist in such directories and
implement a directory configuration secured with  <span class='latex-texttt'>@Secured</span> ,
these page configurations also inherit the  <span class='latex-texttt'>@Secured</span>  definition according to the general view-config rule.
In these cases, not only access to the directory is checked,
but also to individual pages that are represented by view-config classes.
Listing  <a href='#!idx:/deltaspike.html:fig:protect_pages'> Securing Pages with @Secured </a>  illustrates through  <span class='latex-texttt'>Pages.User.Profil.class</span>
that individual pages can also be secured, even if they are not contained in a secured directory.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:protect_pages'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  class Index implements Pages {}

  @Secured(UserAwareAccessDecisionVoter.class)
  interface SecuredPages extends Pages {}

  interface User extends Pages {
    class Login extends DefaultErrorView {}

    class Registration implements User {}

    class Profile implements SecuredPages {}
  }

  interface Idea extends SecuredPages {
    class Overview implements Idea {}

    class Create implements Idea {}
    class Edit implements Idea {}

    class List implements Idea {}
    class Details implements Idea {}
  }

  interface Search extends SecuredPages {
    class Fork implements Search {}
  }

  interface Import extends SecuredPages {
    class Upload implements Import {}
    class Summary implements Import {}
  }
}
</code></pre>
                </div>
 <span class='latex-texttt'>SecuredPages</span>  can also be used through its indirect extension of  <span class='latex-texttt'>ViewConfig</span>  to restrict navigation targets.
Listing  <a href='#!idx:/deltaspike.html:fig:secured-pages_as_navigation-target'> SecuredPages as Navigation Target </a>  shows the  <span class='latex-texttt'>NavigationController</span>  of  <span class='latex-textit'>IdeaFork</span>  converted to view configs.
The method  <span class='latex-texttt'>#toUserProfile</span>  defines  <span class='latex-texttt'>Class&lt;? extends Pages.SecuredPages&gt;</span>  as its return type,
which means navigation can only go to pages in secured directories.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:secured-pages_as_navigation-target'></a>                     <pre><code>@Named
@ApplicationScoped
public class NavigationController {
  public Class&lt;? extends Pages.Idea&gt; toNewIdea() {
    return Pages.Idea.Create.class;
  }

  public Class&lt;? extends Pages.Idea&gt; toIdeaList() {
    return Pages.Idea.List.class;
  }

  public Class&lt;? extends Pages.Import&gt; toIdeaImport() {
    return Pages.Import.Upload.class;
  }

  public Class&lt;? extends Pages.SecuredPages&gt; toUserProfile() {
    return Pages.User.Profile.class;
  }
}
</code></pre>
                </div>
An  <span class='latex-texttt'>AccessDecisionVoter</span>  can either delegate to custom security logic like  <span class='latex-texttt'>UserAwareAccessDecisionVoter</span>  or
forward the verification to any security framework.
In Listing  <a href='#!idx:/deltaspike.html:fig:access-decision-voter_with_typesafe_messages'> AccessDecisionVoter with Type-Safe Messages </a> , we delegate to the  <span class='latex-texttt'>ActiveUserHolder</span>  bean of  <span class='latex-textit'>IdeaFork</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> When  <span class='latex-texttt'>@Secured</span>  is inherited by page configurations through a directory configuration,
then every  <span class='latex-texttt'>AccessDecisionVoter</span>  referenced by  <span class='latex-texttt'>@Secured</span>  is called multiple times.
The first call is performed for the page itself, and
then a separate call is made for each directory level that has inherited @Secured.
For each call, a manual bean lookup is performed with the specified  <span class='latex-texttt'>AccessDecisionVoter</span>  class.
For example, in the case of  <span class='latex-texttt'>Pages.Idea.Overview.class</span> , the method
 <span class='latex-texttt'>UserAwareAccessDecisionVoter#checkPermission</span>  is called on the found CDI bean for
 <span class='latex-texttt'>Pages.Idea.Overview.class</span>  and  <span class='latex-texttt'>Pages.Idea.class</span> .
The calls for access control of directories and pages differ only in the content of the metadata,
which can be accessed using the method  <span class='latex-texttt'>AccessDecisionVoterContext#getMetaData</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:access-decision-voter_with_typesafe_messages'></a>                     <pre><code>@RequestScoped
public class UserAwareAccessDecisionVoter
    extends AbstractAccessDecisionVoter {

  @Inject
  private ActiveUserHolder activeUserHolder;

  @Inject
  private UserMessage userMessage;

  @Override
  protected void checkPermission(
      AccessDecisionVoterContext accessDecisionVoterContext,
      Set&lt;SecurityViolation&gt; securityViolations) {

    if (!activeUserHolder.isLoggedIn()) {
      securityViolations.add(
        newSecurityViolation(userMessage.pleaseLogin()));
    }
  }
}
</code></pre>
                </div>
Listing  <a href='#!idx:/deltaspike.html:fig:access-decision-voter_with_typesafe_messages'> AccessDecisionVoter with Type-Safe Messages </a>  shows, in addition to a simple  <span class='latex-texttt'>AccessDecisionVoter</span>, the use of type-safe messages.
<div class="tip"><b>Tip: </b>The DeltaSpike security model with <span class='latex-texttt'>@Secured</span> and <span class='latex-texttt'>AccessDecisionVoter</span> is replaced in Quarkus by Jakarta Security with <span class='latex-texttt'>@RolesAllowed</span> and <span class='latex-texttt'>SecurityIdentity</span> (Chapter <a href='#!idx:/quarkus.html:10.6'>10.6</a>). On the client side, Angular route guards serve a similar role &mdash; but only as a UX improvement, not a security boundary (Chapter <a href='#!idx:/angular.html:11.6'>11.6</a>).</div>
 <span class='latex-texttt'>UserMessage</span>  is a custom interface annotated with  <span class='latex-texttt'>@MessageBundle</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_message'> Defining Type-Safe Messages </a>  shows an excerpt of  <span class='latex-texttt'>UserMessage</span> .
Each method defines a key that must be present in a resource bundle.
If the name of the resource bundle is not explicitly specified,
then the bundle name corresponds to the fully qualified name of the interface.
If the key name should be different, it can also be explicitly specified.
If the key is, for example,  <span class='latex-texttt'>please_login</span>  instead of  <span class='latex-texttt'>pleaseLogin</span> ,
then the method can be annotated with  <span class='latex-texttt'>@MessageTemplate("{please_login}")</span> .
Alternatively, texts can be specified directly as shown in Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_message'> Defining Type-Safe Messages </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_message'></a>                     <pre><code>@MessageBundle
public interface UserMessage {
    @MessageTemplate("Welcome %s!")
    String welcomeNewUser(String nickName);

    @MessageTemplate("Login failed!")
    String loginFailed();

    @MessageTemplate("Please login")
    String pleaseLogin();

    //...
}
</code></pre>
                </div>
The method  <span class='latex-texttt'>#welcomeNewUser</span>  additionally illustrates that message parameters can be populated using method parameters.
Any number of placeholders  <span class='latex-texttt'>("%s")</span>  are allowed in the message text,
which are replaced in order with the values passed to the method as arguments.
If a parameter type is not a String, the  <span class='latex-texttt'>#toString</span>  method is called.
This enables type-safe parameterization.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For JSF, there is also an extension of this concept, which is illustrated in Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_jsf-message'> Type-Safe JSF Messages </a> .
In contrast to the direct injection of  <span class='latex-texttt'>UserMessage</span>  and use of  <span class='latex-texttt'>#pleaseLogin</span>  from the previous example,
in this case an interface provided by the JSF module named  <span class='latex-texttt'>JsfMessage</span>  is injected,
which is typed to  <span class='latex-texttt'>UserMessage</span> .
This allows, through methods such as  <span class='latex-texttt'>#addInfo</span>  and  <span class='latex-texttt'>#addError</span> , the implicit creation of corresponding Faces messages.
In our example, the text for  <span class='latex-texttt'>#welcomeNewUser</span>  is displayed on the UI as an informational message.
In the background, DeltaSpike uses the locale that is active for the current JSF request, and
adds the created  <span class='latex-texttt'>FacesMessage</span>  instance to the current  <span class='latex-texttt'>FacesContext</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_jsf-message'></a>                     <pre><code>@ViewController
public class LoginViewCtrl {
  //...

  @Inject
  private JsfMessage&lt;UserMessage&gt; userMessage;

  public Class&lt;? extends Pages.Idea&gt; login() {
    userService.login(email, password);

    final Class&lt;? extends Pages.Idea&gt; navigationTarget;
    if (userHolder.isLoggedIn()) {
      userMessage.addInfo()
        .welcomeNewUser(
          userHolder.getAuthenticatedUser().getNickName());
      navigationTarget = Pages.Idea.Overview.class;
    } else {
      userMessage.addError().loginFailed();
      navigationTarget = null;
    }

    return navigationTarget;
  }

  //...
}
</code></pre>
                </div>
Type-safe messages can also be used in EL expressions.
For this, the interface annotated with  <span class='latex-texttt'>@MessageBundle</span>  must additionally be annotated with  <span class='latex-texttt'>@Named</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_messages_and_el'> EL Integration for Type-Safe Messages </a>  shows the corresponding part of  <span class='latex-texttt'>UserMessage</span> ,
which can be accessed with the EL expression  <span class='latex-texttt'>#{userMessage.warning()}</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_messages_and_el'></a>                     <pre><code>@Named
@MessageBundle
public interface UserMessage {
  //...

  @MessageTemplate("Warning!")
  String warning();
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> Interfaces annotated with  <span class='latex-texttt'>@MessageBundle</span>  can additionally be annotated with  <span class='latex-texttt'>@MessageContextConfig</span> .
With this annotation, it is possible to modify the default behavior through corresponding SPI implementations.
For example, custom locale logic can be implemented with a  <span class='latex-texttt'>LocaleResolver</span> , or
arbitrary message sources can be referenced, or a custom  <span class='latex-texttt'>MessageResolver</span>  can be integrated. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
JSF pages can be enhanced not only with type-safe messages.
 <span class='latex-texttt'>POST</span>  requests can also be made "safer" with a component called  <span class='latex-texttt'>preventDoubleSubmit</span> .
This component is available in the namespace  <span class='latex-texttt'>http://deltaspike.apache.org/jsf</span>  and
ensures that a  <span class='latex-texttt'>POST</span>  request cannot be sent multiple times.
For this, as shown in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_preventDoubleSubmit'> Using preventDoubleSubmit </a> , the component must be embedded in a JSF form.
In the background, a unique request token is used, which is verified on the server side.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_preventDoubleSubmit'></a>                     <pre><code>&lt;h:form&gt;
  &lt;!-- ... --&gt;
  &lt;ds:preventDoubleSubmit/&gt;
&lt;/h:form&gt;
</code></pre>
                </div><div class="tip"><b>Tip: </b> For Ajax requests via  <span class='latex-texttt'>POST</span> , JSF itself handles the corresponding management according to the specification.
Therefore, no request token verification is performed for such requests. </div>
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.6' ><span class='entry-number'>5.6</span> Improving Existing Concepts</a> </h2>
 DeltaSpike enriches CDI and Java EE in general.
Beyond that, it also improves existing concepts.
An example of this is the  <span class='latex-texttt'>@JsfPhaseListener</span>  annotation, which is used in Listing  <a href='#!idx:/deltaspike.html:fig:phase-listener_as_cdi-bean'> PhaseListener as CDI Bean </a> .
JSF Phase Listeners can be marked with this annotation to activate them automatically.
This eliminates the otherwise usual configuration in the  <span class='latex-texttt'>faces-config.xml</span>  file.
Optionally, a priority can be specified via  <span class='latex-texttt'>@JsfPhaseListener#ordinal</span> , and
other CDI beans can be injected into the phase listener.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:phase-listener_as_cdi-bean'></a>                     <pre><code>@JsfPhaseListener
public class DebugPhaseListener implements PhaseListener {
  //...
}
</code></pre>
                </div>
Furthermore,  <span class='latex-texttt'>@JsfPhaseListener</span>  can be combined with  <span class='latex-texttt'>@Exclude</span> .
The JSF Phase Listener shown in Listing  <a href='#!idx:/deltaspike.html:fig:conditional_activation_of_a_phase-listener'> Conditionally Activating a PhaseListener </a>  is only activated through the use of
 <span class='latex-texttt'>@Exclude(exceptIfProjectStage = ProjectStage.Development.class)</span>
when the value  <span class='latex-texttt'>Development</span>  is set for the project stage.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:conditional_activation_of_a_phase-listener'></a>                     <pre><code>@JsfPhaseListener
@Exclude(exceptIfProjectStage = ProjectStage.Development.class)
public class DebugPhaseListener implements PhaseListener {
  private static final Logger LOG =
    Logger.getLogger(DebugPhaseListener.class.getName());

  @Override
  public void beforePhase(PhaseEvent event) {
    LOG.info("before " + event.getPhaseId());
  }

  @Override
  public void afterPhase(PhaseEvent event) {
    LOG.info("after " + event.getPhaseId());
  }

  @Override
  public PhaseId getPhaseId() {
    return PhaseId.ANY_PHASE;
  }
}
</code></pre>
                </div> Window management, which can be optionally activated since JSF 2.2, is also improved.
The goal of this functionality is the correct handling of different browser windows/tabs,
since this is not supported by the session scope.
The abstract class  <span class='latex-texttt'>javax.faces.lifecycle.ClientWindow</span>  was defined based on experiences from frameworks like MyFaces CODI and
served as the template for the interface of the same name  <span class='latex-texttt'>org.apache.deltaspike.jsf.spi.scope.window.ClientWindow</span> ,
which can also be used with JSF 2.0 or 2.1.
Before JSF 2.2, for fully correct window management, the  <span class='latex-texttt'>windowId</span> component from the namespace  <span class='latex-texttt'>http://deltaspike.apache.org/jsf</span>  must be included in every page.
In  <span class='latex-textit'>IdeaFork</span> , we therefore add this component at the end of the template.
Listing  <a href='#!idx:/deltaspike.html:fig:activate_window-handling'> Activating Window Management </a>  shows the relevant excerpt from the  <span class='latex-texttt'>main-template.xhtml</span>  file.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:activate_window-handling'></a>                     <pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://java.sun.com/jsf/html"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:ds="http://deltaspike.apache.org/jsf"&gt;

&lt;!-- ... --&gt;

&lt;h:body&gt;
    &lt;!-- ... --&gt;
    &lt;ds:windowId/&gt;
&lt;/h:body&gt;
&lt;/html&gt;
</code></pre>
                </div> Since JSF 2.2, you can choose between the standard window management of the JSF implementation and that of DeltaSpike.
If the  <span class='latex-texttt'>ClientWindow</span>  functionality of JSF is explicitly activated via configuration,
then DeltaSpike uses the window ID that can be queried with  <span class='latex-texttt'>javax.faces.lifecycle.ClientWindow#getId</span>  and
automatically deactivates its own window management.
Otherwise, DeltaSpike handles the window management itself and
forwards the information internally via  <span class='latex-texttt'>javax.faces.lifecycle.Lifecycle#attachWindow</span>  to JSF,
which allows JSF implementations to perform some internal optimizations in managing the server-side component state.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The correct server-side association of browser windows/tabs is required
so that DeltaSpike can provide additional scopes.
The simplest of these scopes is the window scope,
since it is comparable to a session per browser window/tab.
DeltaSpike's JSF module activates the underlying window context before the JSF request lifecycle runs
via the method  <span class='latex-texttt'>org.apache.deltaspike.core.spi.scope.window.WindowContext#activateWindow</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:window-handling_via_window-context'> Window Management with WindowContext </a>  illustrates that the  <span class='latex-texttt'>WindowContext</span>  interface can also be used,
for example, to destroy window-scoped beans after a logout using the method  <span class='latex-texttt'>WindowContext#closeWindow</span> .
Afterwards, the window context for the current window can be reactivated via the method  <span class='latex-texttt'>WindowContext#activateWindow</span> .
For this, the previous window ID can be reused,
since it is no longer used after calling  <span class='latex-texttt'>WindowContext#closeWindow</span>  and
is therefore no worse than a newly generated ID.
The advantage here is that we do not need to worry about updating the client-side window ID.
Depending on which implementation of  <span class='latex-texttt'>ClientWindow</span>  is active, this could potentially be very complex.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:window-handling_via_window-context'></a>                     <pre><code>@Named("menuBean")
@Model //or just @RequestScoped, since @Named is overruled
public class MenuController {
  @Inject
  private WindowContext windowContext;

  //...

  public Class&lt;? extends ViewConfig&gt; logout() {
    resetWindowContext();
    userHolder.setAuthenticatedUser(null);
    return Pages.User.Login.class;
  }

  //...

  private void resetWindowContext() {
    String currentWindowId = windowContext.getCurrentWindowId();
    windowContext.closeWindow(currentWindowId);
    windowContext.activateWindow(currentWindowId);
  }
}
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span> , by activating window management, we must ensure
that the window ID is not lost during manual calls.
We have such a call, for example, in  <span class='latex-texttt'>IdeaImportServlet</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:explicit_window-handling'> Explicit Window Management </a>  illustrates how the window ID can be passed along manually.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:explicit_window-handling'></a>                     <pre><code>@WebServlet("/idea/import")
@MultipartConfig
public class IdeaImportServlet extends HttpServlet {
  @Inject
  private ActiveUserHolder userHolder;

  @Inject
  private FileUploadService fileUploadService;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  @Inject
  private WindowContext windowContext;

  protected void doPost(HttpServletRequest request,
                        HttpServletResponse response)
        throws ServletException, IOException {

    fileUploadService.storeUploadedFiles(
      request.getParts(), userHolder.getAuthenticatedUser());

    ViewConfigDescriptor viewConfigDescriptor = viewConfigResolver
      .getViewConfigDescriptor(Pages.Import.Summary.class);

    request.getRequestDispatcher(
      viewConfigDescriptor.getViewId() +
      "?dswid=" + request.getParameter("dswid"))
      .forward(request, response);
  }
}
</code></pre>
                </div> The same applies to our manual form on the  <span class='latex-texttt'>upload.xhtml</span>  page.
For manually defined forms and links, we must explicitly add the current window ID,
since neither DeltaSpike nor JSF itself can handle this, as is done with the equivalent JSF components.
In Listing  <a href='#!idx:/deltaspike.html:fig:window-id_in_el-expressions'> Window ID in EL Expressions </a> , the current window ID is added to the page markup using the EL expression
 <span class='latex-texttt'>#{dsWindowContext.currentWindowId}</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:window-id_in_el-expressions'></a>                     <pre><code>&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                template="/templates/main-template.xhtml"&gt;

  &lt;ui:define name="content-container"&gt;
    &lt;div class="panel panel-default"&gt;
      &lt;!-- ... --&gt;
      &lt;div class="panel-body"&gt;
        &lt;form method="post" enctype="multipart/form-data"
          action="#{jsf.contextPath}/idea/import?dswid=
                  #{dsWindowContext.currentWindowId}"&gt;
                 &lt;!-- ... --&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/ui:define&gt;
&lt;/ui:composition&gt;
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span> , we also have a self-created HTML link in a second place.
Listing  <a href='#!idx:/deltaspike.html:fig:window-id_with_html-links'> Window ID with HTML Links </a>  shows that we must also extend this with the current window ID
so that server-side window management works reliably.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:window-id_with_html-links'></a>                     <pre><code>&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:h="http://java.sun.com/jsf/html"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                template="/templates/main-template.xhtml"&gt;
  &lt;!-- ... --&gt;

  &lt;ui:define name="content"&gt;
    &lt;!-- ... --&gt;
    &lt;a href="#{jsf.contextPath}/public/idea/export/all?dswid=
        #{dsWindowContext.currentWindowId}" class="btn"&gt;
      &lt;span class="glyphicon glyphicon-import"/&gt; Export My Ideas
    &lt;/a&gt;

    &lt;!-- ... --&gt;
  &lt;/ui:define&gt;
&lt;/ui:composition&gt;
</code></pre>
                </div><div class="tip"><b>Tip: </b> The explicit specification of the window ID can be omitted when JSF components are used instead of HTML tags.
If this is intentionally not done,
then, for example, a JSF command component must be embedded in the DeltaSpike component  <span class='latex-texttt'>disableClientWindow</span> .
The rendered link or button will then not receive a window ID. </div> Which beans the window scope makes sense for depends heavily on the specific requirements.
In  <span class='latex-textit'>IdeaFork</span> , we can introduce an additional concept to illustrate a possible use case.
So far, navigations to the previous page were also defined statically.
We can implement this generically by introducing a  <span class='latex-texttt'>BackNavigator</span>
that records the navigation history per browser window/tab on the server side.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_WindowScope_and_PreViewConfigNavigateEvent'> Using @WindowScoped and PreViewConfigNavigateEvent </a>  shows a first version of  <span class='latex-texttt'>BackNavigator</span> ,
which is annotated with  <span class='latex-texttt'>@WindowScoped</span> .
This allows us to store the navigation history per browser window/tab using a CDI observer for the  <span class='latex-texttt'>PreViewConfigNavigateEvent</span>  event.
DeltaSpike fires this event for every JSF navigation for which a type-safe view config is used.
In  <span class='latex-textit'>IdeaFork</span> , there is already a type-safe configuration for every JSF page,
which means we can use this event to implement the use case without any issues.
Through this event, the navigation target can even be changed in the observer method.
In the method  <span class='latex-texttt'>BackNavigator#onNavigation</span> , no change is required,
since this method only needs to record the navigation history.
Since we do not have an explicit back button on every page, we can limit the recorded navigation history to,
for example, 10 entries to avoid a memory leak.
A little later, we will replace this hard-coded maximum value with a more elegant concept.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The  <span class='latex-texttt'>BackNavigator</span>  class additionally contains a second observer method named  <span class='latex-texttt'>#onFacesRequestEnd</span> ,
which is called before the  <span class='latex-texttt'>FacesContext</span>  is destroyed at the end of a request.
This is made possible by the qualifier  <span class='latex-texttt'>org.apache.deltaspike.core.api.lifecycle.Destroyed</span> ,
which is used here in combination with  <span class='latex-texttt'>FacesContext</span>  as the event type.
Such an observer method is a simple alternative to a  <span class='latex-texttt'>@PreDestroy</span>  callback of a request-scoped bean and
additionally offers the advantage that the current  <span class='latex-texttt'>FacesContext</span>  can still be accessed if needed.
In our case, we reset the  <span class='latex-texttt'>backNavigationActive</span>  flag,
since it could otherwise still have the old state on a subsequent request.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_WindowScope_and_PreViewConfigNavigateEvent'></a>                     <pre><code>@Named
@WindowScoped
public class BackNavigator implements Serializable {
  private Stack&lt;Class&lt;? extends ViewConfig&gt;&gt; previousViewStack =
    new Stack&lt;Class&lt;? extends ViewConfig&gt;&gt;();

  private boolean backNavigationActive;

  public Class&lt;? extends ViewConfig&gt; toPreviousView() {
    backNavigationActive = true;
    return previousViewStack.pop();
  }

  protected void onNavigation(
      @Observes PreViewConfigNavigateEvent navigateEvent) {

    Class&lt;? extends ViewConfig&gt; previousView =
      navigateEvent.getFromView();

    if (previousView != null && !this.backNavigationActive &&
       (previousViewStack.isEmpty() ||
        !previousViewStack.peek().equals(previousView))) {

      previousViewStack.push(previousView);

      if (previousViewStack.size() &gt; 10) {
        previousViewStack.remove(0);
      }
    }
  }

  protected void onFacesRequestEnd(
      @Observes(notifyObserver = IF_EXISTS) @Destroyed
      FacesContext facesContext) {

    this.backNavigationActive = false;
  }
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> The observer method  <span class='latex-texttt'>#onFacesRequestEnd</span>  itself is only called when  <span class='latex-texttt'>BackNavigator</span>  has already been used.
This is only necessary because  <span class='latex-texttt'>BackNavigator</span>  is stored in the window context and
this context does not need to be active during the first request in a browser window/tab.
The reason for this is purely technical. Depending on the configured mode for window management, it is possible
that an initial request is aborted by a redirect to the same URL
so that the newly generated window ID can be added to the requested URL.
This is required, for example, to prevent losing the window ID when refreshing a page in the browser. </div> In JSF pages, this mechanism can be used with the EL expression  <span class='latex-texttt'>#{backNavigator.toPreviousView}</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_BackNavigator'> Using BackNavigator </a>  shows a corresponding button
that is used in  <span class='latex-textit'>IdeaFork</span>  on the  <span class='latex-texttt'>profile.xhtml</span>  page.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_BackNavigator'></a>                     <pre><code>&lt;h:commandButton class="btn btn-default" value="Back"
                 action="#{backNavigator.toPreviousView}"/&gt;
</code></pre>
                </div><div class="tip"><b>Tip: </b> The window context stores beans grouped by window ID in the current session.
Thus, window-scoped beans are also replicated when session replication is performed in a cluster.
Consequently, window-scoped beans are also automatically destroyed when a session is closed. </div> An even more convenient alternative to  <span class='latex-texttt'>@WindowScoped</span>  is a scope
that is based on the window scope and enables more efficient memory usage.
This is the so-called View-Access Scope.
In short,  <span class='latex-texttt'>@ViewAccessScoped</span>  beans exist for a JSF page once they are accessed and
are only disposed of when they are no longer accessed after a JSF navigation to another page.
This is very similar to JSF's own view scope.
The main difference is
that view-access-scoped beans are not destroyed by navigation to another page before the rendering process.
Only when the bean is no longer accessed during the rendering of the new page is that contextual instance destroyed.
Thus, each instance stored in this context can have its own lifetime.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> If, for example, a  <span class='latex-texttt'>@ViewAccessScoped</span>  bean is used as a wizard controller in a wizard and
thus accessed at each wizard step, the  <span class='latex-texttt'>@ViewAccessScoped</span>  bean is available for the entire wizard and
is automatically disposed of by DeltaSpike once the wizard is completed and the subsequent page no longer uses the wizard controller.
In the background, the view-access context collects the contextual instances in a  <span class='latex-texttt'>@WindowScoped</span>  bean.
For this reason,  <span class='latex-texttt'>@ViewAccessScoped</span>  beans are by definition managed per browser window/tab, and
once the session or the window context is terminated, all  <span class='latex-texttt'>@ViewAccessScoped</span>  beans are also destroyed.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div class="tip"><b>Tip: </b><b>@ViewAccessScoped lifecycle in detail:</b> A <span class='latex-texttt'>@ViewAccessScoped</span> bean instance is created on first access within a JSF page and remains active as long as subsequent requests reference the same bean. When navigating to a new page that no longer uses this bean, the instance is destroyed after rendering the new page. This enables cross-page workflows (e.g., master-detail navigation) without burdening the entire session. In Quarkus there is no direct equivalent &mdash; the client-side alternative in Angular is described in Chapter <a href='#!idx:/angular.html:11.4'>11.4</a>.</div>
In the previous step, we already ensured in the page template of  <span class='latex-textit'>IdeaFork</span>  with the  <span class='latex-texttt'>windowId</span>  component
that window management is fully activated.
Therefore, we can switch the view-controller beans in  <span class='latex-textit'>IdeaFork</span>  to the view-access scope without further preparation.
For this, we modify the  <span class='latex-texttt'>@ViewController</span>  stereotype annotation.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ViewAccessScoped'> Using @ViewAccessScoped </a>  shows the new implementation of this annotation,
in which we use the  <span class='latex-texttt'>@ViewAccessScoped</span>  annotation instead of  <span class='latex-texttt'>@RequestScoped</span> .
Since the view-access scope is passivatable like the session scope, we must, according to the CDI rules
that we learned in Chapter  <a href='#!idx:/cdi_basics.html:chap:cdi-basics'>  CDI Basic Concepts </a> ,
annotate all  <span class='latex-texttt'>@ViewController</span>  beans with the marker interface  <span class='latex-texttt'>java.io.Serializable</span> .
Furthermore, in  <span class='latex-textit'>IdeaFork</span>  we have previously modified some  <span class='latex-texttt'>@ViewController</span>  beans
by explicitly defining them as  <span class='latex-texttt'>@SessionScoped</span>  beans.
This is no longer necessary, since we initially only wanted to slightly extend the lifetime of these view controllers.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ViewAccessScoped'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Stereotype

@ViewAccessScoped
@Named
public @interface ViewController {
}
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span> , we have so far used two listeners for the  <span class='latex-texttt'>PreRenderView</span>  event of JSF,
which are included in the pages  <span class='latex-texttt'>index.xhtml</span>  and  <span class='latex-texttt'>list.xhtml</span>  using the  <span class='latex-texttt'>f:event</span>  tag.
As a type-safe alternative, DeltaSpike's  <span class='latex-texttt'>@PreRenderView</span>  annotation can be used for such callback methods.
Since there are normally multiple view controllers in an application, a connection between a page and
the responsible view controller must be defined.
For this, DeltaSpike's  <span class='latex-texttt'>@ViewControllerRef</span>  annotation can be used, for example.
It is natural that the view controller configuration is also done in the application's view config.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ViewControllerRef'> Using @ViewControllerRef </a>  shows a correspondingly extended excerpt of the view config of  <span class='latex-textit'>IdeaFork</span> .
The view controller class is referenced as the value.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ViewControllerRef'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  @ViewControllerRef(IndexViewCtrl.class)
  class Index implements Pages {}

  //...

  interface Idea extends SecuredPages {
    //...

    @ViewControllerRef(IdeaListViewCtrl.class)
    class List implements Idea {}
  }

  //...
}
</code></pre>
                </div> This configuration enables type-safe callback methods in the specified CDI bean.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_PreRenderView'> Using @PreRenderView </a>  shows, as a representative example, the implementation in  <span class='latex-texttt'>IdeaListViewCtrl</span> ,
where the method  <span class='latex-texttt'>#onPreRenderView</span>  is annotated with  <span class='latex-texttt'>@PreRenderView</span> .
This allows the corresponding  <span class='latex-texttt'>f:event</span>  tag to be removed from the JSF page.
In the case of  <span class='latex-texttt'>@PreRenderView</span> , at runtime before the rendering process, it is checked whether there is a view config for the page to be rendered
that is annotated with  <span class='latex-texttt'>@ViewControllerRef</span> .
If so, the method annotated with  <span class='latex-texttt'>@PreRenderView</span>  is called, provided one exists.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_PreRenderView'></a>                     <pre><code>@ViewController
public class IdeaListViewCtrl implements Serializable {
  @Inject
  private IdeaService ideaService;

  @Inject
  private ActiveUserHolder userHolder;

  private List&lt;Idea&gt; ideaList;

  @PreRenderView
  public void onPreRenderView() {
    ideaList = ideaService.loadAllOfAuthor(
      userHolder.getAuthenticatedUser());
  }
  //...
}
</code></pre>
                </div><div class="tip"><b>Tip: </b><span class='latex-texttt'>@PreRenderView</span>  is the most commonly used view-controller annotation.
Additionally, there are the view-controller annotations  <span class='latex-texttt'>@InitView</span> ,  <span class='latex-texttt'>@PreViewAction</span>  and  <span class='latex-texttt'>@PostRenderView</span> .
 <span class='latex-texttt'>@InitView</span>  callback methods are called before or after a JSF request lifecycle phase
when the view ID is set or when the value of the view ID has changed.
 <span class='latex-texttt'>@PreViewAction</span>  callback methods are executed before an action method,
where the subsequent action method is independent of the configured callback method.
 <span class='latex-texttt'>@PostRenderView</span>  callback methods are called once the rendering process of the associated page is finished.
This allows, for example, resources to be released without increasing the latency from the browser's perspective. </div> So far, we have learned about several aspects of the view-config concept that can be used directly without additional effort.
Beyond that, DeltaSpike allows defining custom view-config metadata to implement custom concepts.
Custom metadata is created in the same way as the metadata already provided by DeltaSpike itself.
The only difference lies in the evaluation. While DeltaSpike evaluates the provided annotations and
contains the corresponding implementations, self-defined metadata is added to the metadata model based on the same rules,
which can then be queried.
Since it is custom metadata, the corresponding logic must of course be implemented
to utilize the stored metadata by invoking the appropriate functionality.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span> , we can, for example, create a custom annotation called  <span class='latex-texttt'>@EntryPoint</span> .
In doing so, the standard Java rules for annotations must be followed.
As shown in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ViewMetaData'> Using @ViewMetaData </a> , the  <span class='latex-texttt'>@EntryPoint</span>  annotation must additionally be marked with the  <span class='latex-texttt'>@ViewMetaData</span>  annotation
so that DeltaSpike creates a corresponding entry in the  <span class='latex-texttt'>ViewConfig</span>  metadata model.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ViewMetaData'></a>                     <pre><code>@Target({TYPE})
@Retention(RUNTIME)
@Documented

@ViewMetaData
public @interface EntryPoint {
}
</code></pre>
                </div> As mentioned before, it is not enough to simply create an annotation.
Additionally, the associated functionality must be implemented.
The  <span class='latex-texttt'>@EntryPoint</span>  annotation is intended in  <span class='latex-textit'>IdeaFork</span>  to mark all pages
that are self-contained.
Therefore, certain accumulated data can be reset whenever navigation leads to such pages.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_custom_view-metadata'> Using Custom View Metadata </a>  shows an excerpt of the view config of  <span class='latex-textit'>IdeaFork</span> where some page configurations have been extended with the  <span class='latex-texttt'>@EntryPoint</span>  annotation.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_custom_view-metadata'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  @ViewControllerRef(IndexViewCtrl.class)
  class Index implements Pages {}

  @Secured(UserAwareAccessDecisionVoter.class)
  interface SecuredPages extends Pages {}

  interface User extends Pages {
    @EntryPoint
    class Login extends DefaultErrorView {}

    @EntryPoint
    class Registration implements User {}

    class Profile implements SecuredPages {}
  }

  interface Idea extends SecuredPages {
    @EntryPoint
    class Overview implements Idea {}

    class Create implements Idea {}
    class Edit implements Idea {}

    @ViewControllerRef(IdeaListViewCtrl.class)
    class List implements Idea {}
    class Details implements Idea {}
  }

  //...
}
</code></pre>
                </div> The existing implementation of  <span class='latex-texttt'>BackNavigator</span>  can use this new marker annotation to reset the navigation history
instead of defining an upper limit for navigation history entries.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_EntryPointNavigationEvent'> Using EntryPointNavigationEvent </a>  shows an excerpt from the extended  <span class='latex-texttt'>BackNavigator</span> .
In the method  <span class='latex-texttt'>#onNavigation</span> , the check for the hard-coded upper limit is omitted.
As compensation, there is an observer method for the newly created (marker) event  <span class='latex-texttt'>EntryPointNavigationEvent</span> ,
in which the existing navigation history is reset and then the current page is added.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_EntryPointNavigationEvent'></a>                     <pre><code>@Named
@WindowScoped
public class BackNavigator implements Serializable {
  //...

  protected void onNavigation(
      @Observes PreViewConfigNavigateEvent navigateEvent) {

    Class&lt;? extends ViewConfig&gt; previousView =
      navigateEvent.getFromView();

    if (previousView != null && !this.backNavigationActive &&
       (previousViewStack.isEmpty() ||
        !previousViewStack.peek().equals(previousView))) {

      previousViewStack.push(previousView);
    }
  }

  protected void onEntryPointNavigation(
      @Observes EntryPointNavigationEvent entryPointNavigationEvent) {

    this.previousViewStack.clear();
    this.previousViewStack.push(entryPointNavigationEvent.getView());
  }

  //...
}
</code></pre>
                </div> Since  <span class='latex-texttt'>EntryPointNavigationEvent</span>  is also a custom event,
it must be created when navigating to a page marked with  <span class='latex-texttt'>@EntryPoint</span> .
Therefore, we create a class named  <span class='latex-texttt'>EntryPointHandler</span>  in  <span class='latex-textit'>IdeaFork</span> ,
which contains the observer method  <span class='latex-texttt'>#checkEntryPoints</span>  shown in Listing  <a href='#!idx:/deltaspike.html:fig:assessments_of_custom_view-metadata'> Evaluating Custom View Metadata </a> .
 <span class='latex-texttt'>EntryPointNavigationEvent</span>  is fired as usual via the injected  <span class='latex-texttt'>javax.enterprise.event.Event</span>  interface.
In order for this event to be fired at all,
it must be checked whether the page configuration is marked with  <span class='latex-texttt'>@EntryPoint</span> .
For such evaluations, DeltaSpike provides the injectable  <span class='latex-texttt'>ViewConfigResolver</span>  interface.
The current view ID can be passed to the method  <span class='latex-texttt'>#getViewConfigDescriptor</span> ,
which is contained in the current  <span class='latex-texttt'>FacesContext</span>  or the current view root.
If a view-config entry exists, the method  <span class='latex-texttt'>ViewConfigDescriptor#getMetaData</span>  can be used to check
whether the  <span class='latex-texttt'>@EntryPoint</span>  annotation is stored in the  <span class='latex-texttt'>ViewConfigDescriptor</span>  for this page.
Since we do not want to fire this event when the current request comes from the same entry-point page,
we can remember the view-config class from the last entry point.
Therefore, it makes sense to let  <span class='latex-texttt'>EntryPointHandler</span>  be managed by the window context,
which is why we annotate the class with  <span class='latex-texttt'>@WindowScoped</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:assessments_of_custom_view-metadata'></a>                     <pre><code>@WindowScoped
public class EntryPointHandler implements Serializable {
  private Class&lt;? extends ViewConfig&gt; previousEntryPoint;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  @Inject
  private Event&lt;EntryPointNavigationEvent&gt; entryPointEvent;

  protected void checkEntryPoints(
      @Observes @BeforePhase(JsfPhaseId.RENDER_RESPONSE)
      PhaseEvent phaseEvent) {

    UIViewRoot viewRoot = phaseEvent.getFacesContext().getViewRoot();

    if (viewRoot == null) {
      return;
    }
    String viewIdToRender = viewRoot.getViewId();
    ViewConfigDescriptor viewConfigDescriptor =
      viewConfigResolver.getViewConfigDescriptor(viewIdToRender);

    if (viewConfigDescriptor == null) {
      return;
    }

    if (viewConfigDescriptor.getConfigClass()
        .equals(this.previousEntryPoint)) {

      return;
    }

    if (!viewConfigDescriptor
        .getMetaData(EntryPoint.class).isEmpty()) {

      this.previousEntryPoint =
        viewConfigDescriptor.getConfigClass();

      this.entryPointEvent.fire(
        new EntryPointNavigationEvent(
          viewConfigDescriptor.getConfigClass()));
    }
  }
}
</code></pre>
                </div> However, custom metadata is not always required to make adjustments.
If, for example, only the name of a directory or
a file should be changed, this can be done directly using  <span class='latex-texttt'>@Folder</span>  or  <span class='latex-texttt'>@View</span> .
To use additional DeltaSpike functionality, we create a wizard with which users can promote their own ideas.
For this purpose, a  <span class='latex-texttt'>PromotionRequest</span>  should be created.
Promotion requests can be searched for and promoted by other users.
Promoted ideas should then be visible on the start page for all users.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The wizard for creating a promotion request should consist of the pages
 <span class='latex-texttt'>pages/promotion/step1.xhtml</span> ,  <span class='latex-texttt'>pages/promotion/step2.xhtml</span>  and  <span class='latex-texttt'>pages/promotion/summary.xhtml</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:custom_naming'> Explicit Name Assignment </a>  illustrates the customization of directory and file names.
The configuration interface for the wizard's directory is called  <span class='latex-texttt'>PromotionWizard</span> .
The path for this directory is, however,  <span class='latex-texttt'>pages/promotion/</span>  instead of  <span class='latex-texttt'>pages/promotionWizard</span> ,
since the interface is annotated with  <span class='latex-texttt'>@Folder(name = "promotion")</span> .
The configuration class for the last page of the wizard is called
 <span class='latex-texttt'>Pages.PromotionWizard.FinalStep.class</span>  in Listing  <a href='#!idx:/deltaspike.html:fig:custom_naming'> Explicit Name Assignment </a>  and
is annotated with  <span class='latex-texttt'>@View(name = "summary")</span> ,
which also adjusts the path for this page to  <span class='latex-texttt'>pages/promotion/summary.xhtml</span> .
 <span class='latex-texttt'>Pages.PromotionWizard.FinalStep.class</span>  implements the  <span class='latex-texttt'>PromotionWizard</span>  interface,
which extends  <span class='latex-texttt'>SecuredPages</span> .
Since  <span class='latex-texttt'>SecuredPages</span>  itself extends the Pages interface,  <span class='latex-texttt'>FinalStep</span>  inherits the metadata from Pages through this inheritance hierarchy
in this case.
 <span class='latex-texttt'>@View(navigation = REDIRECT)</span>  is, however, not overridden by  <span class='latex-texttt'>@View(name = "summary")</span> ;
instead, DeltaSpike automatically merges the information together,
resulting at runtime in  <span class='latex-texttt'>@View(name = "summary", navigation = REDIRECT)</span> .
However, information is only merged when a value is not explicitly specified.
If we annotated  <span class='latex-texttt'>FinalStep</span>  with  <span class='latex-texttt'>@View(name = "summary", navigation = FORWARD)</span> ,
then we would override the navigation mode that was originally defined by the  <span class='latex-texttt'>Pages</span>  interface.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_naming'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Secured(UserAwareAccessDecisionVoter.class)
  interface SecuredPages extends Pages {}

  @Folder(name = "promotion")
  interface PromotionWizard extends SecuredPages {
    @EntryPoint
    @ViewControllerRef(PromotionWizardCtrl.class)
    class Step1 implements PromotionWizard {}

    class Step2 implements PromotionWizard {}

    @View(name = "summary")
    class FinalStep implements PromotionWizard {}
  }
}
</code></pre>
                </div> If needed, a completely custom naming convention can even be introduced.
 <span class='latex-texttt'>JsfBaseConfig</span>  defines, among some other configuration options, also options for default  <span class='latex-texttt'>NameBuilder</span> s
such as  <span class='latex-texttt'>JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER</span> .
The underlying configuration key is  <span class='latex-texttt'>org.apache.deltaspike.jsf.api.config.view.Folder$DefaultFolderNameBuilder</span>  and
enables a custom implementation of  <span class='latex-texttt'>org.apache.deltaspike.jsf.api.config.view.Folder$NameBuilder</span>
that can be activated via the previously introduced DeltaSpike configuration mechanism and used for the entire application.
Alternatively, the naming can be customized for a part of the view config.
For directories, this is possible through  <span class='latex-texttt'>@Folder#folderNameBuilder</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:change_single_paths'> Changing Individual Paths </a>  shows how the view config of  <span class='latex-textit'>IdeaFork</span>  can be extended for the second new area
when the view-config structure should not correspond to the actual directory structure in the application.
The interface  <span class='latex-texttt'>PromotionSelectionArea</span>  is annotated with
 <span class='latex-texttt'>@Folder(folderNameBuilder = PromotionSelectionArea.CustomFolderNameBuilder.class)</span>
to change the naming convention for this directory configuration.
Our goal is to place JSF pages in the directory  <span class='latex-texttt'>/pages/promotion/selection</span> .
However, the directory configuration is represented in Listing  <a href='#!idx:/deltaspike.html:fig:change_single_paths'> Changing Individual Paths </a>  by
 <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:change_single_paths'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(folderNameBuilder =
    PromotionSelectionArea.CustomFolderNameBuilder.class)
  interface PromotionSelectionArea extends SecuredPages {
    //...

    class CustomFolderNameBuilder
        extends Folder.DefaultFolderNameBuilder {

      //...
    }
  }
}
</code></pre>
                </div><span class='latex-texttt'>CustomFolderNameBuilder</span>  in Listing  <a href='#!idx:/deltaspike.html:fig:custom_folder-name-builder'> Custom Folder NameBuilder </a>  represents the simplest approach
for changing a single directory.
Before DeltaSpike stores the final definitions of a view config as an immutable  <span class='latex-texttt'>ViewConfigDescriptor</span> ,
the view config is available as a mutable node structure, where ViewConfigNode is the type of a node.
We will look at how view-config metadata can be modified a little later.
Since we only want to change the path of a directory,
it is sufficient to compare the class  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span>  with the result of the method  <span class='latex-texttt'>ViewConfigNode#getSource</span> .
If the source is the class in question, the flag  <span class='latex-texttt'>customPathUsed</span>  is set to  <span class='latex-texttt'>true</span>
so that the method  <span class='latex-texttt'>#isDefaultValueReplaced</span>  can provide this information later.
Additionally, the string  <span class='latex-texttt'>"/pages/promotion/selection"</span>  is returned.
The generation of the remaining directory names is delegated to  <span class='latex-texttt'>DefaultFolderNameBuilder</span> ,
so the result for the other directory configurations does not change.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_folder-name-builder'></a>                     <pre><code>class CustomFolderNameBuilder extends Folder.DefaultFolderNameBuilder {
  private boolean customPathUsed = false;

  @Override
  public String build(Folder folder, ViewConfigNode viewConfigNode) {
    if (Pages.PromotionSelectionArea.class
        .equals(viewConfigNode.getSource())) {

      this.customPathUsed = true;
      return "/pages/promotion/selection";
    }
    return super.build(folder, viewConfigNode);
  }

  @Override
  public boolean isDefaultValueReplaced() {
    return super.isDefaultValueReplaced() || this.customPathUsed;
  }
}
</code></pre>
                </div> Typically, custom  <span class='latex-texttt'>NameBuilder</span>  implementations define custom naming conventions rather than replacing just individual names.
Such  <span class='latex-texttt'>NameBuilder</span>  implementations are activated globally, as mentioned earlier.
An implementation like that in Listing  <a href='#!idx:/deltaspike.html:fig:combine_customized_names'> Combining Customized Names </a>  can, however, be useful
when an application does not yet follow a uniform naming convention and
a corresponding migration is only being performed step by step.
 <span class='latex-texttt'>NameBuilder</span>  implementations can be customized not only for directories but also for files.
Name builders for directories and files are independent of each other, and
therefore the view config can be extended with  <span class='latex-texttt'>@View</span>  as in Listing  <a href='#!idx:/deltaspike.html:fig:combine_customized_names'> Combining Customized Names </a>
to additionally specify the file names explicitly.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:combine_customized_names'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(folderNameBuilder =
    PromotionSelectionArea.CustomFolderNameBuilder.class)
  interface PromotionSelectionArea extends SecuredPages {

    @View(name = "list")
    @ViewControllerRef(PromotionRequestListViewCtrl.class)
    class ListPromotions implements PromotionSelectionArea {}

    @View(name = "promote")
    class SelectPromotion implements PromotionSelectionArea {}

    //...
  }
}
</code></pre>
                </div> Since JSF 2.0, JSF actions are also possible via GET requests.
To automatically include request parameters, the marker  <span class='latex-texttt'>"includeViewParams=true"</span>  can be added to the navigation string.
For this,  <span class='latex-texttt'>@View</span>  also provides a type-safe configuration,
which can be seen in Listing  <a href='#!idx:/deltaspike.html:fig:navigation_parameters_via_view-config'> Navigation Parameters via View-Config </a> .
Parameters can also be specified at the view-config level by using  <span class='latex-texttt'>@NavigationParameter</span> .
The parameter value can be either a fixed string or an EL expression.
As an alternative, action methods can be annotated with  <span class='latex-texttt'>@NavigationParameter</span>  or  <span class='latex-texttt'>@NavigationParameter.List</span>
to restrict parameters to specific action methods.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:navigation_parameters_via_view-config'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(folderNameBuilder =
    PromotionSelectionArea.CustomFolderNameBuilder.class)
  interface PromotionSelectionArea extends SecuredPages {

    @View(name = "list", viewParams = INCLUDE)
    @NavigationParameter(key = "searchHint", value = "*")
    @ViewControllerRef(PromotionRequestListViewCtrl.class)
    class ListPromotions implements PromotionSelectionArea {}

    @View(name = "promote")
    class SelectPromotion implements PromotionSelectionArea {}

    //...
  }
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> If parameters should be added dynamically, we would need to inject  <span class='latex-texttt'>NavigationParameterContext</span> , for example,
into a view controller and dynamically call its methods. </div> After successfully customizing individual path specifications, let us take a closer look at the controllers of the two new areas.
In the view config for the new wizard, we defined a view controller for  <span class='latex-texttt'>Pages.PromotionWizard.Step1.class</span> .
The wizard should be continuously controlled by a controller named  <span class='latex-texttt'>PromotionWizardCtrl</span> .
The previously introduced view-access scope is well suited for this.
However, in our case, we want to explicitly define the controller's lifetime.
At the end of the wizard, the controller instance should be immediately destroyed.
If this were the only requirement, we could use CDI's own conversation scope.
However, it has some limitations and
in the worst case, unexpected  <span class='latex-texttt'>BusyConversationException</span>  errors can even occur with Ajax requests.
For these and other reasons, a custom conversation concept was implemented in DeltaSpike,
which, just like  <span class='latex-texttt'>@WindowScoped</span>  and  <span class='latex-texttt'>@ViewAccessScoped</span> , was adopted from MyFaces CODI.
In DeltaSpike, however, the annotation name was renamed, and
thus CODI conversations are available in DeltaSpike under the name grouped conversations.
Accordingly, the corresponding annotation is called  <span class='latex-texttt'>@GroupedConversationScoped</span>  and
is used for  <span class='latex-texttt'>PromotionWizardCtrl</span>  in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_grouped-conversations'> Using Grouped Conversations </a> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Grouped conversations differ in several aspects from standard CDI conversations.
Each bean exists in a separate conversation that does not need to be explicitly started.
In contrast, the CDI conversation scope has only one large conversation that must be explicitly started.
The excerpt of  <span class='latex-texttt'>PromotionWizardCtrl</span> shown in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_grouped-conversations'> Using Grouped Conversations </a> additionally shows how the bean's current grouped conversation can be terminated.
 <span class='latex-texttt'>GroupedConversation</span>  provides only the method  <span class='latex-texttt'>#close</span> ,
which in our case immediately removes the current instance of  <span class='latex-texttt'>PromotionWizardCtrl</span>  from the grouped-conversation context.
The current instance then only exists for the remaining execution time of the method in which
 <span class='latex-texttt'>GroupedConversation#close</span>  was called.
For the next (external) method call, a new instance of the class is created and stored in the grouped-conversation context.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_grouped-conversations'></a>                     <pre><code>@Named
@GroupedConversationScoped
public class PromotionWizardCtrl implements Serializable {
    @Inject
    private GroupedConversation conversation;

    //...

    public Class&lt;? extends Pages&gt; savePromotionRequest() {
        this.ideaService.requestIdeaPromotion(this.promotionRequest);
        this.conversation.close();
        return Pages.Index.class;
    }
}
</code></pre>
                </div> Since by default every  <span class='latex-texttt'>@GroupedConversationScoped</span>  bean is stored in an isolated conversation,
there can be multiple parallel and independent conversations.
If it becomes necessary to terminate all active grouped conversations,
 <span class='latex-texttt'>GroupedConversationManager</span>  can be used.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_GroupedConversationManager'> Using GroupedConversationManager </a>  shows a possible extension of  <span class='latex-texttt'>EntryPointHandler</span>
to close all grouped conversations at every entry-point page.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_GroupedConversationManager'></a>                     <pre><code>@WindowScoped
public class EntryPointHandler implements Serializable {
  private Class&lt;? extends ViewConfig&gt; previousEntryPoint;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  @Inject
  private GroupedConversationManager conversationManager;

  @Inject
  private Event&lt;EntryPointNavigationEvent&gt; entryPointEvent;

  protected void checkEntryPoints(
      @Observes @BeforePhase(JsfPhaseId.RENDER_RESPONSE)
      PhaseEvent phaseEvent) {

    //...

    if (!viewConfigDescriptor.getMetaData(EntryPoint.class).isEmpty()) {
      this.previousEntryPoint = viewConfigDescriptor.getConfigClass();
      this.conversationManager.closeConversations();
      this.entryPointEvent.fire(
        new EntryPointNavigationEvent(
          viewConfigDescriptor.getConfigClass()));
    }
  }
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> If a bean is not destroyed by an explicit method call,
then this occurs once the window context or the underlying session is closed. </div> In the new page area defined by  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span> ,
instead of using one controller for all pages, each page should have its own.
When an idea is promoted on the page  <span class='latex-texttt'>/pages/promotion/selection/promote.xhtml</span> ,
not all (grouped) conversations should be terminated, nor just the controller of this page.
Therefore, we can define a group for all controller beans in the page area  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span> ,
allowing all beans of a group to be terminated collectively.
Should there be other active  <span class='latex-texttt'>@GroupedConversationScoped</span>  beans
that are assigned to a different group, they remain active.
Listing  <a href='#!idx:/deltaspike.html:fig:explicit_grouping_of_conversations'> Explicit Grouping of Conversations </a>  shows an excerpt from the classes
 <span class='latex-texttt'>PromotionRequestListViewCtrl</span>  and  <span class='latex-texttt'>PromotionRequestSelectionViewCtrl</span> .
Both classes are annotated, in addition to the  <span class='latex-texttt'>@GroupedConversationScoped</span>  annotation, with the CDI qualifier  <span class='latex-texttt'>@ConversationGroup</span> ,
with which the group is specified in a type-safe manner.
For this, any class or (marker) interface can be used.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:explicit_grouping_of_conversations'></a>                     <pre><code>@Named
@GroupedConversationScoped
@ConversationGroup(Pages.PromotionSelectionArea.class)
public class PromotionRequestListViewCtrl implements Serializable {

    //...
}

@Named
@GroupedConversationScoped
@ConversationGroup(Pages.PromotionSelectionArea.class)
public class PromotionRequestSelectionViewCtrl implements Serializable {

    //...
}
</code></pre>
                </div> Our goal was to collectively terminate all view controllers of the page area  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span> .
Therefore, it is natural to reuse this interface also for grouping the beans in Listing  <a href='#!idx:/deltaspike.html:fig:close_grouped_conversaitons'> Terminating Grouped Conversations </a> .
An idea is ultimately promoted through the method  <span class='latex-texttt'>PromotionRequestSelectionViewCtrl#promote</span> ,
in which the entire (conversation) group is terminated by calling  <span class='latex-texttt'>GroupedConversationManager#closeConversationGroup</span> .
As the parameter, the type-safe group, in this case  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span> , is used again.<br /> <div class="tip"><b>Tip: </b> Technically, any class or interface can be used for grouping  <span class='latex-texttt'>@GroupedConversationScoped</span>  beans.
Normally, however, it is natural to use the type-safe view config here as well, for example. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:close_grouped_conversaitons'></a>                     <pre><code>@Named
@GroupedConversationScoped
@ConversationGroup(Pages.PromotionSelectionArea.class)
public class PromotionRequestSelectionViewCtrl implements Serializable {

  @Inject
  private GroupedConversationManager conversationManager;

  public Class&lt;? extends Pages&gt; promote() {
    conversationManager
      .closeConversationGroup(Pages.PromotionSelectionArea.class);

    ideaService.promoteIdea(this.selectedPromotionRequest);
    return Pages.Index.class;
  }

  //...
}
</code></pre>
                </div> The previously created wizard for creating a promotion request works in principle.
However, it does not ensure that the wizard is started via the defined entry point.
Through bookmarks or manual URL entry, it is possible to jump directly to any wizard step.
This can lead to an inconsistent state in the application.
To avoid this, we can create another custom annotation for the view config.
Listing  <a href='#!idx:/deltaspike.html:fig:change_view-metadata'> Modifying View Metadata </a>  shows a possible variant named  <span class='latex-texttt'>@Wizard</span> .
In contrast to  <span class='latex-texttt'>@EntryPoint</span> , this annotation is not only marked with  <span class='latex-texttt'>@ViewMetaData</span> ,
but additionally a  <span class='latex-texttt'>ConfigPreProcessor</span>  is used
to find the page configuration annotated with  <span class='latex-texttt'>@EntryPoint</span>  of a wizard,
if the entry point is not explicitly specified with  <span class='latex-texttt'>Wizard#entryPoint</span> .
So that the subsequent logic does not need to cover different constellations,
a new instance of  <span class='latex-texttt'>@Wizard</span>  is created using  <span class='latex-texttt'>AnnotationInstanceProvider#of</span>  and
the page configuration annotated with  <span class='latex-texttt'>@EntryPoint</span>  is set as the value for  <span class='latex-texttt'>Wizard#entryPoint</span> .
The same result can be achieved with a custom literal class for  <span class='latex-texttt'>@Wizard</span> .
By using  <span class='latex-texttt'>AnnotationInstanceProvider</span> , we primarily save ourselves the creation of such a literal class.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:change_view-metadata'></a>                     <pre><code>@Target({ TYPE })
@Retention(RUNTIME)
@Documented

@ViewMetaData(preProcessor = Wizard.EntryPointProcessor.class)
public @interface Wizard {
  Class&lt;? extends ViewConfig&gt; entryPoint() default ViewConfig.class;

  class EntryPointProcessor implements ConfigPreProcessor&lt;Wizard&gt; {
    @Override
    public Wizard beforeAddToConfig(
        Wizard wizard, ViewConfigNode viewConfigNode) {

      if (!ViewConfig.class.equals(wizard.entryPoint())) {
        return wizard;
      }

      for (ViewConfigNode childNode : viewConfigNode.getChildren()) {
        for (Annotation childMetaData : childNode.getMetaData()) {
          if (EntryPoint.class.equals(childMetaData.annotationType())) {
            Map&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();
            values.put("entryPoint", childNode.getSource());

            return AnnotationInstanceProvider.of(Wizard.class, values);
          }
        }
      }
      return wizard;
    }
  }
}
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_editable_view-metadata'> Using Modifiable View Metadata </a>  shows the use of  <span class='latex-texttt'>@Wizard</span>  with the  <span class='latex-texttt'>Pages.PromotionWizard</span>  interface.
The previously mentioned modification of the metadata results at runtime in the information
 <span class='latex-texttt'>@Wizard(entryPoint = Pages.PromotionWizard.Step1.class)</span> , which is inherited through metadata inheritance to
 <span class='latex-texttt'>Pages.PromotionWizard.Step1.class</span> ,  <span class='latex-texttt'>Pages.PromotionWizard.Step2.class</span>  and  <span class='latex-texttt'>Pages.PromotionWizard.FinalStep.class</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_editable_view-metadata'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(name = "promotion")
  @Wizard
  interface PromotionWizard extends SecuredPages {
    @EntryPoint
    @ViewControllerRef(PromotionWizardCtrl.class)
    class Step1 implements PromotionWizard {}

    class Step2 implements PromotionWizard {}

    @View(name = "summary")
    class FinalStep implements PromotionWizard {}
  }
}
</code></pre>
                </div> As with  <span class='latex-texttt'>@EntryPoint</span> ,  <span class='latex-texttt'>@Wizard</span>  must also be evaluated at the appropriate place.
This can likewise be implemented in the  <span class='latex-texttt'>EntryPointHandler</span>  class.
The original method  <span class='latex-texttt'>#checkEntryPoints</span>  is renamed to  <span class='latex-texttt'>#checkEntryPointsAndWizardSteps</span>  in Listing  <a href='#!idx:/deltaspike.html:fig:combined_assessment_of_custom_view-metadata'> Combined Evaluation of Custom Metadata </a>  and
extended with an additional block in which, when a  <span class='latex-texttt'>@Wizard</span>  annotation is present for the current page, it is checked
whether the wizard was originally entered through the referenced entry point.
If this is not the case, a navigation to this entry point is performed via the injected  <span class='latex-texttt'>ViewNavigationHandler</span> .
This prevents any inconsistent state in the application, since the wizard is always entered through the defined entry point.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:combined_assessment_of_custom_view-metadata'></a>                     <pre><code>@WindowScoped
public class EntryPointHandler implements Serializable {
  private Class&lt;? extends ViewConfig&gt; previousEntryPoint;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  @Inject
  private ViewNavigationHandler viewNavigationHandler;

  @Inject
  private GroupedConversationManager conversationManager;

  @Inject
  private Event&lt;EntryPointNavigationEvent&gt; entryPointEvent;

  protected void checkEntryPointsAndWizardSteps(
      @Observes @BeforePhase(JsfPhaseId.RENDER_RESPONSE)
      PhaseEvent phaseEvent) {

    //...

    if (!viewConfigDescriptor.getMetaData(EntryPoint.class).isEmpty()) {
      this.previousEntryPoint = viewConfigDescriptor.getConfigClass();
      this.conversationManager.closeConversations();
      this.entryPointEvent.fire(
        new EntryPointNavigationEvent(
          viewConfigDescriptor.getConfigClass()));
    } else if (!viewConfigDescriptor
                  .getMetaData(Wizard.class).isEmpty()) {

      Wizard wizard =
        viewConfigDescriptor.getMetaData(Wizard.class).iterator().next();

      Class&lt;? extends ViewConfig&gt; entryPointOfWizard =
        wizard.entryPoint();

      if (!entryPointOfWizard.equals(this.previousEntryPoint)) {
        this.viewNavigationHandler.navigateTo(entryPointOfWizard);
      }
    }
  }
}
</code></pre>
                </div> The logic implemented so far for  <span class='latex-texttt'>@Wizard</span>  does not, however, ensure
that a wizard actually has a defined entry point.
To verify this during application startup, a  <span class='latex-texttt'>ConfigDescriptorValidator</span>  can be implemented and
activated as shown in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ViewConfigRoot'> Using @ViewConfigRoot </a>  via  <span class='latex-texttt'>@ViewConfigRoot</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ViewConfigRoot'></a>                     <pre><code>@ViewConfigRoot(
  configDescriptorValidators = IdeaForkViewMetaDataValidator.class)
@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(name = "promotion")
  @Wizard
  interface PromotionWizard extends SecuredPages {
    @EntryPoint
    @ViewControllerRef(PromotionWizardCtrl.class)
    class Step1 implements PromotionWizard {}

    class Step2 implements PromotionWizard {}

    @View(name = "summary")
    class FinalStep implements PromotionWizard {}
  }

  //...
}
</code></pre>
                </div> Implementations of the  <span class='latex-texttt'>ConfigDescriptorValidator</span>  interface can, as shown in
Listing  <a href='#!idx:/deltaspike.html:fig:implementation_of_ConfigDescriptorValidator'> Implementation of ConfigDescriptorValidator </a> , validate logical relationships of view-config metadata.
In  <span class='latex-texttt'>IdeaForkViewMetaDataValidator</span> , it is validated
whether at most one  <span class='latex-texttt'>@Wizard</span>  instance exists per  <span class='latex-texttt'>ViewConfigDescriptor</span>  instance and
whether the default value for  <span class='latex-texttt'>Wizard#entryPoint</span>  has been replaced with a concrete entry point.
Either through explicit specification with the  <span class='latex-texttt'>@Wizard</span>  annotation itself or through combination with  <span class='latex-texttt'>@EntryPoint</span> ,
which we initially implemented in  <span class='latex-texttt'>Wizard$EntryPointProcessor</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:implementation_of_ConfigDescriptorValidator'></a>                     <pre><code>public class IdeaForkViewMetaDataValidator
    implements ConfigDescriptorValidator {

  @Override
  public boolean isValid(ConfigDescriptor configDescriptor) {
    List&lt;Wizard&gt; wizardMetaData =
      configDescriptor.getMetaData(Wizard.class);

    if (wizardMetaData.isEmpty()) {
      return true;
    }

    if (wizardMetaData.size() &gt; 1) {
      throw new IllegalStateException("...");
    }

    Wizard wizardAnnotation = wizardMetaData.iterator().next();

    if (ViewConfig.class.equals(wizardAnnotation.entryPoint())) {
      throw new IllegalStateException("...");
    }

    return true;
  }
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> With  <span class='latex-texttt'>@ViewConfigRoot</span> , not only can the view-config concept be extended or customized,
but in combination with, for example,  <span class='latex-texttt'>@ApplicationScoped</span> , this annotation is required
when the  <span class='latex-texttt'>bean-discovery-mode</span>   <span class='latex-texttt'>annotated</span>  available since CDI 1.1 is activated. </div> In this chapter, we have learned about, among other things, several view-config mechanisms and
how they can be combined with other DeltaSpike functionalities.
Beyond that, additional customization options and annotations are available.
For example, with  <span class='latex-texttt'>@ViewRef</span> , the configuration of view controllers can be decentralized.
In the following part, we will take a closer look at the integration with other libraries,
alternative concepts for Java EE mechanisms, and the early use of EE7 functionalities in an EE6 application.<br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.7' ><span class='entry-number'>5.7</span> Flexibility with Alternatives</a> </h2>
So far in this chapter, we have primarily used DeltaSpike to extend
standard CDI concepts or other Java EE specifications such as JSF.
Apart from such extensions, DeltaSpike also provides alternatives to existing Java EE concepts.
We have already encountered some alternatives, such as type-safe project stages and type-safe JSF navigation.
This section, however, focuses on alternatives that are each available as separate DeltaSpike modules.
The main difference from the equivalent Java EE mechanisms is their greater flexibility.
All alternatives can, for example, also be used outside of Java EE servers.
Additionally, extra extension points open up new possibilities for extending or completely changing the default behavior.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> We begin by automating an area in  <span class='latex-textit'>IdeaFork</span> ,
that we newly added in this chapter.
So far, our config context can only be reset manually via JMX
to re-read any changed values from the configuration sources.
In addition to this option, we can perform an automatic reset of the beans in the config context at regular intervals,
so that the corresponding CDI beans and thus the loaded configuration values are regularly refreshed.<br />In Java EE, we would use the EJB annotation  <span class='latex-texttt'>@javax.ejb.Schedule</span>  for this purpose.
The advantage of this annotation is its high portability across Java EE servers.
As soon as we want to deploy an application outside of a Java EE server,
we would need to use an additional container such as the embedded version of Apache OpenEJB.
Alternatively, the Scheduler module of DeltaSpike enables the use of Quartz jobs as CDI beans.
Listing  <a href='#!idx:/deltaspike.html:fig:quartz-job_as_cdi-bean'> Quartz Job as CDI Bean </a>  illustrates the use of the annotation  <span class='latex-texttt'>@org.apache.deltaspike.scheduler.api.Scheduled</span> .
In this example, the class  <span class='latex-texttt'>ConfigReloaderJob</span>  is an implementation of  <span class='latex-texttt'>org.quartz.Job</span> .
Through the  <span class='latex-texttt'>@Scheduled</span>  annotation, this Quartz job is automatically activated and CDI-based injection becomes available.
For this reason, no additional configuration is required and the  <span class='latex-texttt'>ConfigReloader</span>  bean can simply be injected as usual.
Specifying a CDI scope for the Quartz job is optional. In principle, any active scope can be chosen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:quartz-job_as_cdi-bean'></a>                     <pre><code>@ApplicationScoped
@Scheduled(cronExpression = "0 0/10 * * * ?")
public class ConfigReloaderJob implements Job {
  @Inject
  private ConfigReloader configReloader;

  @Override
  public void execute(JobExecutionContext context)
    throws JobExecutionException {
      configReloader.reloadConfig();
  }
}
</code></pre>
                </div> Besides controlling the execution times using a CRON expression, the context control can also be customized.
The default value for  <span class='latex-texttt'>@Scheduled#startScopes</span>  is  <span class='latex-texttt'>SessionScoped.class</span>  and  <span class='latex-texttt'>RequestScoped.class</span> .
Without an explicit specification of other scope annotations,
the request and session scopes are automatically started in the background for each launched Quartz job and stopped again after the execution of the
 <span class='latex-texttt'>#execute</span>  method.
The specified contexts are started and stopped using DeltaSpike CDI Control,
which we will explore in detail when working with the Test-Control module.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Explicit control of the scheduler and individual scheduler jobs can optionally be implemented via the
 <span class='latex-texttt'>org.apache.deltaspike.scheduler.spi.Scheduler</span>  SPI.
For example, it is possible to deactivate the automatic configuration of a
scheduling job with  <span class='latex-texttt'>@Scheduled(onStartup = false)</span> , in order to inject a contextual reference to  <span class='latex-texttt'>Scheduler</span>  into any CDI bean and
manually execute such a scheduling job depending on a configuration via  <span class='latex-texttt'>Scheduler#startJobManually</span> .<br /> <div class="tip"><b>Tip: </b> Through the  <span class='latex-texttt'>Scheduler</span>  SPI, even Quartz itself can be replaced as the scheduling framework.
As long as the preferred scheduling framework supports at least scheduling jobs based on CRON expressions,
an implementation of  <span class='latex-texttt'>org.apache.deltaspike.scheduler.spi.Scheduler</span>  can serve as an adapter to this scheduling framework. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Another module that was primarily created as a CDI-based alternative to EJBs is the JPA module of DeltaSpike.
The annotations  <span class='latex-texttt'>@org.apache.deltaspike.jpa.api.transaction.Transactional</span> ,
 <span class='latex-texttt'>@org.apache.deltaspike.jpa.api.transaction.TransactionScoped</span>  and  <span class='latex-texttt'>@PersistenceUnitName</span> represent the central components of this module.
For the first two annotations, identically named equivalents have existed since Java EE 7 (or JTA v1.2),
although both  <span class='latex-texttt'>@Transactional</span>  variants fundamentally share the same goal,
they implement it differently in detail.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span> , transactions have so far been implicitly managed through EJBs at the service level.
In summary, a proxy instance for the  <span class='latex-texttt'>EntityManager</span>  is injected by the EE server in the class  <span class='latex-texttt'>EntityManagerProducer</span> .
Through the self-defined CDI producer method, we can type-safely inject this  <span class='latex-texttt'>EntityManager</span>  into EJBs or CDI beans.
In the background, the EJB container creates a new  <span class='latex-texttt'>EntityManager</span>  instance per transaction.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/deltaspike.html:fig:entity-manager-producer_without_ejb'> EntityManager Producer Independent of EJBs </a> shows how we can achieve the same behavior without EJBs using the JPA module of DeltaSpike.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:entity-manager-producer_without_ejb'></a>                     <pre><code>@ApplicationScoped
public class EntityManagerProducer {
  @PersistenceUnit(unitName = "ideaForkPU")
  private EntityManagerFactory entityManagerFactory;

  @Produces
  @Default
  @TransactionScoped
  protected EntityManager exposeEntityManagerProxy() {
    return entityManagerFactory.createEntityManager();
  }

  protected void onTransactionEnd(
    @Disposes @Default EntityManager entityManager) {
      if (entityManager.isOpen()) {
        entityManager.close();
      }
  }
}
</code></pre>
                </div> Since we are forgoing EJB support, we must fall back to the thread-safe  <span class='latex-texttt'>EntityManagerFactory</span> .
In an EE server,  <span class='latex-texttt'>EntityManagerFactory</span>  is injected by the container itself in combination with  <span class='latex-texttt'>@PersistenceUnit</span> .
Outside of an EE server, we would need to rely on plug-ins for the CDI container.
OpenWebBeans, for example, provides a corresponding plugin with the Resource module.
However, this is not portable and therefore only usable with OpenWebBeans.
A portable result can be achieved outside the EE server with the annotation
 <span class='latex-texttt'>@org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Before we use this annotation, let us examine our previous approach in our tests.
In  <span class='latex-textit'>IdeaFork</span> , we use in-memory repositories for unit tests.
Such an approach is often recommended when the repositories themselves are not being tested.
However, if too many central classes are replaced for tests, errors often cannot be detected early enough.
In the tests of  <span class='latex-textit'>IdeaFork</span> , we symbolically illustrated this in the test class  <span class='latex-texttt'>EventTest</span> .
Specifically, we call the method  <span class='latex-textit'>UserManager#createUserFor</span>  in various test methods.
Afterward, ideas are created and saved for this user.
However, due to the in-memory repositories in the test code, it went unnoticed that the created user instance was not persisted.
This only becomes apparent when we also use the production repository implementations in the tests.
To retain our normal JPA repositories in tests as well, we simply delete the specialized repository implementations,
causing the production implementations to become automatically active again.
As previously mentioned, the CDI producer for the  <span class='latex-texttt'>EntityManager</span> described in Listing  <a href='#!idx:/deltaspike.html:fig:entity-manager-producer_without_ejb'> EntityManager Producer Independent of EJBs </a>  cannot be used portably outside an EE server.
Instead, we can introduce the specialized variant
of the  <span class='latex-texttt'>EntityManagerProducer</span>  class shown in Listing  <a href='#!idx:/deltaspike.html:fig:entity-manager-producer_for_tests'> Portable Test EntityManager Producer </a>  in the test module.
By using the qualifier annotation  <span class='latex-texttt'>@PersistenceUnitName</span> , we can continue to have the injection point for  <span class='latex-texttt'>EntityManagerFactory</span>  filled automatically.
The remaining producer logic is equivalent to  <span class='latex-texttt'>EntityManagerProducer</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:entity-manager-producer_for_tests'></a>                     <pre><code>@Specializes
public class TestEntityManagerProducer extends EntityManagerProducer {
  @Inject
  @PersistenceUnitName("ideaForkPU")
  private EntityManagerFactory entityManagerFactory;

  //...
}
</code></pre>
                </div> The corresponding changes are summarized in a single commit in the Git repository of  <span class='latex-textit'>IdeaFork</span> .
This commit additionally shows that further test dependencies for JPA in unit tests and
a separate JPA configuration (see  <span class='latex-texttt'>META-INF/persistence.xml</span> ) are required.
Both are independent of CDI or DeltaSpike, and therefore we will not go into these details further.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> At this point, we have converted the  <span class='latex-texttt'>EntityManagerProducer</span>  and
the created  <span class='latex-texttt'>EntityManager</span>  instance is stored in the transaction context for the current thread through  <span class='latex-texttt'>@TransactionScoped</span> .
However, the transaction context is not automatically active;
it is activated by the  <span class='latex-texttt'>@Transactional</span>  interceptor from DeltaSpike, since this interceptor manages the transactions.
For this reason,  <span class='latex-texttt'>@TransactionScoped</span>  can only be used in conjunction with  <span class='latex-texttt'>@Transactional</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span> , we have so far defined transaction handling in the EE6 module through EJBs.
In the core of  <span class='latex-textit'>IdeaFork</span> , we therefore had no transactional beans.
Our switch from in-memory repositories to JPA repositories therefore requires transactional beans in  <span class='latex-textit'>IdeaFork</span>  Core.
Listing  <a href='#!idx:/deltaspike.html:fig:extended_stereotype'> Extending a Stereotype </a>  shows the required extension of the  <span class='latex-texttt'>@Repository</span>  stereotype annotation.
As soon as we add the  <span class='latex-texttt'>@Transactional</span>  annotation to our  <span class='latex-texttt'>@Repository</span>  annotation,
all repository implementations in  <span class='latex-textit'>IdeaFork</span>  become transactional.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:extended_stereotype'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Stereotype
@ApplicationScoped
@Monitored

@Transactional
public @interface Repository {
}
</code></pre>
                </div> However, this requires CDI 1.1 or Java EE7.
With CDI 1.0 and consequently also with EE6, we still need to declare the interceptor in the  <span class='latex-texttt'>META-INF/beans.xml</span>  file.
In some EE6 servers, such as Apache TomEE, this can already be omitted, while in others the BDA rules are so strictly implemented
that the interceptor must be activated again in each CDI archive.
In such cases, the class  <span class='latex-texttt'>org.apache.deltaspike.jpa.impl.transaction.TransactionalInterceptor</span> must be added as an interceptor class,
as shown in Listing  <a href='#!idx:/deltaspike.html:fig:configure_transactional_interceptor_ee6'> Activating TransactionalInterceptor for EE6 Servers </a> .
Without this activation, the  <span class='latex-texttt'>@Transactional</span>  annotation would simply be ignored.<br />Listing  <a href='#!idx:/deltaspike.html:fig:configure_transactional_interceptor_ee6'> Activating TransactionalInterceptor for EE6 Servers </a>  shows the required configuration entry.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:configure_transactional_interceptor_ee6'></a>                     <pre><code>&lt;beans&gt;
  &lt;!-- ... --&gt;

  &lt;interceptors&gt;
    &lt;!-- ... --&gt;
    &lt;class&gt;
      org.apache.deltaspike.jpa.impl.transaction.TransactionalInterceptor
    &lt;/class&gt;
  &lt;/interceptors&gt;

  &lt;!-- ... --&gt;
&lt;/beans&gt;
</code></pre>
                </div> For the service implementations of the EE6 module of  <span class='latex-textit'>IdeaFork</span> , we can follow a similar approach.
However, here we first need to create a stereotype annotation.
Listing  <a href='#!idx:/deltaspike.html:fig:stereotype_for_transactional_services'> Stereotype for Transactional Services </a>  illustrates this stereotype annotation named  <span class='latex-texttt'>@Service</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:stereotype_for_transactional_services'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Stereotype
@ApplicationScoped

@Transactional
public @interface Service {
}
</code></pre>
                </div> Beans marked with this new  <span class='latex-texttt'>@Service</span>  stereotype automatically become transactional application-scoped beans.
We can use  <span class='latex-texttt'>@Transactional</span>  either at the class level or at the method level.
By using  <span class='latex-texttt'>@Transactional</span>  in the two stereotype annotations  <span class='latex-texttt'>@Repository</span>  and  <span class='latex-texttt'>@Service</span> ,
all methods of the annotated CDI bean become transactional.
If we were to explicitly annotate individual methods with  <span class='latex-texttt'>@Transactional</span>  instead,
then only those methods would be executed within a transaction.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span> , both repository beans and service beans are transactional,
so that repository beans can be tested in a fine-grained manner without additional constructs and
 <span class='latex-textit'>IdeaFork</span>  Core can be used as a standalone module.
In the EE6 module, we optimize the transaction boundaries for the JSF application by defining transactional service beans.
We could therefore, in addition to the EE6 module, also implement modules for other UI technologies
that might have different requirements for transaction boundaries.
In any of the possible cases,  <span class='latex-textit'>IdeaFork</span>  Core ensures
that at least repository beans are executed in the context of an active transaction.
When a transactional method is called, DeltaSpike automatically checks whether a transaction is already active for the current thread.
If a transactional service method calls one or more transactional repository methods,
only one transaction is started at the service level and ended after the call.
All repository calls in this constellation are executed within the transaction context of the service method and
therefore do not receive their own transaction.
If transactional repository methods are called from a non-transactional (CDI) bean, however,
each repository method is executed in its own transaction.
As a result, a transaction is always started and stopped by the outermost transactional method.
The result closely resembles the concepts defined by EJBs.
A major difference is that transactional CDI beans must be explicitly marked with  <span class='latex-texttt'>@Transactional</span> .
Furthermore, the transaction strategy of DeltaSpike can be customized if needed.<br />With this information, we can convert our existing EJBs to transactional CDI beans.
Listing  <a href='#!idx:/deltaspike.html:fig:transactional_cdi-beans_instead_of_ejbs'> Transactional CDI Beans Instead of EJBs </a>  illustrates this conversion using  <span class='latex-texttt'>IdeaService</span>  as a representative example.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:transactional_cdi-beans_instead_of_ejbs'></a>                     <pre><code>//old
@Stateless
public class IdeaService {
  @Inject
  private IdeaManager ideaManager;

  //...
}

//new
@Service
public class IdeaService {
  @Inject
  private IdeaManager ideaManager;

  //...
}
</code></pre>
                </div> Any exceptions that may have occurred are also handled at this outermost level.
If a transactional method is called by another transactional method,
the transaction is only rolled back when the outermost transactional method does not catch and handle an exception or throws one itself.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The commit in the Git repository also contains a change in the class  <span class='latex-texttt'>AppStructureValidationExtension</span> .
This change is necessary because the service implementations in  <span class='latex-textit'>IdeaFork</span>  are no longer EJBs
but should now be annotated with @Service instead.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For managing transactions, DeltaSpike provides several variants and
additionally enables the implementation of custom concepts.
This is possible through the  <span class='latex-texttt'>org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy</span>  SPI.
In  <span class='latex-texttt'>TransactionalInterceptor</span> , a CDI bean that implements this interface is injected.
By default, an implementation named  <span class='latex-texttt'>ResourceLocalTransactionStrategy</span>  is active,
which requires  <span class='latex-texttt'>"RESOURCE_LOCAL"</span>  as the value for  <span class='latex-texttt'>"transaction-type"</span>  for persistence units.
For this reason,  <span class='latex-texttt'>@Transactional</span>  can be used both inside and outside of Java EE servers.
In addition, DeltaSpike provides two further implementations of the  <span class='latex-texttt'>TransactionStrategy</span>  interface.
 <span class='latex-texttt'>BeanManagedUserTransactionStrategy</span>  enables the use of  <span class='latex-texttt'>"JTA"</span>  as the value for  <span class='latex-texttt'>"transaction-type"</span>  and
 <span class='latex-texttt'>EnvironmentAwareTransactionStrategy</span>  supports both configurations
by determining the transaction type for each active transaction.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> If the active implementation needs to be changed,
the desired alternative class can be configured in the  <span class='latex-texttt'>META-INF/beans.xml</span>  file.
Especially with Weld-based EE6 servers, this is not possible due to the stricter interpretation of the BDA rules.
To still activate an alternative implementation globally on such servers,
we can fall back on the Global Alternative concept of DeltaSpike.
In our case, we create the file  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  and
add the line from Listing  <a href='#!idx:/deltaspike.html:fig:global_alternatives'> Global Alternatives with CDI 1.0 </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:global_alternatives'></a>                     <pre><code>globalAlternatives.org.apache.deltaspike.jpa
.spi.transaction.TransactionStrategy=org.apache.deltaspike.jpa
.impl.transaction.EnvironmentAwareTransactionStrategy
</code></pre>
                </div> This configuration file is integrated into the configuration mechanism of DeltaSpike like any other configuration source and
is internally loaded by the class  <span class='latex-texttt'>PropertyFileConfigSource</span> .
In this chapter, we have already learned about the prioritization of configuration sources.
 <span class='latex-texttt'>PropertyFileConfigSource</span>  uses the default value  <span class='latex-texttt'>100</span>  for configuration files
named  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> .
The same applies to configuration files that are automatically included through implementations of the  <span class='latex-texttt'>PropertyFileConfig</span>  interface.
Each configuration source, including any file named  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> ,
can define its own predefined priority.
To do this, we need to add a configuration entry with the key  <span class='latex-texttt'>deltaspike_ordinal</span> .
As the value, we choose the desired position in the configuration chain.
DeltaSpike uses the values 100, 200, 300, and 400 for its own configuration sources.
If we want to ensure that our just-defined configuration for the global transaction strategy
always takes precedence over values in the default sources, we must choose a value higher than 400.
In our case, we add the configuration entry
 <span class='latex-texttt'>deltaspike_ordinal=1000</span>  to the file  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> .<br /> <div class="tip"><b>Tip: </b> The  <span class='latex-texttt'>@Transactional</span>  annotation is intended as an alternative to EJBs,
but it can also be combined with them.
If  <span class='latex-texttt'>@Transactional</span>  uses the current  <span class='latex-texttt'>UserTransaction</span>  and thus JTA,
then a transactional CDI bean can take over the  <span class='latex-texttt'>UserTransaction</span>  of an EJB,
provided the EJB calls a transactional method of a CDI bean. </div><h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.8' ><span class='entry-number'>5.8</span> Custom Concepts</a> </h2>
 In  <span class='latex-textit'>IdeaFork</span> , we have so far learned about several ways to access configured values,
which were implemented using DeltaSpike.
The demonstrated options illustrate some concepts that are directly supported by DeltaSpike.
Each of the described variants had at least one aspect that could be improved.
In many cases, this lies in the nature of the matter, since we want to access untyped configuration values as type-safely as possible.
For example, the use of  <span class='latex-texttt'>@ConfigProperty</span>  requires that the key be specified at each injection point and
must be updated when changes occur.
Here, we could of course resort to an interface that defines the keys as static strings.
Nevertheless, a correspondingly high level of discipline must be maintained during implementation.
With the second variant, the producer classes that extend  <span class='latex-texttt'>BaseConfigPropertyProducer</span> ,
we need a separate producer method for each key.
While such methods are trivial to implement, an implementation and in many cases also a CDI qualifier is needed for each key.
The situation is similar with custom configuration beans.
The advantage of  <span class='latex-texttt'>MonitoringConfig</span>  was the optional use of any scope,
yet we still had to implement a separate method for each configuration key.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> However, we can overcome the limitations just mentioned in a few steps by implementing a custom concept.
To accomplish this, we can make use of the Partial-Bean module of DeltaSpike.
This module allows the implementation of interfaces and abstract classes
for which there is only a generic handler instead of concrete implementations.
The connection between interfaces or abstract classes and the corresponding generic handler
is made through a self-defined binding annotation.
Such a binding annotation can be seen in Listing  <a href='#!idx:/deltaspike.html:fig:partial-bean_binding'> Partial-Bean Binding </a>  and must be marked with the annotation
 <span class='latex-texttt'>@org.apache.deltaspike.partialbean.api.PartialBeanBinding</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:partial-bean_binding'></a>                     <pre><code>@PartialBeanBinding

@Retention(RUNTIME)
@Target(TYPE)
public @interface TypedConfig {
}
</code></pre>
                </div> Both the interfaces or abstract classes and the handler class must be annotated with the same binding annotation
to establish a connection.
In  <span class='latex-textit'>IdeaFork</span> , in this chapter we introduced the qualifier  <span class='latex-texttt'>@MaxNumberOfHighestRatedCategories</span>
to type-safely inject the configured value.
One qualifier per configuration key improves safety during usage,
but at the same time increases the effort during initial implementation.
Before this qualifier, we had a class named  <span class='latex-texttt'>ApplicationConfig</span>
that provided several configuration values in a type-safe manner.
However, we had to load the configuration ourselves and prepare the individual properties, or
in the case of multiple configuration sources, even a prioritization per source would be necessary.
The result, regardless of the preceding steps,
was consumed in this case through the method  <span class='latex-texttt'>#getMethodInvocationThreshold</span> .
Apart from the manual processing of the configuration, this approach was quite practical.
Therefore, we want to refine our original approach with the Partial-Bean concept
based on the configuration infrastructure of DeltaSpike.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> As a first simplification, we remove the qualifier  <span class='latex-texttt'>@MaxNumberOfHighestRatedCategories</span>  again and create
 <span class='latex-texttt'>ApplicationConfig</span>  this time as an interface with the method  <span class='latex-texttt'>#maxNumberOfHighestRatedCategories</span> .
The interface shown in Listing  <a href='#!idx:/deltaspike.html:fig:minimal_partial_bean'> Minimal Partial-Bean </a>  is connected to a generic handler through the  <span class='latex-texttt'>@TypedConfig</span>  annotation.
As a result, we get our first partial bean.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_partial_bean'></a>                     <pre><code>@TypedConfig
public interface ApplicationConfig {
  Integer maxNumberOfHighestRatedCategories();
}
</code></pre>
                </div> So far, we have created a binding annotation and an interface.
The previously mentioned generic handler is implemented in the next step.
This handler must implement  <span class='latex-texttt'>java.lang.reflect.InvocationHandler</span>  and be annotated with our binding annotation.
Listing  <a href='#!idx:/deltaspike.html:fig:minimal_partial-bean_handler'> Minimal Partial-Bean Handler </a>  shows a simplified variant of a handler.
The method name is passed as the key to the previously introduced method  <span class='latex-texttt'>ConfigResolver#getPropertyValue</span> .
Then the value loaded by DeltaSpike is parsed based on the return type of the method.
This result consequently represents the return value of the partial-bean method.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_partial-bean_handler'></a>                     <pre><code>@TypedConfig
public class TypedConfigHandler implements InvocationHandler {
  public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {

      String key = method.getName();
      Class&lt;?&gt; configType = method.getReturnType();

      String loadedValue = ConfigResolver.getPropertyValue(key);
      return parseValue(loadedValue, configType);
  }

  private Object parseValue(String loadedValue, Class&lt;?&gt; configType) {
    //...
  }
}
</code></pre>
                </div> Without additional configuration or activation, our first partial bean is immediately ready to use and
we can inject  <span class='latex-texttt'>ApplicationConfig</span>  like a regular CDI bean into other CDI beans.
With every method call, in our case of the method  <span class='latex-texttt'>#maxNumberOfHighestRatedCategories</span> ,
the generic handler for this partial bean is called in the background.<br />Listing  <a href='#!idx:/deltaspike.html:fig:using_partial-beans'> Using Partial-Beans </a>  illustrates
that no additional aspects need to be considered when using a partial bean.
Simply by looking at the usage, for example in  <span class='latex-texttt'>IdeaJpaRepository</span> , we cannot distinguish it from a regular CDI bean.
Only when searching for the corresponding implementation would we discover
that no explicit implementation of the interface exists.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:using_partial-beans'></a>                     <pre><code>@Repository
public class IdeaJpaRepository extends GenericJpaRepository&lt;Idea&gt;
  implements IdeaRepository {

    @Inject
    private ApplicationConfig applicationConfig;

    //...

    @Override
    public List&lt;CategoryView&gt; getHighestRatedCategories() {
      return entityManager.createQuery("...")
        .setMaxResults(
          applicationConfig.maxNumberOfHighestRatedCategories())
        .getResultList();
    }
}
</code></pre>
                </div> In our case,  <span class='latex-texttt'>ApplicationConfig</span>  currently has only one method,
which makes the effort seem disproportionately high.
The goal of partial beans is, of course, to use interfaces with multiple methods
or to connect multiple partial beans with a single generic handler.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> When defining additional configuration beans, we immediately benefit from the underlying idea.
Listing  <a href='#!idx:/deltaspike.html:fig:config_as_cdi-bean'> MonitoringConfig as a Simple CDI Bean </a>  shows the class  <span class='latex-texttt'>MonitoringConfig</span> , which we added in this chapter.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:config_as_cdi-bean'></a>                     <pre><code>@ConfigScoped
public class MonitoringConfig {
  @Inject
  @ConfigProperty(name = "methodInvocationThreshold")
  private Integer methodInvocationThreshold;

  public Integer getMethodInvocationThreshold() {
    return methodInvocationThreshold;
  }
}
</code></pre>
                </div> While the approach is very straightforward, we can significantly simplify this configuration class.
Listing  <a href='#!idx:/deltaspike.html:fig:config_as_partial-bean'> MonitoringConfig as a PartialBean </a>  shows the conversion of  <span class='latex-texttt'>MonitoringConfig</span>  to a partial bean.
Since we have already implemented both the partial-bean binding and the generic handler,
the creation effort for all further partial beans or the addition of further methods is minimal.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:config_as_partial-bean'></a>                     <pre><code>@TypedConfig
public interface MonitoringConfig {
  Integer methodInvocationThreshold();
}
</code></pre>
                </div> However, when converting  <span class='latex-texttt'>MonitoringConfig</span> , we lost one mechanism.
The loaded values are no longer stored in our config context and
must therefore be reloaded by DeltaSpike on every access.
We could annotate our partial bean itself with the  <span class='latex-texttt'>@ConfigScoped</span>  annotation again.
However, in this case we would only place the internally generated instance in this context.
Method calls would still be forwarded to the generic handler,
which reloads the value on every access.
For this reason, we must store the generic handler itself in the config context and cache the loaded values locally.
Listing  <a href='#!idx:/deltaspike.html:fig:caching_via_partial-bean_handler'> Caching Configuration Values in TypedConfigHandler </a>  illustrates the required changes in the class  <span class='latex-texttt'>TypedConfigHandler</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:caching_via_partial-bean_handler'></a>                     <pre><code>@TypedConfig
@ConfigScoped
public class TypedConfigHandler implements InvocationHandler {
  private Map&lt;String, Object&gt; loadedValues =
    new ConcurrentHashMap&lt;String, Object&gt;();

  public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {

      String key = method.getName();
      Object result = loadedValues.get(key);

      if (result != null) {
        return result;
      }

      String loadedValue = ConfigResolver.getPropertyValue(key);

      Class&lt;?&gt; configType = method.getReturnType();
      result = parseValue(loadedValue, configType);

      loadedValues.put(key, result);
      return result;
  }

  //...
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> If it becomes necessary to manually implement individual methods of a partial bean,
abstract classes can be used for this purpose.
Abstract methods continue to be forwarded to the corresponding generic handler.
Explicitly implemented methods, however, are executed normally, thereby bypassing the handler in such cases. </div> This approach has the additional advantage that we can implement changes centrally.
Instead of annotating each configuration class individually with  <span class='latex-texttt'>@ConfigScoped</span> ,
this is now only necessary for the class  <span class='latex-texttt'>TypedConfigHandler</span> .
Other changes could also be made centrally for all configurations.
For example, as shown in Listing  <a href='#!idx:/deltaspike.html:fig:project-stage_based_config-values'> Switching to Project-Stage Dependent Configuration Values </a> ,
instead of the method  <span class='latex-texttt'>ConfigResolver#getPropertyValue</span>  we could use the method
 <span class='latex-texttt'>ConfigResolver#getProjectStageAwarePropertyValue</span>
to bind configuration values to a project stage.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:project-stage_based_config-values'></a>                     <pre><code>@TypedConfig
@ConfigScoped
public class TypedConfigHandler implements InvocationHandler {
  //...

  public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {

    //...
    String loadedValue =
      ConfigResolver.getProjectStageAwarePropertyValue(key);

    //...
    return result;
  }

  //...
}
</code></pre>
                </div> This change allows configuration values to be overridden for specific project stages.
For the key  <span class='latex-texttt'>maxNumberOfHighestRatedCategories</span> , our configuration entry is, for example,  <span class='latex-texttt'>maxNumberOfHighestRatedCategories=10</span> .
This entry remains valid unless there is an explicit entry for the current project stage.
If we were to activate the  <span class='latex-texttt'>Development</span>  project stage, we could override the entry
 <span class='latex-texttt'>maxNumberOfHighestRatedCategories=10</span>  with, for example,  <span class='latex-texttt'>maxNumberOfHighestRatedCategories.Development=100</span> .
This way, during development, we could conduct experiments
to see how the page behaves when displaying a large number of categories without risking
accidentally modifying a production configuration.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Some configurations do not necessarily require regular updates.
In  <span class='latex-textit'>IdeaFork</span> , in this chapter we created, for example, a CDI qualifier named  <span class='latex-texttt'>ApplicationName</span>
that was additionally annotated with  <span class='latex-texttt'>@ConfigProperty</span>  so that the configured application name becomes type-safely injectable and
at the same time the corresponding producer logic can generically load the configured value based on  <span class='latex-texttt'>@ConfigProperty</span> .
The conversion of the configuration classes in  <span class='latex-textit'>IdeaFork</span>  to partial beans, however, does not yet take CDI qualifiers into account.
If we replace the previously used  <span class='latex-texttt'>ConfigProducer</span> , we would get a partial bean named  <span class='latex-texttt'>ApplicationConfig</span> ,
as shown in Listing  <a href='#!idx:/deltaspike.html:fig:partial-bean_without_producer'> Partial-Bean Without Producer </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:partial-bean_without_producer'></a>                     <pre><code>@TypedConfig
public interface ApplicationConfig {
  Integer maxNumberOfHighestRatedCategories();

  String name();

  ApplicationVersion version();

  ExternalFormat.TargetFormat defaultExternalFormat();
}
</code></pre>
                </div> Accordingly, we could no longer inject the application name as a String in combination with the  <span class='latex-texttt'>@ApplicationName</span>  qualifier.
To continue using this capability, a small extension of the partial bean is required.
As shown in Listing  <a href='#!idx:/deltaspike.html:fig:partial-bean_with_producer'> Partial-Bean with Producer </a> , we can also annotate methods in a partial bean with  <span class='latex-texttt'>@Produces</span>  and
optionally with a qualifier annotation.
Producer methods in partial beans act like conventional CDI producers with the sole difference
that here too the partial-bean handler takes over the execution of the methods.
A positive side effect is
that qualifiers, such as the  <span class='latex-texttt'>@ApplicationName</span>  annotation in our case, no longer need to be marked with  <span class='latex-texttt'>@ConfigProperty</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:partial-bean_with_producer'></a>                     <pre><code>@TypedConfig
public interface ApplicationConfig {
  Integer maxNumberOfHighestRatedCategories();

  @Produces
  @ApplicationName
  String name();

  @Produces
  ApplicationVersion version();

  @Produces
  ExternalFormat.TargetFormat defaultExternalFormat();
}
</code></pre>
                </div> Since we do not use a scope annotation on any producer method in  <span class='latex-texttt'>ApplicationConfig</span> ,
the result is always a dependent-scoped bean.
As before, configuration values created this way can only be updated
when the corresponding injection point is refilled.
Of course, we could also inject  <span class='latex-texttt'>ApplicationConfig</span>  and access all its methods directly.
For information like the application name, however, we do not need to always use the currently cached value through a direct call to
 <span class='latex-texttt'>ApplicationConfig#name</span> , and
therefore we can also use such information directly in other CDI beans without the detour through  <span class='latex-texttt'>ApplicationConfig</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-texttt'>ApplicationConfig</span> , we also defined the result of  <span class='latex-texttt'>defaultExternalFormat</span>  as a dependent-scoped bean.
There is a technical reason for this, however: no proxy can be created for enum values,
which means we cannot use CDI normal scopes.
In our case, we want to simplify  <span class='latex-texttt'>CurrentObjectConverterProducer</span> ,
since previously the configured value was injected using  <span class='latex-texttt'>@ConfigProperty</span>  and the string was evaluated manually.
Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_strategy_selection'> Activating Implementations After Configuration Changes </a>  shows the modified implementation of  <span class='latex-texttt'>CurrentObjectConverterProducer</span> .
Through the producer for  <span class='latex-texttt'>ExternalFormat.TargetFormat</span> , we can inject the current value directly.
The previous version of  <span class='latex-texttt'>CurrentObjectConverterProducer</span>  provided the selected  <span class='latex-texttt'>ObjectConverter</span> as a dependent-scoped bean for the  <span class='latex-texttt'>@Default</span>  qualifier.
If we continued to do this, a configuration refresh would not propagate consistently throughout the application.
If we inject, for example, the  <span class='latex-texttt'>@Default</span>   <span class='latex-texttt'>ObjectConverter</span>  into an application-scoped bean,
that bean would use the dependent-scoped  <span class='latex-texttt'>ObjectConverter</span>  until the application is restarted.
An injection into a request-scoped bean, on the other hand, would result in
us receiving a new reference to the current  <span class='latex-texttt'>ObjectConverter</span>  per request.
If the configured value for the key  <span class='latex-texttt'>defaultExternalFormat</span>  changes at runtime,
the request-scoped bean would receive this new value as soon as the cache in  <span class='latex-texttt'>TypedConfigHandler</span>  is updated.
The application-scoped bean, however, would continue to work with the original  <span class='latex-texttt'>ObjectConverter</span> .
To avoid such inconsistencies at runtime, we can additionally extend the producer method
in Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_strategy_selection'> Activating Implementations After Configuration Changes </a>  with the  <span class='latex-texttt'>@ConfigScoped</span>  annotation.
Through this change, the current  <span class='latex-texttt'>ObjectConverter</span>  is updated for all injection points
as soon as the config context is reset.
This simultaneously means that all beans always use the current  <span class='latex-texttt'>ObjectConverter</span>  regardless of their scope.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_strategy_selection'></a>                     <pre><code>@ApplicationScoped
public class CurrentObjectConverterProducer {
  @Produces
  @Default
  @ConfigScoped
  protected ObjectConverter defaultConverter(
    @ExternalFormat(XML) ObjectConverter objectConverterXml,
    @ExternalFormat(JSON) ObjectConverter objectConverterJson,
    ExternalFormat.TargetFormat defaultFormat) {
      switch (defaultFormat) {
        case JSON:
          return objectConverterJson;
        default:
          return objectConverterXml;
      }
    }
}
</code></pre>
                </div> The result of our conversion is a simple, uniform, and refreshable configuration that is also type-safe.
For each new configuration entry, in the simplest case only a method in an interface needs to be added.
If the key of a configuration entry changes, only this one method needs to be renamed accordingly.
All modern Java IDEs automatically update the corresponding method calls during such a refactoring.
If this is not done correctly, the Java compiler would report an error at the latest.
The entire logic for loading, parsing, and caching the values can be performed centrally in a handler.
Changes can therefore also be made centrally.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Nevertheless, we have not yet eliminated an important source of error in our type-safe configuration.
While we have ensured that we access the configured values in a type-safe manner,
we do not know whether every interface method actually leads to a configured value.
For example, the key of an entry could change and our application would continue to start normally,
even if the corresponding method was not renamed.
The effect would therefore only become visible at runtime when the method is accessed.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> To prevent this, we can implement the interface  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigValidator</span>  and
activate it in the file  <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.core.spi.config.ConfigValidator</span> .
So that we can find the interfaces annotated with our self-created annotation  <span class='latex-texttt'>@TypedConfig</span> ,
our validator additionally implements  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>  and
must also be added to the file  <span class='latex-texttt'>META-INF/services/javax.enterprise.inject.spi.Extension</span> .
In Listing  <a href='#!idx:/deltaspike.html:fig:validating_typesafe_configs'> Extension for Validating Type-Safe Configuration </a> , this implementation is called  <span class='latex-texttt'>TypedConfigValidationExtension</span> .
The method  <span class='latex-texttt'>#findTypedConfigClasses</span>  checks
whether the found bean is an implementation of  <span class='latex-texttt'>InvocationHandler</span>
that is additionally annotated with  <span class='latex-texttt'>@TypedConfig</span> .
In this case, the found class is added to a list
that is used in the method  <span class='latex-texttt'>#processValidation</span>  for validation.
During validation, each method name is used as a key for the method call  <span class='latex-texttt'>getPropertyValue</span> .
If no configured value can be found for a key, an appropriate error message is generated.
If we had optional configurations, we would additionally need to introduce another annotation for methods.
This could be called, for example,  <span class='latex-texttt'>@OptionalKey</span> , and methods with such an annotation would simply be skipped during validation.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:validating_typesafe_configs'></a>                     <pre><code>public class TypedConfigValidationExtension
  implements ConfigValidator, Extension {

  private static List&lt;Class&gt; foundConfigClasses =
    new CopyOnWriteArrayList&lt;Class&gt;();

  public void findTypedConfigClasses(@Observes ProcessAnnotatedType pat) {
    Class&lt;?&gt; beanClass = pat.getAnnotatedType().getJavaClass();
    TypedConfig typedConfig = beanClass.getAnnotation(TypedConfig.class);

    if (typedConfig != null &&
        !InvocationHandler.class.isAssignableFrom(beanClass)) {
      foundConfigClasses.add(beanClass);
    }
  }

  @Override
  public Set&lt;String&gt; processValidation() {
    Set&lt;String&gt; violations = new HashSet&lt;String&gt;();
    for (Class configClass : foundConfigClasses) {
      validateConfigKeys(configClass.getMethods(), violations);
    }

    foundConfigClasses.clear();
    return violations;
  }

  private void validateConfigKeys(
    Method[] methods, Set&lt;String&gt; violations) {

      for (Method method : methods) {
        String key = method.getName();
        String configuredValue = ConfigResolver.getPropertyValue(key);

        if (configuredValue == null) {
          violations.add("missing config-key: " + key);
        }
      }
  }
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> Some servers are not specification-compliant,
which is why we must use a static variable in the class  <span class='latex-texttt'>TypedConfigValidationExtension</span> .
In specification-compliant servers, we could also use an instance variable,
which makes it easier to use such extensions in shared modules across multiple modules.
In this case, we would need to use a bean lookup for  <span class='latex-texttt'>TypedConfigValidationExtension</span>  in the method  <span class='latex-texttt'>#processValidation</span> ,
so that we get the  <span class='latex-texttt'>Extension</span>  instance with the populated list. </div><h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.9' ><span class='entry-number'>5.9</span> Increasing Flexibility Further</a> </h2>
 In many projects, the ability to load configured values from a database is additionally created,
so that a configuration can be changed at runtime if necessary, without redeploying the application.
This concept is normally simple and quick to implement.
In our case, we want to keep this implementation as minimalistic as possible and
additionally integrate it with the previously introduced configuration mechanism of DeltaSpike.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the first step, we create a simple JPA entity named  <span class='latex-texttt'>ConfigEntry</span> ,
which can be seen in Listing  <a href='#!idx:/deltaspike.html:fig:jpa-entity_for_dynamic_configs'> JPA Entity for Dynamic Configurations </a> .
We could use this entity as usual with the help of a repository implementation.
With  <span class='latex-texttt'>GenericJpaRepository</span> , we already have a base implementation in the core of  <span class='latex-textit'>IdeaFork</span> with which we would only need to type a concrete implementation to our new entity type.
DeltaSpike provides a similar approach through the Data module,
allowing us to forgo our own base implementation and benefit from additional functionalities.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:jpa-entity_for_dynamic_configs'></a>                     <pre><code>@Entity
public class ConfigEntry extends BaseEntity {
  @Column(unique = true, nullable = false)
  private String entryKey;

  @Column
  private String value;

  //+ getter and setter ...
}
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:ds-data_repository'> Entity Repository Based on DeltaSpike Data </a>  shows a partial bean
that is brought to life by a generic handler in the Data module of DeltaSpike.
The annotation  <span class='latex-texttt'>@org.apache.deltaspike.data.api.Repository</span>  marks this interface as a partial bean,
whereby the DeltaSpike handler generates queries based on method names or optional metadata.
In our case, we add the metadata  <span class='latex-texttt'>@Query(singleResult = OPTIONAL)</span>
that enables an optional result.
Furthermore,  <span class='latex-texttt'>ConfigRepository</span>  extends the interface  <span class='latex-texttt'>org.apache.deltaspike.data.api.EntityRepository</span> ,
which provides methods such as  <span class='latex-texttt'>#save</span> ,  <span class='latex-texttt'>#remove</span> ,  <span class='latex-texttt'>#count</span> ,  <span class='latex-texttt'>#findAll</span> , and many more.
When specifying the type parameters, we provide both the entity type and the type of the primary key.
In our case, the entity type is the class  <span class='latex-texttt'>ConfigEntry</span>  and the primary key is defined as a String in  <span class='latex-texttt'>BaseEntity</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-data_repository'></a>                     <pre><code>@org.apache.deltaspike.jpa.api.transaction.Transactional
@org.apache.deltaspike.data.api.Repository
public interface ConfigRepository
  extends EntityRepository&lt;ConfigEntry, String&gt; {

    @Query(singleResult = OPTIONAL)
    ConfigEntry findByEntryKey(String key);
}
</code></pre>
                </div> We could inject our repository without any further annotation into, for example, EJBs or transactional services as usual with  <span class='latex-texttt'>@Inject</span> .
We can then call the predefined or self-defined methods.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> If the repository itself should be transactional, it must additionally be marked with  <span class='latex-texttt'>@Transactional</span> .
Partial beans do have minor limitations, however, as for example CDI decorators cannot be used.
If decorators are needed, we would have to stick with  <span class='latex-texttt'>GenericJpaRepository</span>  from  <span class='latex-textit'>IdeaFork</span>  Core.
For this reason, we do not convert the remaining repositories of  <span class='latex-textit'>IdeaFork</span>  Core.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span> , we want to integrate  <span class='latex-texttt'>ConfigRepository</span>  with an additional  <span class='latex-texttt'>ConfigSource</span> .
The class  <span class='latex-texttt'>DataBaseAwareConfigSource</span>  from Listing  <a href='#!idx:/deltaspike.html:fig:db_aware_config-source'> Config Source for Loading Values from a Database </a>  this time directly implements the interface
 <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span> .
As the ordinal value, we choose a high value that ensures this config source is queried first in the chain.
The method  <span class='latex-texttt'>#getProperties</span>  only needs to be meaningfully implemented
when the method  <span class='latex-texttt'>#isScannable</span>  returns the value  <span class='latex-texttt'>"true"</span> .
This is only necessary if we need the method  <span class='latex-texttt'>ConfigResolver#getAllProperties</span>  in our application.
The method  <span class='latex-texttt'>#getConfigName</span>  is primarily needed for log entries, so that, for example, a possible error search becomes easier.
The main part of  <span class='latex-texttt'>DataBaseAwareConfigSource </span>  is found in the method  <span class='latex-texttt'>#getPropertyValue</span> .
With  <span class='latex-texttt'>BeanManagerProvider#isActive</span> , we can check whether  <span class='latex-texttt'>BeanProvider</span>  can already be used.
We need it for a dynamic lookup of  <span class='latex-texttt'>ConfigRepository</span> .
Additionally, we can filter out keys that start with  <span class='latex-texttt'>"deltaspike."</span> ,
since we do not want to load the configuration of DeltaSpike itself from the database.
Once our partial bean named  <span class='latex-texttt'>ConfigRepository</span>  is found,
we can try to load the configuration entry from the database for the sought key via the method  <span class='latex-texttt'>#findByEntryKey</span> .
If a corresponding entry is found, we use the result of the method  <span class='latex-texttt'>#getValue</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:db_aware_config-source'></a>                     <pre><code>public class DataBaseAwareConfigSource implements ConfigSource {
  private final static int ordinal = 2000;

  @Override
  public int getOrdinal() {
    return ordinal;
  }

  @Override
  public String getPropertyValue(String key) {
    if (!BeanManagerProvider.isActive() ||
        key.startsWith("deltaspike.")) {

          return null;
    }

    ConfigRepository configRepository =
      BeanProvider.getContextualReference(ConfigRepository.class, true);

    if (configRepository != null) {
      ConfigEntry configEntry = configRepository.findByEntryKey(key);

      if (configEntry != null) {
        return configEntry.getValue();
      }
    }
    return null;
  }

  @Override
  public String getConfigName() {
    return "config-db";
  }

  @Override
  public boolean isScannable() {
    return false;
  }

  @Override
  public Map&lt;String, String&gt; getProperties() {
    return Collections.emptyMap();
  }
}
</code></pre>
                </div> Implementations of  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span>  are not used by DeltaSpike as CDI beans,
since this mechanism was originally designed primarily to configure parts of DeltaSpike itself
that must be fixed during container startup.
Consequently, it is a classic Java SPI and we must activate our class with its fully qualified name in the file
 <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.core.spi.config.ConfigSource</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> With this last step, we have extended our type-safe configuration with an additional configuration source
without making any further changes in  <span class='latex-textit'>IdeaFork</span> .
We can continue to store default values in the static configuration sources.
If a change is needed at runtime, we can store the new value in the database.
As soon as the cached configuration is refreshed manually or automatically,
the new values from the database take precedence due to the higher ordinal of our configuration source and thus become active.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span> , we can simulate this when starting the application if we use the  <span class='latex-texttt'>Development</span>  project stage.
In Java EE, there are many ways to implement initialization code.
For example, the  <span class='latex-texttt'>@Startup</span>  annotation can be used for EJBs,
the  <span class='latex-texttt'>ServletContainerInitializer</span>  interface for servlets, or the JSF event  <span class='latex-texttt'>PostConstructApplicationEvent</span> .
Since CDI 1.1 and therefore Java EE 7, observer methods can also be used for monitoring standard scopes.
An observer method that uses  <span class='latex-texttt'>@Observes @Initialized(ApplicationScoped.class)</span>
is called, for example, as soon as the application context has been initialized.
All variants have in common that only part of the server has started.
However, none of these variants guarantees the implementation of portable initialization logic
that is executed after the server has fully started.
For Java EE applications with JSF pages, as  <span class='latex-textit'>IdeaFork</span>  is, we can use a JSF add-on for DeltaSpike.
This add-on executes the initialization logic on the first JSF request, which guarantees
that the entire Java EE container is fully initialized.
This add-on additionally illustrates the configuration mechanism of DeltaSpike.
The add-on defines the configuration key  <span class='latex-texttt'>first-faces-request_event-class</span>  to specify the class of the startup event.
By default, the class  <span class='latex-texttt'>FirstFacesRequestEvent</span>  is used for this purpose.
This configuration entry is stored in the  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  file of the add-on.
In the same file,  <span class='latex-texttt'>deltaspike_ordinal=1</span>  defines a very low ordinal value.
Since the default value is higher,
we would not need to assign a value for  <span class='latex-texttt'>deltaspike_ordinal</span>  in the  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  of  <span class='latex-textit'>IdeaFork</span>
in order to override the default configuration.
However, when configuring a global transaction strategy, we already chose the value 1000,
which we can of course also keep.
In  <span class='latex-textit'>IdeaFork</span> , we want to use the class  <span class='latex-texttt'>IdeaForkStartedEvent</span>  and
therefore add a corresponding entry in the  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  file of  <span class='latex-textit'>IdeaFork</span> .
The DeltaSpike add-on also uses the previously introduced method  <span class='latex-texttt'>ConfigResolver#getProjectStageAwarePropertyValue</span> ,
which allows us to, for example, define a separate event for the  <span class='latex-texttt'>Development</span>  project stage.
Listing  <a href='#!idx:/deltaspike.html:fig:ds-addon_config'> Stage-Dependent Startup Event </a>  illustrates both configuration entries.
Both classes are simple (marker) classes without additional logic.
In the case of the  <span class='latex-texttt'>Development</span>  project stage, the value for  <span class='latex-texttt'>first-faces-request_event-class.Development</span>  is searched first.
Only if this is not present is the value for  <span class='latex-texttt'>first-faces-request_event-class</span>  loaded.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-addon_config'></a>                     <pre><code>first-faces-request_event-class=
  at.irian.cdiatwork.ideafork.core.api.startup.IdeaForkStartedEvent
first-faces-request_event-class.Development=
  at.irian.cdiatwork.ideafork.ee.infrastructure.DevStartupEvent
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:custom_startup-event'> Observing a Stage-Dependent Startup Event </a>  shows how we can use such a startup event.
In the concrete case, at the  <span class='latex-texttt'>Development</span>  project stage we change a configured value
by storing the desired value in the database using the  <span class='latex-texttt'>ConfigEntry</span>  entity.
For all subsequent accesses to  <span class='latex-texttt'>maxNumberOfHighestRatedCategories</span> ,
the value configured in the database is used.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_startup-event'></a>                     <pre><code>public class DataImporter {
  @Inject
  private ConfigRepository configRepository;

  protected void init(@Observes DevStartupEvent devStartupEvent) {
    configRepository.save(
      new ConfigEntry("maxNumberOfHighestRatedCategories", "2"));
  }
}
</code></pre>
                </div> As an alternative to  <span class='latex-texttt'>DevStartupEvent</span> , we could define an observer for the event  <span class='latex-texttt'>IdeaForkStartedEvent</span>  in a bean
that is annotated with  <span class='latex-textit'>@Exclude(exceptIfProjectStage = ProjectStage.Development.class)</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In our application, we can additionally have the class  <span class='latex-texttt'>DevStartupEvent</span>  extend  <span class='latex-texttt'>IdeaForkStartedEvent</span> ,
so that when the event  <span class='latex-texttt'>DevStartupEvent</span>  is fired, observers for the event  <span class='latex-texttt'>IdeaForkStartedEvent</span>  are also called.
The observer in Listing  <a href='#!idx:/deltaspike.html:fig:observer_for_custom_startup-event'> Observer for a Portable Startup Event </a> is thus called both in the  <span class='latex-texttt'>Development</span>  project stage and in the  <span class='latex-texttt'>Production</span>  project stage.
In our case, we use this observer to dynamically add  <span class='latex-texttt'>DataBaseAwareConfigSource</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:observer_for_custom_startup-event'></a>                     <pre><code>@ApplicationScoped
public class IdeaForkCoreStartupObserver {
    protected void onStartup(
      @Observes IdeaForkStartedEvent ideaForkStartedEvent,
      DataBaseAwareConfigSource configSource) {

        ConfigResolver.addConfigSources(
          Arrays.&lt;ConfigSource&gt;asList(configSource));
    }
}
</code></pre>
                </div> Through the dynamic registration, it is no longer necessary to configure the config source implementation in the file
 <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.core.spi.config.ConfigSource</span> .
An additional advantage is the simpler implementation of  <span class='latex-texttt'>DataBaseAwareConfigSource</span> ,
which can be seen in Listing  <a href='#!idx:/deltaspike.html:fig:changed_config-source'> Changes to DataBaseAwareConfigSource </a> .
Instead of the manual use of  <span class='latex-texttt'>BeanManagerProvider</span>  and  <span class='latex-texttt'>BeanProvider</span> , we can inject  <span class='latex-texttt'>ConfigRepository</span>  as usual via  <span class='latex-texttt'>@Inject</span> ,
because  <span class='latex-texttt'>DataBaseAwareConfigSource</span>  is now managed by the CDI container.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:changed_config-source'></a>                     <pre><code>@ApplicationScoped
public class DataBaseAwareConfigSource implements ConfigSource {
  //...

  @Inject
  private ConfigRepository configRepository;

  @Override
  public String getPropertyValue(String key) {
    if (key.startsWith("deltaspike.")) {
      return null;
    }

    ConfigEntry configEntry = configRepository.findByEntryKey(key);

    if (configEntry != null) {
      return configEntry.getValue();
    }
    return null;
  }

  //...
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.10' ><span class='entry-number'>5.10</span> Better Sooner Than Later</a> </h2>
 As we have already seen in this chapter, DeltaSpike extends the Java EE platform with diverse and innovative concepts.
Another aspect of DeltaSpike is the early provision of new Java EE concepts for older versions of Java EE.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Examples of this are the Servlet and the Bean Validation modules.
The Servlet module enables, for example, a portable injection of the current  <span class='latex-texttt'>HttpServletResponse</span>  instance.
In a Java EE6 server, this is already supported with  <span class='latex-texttt'>@Context</span> .
Only from Java EE7 onwards can  <span class='latex-texttt'>@Inject</span>  also be used for this purpose.
The Servlet module of DeltaSpike allows injection via  <span class='latex-texttt'>@Inject</span>  in combination with the  <span class='latex-texttt'>@DeltaSpike</span>  qualifier.
Through the qualifier, the injection point is not only usable with Java EE6 and in a servlet container with CDI,
but also without changes in a Java EE7 server and every subsequent version.
The functionality is therefore available before EE7 and is furthermore completely portable.
Listing  <a href='#!idx:/deltaspike.html:fig:ds-qualifier'> Injection via @DeltaSpike Qualifier </a>  shows an excerpt from  <span class='latex-texttt'>IdeaExporter</span>  that is adjusted accordingly.
As soon as the Servlet module of DeltaSpike is added, the injection point in  <span class='latex-texttt'>IdeaExporter</span>  can be filled.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-qualifier'></a>                     <pre><code>@Path("/idea/")
@Produces(MediaType.APPLICATION_JSON)
public class IdeaExporter {
    @Inject
    @DeltaSpike
    private HttpServletResponse response;

  //...
}
</code></pre>
                </div> Besides the injection of  <span class='latex-texttt'>(Http)ServletResponse</span> , the Servlet module also supports the injection of the current
 <span class='latex-texttt'>ServletContext</span> ,  <span class='latex-texttt'>(Http)ServletRequest</span> ,  <span class='latex-texttt'>HttpSession</span> , and  <span class='latex-texttt'>Principal</span>  instances.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The Bean Validation module of DeltaSpike offers a similar advantage.
In the previous chapter, we implemented  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span> ,
which enabled CDI-based injection in constraint validators.
DeltaSpike also provides exactly this functionality.
For this, we need to add the Bean Validation module and change the configuration entry in the  <span class='latex-texttt'>validation.xml</span>  file.
Listing  <a href='#!idx:/deltaspike.html:fig:ds_bean-validation'> Activating CDIAwareConstraintValidatorFactory </a>  illustrates the new content of this configuration file.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds_bean-validation'></a>                     <pre><code>&lt;validation-config&gt;
  &lt;constraint-validator-factory&gt;
    org.apache.deltaspike.beanvalidation.impl
      .CDIAwareConstraintValidatorFactory
  &lt;/constraint-validator-factory&gt;
&lt;/validation-config&gt;
</code></pre>
                </div> In contrast to the original implementation named  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span> ,
DeltaSpike's  <span class='latex-texttt'>CDIAwareConstraintValidatorFactory</span>  can also be used with Java EE7.
While EE7 already provides this functionality automatically,
the additional compatibility with EE7 means that  <span class='latex-textit'>IdeaFork</span>  is compatible with EE7 servers without any changes.
With EE7, we could remove this configuration and the corresponding module entirely from  <span class='latex-textit'>IdeaFork</span> ,
but in that case  <span class='latex-textit'>IdeaFork</span>  would no longer be compatible with EE6.<br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.11' ><span class='entry-number'>5.11</span> Safe Paths</a> </h2>
 We conclude this chapter with a page-bean test.
In our case, we want to test the promotion wizard in a type-safe manner.
In addition to the page-bean logic, the persisted result should also be verified.
Unlike frameworks such as JBoss Arquillian, we do not create micro test deployments
that are deployed and tested in a full EE server.
So far, we have used  <span class='latex-texttt'>CdiTestRunner</span>  from the Test-Control module.
This module starts the desired CDI container using the CDI Control module of DeltaSpike,
but not a complete EE server.
For page-bean tests, however, we also need a running JSF container.
To integrate other containers such as a mocked JSF container,
the  <span class='latex-texttt'>org.apache.deltaspike.testcontrol.spi.ExternalContainer</span>  SPI can be used.
The Test-Control module of DeltaSpike contains various adapters for MyFaces-Test.
For example, we can activate  <span class='latex-texttt'>org.apache.deltaspike.testcontrol.impl.jsf.MyFacesContainerAdapter</span>  in the file
 <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.testcontrol.spi.ExternalContainer</span> .
Through this configuration and the corresponding test dependencies for MyFaces-Test, not only is a mocked JSF container
automatically started, but the request and session scopes are also started as they are for CDI.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:register_user'> User Registration and Login via Page-Bean Test </a> , we register a new  <span class='latex-texttt'>User</span>  via the  <span class='latex-texttt'>RegistrationViewCtrl</span>  bean of  <span class='latex-textit'>IdeaFork</span> .
Our page beans are defined with our own stereotype annotation  <span class='latex-texttt'>@ViewController</span> .
This stereotype specifies the View-Access Scope from DeltaSpike as the default scope.
Since this scope builds upon the window scope,
we must activate the corresponding window context before each test method,
provided that methods of a page bean are called in the test.
In our test, this is implemented in the  <span class='latex-texttt'>@Before</span>  callback named  <span class='latex-texttt'>#initTestWindow</span> with the call to the method  <span class='latex-texttt'>#activateWindow</span> .
Consequently, we can call, for example,  <span class='latex-texttt'>RegistrationViewCtrl#getNewUser</span>  in our test.
Any string can be used as the window ID.
In page-bean tests, this call creates a simulated browser window with the ID  <span class='latex-texttt'>"testWindow"</span>  before each test method.
As before,  <span class='latex-texttt'>CdiTestRunner</span>  of course continues to restart the request and session scopes for each test method.
In the background, the window context stores all data under the specified window ID in the session.
These two aspects ensure that each test method can assume a fresh window context.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For the tests of the promotion wizard beans, we need a registered and logged-in  <span class='latex-texttt'>User</span> .
We could do this manually using the responsible services and beans, or also with page beans of these pages.
We choose the second variant and begin in our test method named  <span class='latex-texttt'>#flowFromRegistrationToIdeaPromotion</span> with the calls to the setter methods
that are normally filled automatically by JSF based on the value bindings in the  <span class='latex-texttt'>registration.xhtml</span>  page.
Then we call the action method  <span class='latex-texttt'>#register</span>  and verify the navigation result.
By using the type-safe view config as the navigation result,
we can also benefit from type safety and its associated advantages in tests.
We finish the verification of this first part by calling the JSF API
to check that not only the navigation result meets expectations
but also that a message was added.
This is one of the main differences between page-bean tests and full UI tests.
The advantage is the easier creation of tests.
However, at least some of the flows that are normally executed automatically must be manually replicated.
Some results, moreover, cannot be verified in the rendered response
but rather through the corresponding JSF APIs.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:register_user'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  @Inject
  private WindowContext windowContext;

  @Inject
  private RegistrationViewCtrl registrationViewCtrl;

  @Before
  public void initTestWindow() {
    windowContext.activateWindow("testWindow");
  }

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    registrationViewCtrl.getNewUser().setNickName("os890");
    registrationViewCtrl.getNewUser().setEmail("os890@test.org");
    registrationViewCtrl.getNewUser().setPassword("test");
    Class&lt;? extends ViewConfig&gt; navigationResult =
      registrationViewCtrl.register();

    Assert.assertEquals(Pages.User.Login.class, navigationResult);
    Assert.assertFalse(
      FacesContext.getCurrentInstance().getMessageList().isEmpty());

    //...
  }
}
</code></pre>
                </div> When we want to test a use case with a single test method that spans multiple pages,
it is necessary to divide the test method into multiple logical requests.
Listing  <a href='#!idx:/deltaspike.html:fig:simulate_requests'> Restarting the Request Scope in a Test Method </a>  illustrates how we can restart the request scope using the CDI Control API.
After the request context is stopped, it can be started again immediately.
Normally, the JSF module of DeltaSpike automatically ensures that the window ID is restored at the beginning of each request.
We must also manually replicate this aspect by calling the previously introduced method  <span class='latex-texttt'>#initTestWindow</span>  in the method  <span class='latex-texttt'>#newRequest</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:simulate_requests'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...
  @Inject
  private ContextControl contextControl;

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    newRequest();

    //...
  }

  private void newRequest() {
    contextControl.stopContext(RequestScoped.class);
    contextControl.startContext(RequestScoped.class);
    initTestWindow();
  }
}
</code></pre>
                </div> After the successful registration of a test user, we start a new logical request
to log in the just-created user via the  <span class='latex-texttt'>LoginViewCtrl</span>  page bean.
We proceed in a similar manner as with the registration.
After we have called the corresponding setter methods and finally the action method,
we can verify the navigation result.
Here too, we can subsequently check via the JSF API whether a message was added.
To verify that it is not the message from the previous request,
we begin in Listing  <a href='#!idx:/deltaspike.html:fig:check_faces-messages'> Verifying Messages in a Logical Request </a>  with a check for an empty message list.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:check_faces-messages'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...

  @Inject
  private LoginViewCtrl loginViewCtrl;

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    Assert.assertTrue(
      FacesContext.getCurrentInstance().getMessageList().isEmpty());

    loginViewCtrl.setEmail("os890@test.org");
    loginViewCtrl.setPassword("test");
    navigationResult = loginViewCtrl.login();
    Assert.assertEquals(Pages.Idea.Overview.class, navigationResult);

    Assert.assertFalse(
      FacesContext.getCurrentInstance().getMessageList().isEmpty());

    //...
  }

  //...
}
</code></pre>
                </div> In the previous example, however, we overlooked one aspect.
Between the execution of the action method and the rendering of the added message, a redirect is performed in the real application.
We could simulate this with another call to the method  <span class='latex-texttt'>#newRequest</span> .
Had we done this before verifying the messages, the check would have failed.
The reason is that DeltaSpike only preserves JSF messages across a real redirect.
When it is not about handling messages,
we can still use the method  <span class='latex-texttt'>#newRequest</span>  to simulate a redirect.
In Listing  <a href='#!idx:/deltaspike.html:fig:test_with_view-controller_methods'> Testing with View Controller Methods </a> , for example,
after calling the action method  <span class='latex-texttt'>#save</span> , we can start a new logical request by calling the method  <span class='latex-texttt'>#newRequest</span>  before manually calling the callback method  <span class='latex-texttt'>#onPreRenderView</span>  and
verifying the result of the method  <span class='latex-texttt'>#getSelectableIdeaList</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:test_with_view-controller_methods'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...

  @Inject
  private IdeaCreateViewCtrl ideaCreateViewCtrl;

  @Inject
  private NavigationController navigationController;

  @Inject
  private PromotionWizardCtrl promotionWizardCtrl;

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    newRequest();

    final String topic = "Test Page-Beans";
    final String category = "test";

    ideaCreateViewCtrl.setTopic(topic);
    ideaCreateViewCtrl.setCategory(category);
    navigationResult = ideaCreateViewCtrl.save();
    Assert.assertEquals(Pages.Idea.Overview.class, navigationResult);

    newRequest();

    navigationResult = navigationController.toIdeaPromotionWizard();
    Assert.assertEquals(
      Pages.PromotionWizard.Step1.class, navigationResult);

    newRequest(); //simulates a redirect

    promotionWizardCtrl.onPreRenderView();

    List&lt;SelectableEntity&lt;Idea&gt;&gt; selectableIdeas =
      promotionWizardCtrl.getSelectableIdeaList();
    Assert.assertNotNull(selectableIdeas);
    Assert.assertEquals(1, selectableIdeas.size());

    //...
  }

  //...
}
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span> , we use a table for selecting ideas that can be promoted.
Here too, in our page-bean test, we must select an idea and manually pass it to the action method named  <span class='latex-texttt'>#select</span> .
In the previous listing, we already assigned the result of the page-bean method  <span class='latex-texttt'>#getSelectableIdeaList</span> to the local variable  <span class='latex-texttt'>selectableIdeas</span> .
In Listing  <a href='#!idx:/deltaspike.html:fig:simulate_ui-selection'> Selecting an Entry </a> , we select an entry from this list and
pass it to the method  <span class='latex-texttt'>promotionWizardCtrl#select</span> .
Then we navigate as usual with the subsequent request to the next page of the wizard.
With the call to the action method  <span class='latex-texttt'>#toStep2</span> , we confirm this wizard step for selecting an idea.
In the remaining wizard steps, we enter a description for the promotion request and finally save it.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:simulate_ui-selection'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    newRequest();

    promotionWizardCtrl.select(selectableIdeas.iterator().next());

    newRequest();

    navigationResult = promotionWizardCtrl.toStep2();
    Assert.assertEquals(
      Pages.PromotionWizard.Step2.class, navigationResult);

    newRequest(); //simulates a redirect

    promotionWizardCtrl.onPreRenderView();

    newRequest();

    promotionWizardCtrl.getPromotionRequest()
      .setDescription("promote it");
    navigationResult = promotionWizardCtrl.showConfirmation();
    Assert.assertEquals(
      Pages.PromotionWizard.FinalStep.class, navigationResult);

    newRequest(); //simulates a redirect

    promotionWizardCtrl.onPreRenderView();

    newRequest();

    promotionWizardCtrl.savePromotionRequest();

    //...
  }

  //...
}
</code></pre>
                </div> How page-bean tests are implemented in detail can be adapted to the specific circumstances.
Even in page-bean tests, from a technical perspective, we can use any CDI beans as before.
In Listing  <a href='#!idx:/deltaspike.html:fig:mixed_page-bean_test'> Direct Access to Services </a> , we take a shortcut for the last step via the  <span class='latex-texttt'>IdeaService</span>  bean.
Since a different user is needed for confirming promotion requests,
a test using only page beans would require registering and logging in this user again.
Only then could we use  <span class='latex-texttt'>PromotionRequestListViewCtrl</span>  to review the promotion requests of other users.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:mixed_page-bean_test'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...

  @Inject
  private IdeaService ideaService;

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    newRequest();

    User testUser = new User("tester", null, null);
    List&lt;PromotionRequest&gt; foundPromotionRequests =
      ideaService.loadRecentIdeaPromotions(testUser, "*");
    Assert.assertNotNull(foundPromotionRequests);
    Assert.assertEquals(1, foundPromotionRequests.size());

    PromotionRequest loadedPromotionRequest =
      foundPromotionRequests.iterator().next();

    Assert.assertEquals("promote it",
      loadedPromotionRequest.getDescription());
    Assert.assertEquals(topic,
      loadedPromotionRequest.getIdeaForPromotion().getTopic());
    Assert.assertEquals(category,
      loadedPromotionRequest.getIdeaForPromotion().getCategory());

    //...
    newRequest();

    foundPromotionRequests =
      ideaService.loadRecentIdeaPromotions(testUser, "x");
    Assert.assertNotNull(foundPromotionRequests);
    Assert.assertTrue(foundPromotionRequests.isEmpty());
  }

  //...
}
</code></pre>
                </div><div class="tip"><b>Tip: </b> In the Git repository of  <span class='latex-textit'>IdeaFork</span> , in addition to the two checks for  <span class='latex-texttt'>#loadRecentIdeaPromotions</span> , there are further variants that verify different parameter values. </div> In our test, we demonstrated a complete walkthrough from registering a new user
through to verifying promotion requests from other users.
In doing so, we learned about various aspects such as simulating new requests, using page beans,
and the type-safe verification of navigation results in tests.
In practice, rather smaller portions of the application are tested per test method.
Even for such cases, data can first be created with other CDI beans, for example,
in order to test individual page beans with the state thus created in the application.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><div class="tip"><b>Tip: </b> Tests that verify complete use cases from UI logic down to the data access layer
typically take somewhat longer than simple unit tests, and
therefore a dedicated test profile named  <span class='latex-texttt'>DeltaSpikeTest</span>  is used in the Git repository of  <span class='latex-textit'>IdeaFork</span>  for these tests. </div> In this chapter, we gained a broad overview of the feature set of Apache DeltaSpike.
Additionally, we extended the available mechanisms with our own type-safe configuration.
In the next chapter, we will use DeltaSpike to integrate other containers such as Spring and Akka with CDI.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> With DeltaSpike 2.0, the migration to the <span class='latex-texttt' style='color:#2e7d32;'>jakarta.*</span> namespace was completed to ensure compatibility with Jakarta EE 10. Furthermore, MicroProfile Config in modern runtimes like Quarkus replaces significant parts of the configuration mechanism described here. See Chapter <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a> for namespace migration details and Chapter <a href='#!idx:/quarkus.html:10' style='color:#2e7d32;'>10</a> for Quarkus alternatives to DeltaSpike modules.</div>
</section><section class="chapter-section" id="chapter-6">
<h1> <a class='latex-index-anchor' name='!idx:/cdi_lite.html:6' ><span class='entry-number'>6</span> CDI Lite</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> The text of this chapter has been revised by Claude (Anthropic) as co-author. This revision was made without post-review by the original author. Use at your own risk.
</div>
<a name = '!idx:/cdi_lite.html:chap:cdi_lite'> </a> In the previous chapters, some readers may have gotten the impression that CDI is very extensive.
While the specification was written from scratch and does not suffer from legacy baggage,
in the end some concepts were also specified that may seem rather exotic.
In practice, however, it is not necessary or only rarely useful to employ all CDI concepts in a single application.
Therefore, in this chapter we take inventory of the current state and simplify the implementation of  <span class='latex-textit'>IdeaFork</span> ,
by keeping only the concepts that are meaningful for  <span class='latex-textit'>IdeaFork</span> .<br />
<div class="tip"><b>Tip: </b>The name &ldquo;IdeaForkLite&rdquo; refers to a simplified version of the application and has nothing to do with the CDI Lite specification (CDI 4.0). The CDI Lite specification defines a build-time compatible subset of CDI &mdash; see Chapter <a href='#!idx:/upgrade.html:9.3'>9.3</a> for the formal definition.</div>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.1' ><span class='entry-number'>6.1</span> Fewer Alternatives</a> </h2>
 In  <span class='latex-textit'>IdeaFork</span>  we used the concept of alternative implementations
to easily switch between frameworks such as GSon and Jackson during development time.
Since we relied on  <span class='latex-texttt'>@com.fasterxml.jackson.annotation.JsonView</span>  fairly early in  <span class='latex-textit'>IdeaFork</span> ,
our implementations of the  <span class='latex-texttt'>ObjectConverter</span>  interface are not fully portable.
Consequently, using Gson in  <span class='latex-textit'>IdeaFork</span>  would currently produce a different result.
By activating  <span class='latex-texttt'>@JacksonConverter</span>  in the  <span class='latex-texttt'>beans.xml</span>  file, we have not actively observed this effect.
If we do not supplement our Gson-based implementation, we no longer have any use for it.
The described mechanisms for dynamically determining the current export format can
also be used in various areas, but in  <span class='latex-textit'>IdeaFork</span>  we can limit ourselves to JSON as the export format.
The combination of both simplifications makes it possible to remove  <span class='latex-texttt'>@JacksonConverter</span>  as well as the qualifier  <span class='latex-texttt'>@ExternalFormat</span> ,
the  <span class='latex-texttt'>ObjectConverter</span>  interface, all JAXB annotations such as  <span class='latex-texttt'>@XmlRootElement</span> , and
the  <span class='latex-texttt'>CurrentObjectConverterProducer</span>  bean.
What remains is a simple CDI bean that delegates directly to Jackson, as shown in Listing  <a href='#!idx:/cdi_lite.html:fig:minimal_object-converter'> Object Converter Without Abstractions </a> .
This way we get rid of all the abstractions in this area
that we primarily introduced to illustrate various CDI mechanisms in  <span class='latex-textit'>IdeaFork</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_lite.html:fig:minimal_object-converter'></a>                     <pre><code>public class ObjectConverter {
  //...

  public String toString(Object entity, Class typeSafeDataView) {
    try {
      ObjectMapper objectMapper = new ObjectMapper();
      if (typeSafeDataView != null) {
        objectMapper.configure(
          MapperFeature.DEFAULT_VIEW_INCLUSION, false);
        return objectMapper.writerWithView(typeSafeDataView)
                 .writeValueAsString(entity);
      }
      return objectMapper.writeValueAsString(entity);
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(e);
    }
  }
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.2' ><span class='entry-number'>6.2</span> From Decorators to Interceptors</a> </h2>
 CDI decorators are among the concepts that are rather rarely encountered in the wild of (application) development.
In many cases a simple interceptor is sufficient.
In  <span class='latex-textit'>IdeaFork</span>  we used decorators to implement additional logic for  <span class='latex-texttt'>UserRepository</span>  and  <span class='latex-texttt'>IdeaRepository</span> .
The primary advantage here lies in the type safety of decorators.
If we were to rename the method  <span class='latex-texttt'>GenericRepository#save</span> , for example,
it is ensured that this change is reflected in all implementations.
This includes  <span class='latex-texttt'>GenericRepositoryDecorator</span>  as well.
If we had an interceptor instead, we would have to work manually with strings, which means type safety would no longer be guaranteed.
The additional effort for decorators can therefore be well justified.
In some cases it may also be reasonable to forgo the advantages of decorators.
For example, we can eliminate  <span class='latex-texttt'>GenericRepository</span> ,  <span class='latex-texttt'>GenericJpaRepository</span> , as well as our own  <span class='latex-texttt'>@Repository</span>  annotation
by using DeltaSpike Data.
However, we are not limited to the logic generated by DeltaSpike Data alone.
If we want to combine it with our own implementations, we need to use abstract classes instead of interfaces.
While implemented methods are called unchanged, DeltaSpike Data transforms abstract methods into corresponding JPA queries.
This mechanism allows us to easily mix custom logic with generated logic,
which means we can significantly simplify all repository beans.
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In a further step we can rework our decorator mechanism for repositories.
Since the  <span class='latex-texttt'>org.apache.deltaspike.data.api.EntityRepository</span>  interface contains all the methods
that we have previously "extended" in our decorators, and these do not change,
we can safely replace the type-safe decorators with a generic interceptor.<br />Listing  <a href='#!idx:/cdi_lite.html:fig:ds-data_with_interceptors'> DeltaSpike Data Repository with Interceptors </a>  shows a possible conversion of  <span class='latex-texttt'>UserRepository</span>  based on DeltaSpike Data.
After converting all other repositories in  <span class='latex-textit'>IdeaFork</span>  as well, we can delete the previously mentioned artifacts
such as  <span class='latex-texttt'>GenericJpaRepository</span>  and  <span class='latex-texttt'>UserRepositoryDecorator</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_lite.html:fig:ds-data_with_interceptors'></a>                     <pre><code>@Monitored
@EntityProcessor

@Transactional
@Repository
public abstract class UserRepository
  implements EntityRepository&lt;User, String&gt; {

  @Inject
  private EntityManager entityManager;

  public User loadByNickName(String nickName) {
    //...
  }

  public User loadByEmail(String email) {
    //...
  }
}
</code></pre>
                </div> Instead of the removed decorators we can introduce an interceptor called  <span class='latex-texttt'>EntityProcessorInterceptor</span> .
As Listing  <a href='#!idx:/cdi_lite.html:fig:entity-processor_interceptor'> EntityProcessor Interceptor </a>  illustrates, with  <span class='latex-texttt'>EntityProcessorInterceptor</span>  we have to resort to strings,
which means the implementation is not type-safe. In our case, however, we take advantage of the fact
that the methods of interest to us are predefined by DeltaSpike Data and therefore do not change.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_lite.html:fig:entity-processor_interceptor'></a>                     <pre><code>@Interceptor
@EntityProcessor
public class EntityProcessorInterceptor implements Serializable {

  @Inject
  private BeanManager beanManager;

  @Inject
  @Default
  private Event&lt;UserChangedEvent&gt; userChangedEvent;

  @Inject
  @Default
  private Event&lt;IdeaChangedEvent&gt; ideaChangedEvent;

  @AroundInvoke
  public Object intercept(InvocationContext ic) throws Exception {
    boolean saveMethod = false;
    boolean validateEntityParameter = false;

    Object[] parameters = ic.getParameters();
    if (parameters.length == 1) {
      Class parameterType = resolveParameterType(ic.getTarget());

      if (parameterType != null &&
          BaseEntity.class.isAssignableFrom(parameterType)) {

          String methodName = ic.getMethod().getName();

          if ("save".equals(methodName)) {
            saveMethod = true;
            validateEntityParameter = true;
          } else if ("remove".equals(methodName) ||
              "attachAndRemove".equals(methodName)) {

            validateEntityParameter = true;
          }
      }
    }

    if (validateEntityParameter) {
      checkEntity((BaseEntity) ic.getParameters()[0]);
    }

    Object result = ic.proceed();

    if (saveMethod) {
      if (parameters[0] instanceof User) {
        broadcastUserChangedEvent((User) ic.getParameters()[0]);
      } else if (parameters[0] instanceof Idea) {
        broadcastIdeaChangedEvent((Idea) ic.getParameters()[0]);
      }
    }

    return result;
  }

  private void checkEntity(BaseEntity entity) {
    //...
  }

  private Class resolveParameterType(Object target) {
    //...
  }

  private void broadcastUserChangedEvent(User entity) {
    UserChangedEvent userChangedEvent = new UserChangedEvent(entity);
        this.userChangedEvent.fire(userChangedEvent);
  }

  public void broadcastIdeaChangedEvent(Idea entity) {
        IdeaChangedEvent ideaChangedEvent = new IdeaChangedEvent(entity);
        this.ideaChangedEvent.fire(ideaChangedEvent);
  }
}
</code></pre>
                </div> By switching to an interceptor and to DeltaSpike Data, the reflection-based part of  <span class='latex-texttt'>GenericJpaRepository#detectConcreteEntityType</span>  has moved to  <span class='latex-texttt'>EntityProcessorInterceptor#resolveParameterType</span> .
So while we have significantly simplified some parts, a small portion using reflection remains.
We could only avoid this with specialized interceptors, which would be somewhat more complex to implement.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.3' ><span class='entry-number'>6.3</span> Less Is More</a> </h2>
 Strictly speaking, in  <span class='latex-textit'>IdeaFork</span>  we can also dispense with interceptor strategies,
since in one of the subsequent steps we will dissolve the  <span class='latex-texttt'>ideafork-core</span>  module, and
the customizability of the preconfigured  <span class='latex-texttt'>MonitoredInterceptor</span>  class becomes less important.
Consequently, we can remove the  <span class='latex-texttt'>MonitoredInterceptorStrategy</span>  interface and
move the corresponding implementation into  <span class='latex-texttt'>MonitoredInterceptor</span> .
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In other cases, such as with the Project Stages from DeltaSpike, it is often sufficient to use the existing mechanisms unchanged.
For instance, in  <span class='latex-textit'>IdeaFork</span>  we can use the predefined Project Stages from DeltaSpike without the  <span class='latex-texttt'>CustomProjectStage</span>  extension.
Especially in large projects it may become necessary to define additional stages.
DeltaSpike is extensible for such cases and is therefore well equipped for the requirements of real-world applications.
In  <span class='latex-textit'>IdeaFork</span> , however, the distinction between Project Stage  <span class='latex-texttt'>Development</span> ,  <span class='latex-texttt'>UnitTest</span> , and  <span class='latex-texttt'>Production</span>  is sufficient.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.4' ><span class='entry-number'>6.4</span> Following Conventions</a> </h2>
 DeltaSpike is very flexible and customizable. We saw one customization option with the type-safe view config.
In just a few steps we were able to change the path convention of a subsection.
However, if we adhere to the predefined conventions, the resulting view config is simpler and more transparent.
Listing  <a href='#!idx:/cdi_lite.html:fig:convention_based_view-config'> Simplified View Config </a>  shows the simplified excerpt for  <span class='latex-textit'>IdeaFork</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_lite.html:fig:convention_based_view-config'></a>                     <pre><code>@ViewConfigRoot(
  configDescriptorValidators = IdeaForkViewMetaDataValidator.class)
@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  @ViewControllerRef(IndexViewCtrl.class)
  class Index implements Pages {}

  @Secured(UserAwareAccessDecisionVoter.class)
  interface SecuredPages extends Pages {}

  interface User extends Pages {
    @EntryPoint
    class Login extends DefaultErrorView {}

    @EntryPoint
    class Registration implements User {}

    class Profile implements SecuredPages {}
  }

  //...

  interface Promotion extends SecuredPages {
    interface Selection extends Promotion {
      @View(viewParams = INCLUDE)
      @NavigationParameter(key = "searchHint", value = "*")
      @ViewControllerRef(PromotionRequestListViewCtrl.class)
      class List implements Selection {}

      @View(name = "promote")
      class SelectPromotion implements Selection {}
    }

    @Folder(name = "wizard")
    @Wizard
    interface PromotionWizard extends Promotion {
      @EntryPoint
      @ViewControllerRef(PromotionWizardCtrl.class)
      class Step1 implements PromotionWizard {}

      class Step2 implements PromotionWizard {}

      @View(name = "summary")
      class FinalStep implements PromotionWizard {}
    }
  }
}
</code></pre>
                </div> Naturally, the JSF pages must also be moved to match the new view config
so that the application continues to work as desired.
During this restructuring, one of the strengths of view configs becomes visible again.
While the existence of the configured pages is verified at application startup,
the compiler already ensures during the build process that all affected page navigations have been updated.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.5' ><span class='entry-number'>6.5</span> Reducing Layers</a> </h2>
 In the final step we also simplify the structure by dissolving the independent  <span class='latex-texttt'>ideafork-core</span>  module and
thereby removing unnecessary layers.
Originally we separated the  <span class='latex-texttt'>ideafork-core</span>  module from the rest of the Java EE application
to demonstrate that CDI can also be used independently of Java EE.
To preserve the naming separation of the two parts, we move the package  <span class='latex-texttt'>at.irian.cdiatwork.ideafork.core</span> into the existing  <span class='latex-texttt'>ideafork-ee6</span>  module.
This change is also reflected in the Maven build.
In the configuration for  <span class='latex-texttt'>ideafork-ee6</span>  we remove the references to  <span class='latex-texttt'>ideafork-core</span>  and
add instead all dependencies that were previously defined in  <span class='latex-texttt'>ideafork-core</span> .
This simplification also allows us to greatly simplify some build configurations for the different EE servers.<br /> <div class="tip"><b>Tip: </b> Due to the extensive restructuring, all changes are consolidated in a separate Git repository of  <span class='latex-textit'>IdeaFork</span> called  <span class='latex-textit'>IdeaForkLite</span> .
In this repository there is a separate commit for each transformation in this chapter.
This makes it easy to trace all changes. </div> The restructuring additionally enables the elimination of the manager layer,
since we no longer need this encapsulation in  <span class='latex-textit'>IdeaFork</span>  Core.
Instead, we move the implemented logic into the corresponding service classes,
which then access the new and greatly simplified repository beans directly.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> With the simplifications shown, we are well prepared for the subsequent chapters,
since, for example, in the next chapter we will increase the complexity somewhat through the integration of other frameworks.
In real-world applications it is not uncommon for multiple frameworks to have to be combined.
The lower we keep the complexity of the base structure, the more maintainable the entire application becomes.
Both CDI and DeltaSpike enable not only innovative and flexible approaches,
but also the reduction of complexity in areas where it is not required.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Since CDI 4.0 (Jakarta EE 10), the term "CDI Lite" has gained an official meaning as a specification profile that defines the build-time-compatible subset of CDI. The concept described in this chapter — using only the features you actually need — is independent of that, but follows a similar philosophy. The distinction between both meanings is explained in Chapter <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div>
<div class="tip"><b>Tip: </b><span class='latex-textit'>IdeaForkLite</span> demonstrated that CDI works efficiently outside a full Java EE server. Chapter <a href='#!idx:/cdi_usecases.html:8'>8</a> takes this approach further with <span class='latex-textit'>IdeaForkMicro</span> &mdash; a microservice architecture that uses CDI as its central component model.</div>
</section>
<section class="chapter-section" id="chapter-7">
<h1> <a class='latex-index-anchor' name='!idx:/integration.html:7' ><span class='entry-number'>7</span> CDI or Not CDI</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> The text of this chapter has been revised by Claude (Anthropic) as co-author. This revision was made without post-review by the original author. Use at your own risk.
</div>
<a name = '!idx:/integration.html:chap:cdi-integration'> </a> The relevance of a popular technology often only becomes apparent after years, once the initial hype has subsided.
With CDI, the outcome is clear. Many Java EE applications benefit from CDI, as application and
test logic can be implemented very efficiently.
Furthermore, with each version of Java EE the CDI integration of other specifications such as JSF is being expanded further,
making CDI an increasingly essential aspect of Java EE.
In the case of JSF, various new functionalities are even only supported in conjunction with CDI.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI also enjoys great popularity outside the Java EE platform.
Virtually every popular framework that integrates with dependency injection frameworks
either supports CDI directly or at least allows for a straightforward integration.
It has become quite difficult to find a popular framework without a CDI module.
One application framework that does not ship with CDI support is the actor framework Akka (see http://akka.io).
We take this as an opportunity to illustrate the easy integration of CDI with other frameworks.<br />
<div class="tip"><b>Tip: </b><b>DeltaSpike 2.0 and current project status:</b> DeltaSpike 2.0 supports the <span class='latex-texttt'>jakarta.*</span> namespace and is thus prepared for Jakarta EE 10+. However, development activity has notably decreased since the release of MicroProfile and Quarkus. For new projects, evaluate which DeltaSpike modules are still needed &mdash; many features have been absorbed into standards.</div>
<div class="tip"><b>Tip: </b>Many DeltaSpike innovations have been absorbed into CDI specifications or MicroProfile: configuration lives on in MicroProfile Config, <span class='latex-texttt'>@Exclude</span> has a counterpart in <span class='latex-texttt'>@Vetoed</span>, and the Security module has been standardized through Jakarta Security. For migration projects, evaluate which modules your project actually still needs versus standard alternatives.</div>
 <h2><a class='latex-index-anchor' name='!idx:/integration.html:7.1' ><span class='entry-number'>7.1</span> CDI Integration Through Producers</a> </h2>
 Before we can begin integrating CDI and Akka, it is important to know and
understand the fundamental characteristics of both technologies.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> We have already examined several details about CDI in the previous chapters.
Therefore, we can focus here on the most important aspects of Akka.
The central concept of Akka is actors.
Actors process messages asynchronously, where an actor instance is executed by a thread for processing a single message.
When an actor sends a message to another actor, further processing is normally carried out by a different thread.
Therefore, we cannot assume, as with Java EE,
that there is a kind of request that is completely processed by a single thread and only branches asynchronously in exceptional cases.
Only the message processing within an actor is assigned to a specific thread, which guarantees thread safety.
A message can be sent to an actor via a so-called actor reference.
This reference is not, like a contextual reference in CDI, valid indefinitely.
Since Akka defines different rules for various actor types in some versions,
what is primarily important for the following integration steps is that actor references are not always indefinitely valid and
it is safer to create new references regularly.<br /> <div class="tip"><b>Tip: </b> Another rule that is specific to Akka concerns the scope of an actor instance.
The Akka documentation recommends using only instances that are not managed by any other container.
In the case of CDI, this means using simple dependent-scoped beans for actors.
Because for dependent-scoped beans without interceptors and
decorators, the CDI container normally does not create a contextual reference in the form of a proxy.
Within the actor instances themselves we can inject CDI beans with other scopes,
provided the corresponding context is active when the contextual reference is accessed.
However, with Akka the injection must be done via constructor injection. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaForkLite</span>  we can use Akka for asynchronously firing CDI events.
Since actors themselves already run in their own threads,
we only need to enable CDI-based injection for actor instances in order to then fire CDI events synchronously within them.
Furthermore, we can also make it easier for CDI beans to send messages to actors.
In  <span class='latex-texttt'>EntityProcessorInterceptor</span>  of  <span class='latex-textit'>IdeaForkLite</span> , the event  <span class='latex-texttt'>IdeaChangedEvent</span>  is currently fired synchronously.
To fire the asynchronous variant of this event via an actor, we need to add an appropriate actor reference.
Since interceptors inherit the lifetime of the respectively intercepted CDI bean, we should not inject this actor reference directly.
While this would be technically possible, as mentioned earlier, actor references can become invalid.
Therefore, it makes sense to choose as short a scope as possible for CDI beans into which actor references are to be injected.
One possible variant in  <span class='latex-textit'>IdeaForkLite</span>  is to extract the previously mentioned event logic
into a CDI bean called  <span class='latex-texttt'>IdeaEventBroadcaster</span> , which is placed, for example, in the previously introduced transaction scope from DeltaSpike.
As we will see in the following steps, the actor reference itself must be a dependent-scoped CDI bean.
By combining a dependent-scoped actor reference with
its use in a transaction-scoped bean, we limit the lifetime of an actor reference in our example to a single transaction.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Akka provides its own class called  <span class='latex-texttt'>ActorRef</span>  for actor references.
Since this class is independent of a specific actor, we must, as shown in Listing  <a href='#!idx:/integration.html:fig:notify_akka_actor'> Notifying Akka Actors </a> ,
use a custom CDI qualifier called  <span class='latex-texttt'>@Actor</span> .
This self-defined CDI qualifier allows specifying the actor class,
so that we can later determine which actor the message should be delivered to.
We will examine the corresponding producer in one of the next steps.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:notify_akka_actor'></a>                     <pre><code>@TransactionScoped
public class EntityChangedEventBroadcaster {
  //...

  @Inject
  @Actor(type = IdeaChangedEventActor.class)
  private ActorRef asyncBroadcaster;

  public void broadcastIdeaChangedEvent(Idea entity) {
    IdeaChangedEvent ideaChangedEvent = new IdeaChangedEvent(entity);
    this.asyncBroadcaster.tell(ideaChangedEvent, this.asyncBroadcaster);
    //...
  }
}
</code></pre>
                </div> With the method  <span class='latex-texttt'>ActorRef#tell</span>  we can send a message to the underlying actor, which is delivered asynchronously by Akka.
The processing of the message sent in this way can, for example, take place as shown in Listing  <a href='#!idx:/integration.html:fig:actor_with_cdi-support'> Actor with CDI Support </a> .
The only requirement from Akka for implementing a Java actor is extending the class  <span class='latex-texttt'>UntypedActor</span> ,
which prescribes the actor method  <span class='latex-texttt'>#onReceive</span> .
Every message to an actor is processed by this method in its own actor thread.<br />In Listing  <a href='#!idx:/integration.html:fig:actor_with_cdi-support'> Actor with CDI Support </a> , a CDI event ( <span class='latex-texttt'>javax.enterprise.event.Event</span> ) is additionally injected via constructor injection.
Through the type parameterization to  <span class='latex-texttt'>IdeaChangedEvent</span>  and
the self-defined  <span class='latex-texttt'>@Async</span>  qualifier, we can fire a specifically qualified CDI event within the actor instance.
The actual firing of the CDI event using the  <span class='latex-texttt'>#fire</span>  method happens synchronously.
However, since the  <span class='latex-texttt'>#onReceive</span>  method itself is executed asynchronously,
the firing of the CDI event is asynchronous from the perspective of  <span class='latex-texttt'>EntityChangedEventBroadcaster</span>  and
therefore does not block its further execution.
The  <span class='latex-texttt'>@Async</span>  qualifier serves only to distinguish or select this new event type.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:actor_with_cdi-support'></a>                     <pre><code>public class IdeaChangedEventActor extends UntypedActor {
  private final Event&lt;IdeaChangedEvent&gt; entityChangedEvent;

  @Inject
  public IdeaChangedEventActor(
    @Async Event&lt;IdeaChangedEvent&gt; entityChangedEvent) {

    this.entityChangedEvent = entityChangedEvent;
  }

  @Override
  public void onReceive(Object message) throws Exception {
    if (message instanceof IdeaChangedEvent) {
      this.entityChangedEvent.fire((IdeaChangedEvent)message);
    } else {
      unhandled(message);
    }
  }
}
</code></pre>
                </div><span class='latex-texttt'>@Async IdeaChangedEvent</span>  represents a synchronous CDI event that is fired in an asynchronous actor thread.
The CDI event observer shown in Listing  <a href='#!idx:/integration.html:fig:async_event-observer'> CDI Event Observer for @Async IdeaChangedEvent </a>  accordingly follows the conventional rules for CDI observers.
The  <span class='latex-texttt'>@Async</span>  qualifier restricts the observer to events that, in our case, were fired by  <span class='latex-texttt'>IdeaChangedEventActor</span> .
Thus, the observer is executed in the same thread as  <span class='latex-texttt'>IdeaChangedEventActor</span> ,
but in a different thread than  <span class='latex-texttt'>EntityChangedEventBroadcaster</span> .
Consequently, the execution of  <span class='latex-texttt'>EntityProcessorInterceptor</span>  and the processing of the entire web request is not blocked either.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:async_event-observer'></a>                     <pre><code>@ApplicationScoped
public class IdeaHistoryProcessor {
    @Inject
    private ObjectConverter currentObjectConverter;

    @Inject
    private EntityChangeRepository entityChangeRepository;

    public void onIdeaCreated(
      @Observes @Async IdeaChangedEvent changedEvent) {
        Idea entity = changedEvent.getEntity();
        String ideaSnapshot = currentObjectConverter.toString(entity);
        EntityChange entityChange = new EntityChange(
                entity.getId(),
                entity.getVersion() != null ? entity.getVersion() : 0,
                ideaSnapshot,
                changedEvent.getCreationTimestamp());

        entityChangeRepository.save(entityChange);
    }
}
</code></pre>
                </div> The next step covers two aspects.
In Listing  <a href='#!idx:/integration.html:fig:notify_akka_actor'> Notifying Akka Actors </a>  we used an injection point of type  <span class='latex-texttt'>ActorRef</span> .
Since Akka currently does not have its own CDI module, we need a CDI producer for this type.
As already mentioned, we need an additional CDI qualifier
so that we can determine in the producer for which actor type an actor reference should be created.
Listing  <a href='#!idx:/integration.html:fig:custom_actor-qualifier'> Custom CDI Qualifier for Actors </a>  shows one possible variant of such a qualifier.
So that we do not need a CDI producer for each concrete actor type,
but only one generic producer for all injection points of type  <span class='latex-texttt'>ActorRef</span> , we must mark all annotation members
that are not needed for the assignment to a generic producer method with  <span class='latex-texttt'>@Nonbinding</span> .
In our example we evaluate all annotation members in the producer method itself and
therefore must annotate all of them with  <span class='latex-texttt'>@Nonbinding</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:custom_actor-qualifier'></a>                     <pre><code>@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD})
public @interface Actor {
  String AKKA_DEFAULT = "default";

  @Nonbinding
  Class&lt;? extends akka.actor.Actor&gt; type();

  @Nonbinding
  String systemName() default AKKA_DEFAULT;
}
</code></pre>
                </div> Instead of creating a separate CDI producer for each actor type, in our case  <span class='latex-texttt'>IdeaChangedEventActor</span>  and in the next section  <span class='latex-texttt'>UserRegisteredEventActor</span> ,
Listing  <a href='#!idx:/integration.html:fig:actor-ref_producer'> Producer for Actor References </a>  illustrates a generic producer method for all injection points
of type  <span class='latex-texttt'>ActorRef</span>  in combination with the  <span class='latex-texttt'>@Actor</span>  qualifier.
The required actor class is specified with  <span class='latex-texttt'>@Actor#type</span>  only in the CDI bean,
in our current example with  <span class='latex-texttt'>@Actor(type = IdeaChangedEventActor.class)</span> .
In the previous CDI producers we mostly used CDI qualifiers only for mapping between injection point and producer.
Such producers then created an instance independently of the injection point, which was assigned to the injection point.
In our current example this is not possible, because the result of the producer depends on metadata of the respective injection point.
This means our producer method must dynamically evaluate injection point metadata
to obtain the required information from  <span class='latex-texttt'>@Actor</span>  in the concrete case.
In other words, we must evaluate the metadata of the reference variable, in our example  <span class='latex-texttt'>ActorRef asyncBroadcaster</span> ,
before we can create a contextual instance that the CDI container assigns to this reference variable.
This approach may at first glance seem unnecessarily complicated, but it is always required
when a generic producer for injection points of a single type with different metadata is to be implemented.
CDI defines the interface  <span class='latex-texttt'>javax.enterprise.inject.spi.InjectionPoint</span>  for such special cases.
Any producer method for dependent-scoped beans can optionally use a parameter of type  <span class='latex-texttt'>InjectionPoint</span>
to evaluate the definition of the respective injection point.
For each invocation of such a producer method, the CDI container populates this parameter with an  <span class='latex-texttt'>InjectionPoint</span>  instance
that represents the current  <span class='latex-texttt'>InjectionPoint</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Via methods such as  <span class='latex-texttt'>InjectionPoint#getAnnotated#getAnnotation</span> , the metadata of the current injection point can be accessed.
In Listing  <a href='#!idx:/integration.html:fig:actor-ref_producer'> Producer for Actor References </a>  we retrieve the  <span class='latex-texttt'>@Actor</span>  instance from the injection point using the method just mentioned.
This instance of the  <span class='latex-texttt'>@Actor</span>  annotation contains all the values we specified at the injection point and
that are needed for creating a matching  <span class='latex-texttt'>ActorRef</span> .
 <span class='latex-texttt'>@Actor#type</span>  returns  <span class='latex-texttt'>IdeaChangedEventActor.class</span>  in our example and
 <span class='latex-texttt'>@Actor#systemName</span>  returns the default value  <span class='latex-texttt'>default</span> .<br /> <div class="tip"><b>Tip: </b> We know that  <span class='latex-texttt'>@Actor</span>  is present in our example
because our producer method is responsible for all injection points of type  <span class='latex-texttt'>ActorRef</span>
that are annotated with the  <span class='latex-texttt'>@Actor</span>  qualifier. </div> With the information just extracted, we can delegate the creation of the actor system to Akka.
The necessary Akka call for this is encapsulated in the method  <span class='latex-texttt'>#getActorSystem</span> .
The result of this call is an instance of type  <span class='latex-texttt'>akka.actor.ActorSystem</span> ,
which can be used to create an  <span class='latex-texttt'>ActorRef</span> .
Details on this can be found in the Git repository of  <span class='latex-textit'>IdeaForkLite</span> .
The actor system created by Akka can be stored in a map.
On each subsequent access to the same actor system, the already created actor system is reused.
To cache the actor systems directly in an  <span class='latex-texttt'>ActorRefProducer</span>  instance for the lifetime of the application,
this class is annotated with  <span class='latex-texttt'>@ApplicationScoped</span> .<br /> <div class="tip"><b>Tip: </b> The producer method is annotated not only with  <span class='latex-texttt'>@Produces</span>  but also with the  <span class='latex-texttt'>@Actor</span>  qualifier.
Since  <span class='latex-texttt'>@Actor#type</span>  does not define a default value,
as is the case with  <span class='latex-texttt'>@Actor#systemName</span> , we must specify an arbitrary but valid value at this point
to avoid a compilation error. The value  <span class='latex-texttt'>akka.actor.Actor.class</span>  specified here is ignored at runtime,
as it is only needed for the compilation process. </div> The final step in the producer method from Listing  <a href='#!idx:/integration.html:fig:actor-ref_producer'> Producer for Actor References </a>  enables the injection of CDI beans into actor instances.
If the actor implementation extends  <span class='latex-texttt'>UntypedActor</span> , the actor system is informed
that  <span class='latex-texttt'>CdiAwareCreator</span>  should be used for creating actor instances.
 <span class='latex-texttt'>CdiAwareCreator</span>  implements the interface  <span class='latex-texttt'>akka.japi.Creator</span>  and is initialized with the desired actor class.
Since we should use dependent-scoped beans as actors,
we delegate in the method  <span class='latex-texttt'>CdiAwareCreator#create</span>  to  <span class='latex-texttt'>BeanProvider#getDependent#get</span> .
The class of the actor instance to be created is passed to the method  <span class='latex-texttt'>BeanProvider#getDependent</span> .
As a result, this DeltaSpike helper method returns an instance of type  <span class='latex-texttt'>org.apache.deltaspike.core.api.provider.DependentProvider</span> .
This data structure encapsulates the dependent-scoped instance together with the associated metadata
needed for later destruction of the instance by calling  <span class='latex-texttt'>DependentProvider#destroy</span> .
By calling the  <span class='latex-texttt'>#get</span>  method, we provide Akka with the dependent-scoped instance.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:actor-ref_producer'></a>                     <pre><code>@ApplicationScoped
public class ActorRefProducer {
  private Map&lt;String, ActorSystem&gt; actorSystemMap =
    new HashMap&lt;String, ActorSystem&gt;();

  @Produces
  @Actor(type = akka.actor.Actor.class)
  protected ActorRef createActorRef(InjectionPoint injectionPoint) {
    final Actor actorQualifier = injectionPoint.getAnnotated()
      .getAnnotation(Actor.class);

    ActorSystem actorSystem = getActorSystem(actorQualifier.systemName());

    if (!UntypedActor.class.isAssignableFrom(actorQualifier.type())) {
      actorSystem.actorOf(Props.create(actorQualifier.type()));
    }
    return actorSystem.actorOf(Props.create(
      new CdiAwareCreator(actorQualifier.type())));
  }

  public ActorSystem getActorSystem(String actorSystemName) {
    ActorSystem actorSystem = actorSystemMap.get(actorSystemName);
    if (actorSystem == null || actorSystem.isTerminated()) {
      actorSystem = bootActorSystem(actorSystemName);
    }

    return actorSystem;
  }

  private synchronized ActorSystem bootActorSystem(
    String actorSystemName) {

    ActorSystem actorSystem = actorSystemMap.get(actorSystemName);
    if (actorSystem != null && !actorSystem.isTerminated()) {
      return actorSystem;
    }

    actorSystem = ActorSystem.create(actorSystemName);
    actorSystemMap.put(actorSystemName, actorSystem);
    return actorSystem;
  }

  @PreDestroy
  protected void cleanup() {
        for (ActorSystem actorSystem : actorSystemMap.values()) {
            if (!actorSystem.isTerminated()) {
                actorSystem.shutdown();
            }
        }
  }

  private static class CdiAwareCreator
    implements Creator&lt;akka.actor.Actor&gt; {

    private static final long serialVersionUID = 3739310463390426896L;

    private final Class&lt;? extends akka.actor.Actor&gt; actorClass;

    public CdiAwareCreator(Class&lt;? extends akka.actor.Actor&gt; actorClass) {
      this.actorClass = actorClass;
    }

    @Override
    public akka.actor.Actor create() throws Exception {
      return BeanProvider.getDependent(actorClass).get();
    }
  }
}
</code></pre>
                </div> Akka registers the provided instance internally and creates the corresponding  <span class='latex-texttt'>ActorRef</span>  instance,
which we finally return as the result of the producer method.
Producer methods in which injection point information is evaluated must create dependent-scoped beans.
Since Akka does not have an extended scope concept anyway, we do not need to consider any additional aspects in the integration of both containers.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The destruction of actor instances is handled by Akka itself (currently),
which means we cannot call  <span class='latex-texttt'>DependentProvider#destroy</span>  as usual.
For this reason, we can use  <span class='latex-texttt'>@PostConstruct</span>  in actors integrated in this way, but not  <span class='latex-texttt'>@PreDestroy</span> .
If we were to annotate a callback method with  <span class='latex-texttt'>@PreDestroy</span> , it would not be invoked.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> However, we do need to manually shut down the created actor systems when the application shuts down.
In the  <span class='latex-texttt'>@PreDestroy</span>  callback method called  <span class='latex-texttt'>ActorRefProducer#cleanup</span> , we call
the method  <span class='latex-texttt'>akka.actor.ActorSystem#shutdown</span>  on the respective instance for this purpose.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Due to the integration of Akka and CDI beans, we need to change the scope of  <span class='latex-texttt'>MonitoredStorage</span> .
Previously we assigned this CDI bean to the request context with  <span class='latex-texttt'>@RequestScoped</span> .
However, the request context is not active in an actor thread, so we must use  <span class='latex-texttt'>@ApplicationScoped</span>  instead, for example,
since it is always active. This change naturally requires that the bean is thread-safe.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In our CDI extension for validating application structures, we can add an additional check for actors.
Listing  <a href='#!idx:/integration.html:fig:actor-validation'> Validation of Actor Beans </a>  shows an example of such a validation.
In our case, we verify that all actor classes are explicitly or implicitly implemented as dependent-scoped beans.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:actor-validation'></a>                     <pre><code>public class AppStructureValidationExtension implements Extension {
  private List&lt;String&gt; violations = new ArrayList&lt;String&gt;();

  public void validateArtifacts(@Observes ProcessManagedBean pmb,
                                BeanManager beanManager) {
    Class beanClass = pmb.getAnnotatedBeanClass().getJavaClass();
    //...

    if (Actor.class.isAssignableFrom(beanClass)) {
      validateActor(beanClass,
        pmb.getAnnotatedBeanClass().getAnnotations(),
        beanManager);
    }
  }

  public void checkAndAddViolations(
    @Observes AfterDeploymentValidation afterDeploymentValidation) {

    //...
  }

  private void validateActor(Class beanClass, Set&lt;Annotation&gt; annotations,
                             BeanManager beanManager) {
    for (Annotation annotation : annotations) {
      if (beanManager.isScope(annotation.annotationType()) &&
        !Dependent.class.isAssignableFrom(annotation.annotationType())) {

        this.violations.add(
          "It isn't allowed to use " + annotation.annotationType() +
          " for Akka-Actors. " +
          "Please remove the annotation from " + beanClass.getName());
      }
    }
  }
}
</code></pre>
                </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the second section of this chapter we integrate CDI and Spring.
In the corresponding examples we also build on top of the Akka integration.<br /> <h2><a class='latex-index-anchor' name='!idx:/integration.html:7.2' ><span class='entry-number'>7.2</span> Beans from Other Worlds</a> </h2>
 Over time, various dependency injection frameworks have emerged.
Some of them served the CDI Expert Group directly or indirectly as inspiration when defining CDI.
While JBoss Seam, for example, has been superseded by CDI and Apache DeltaSpike,
projects like Google Guice and the Spring Framework continue to exist alongside CDI.
The feature set is similar across some of the available alternatives.
CDI is widely used in many Java EE applications
because CDI has been part of the platform since Java EE 6 and leaves little to be desired compared to the alternatives.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> As similar as the individual dependency injection frameworks are, their ecosystems are that different.
The Spring Framework in particular, with its long history, has a great many extensions.
How useful or necessary the individual extensions are depends heavily on the area of use.
In many cases the Spring Framework provides adapters for other technologies
to enable somewhat simpler usage of these technologies.
From the perspective of a Java EE application, it can therefore seem worthwhile to leverage such advantages
when there is no equivalent extension for CDI.
However, this is not a reason to fully migrate a CDI-based application to another framework like Spring.
As with the Akka integration earlier, we can again leverage the strong extensibility of CDI to benefit from both technologies.
We can implement a portable extension that allows Spring beans to be used in CDI beans.
Such an integration is widely known as a CDI/Spring bridge.
Over the years, various bridges have emerged in the CDI community.
The majority of them are unidirectional, but bidirectional implementations are also possible with some limitations.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaForkLite</span>  we want to implement a rudimentary Spring bridge
that enables a unidirectional injection of Spring beans into CDI beans.
Through such a bridge, Spring extensions can then be used in a primarily CDI-based application like  <span class='latex-textit'>IdeaForkLite</span> .
Specifically, we will extend  <span class='latex-textit'>IdeaForkLite</span>  with Spring Mail.
Apart from that, such bridges can also be used for the gradual migration from Spring to CDI.<br /> <div class="tip"><b>Tip: </b> Bidirectional CDI/Spring bridges allow not only the injection of Spring beans into CDI beans
but also the injection of CDI beans into Spring beans.
However, for both unidirectional and bidirectional bridges, a primary container must be defined.
This container is started first and is responsible for initiating the startup process of the other container. </div> Starting from a simple base configuration for Spring, we will use a portable CDI extension to start the Spring container and
register a corresponding adapter as a CDI bean for each Spring bean,
which delegates to the Spring container when creating a contextual instance.
Listing  <a href='#!idx:/integration.html:fig:portable-extension_to_start_spring'> Starting Spring via CDI Extension </a>  shows the skeleton for a CDI extension class called  <span class='latex-texttt'>SpringBridgeExtension</span> .
This extension class must, as is customary with CDI, be activated in the service-loader configuration file
 <span class='latex-texttt'>META-INF/services/javax.enterprise.inject.spi.Extension</span> .
After the successful startup of the Spring container in the observer method for the  <span class='latex-texttt'>AfterBeanDiscovery</span>  event,
we can assign the created  <span class='latex-texttt'>ConfigurableApplicationContext</span>  instance to an instance variable of the extension.
In Listing  <a href='#!idx:/integration.html:fig:portable-extension_to_start_spring'> Starting Spring via CDI Extension </a>  this variable is called  <span class='latex-texttt'>springContext</span> .
Since the CDI container creates only one instance per application and extension class,
we can access the stored Spring context in different phases of the container lifecycle.
In the  <span class='latex-texttt'>AfterBeanDiscovery</span>  observer we can evaluate the Spring bean definitions through the bean factory.
However, we are only interested in self-created Spring beans that we implement in our application.
With the method  <span class='latex-texttt'>AfterBeanDiscovery#addBean</span>  we therefore add CDI adapter beans only for those Spring beans
whose packages do not start with  <span class='latex-texttt'>org.springframework</span> .<br /> <div class="tip"><b>Tip: </b> Especially in older EE servers it can happen that instance variables in extension classes, in our case  <span class='latex-texttt'>springContext</span> ,
are only usable within a single observer method. In such cases, class-level (static) variables must be used instead.
The only alternative would be a server update. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:portable-extension_to_start_spring'></a>                     <pre><code>public class SpringBridgeExtension implements Extension {
  private ConfigurableApplicationContext springContext;

  public void initContainerBridge(
    @Observes AfterBeanDiscovery abd, BeanManager beanManager) {

    springContext = bootContainer();

    for (String beanName : springContext.getBeanDefinitionNames()) {
      BeanDefinition beanDefinition = springContext.getBeanFactory()
        .getBeanDefinition(beanName);
      Class&lt;?&gt; beanClass = springContext.getType(beanName);

      if (!beanClass.getName().startsWith("org.springframework.")) {
        abd.addBean(createBeanAdapter(
          beanClass, beanName, beanDefinition,
          springContext, beanManager));
      }
    }
  }

  public void cleanup(@Observes BeforeShutdown beforeShutdown) {
    springContext.close();
  }

  private &lt;T&gt; Bean&lt;T&gt; createBeanAdapter(
    Class&lt;T&gt; beanClass, String beanName,
    BeanDefinition beanDefinition,
    ConfigurableApplicationContext applicationContext,
    BeanManager bm) {

    //...
  }

  private ConfigurableApplicationContext bootContainer() {
    //...
  }
}
</code></pre>
                </div> The implementation of the  <span class='latex-texttt'>#createBeanAdapter</span>  method from Listing  <a href='#!idx:/integration.html:fig:create_adapter-beans'> Creating CDI Bean Adapters for Spring Beans </a>  illustrates
that DeltaSpike provides helpful concepts here as well.
With  <span class='latex-texttt'>AnnotatedTypeBuilder</span> , an  <span class='latex-texttt'>AnnotatedType</span>  instance can be created based on arbitrary classes.
In our example we could also use  <span class='latex-texttt'>BeanManager#createAnnotatedType</span>  for this purpose.
However, with  <span class='latex-texttt'>AnnotatedTypeBuilder</span>  we could influence the generated result,
for example by adding or removing bean metadata.
A comparable builder called  <span class='latex-texttt'>BeanBuilder</span>  also exists for  <span class='latex-texttt'>javax.enterprise.inject.spi.Bean</span> .
With this builder we modify various properties in Listing  <a href='#!idx:/integration.html:fig:create_adapter-beans'> Creating CDI Bean Adapters for Spring Beans </a>
so that the adapter for the Spring bean works as efficiently as possible.
For example, we use  <span class='latex-texttt'>@Dependent</span>  as the scope annotation in every case,
since the Spring container is responsible for the scope of the Spring beans.
The reference to a Spring bean returned by the Spring context is thus used unchanged.
The bean name in our example is also taken from Spring.
Since the Spring container populates the injection points of Spring beans,
we can in a further step use the  <span class='latex-texttt'>#injectionPoints</span>  method to remove all injection points from CDI's perspective.
Up to this point, however, we are only creating an empty adapter.
Only by implementing and registering a  <span class='latex-texttt'>ContextualLifecycle</span>  instance
can we delegate to the Spring context when creating the CDI bean.
In our case, we call the implementation  <span class='latex-texttt'>SpringAwareBeanLifecycle</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:create_adapter-beans'></a>                     <pre><code>private &lt;T&gt; Bean&lt;T&gt; createBeanAdapter(
  Class&lt;T&gt; beanClass, String beanName,
  BeanDefinition beanDefinition,
  ConfigurableApplicationContext applicationContext, BeanManager bm) {

  String beanScope = beanDefinition.getScope();
  ContextualLifecycle lifecycleAdapter =
    new SpringAwareBeanLifecycle(applicationContext, beanName, beanScope);

   beanClass = ProxyUtils.getUnproxiedClass(beanClass);
    return new BeanBuilder&lt;T&gt;(bm)
      .readFromType(new AnnotatedTypeBuilder&lt;T&gt;()
        .readFromType(beanClass).create())
      .name(beanName)
      .beanLifecycle(lifecycleAdapter)
      .injectionPoints(Collections.&lt;InjectionPoint&gt;emptySet())
      .scope(Dependent.class)
      .create();
}
</code></pre>
                </div><span class='latex-texttt'>SpringAwareBeanLifecycle</span>  from Listing  <a href='#!idx:/integration.html:fig:contextual-lifecycle_for_spring-beans'> Contextual Lifecycle for Spring Beans </a> delegates the management of bean instances to the Spring context using the  <span class='latex-texttt'>#getBean</span>  method.
From the CDI container's perspective, the result is a simple dependent-scoped bean.
Accordingly, the rules for dependent-scoped beans are applied.
The equivalent Spring scope is called prototype scope.
Therefore, when destroying the contextual instance through the CDI container,
we may only forward the call to the  <span class='latex-texttt'>#destroyBean</span>  method
if it is the prototype scope.
Otherwise, the Spring container must manage the lifetime of the corresponding Spring bean depending on its scope.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:contextual-lifecycle_for_spring-beans'></a>                     <pre><code>class SpringAwareBeanLifecycle implements ContextualLifecycle {
  private final ConfigurableApplicationContext applicationContext;
  private final String beanName;
  private final boolean prototypeScope;

  public SpringAwareBeanLifecycle(
    ConfigurableApplicationContext applicationContext,
    String beanName, String scope) {

    this.applicationContext = applicationContext;
    this.beanName = beanName;
    this.prototypeScope = "prototype".equalsIgnoreCase(scope);
  }

  @Override
  public Object create(Bean bean, CreationalContext creationalContext) {
    return this.applicationContext.getBean(this.beanName);
  }

  @Override
  public void destroy(Bean bean, Object instance,
                      CreationalContext creationalContext) {

    if (this.prototypeScope) {
      this.applicationContext.getBeanFactory()
        .destroyBean(this.beanName, instance);
    }
  }
}
</code></pre>
                </div> Our rudimentary CDI/Spring bridge is now complete and we can implement our first Spring bean,
which we will inject into a CDI bean in a further step.
As mentioned at the beginning, we will use Spring Mail for demonstration purposes.
In practice, it is of course more natural to evaluate alternatives such as Apache Commons Email,
since no additional container is required for that.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/integration.html:fig:simple_spring-bean'> Simple Spring Bean </a>  shows a simple implementation of a Spring bean
that delegates the actual sending to  <span class='latex-texttt'>JavaMailSender#send</span>  from Spring Mail.
Since we only implement one Spring bean in  <span class='latex-textit'>IdeaForkLite</span> , we do not create a separate module.
For this reason, the CDI container also sees this bean.
However, the CDI adapter bean for this Spring bean receives the same type.
Therefore, we must make this class invisible to the CDI container.
In our example we use  <span class='latex-texttt'>@Exclude</span>  from DeltaSpike for this purpose.
This would of course not be necessary if we provided Spring beans outside of a BDA for CDI.<br /> <div class="tip"><b>Tip: </b> A similar aspect must also be considered from the Spring container's perspective.
If the Spring container were to see all CDI beans of  <span class='latex-textit'>IdeaForkLite</span> , we would register adapter beans for Spring beans
that are already CDI beans and are only supposed to be visible to the CDI container.
There is a simple solution for this somewhat complicated-sounding cyclic situation.
For this, in  <span class='latex-textit'>IdeaForkLite</span> , alongside configurations for Spring Mail, we define the base package for Spring beans of our application
in the Spring configuration file called  <span class='latex-texttt'>applicationContext.xml</span> . </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:simple_spring-bean'></a>                     <pre><code>@Exclude
public class SpringMailSender {
  @Autowired
  private JavaMailSender mailSender;

  public void send(String senderAddress, String recipientAddress,
                   String subject, String text) {
    SimpleMailMessage message = new SimpleMailMessage();
    message.setTo(recipientAddress);
    message.setFrom(senderAddress);
    message.setSubject(subject);
    message.setText(text);
    this.mailSender.send(message);
  }
}
</code></pre>
                </div> The Spring bean from Listing  <a href='#!idx:/integration.html:fig:simple_spring-bean'> Simple Spring Bean </a> can be injected in the next step into a CDI bean called  <span class='latex-texttt'>MailService</span> .
Listing  <a href='#!idx:/integration.html:fig:injection_of_a_spring-bean_into_a_cdi-bean'> Injecting a Spring Bean into a CDI Bean </a>  shows
that the injection point does not differ from a regular injection point for a CDI bean.
The previously implemented CDI adapter bean is called at runtime
when the CDI container wants to populate the injection point in  <span class='latex-texttt'>MailService</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:injection_of_a_spring-bean_into_a_cdi-bean'></a>                     <pre><code>@ApplicationScoped
public class MailService {
  @Inject
  private SpringMailSender mailSender;

  public void sendWelcomeMessage(User user) {
    String senderAddress = ConfigResolver
      .getProjectStageAwarePropertyValue(
        "ideafork.sender", "admin@ideafork.com");
    String subject = "Welcome " + user.getNickName();
    String text = "Welcome @ IdeaFork!";
    this.mailSender.send(senderAddress, user.getEmail(), subject, text);
  }
}
</code></pre>
                </div> Building on this groundwork, we can add another actor to  <span class='latex-textit'>IdeaForkLite</span>
through which emails can be sent asynchronously after a successful registration.
We could again fire a synchronous CDI event with the  <span class='latex-texttt'>@Async</span>  qualifier in the asynchronous actor thread.
For our use case this is not necessary, and
therefore in Listing  <a href='#!idx:/integration.html:fig:async-mails'> Sending Mails Asynchronously </a>  we delegate directly to the previously implemented  <span class='latex-texttt'>MailService</span> .
Furthermore, we need an event called  <span class='latex-texttt'>UserRegisteredEvent</span> , which is also shown in the same listing.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:async-mails'></a>                     <pre><code>public class UserRegisteredEvent extends EntityChangedEvent&lt;User&gt; {
    public UserRegisteredEvent(User createdEntity) {
        super(createdEntity);
    }
}

public class UserRegisteredEventActor extends UntypedActor {
  private final MailService mailService;

  @Inject
  public UserRegisteredEventActor(MailService mailService) {
    this.mailService = mailService;
  }

  @Override
  public void onReceive(Object message) throws Exception {
    if (message instanceof UserRegisteredEvent) {
      this.mailService.sendWelcomeMessage(((UserRegisteredEvent)message)
        .getEntity());
    } else {
      unhandled(message);
    }
  }
}
</code></pre>
                </div> Via constructor injection we can inject our  <span class='latex-texttt'>MailService</span>  bean
to send emails in the  <span class='latex-texttt'>#onReceive</span>  method using this CDI bean and the underlying Spring bean.
In our example, we want to send a welcome message after a new user entity has been saved.<br />The registration logic in  <span class='latex-textit'>IdeaForkLite</span>  is located in the method  <span class='latex-texttt'>UserService#registerUser</span> .
The excerpt illustrated in Listing  <a href='#!idx:/integration.html:fig:improved_registration-method'> Triggering CDI and Akka Events </a>  shows the extended method as well as
the new  <span class='latex-texttt'>UserRegisteredEventBroadcaster</span> , which first triggers an asynchronous actor event via Akka and
then a synchronous CDI event.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:improved_registration-method'></a>                     <pre><code>@Service
public class UserService {
  //...

  @Inject
  private UserRegisteredEventBroadcaster userRegisteredEventBroadcaster;

  public User registerUser(User newUser) {
    if (userRepository.loadByEmail(newUser.getEmail()) == null) {
      newUser.setPassword(
        passwordManager.createPasswordHash(newUser.getPassword()));
      userRepository.save(newUser);
      User registeredUser = userRepository.findBy(newUser.getId());

      if (registeredUser != null) {
        userRegisteredEventBroadcaster
          .broadcastUserRegisteredEvent(registeredUser);
        return registeredUser;
      }
    }
    return null;
  }
}

@TransactionScoped
public class UserRegisteredEventBroadcaster {
    @Inject
    @Default
    private Event&lt;UserRegisteredEvent&gt; userRegisteredEvent;

    @Inject
    @Actor(type = UserRegisteredEventActor.class)
    private ActorRef asyncBroadcaster;

    public void broadcastUserRegisteredEvent(User entity) {
        UserRegisteredEvent userRegisteredEvent =
          new UserRegisteredEvent(entity);
        asyncBroadcaster.tell(userRegisteredEvent, this.asyncBroadcaster);
        userRegisteredEvent.fire(userRegisteredEvent);
    }
}
</code></pre>
                </div> The implementation described so far works flawlessly, but has the disadvantage, especially in unit tests,
that whenever a registration is performed, an attempt is always made to send an email.
Instead, it would suffice to verify whether an email would be sent or whether the content is correct.
Listing  <a href='#!idx:/integration.html:fig:specialized_mail-service'> Mail Service for Unit Tests </a>  shows how we can enable the first case
by creating a specialized CDI bean in the test package and overriding the  <span class='latex-texttt'>#sendWelcomeMessage</span>  method.
Since we only use this CDI bean in the test package, the original  <span class='latex-texttt'>MailService</span>  implementation is always active in the productive package of  <span class='latex-textit'>IdeaForkLite</span> ,
because the class  <span class='latex-texttt'>TestMailService</span>  does not exist there.
If we also do not want to use  <span class='latex-texttt'>TestMailService</span>  for integration tests,
we could additionally annotate the class with  <span class='latex-texttt'>@Exclude(ifProjectStage = ProjectStage.IntegrationTest.class)</span> , for example.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:specialized_mail-service'></a>                     <pre><code>@Specializes
public class TestMailService extends MailService {
    private AtomicInteger sentWelcomeMessageCount = new AtomicInteger();

    @Override
    public void sendWelcomeMessage(User user) {
        sentWelcomeMessageCount.incrementAndGet();
    }

    public Integer getSentWelcomeMessageCount() {
        int result = sentWelcomeMessageCount.get();
        if (result == 0) {
            return null;
        }
        return result;
    }
}
</code></pre>
                </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Finally, we can inject the  <span class='latex-texttt'>TestMailService</span>  bean in our JUnit test
to verify the result after a successful registration attempt.
Since we always send emails via an asynchronous actor thread, we need to build in a delay.
There are several ways to accomplish this.
In Listing  <a href='#!idx:/integration.html:fig:registration_test_with_specialized_mail-service'> Test with Specialized Mail Service </a>  this is implemented with a  <span class='latex-texttt'>RetryHelper</span> .
The complete implementation can be found in the Git repository of  <span class='latex-textit'>IdeaForkLite</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:registration_test_with_specialized_mail-service'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  @Inject
  private RegistrationViewCtrl registrationViewCtrl;

  @Inject
  private TestMailService testMailService;

  @Inject
  private EntityChangeRepository entityChangeRepository;

  //...

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    registrationViewCtrl.getNewUser().setNickName("os890");
    registrationViewCtrl.getNewUser().setEmail("os890@test.org");
    registrationViewCtrl.getNewUser().setPassword("test");
    Class&lt;? extends ViewConfig&gt; navigationResult =
      registrationViewCtrl.register();

    //...

    int sentWelcomeMessageCount = getSentWelcomeMessageCount();
    Assert.assertEquals(1, sentWelcomeMessageCount);
  }

  private Integer getSentWelcomeMessageCount() {
    return new RetryHelper&lt;Integer&gt;() {
      @Override
      protected Integer execute() {
        Integer result = testMailService.getSentWelcomeMessageCount();

        if (result == null) {
          return 0;
        }
        return result;
      }
    }.start();
  }

  private abstract class RetryHelper&lt;T&gt; {
    //...
  }
}
</code></pre>
                </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Whether the CDI and Spring integration described here makes sense depends heavily on the requirements of a project.
In our case, we could have done without Spring, for example.
Instead of Spring Mail, we could use alternatives such as Apache Commons Email.
Therefore, during the evaluation phase, it should be assessed
whether the disadvantages of an additional container are acceptable compared to the benefits of the add-ons.
Such disadvantages include, among others, higher complexity in the application through the use of an additional container,
its configuration, and integration.
Furthermore, at runtime even after the somewhat longer application startup there is a certain overhead, and
the somewhat higher memory consumption should not be disregarded either.
In some cases, however, the advantages outweigh these drawbacks, and
CDI-based applications can thus benefit from other ecosystems through such bridges.
<div class="tip"><b>Tip: </b>The CDI-Spring bridge pattern is less relevant in modern Quarkus projects, as Quarkus provides its own Spring compatibility layer (<span class='latex-texttt'>quarkus-spring-di</span>, <span class='latex-texttt'>quarkus-spring-web</span>). For new projects, using native Quarkus APIs is recommended &mdash; details in Chapter <a href='#!idx:/quarkus.html:10'>10</a>.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Since CDI 2.0 (Java EE 8), the specification provides native support for asynchronous events via <span class='latex-texttt'>@ObservesAsync</span>. This makes many of the Akka-based patterns shown in Section 7.1 significantly easier to implement – without an external actor container. For more complex asynchronous communication, MicroProfile Reactive Messaging or Jakarta Messaging are now available as standardized alternatives. The CDI/Spring Bridge from Section 7.2 has also become less practically relevant, as both ecosystems have matured and independently cover all common requirements. The integration techniques presented in this chapter remain valuable, however, as patterns for connecting arbitrary frameworks via CDI producers and portable extensions.</div>
<div class="tip"><b>Tip: </b><b>DeltaSpike modules &mdash; migration targets:</b><br />
&bull; <b>Core (Config):</b> <span class='latex-texttt'>@ConfigProperty</span> &rarr; MicroProfile Config (Chapter <a href='#!idx:/quarkus.html:10.4'>10.4</a>)<br />
&bull; <b>Core (@Exclude):</b> &rarr; <span class='latex-texttt'>@Vetoed</span> (CDI 1.1) or Quarkus <span class='latex-texttt'>@IfBuildProfile</span><br />
&bull; <b>Security:</b> <span class='latex-texttt'>@Secured</span> &rarr; <span class='latex-texttt'>@RolesAllowed</span> + MicroProfile JWT (Chapter <a href='#!idx:/quarkus.html:10.6'>10.6</a>)<br />
&bull; <b>Data:</b> <span class='latex-texttt'>@Repository</span> &rarr; Quarkus Panache (Chapter <a href='#!idx:/quarkus.html:10.6'>10.6</a>)<br />
&bull; <b>JSF:</b> ViewConfig, <span class='latex-texttt'>@ViewAccessScoped</span> &rarr; Angular Router + Components (Chapter <a href='#!idx:/angular.html:11'>11</a>)<br />
&bull; <b>Scheduler:</b> <span class='latex-texttt'>@Scheduled</span> &rarr; Quarkus Scheduler (<span class='latex-texttt'>@Scheduled</span>)<br />
&bull; <b>Test-Control:</b> <span class='latex-texttt'>CdiTestRunner</span> &rarr; <span class='latex-texttt'>@QuarkusTest</span> (Quarkus) or Weld-JUnit5<br />
&bull; <b>Partial-Bean:</b> <span class='latex-texttt'>@ResourceClient</span> &rarr; MicroProfile REST Client</div>
</section><section class="chapter-section" id="chapter-8">
<h1> <a class='latex-index-anchor' name='!idx:/cdi_micro.html:8' ><span class='entry-number'>8</span> CDI Micro</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> The text of this chapter has been revised by Claude (Anthropic) as co-author. This revision was made without post-review by the original author. Use at your own risk.
</div>
<a name = '!idx:/cdi_micro.html:chap:cdi_micro'> </a> For several years now, topics such as cloud computing and smaller deployment units have been strongly pushed.
Some PaaS platforms already allowed standards-compliant EE applications to be deployed unchanged since Java EE 6.
In many cases, however, Java EE itself is no longer at the center of architectural considerations, but rather represents one possible option.
Applications are increasingly being divided into independent small modules that can be deployed independently.
In this context, so-called micro-deployments have become common practice.
There are various forms of these, for which there are sometimes different definitions, perspectives, and recommendations.
Often the different approaches are broadly referenced using the term "Microservices."
In this chapter, we will stick with the term micro-deployments,
since we will look at splitting  <span class='latex-textit'>IdeaFork</span>  into smaller deployment units as an example.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Communication between services or modules takes place via a predefined protocol.
Inter-module communication via REST spread very quickly in this context,
since by definition it enables loose coupling and modules can consequently be implemented with different technologies.
However, using REST is not a requirement.
In principle, any protocol supported by the technologies of all modules can be used.
Due to the characteristics of HTTP (v1.0 and v1.1), some projects resort to alternatives such as "gRPC."
Instead of JSON as the serialization format, Protocol Buffers are used in this case.
This can optimize communication between services and significantly reduce latency.
The more services required to process a single client request, the more important such aspects become.
So far we have developed  <span class='latex-textit'>IdeaFork</span>  based on various Java EE specifications and will continue to do so in this chapter.
Components of Java EE, such as JAX-RS, are also used outside the platform for building applications with micro-deployments.
Therefore, we follow our previous path and refrain from proprietary approaches such as "gRPC."<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.1' ><span class='entry-number'>8.1</span> EE or Not EE</a> </h2>
 Java EE servers were long considered sluggish.
Only a few application servers directly supported micro-deployments.
Today, the situation is quite different.
There are hardly any slow-starting servers, servers with high resource consumption, or servers without an embedded mode.
The pursuit of up-to-date runtime environments and the associated faster release cycles
ultimately led to a new community and the unofficial Micro-Profile.
Originally, this initiative defined a subset of Java EE consisting of CDI, JAX-RS, and JSON-P.
Meanwhile, there are also specifications that were implemented outside the JCP.
Some parts, especially the Configuration specification, were extracted from open-source projects such as Apache DeltaSpike and
could potentially be incorporated into Java EE in the future.
Other parts such as "Fault-Tolerance," "Health," "Metrics," and "JWT-Auth" are mostly new developments from an API perspective and
still need to stand the test of time.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> When it comes to cloud and micro-deployments, there are many competing new approaches beyond Java EE and the Micro-Profile.
As usual, Java EE does not try to push its own approaches, but rather specifies proven technologies.
For this reason, we focus primarily on the specifications included in Java EE in this chapter and
extend them if necessary.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.2' ><span class='entry-number'>8.2</span> IdeaForkMicro</a> </h2>
 Instead of refactoring  <span class='latex-textit'>IdeaForkLite</span> , we will rebuild the application completely step by step.
Some parts can be taken over unchanged, while we will make other parts even leaner and extend them with new concepts as needed.
Since the functionality of  <span class='latex-textit'>IdeaFork</span>  itself will not change, we will only discuss some of the changes in excerpt form.
There will be the fewest changes in the UI part. Our goal is to take over the existing implementation in the UI as much as possible.
In principle, JSF also allows splitting into multiple nearly independent modules,
but then we could not benefit from features such as the Window-Scope.
 <span class='latex-textit'>IdeaForkMicro</span>  will therefore consist of a monolithic UI layer,
which communicates via REST with the individual independent backend modules.
Each module stores data in a data structure optimized for that module.
Redundant data is not just a side effect with this structuring concept, but a "desired" effect.
Both the backend modules and the UI module are stored in a Git repository called  <span class='latex-textit'>IdeaForkMicro</span> ,
in which the most important steps are divided into individual commits.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Due to the diverse possibilities with micro-deployments, we can only focus on selected aspects in this chapter.
This is primarily intended as inspiration and illustrates, among other things, how communication between modules
can be encapsulated and simplified with Partial-Beans.
Furthermore, we will incorporate new mechanisms from CDI 1.1 through 2.0 into  <span class='latex-textit'>IdeaForkMicro</span> .
Compared to previous chapters, the goal is therefore not to cover as many aspects as possible
that can be directly adopted into production projects.
Rather, for example, the prototype for inter-module communication helps to quickly and easily experiment with different modules without
having to study topics such as service discovery and container solutions in advance.
If micro-deployments are to actually be used in a project, these and other topics cannot be avoided.
However, for example, a professional service discovery solution can be integrated in a similar way via Partial-Beans.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.3' ><span class='entry-number'>8.3</span> Modules upon Modules</a> </h2>
 Exactly how an application is divided into modules is a science in itself, and
both opinions and recommendations sometimes diverge significantly on this seemingly simple topic.
Two questions are of central importance for us. We have already anticipated the question of how to split the UI.
In contrast to the SCS approach ("Self-Contained Systems"), we will not split the  <span class='latex-textit'>IdeaFork</span>  UI into individual modules.
The second question revolves around the module boundaries of the backend modules and is somewhat more extensive,
since we need to find an answer to the communication overhead here.
To minimize this as much as possible, we will reduce communication between modules to the absolute minimum.
At the same time, we need to ensure that the failure of one module does not bring down the entire application.
This aspect must not be neglected, since remote communication between modules by definition not only increases latency,
but also introduces additional sources of errors.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span class='latex-textit'>IdeaFork</span>  itself is a fairly small application, which limits the modularization possibilities.
An obviously independent part consists of user registration and login.
We will call the backend module needed for this the User-Service.
In  <span class='latex-textit'>IdeaForkLite</span> , we only have an email notification at the end of the registration process,
but we still move it into a separate module that is called asynchronously.
The management of ideas is also handled by a separate module called Idea-Service.
Both the User-Service and Idea-Service archive changes asynchronously via a module that we call History-Service.
All modules can obtain configurations via the Config-Service.
Due to the communication overhead, however, we will use a two-tier concept here,
which can additionally compensate for the possible failure of the Config-Service.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.4' ><span class='entry-number'>8.4</span> Keeping Up with the Times</a> </h2>
 Independent modules allow the use of different technology stacks.
For the modules of  <span class='latex-textit'>IdeaForkMicro</span> , we define CDI and JAX-RS as the absolute minimum.
The UI module remains nearly unchanged as mentioned and therefore continues to rely on Java EE v6 or v7.
However, we want to enable the fastest possible startup and at the same time simplify the build configuration.
Until now,  <span class='latex-textit'>IdeaFork</span>  or  <span class='latex-textit'>IdeaForkLite</span>  could be deployed in TomEE, JBoss AS or WildFly, and GlassFish.
Each of these servers enables the implementation of proprietary micro-deployments.
Therefore, we could explicitly choose a server at least per module.
The application code remains portable through the Java EE APIs, but we additionally need a proprietary starter for the server.
In  <span class='latex-textit'>IdeaForkMicro</span> , we will use one class per module for this purpose, placed in the base directory "dev-starter."
For each server, we could implement our own implementation consisting of less than an average of 10 lines of configuration and initialization code,
based on the proprietary deployment API of the respective server.
However, we decide on two new servers.
For the UI module, we chose JBoss WildFly-Swarm.
This is a modular server that makes it possible to use only certain parts of JBoss WildFly.
For the backend modules, Apache Meecrowave is used.
The name Meecrowave is an allusion to micro-deployments, but has little in common with the Micro-Profile specification.
If necessary, Meecrowave can be extended to a Micro-Profile compliant server.
Meecrowave itself is a lean server that primarily combines Apache Tomcat as a servlet container, Apache OpenWebBeans as the CDI implementation,
Apache CXF as the JAX-RS implementation, and Apache Johnzon for JSON-P (= JSON Processing).
The result is a performant server that is ready for use in just a few seconds.
Another positive side effect for us is the support for CDI 2.0. Consequently, we can for example
use asynchronous CDI events directly instead of EJBs or Akka for asynchronous events.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div class="tip"><b>Tip: </b>Apache Meecrowave popularized CDI-first microservices: a lightweight server with CDI, JAX-RS, and JSON-B at its core. Today, Quarkus (Chapter <a href='#!idx:/quarkus.html:10'>10</a>) offers the same philosophy with additional build-time optimization, a larger ecosystem, and native image support. The patterns shown in this chapter &mdash; modular beans, REST endpoints, event-based communication &mdash; transfer directly to Quarkus.</div>
<h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.5' ><span class='entry-number'>8.5</span> Project Structure</a> </h2>
 Instead of a build configuration in the root directory of the project, our base directory now contains only three folders.
In the "ui" directory, we will place the slightly adapted UI layer from  <span class='latex-textit'>IdeaForkLite</span> ,
while in the "backend" directory we create a folder for each service.
The "config" directory is the third folder and will contain a generic extension
that enables simple access to a central Config-Service.<br />The starting point is the User-Service. In the directory  <span class='latex-texttt'>backend/ideafork_user-service</span> , we create a build configuration
that incrementally defines dependencies for the CDI 2.0, JAX-RS 2.0, and JPA 2.1 APIs as well as
dependencies for the corresponding implementations and "H2" as an in-memory database for demo purposes.
We also add dependencies to DeltaSpike-Core, -JPA, and -Data.
Apart from slightly different versions, this corresponds to a subset of the previous dependencies of  <span class='latex-textit'>IdeaForkLite</span> .
Completely new is the dependency to Meecrowave, which we define with  <span class='latex-texttt'>org.apache.meecrowave</span>  as  <span class='latex-texttt'>groupId</span>  and
 <span class='latex-texttt'>meecrowave-core</span>  as  <span class='latex-texttt'>artifactId</span>  and  <span class='latex-texttt'>provided</span>  as  <span class='latex-texttt'>scope</span> .
We need this dependency for implementing a starter class,
with which we can start the application in an embedded instance of the server from the IDE.
No special IDE plugin is required for this.
Since we are implementing an independent module, we can easily switch from Java 7 to Java 8.
Both Meecrowave and DeltaSpike are compatible with Java 8.
If there were other services with dependencies for which this is not the case,
we could fall back to an older Java version for the corresponding modules if necessary, until an upgrade is possible.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.6' ><span class='entry-number'>8.6</span> Every Start Is Simple</a> </h2>
 Meecrowave can be started in various ways.
In addition to a Maven plugin, Meecrowave provides a simple API
to start an embedded instance. For this, we create the class  <span class='latex-texttt'>DevUserServerStarter</span>  in the User-Service module.
The simplest way to start the server via the Java API is:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>    <span class='latex-texttt'>new Meecrowave().bake().await();</span><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Starting an EE micro server can hardly be any simpler than this.
With regard to micro-deployments, the first pitfall is already hidden here.
In contrast to a monolith, we want to start each module in its own server instance.
For this to be possible locally, each instance must use its own port.
Without a container solution such as Docker, we need to assign a corresponding port to each server instance.
In our case, we load the configured port with the  <span class='latex-texttt'>ConfigResolver</span>  from DeltaSpike.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:meecrowave_starter-class'></a>                     <pre><code>public class DevUserServerStarter {
  public static void main(String[] args) {
    Meecrowave.Builder builder = new Meecrowave.Builder();
    String configuredPort =
      ConfigResolver.getPropertyValue("user-service.http.port");
      builder.setHttpPort(Integer.parseInt(configuredPort));

      new Meecrowave(builder).bake().await();
  }
}
</code></pre>
                </div>
Listing  <a href='#!idx:/cdi_micro.html:fig:meecrowave_starter-class'> Meecrowave Starter Class </a>  illustrates
that we can customize and start Meecrowave with just a few lines in a standard main method.
The value for  <span class='latex-texttt'>user-service.http.port</span>  can be stored as usual in the file  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  or
another active config source (from DeltaSpike).
In our case, we want to store the port in the build configuration and therefore need a placeholder.
Thus the configuration in  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  looks as follows:
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> service.name=user-service
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> user-service.http.port=${app.http.port}
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The value of  <span class='latex-texttt'>service.name</span>  is the basis for the port configuration of the module.
The value configured here serves as a prefix for the port configuration.
With  <span class='latex-texttt'>[prefix].http.port</span> , the port of a service module is configured.
This would even allow us to store port configurations in a central config source (from DeltaSpike).
The placeholder  <span class='latex-texttt'>${app.http.port}</span>  is replaced here by Maven.
Consequently, the properties entry  <span class='latex-texttt'>&lt;app.http.port&gt;8082&lt;/app.http.port&gt;</span>  is still missing in the build configuration.
 <span class='latex-texttt'>service.name</span>  plays a minor role for us at this point.
However, in one of the next steps, we will add a CDI extension called Remote-Access-Lite,
which requires exactly this kind of port configuration.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.7' ><span class='entry-number'>8.7</span> From Lite to Micro</a> </h2>
 The base technologies and the fundamental functions of  <span class='latex-textit'>IdeaForkLite</span>  do not change.
However, small changes are necessary for the modularization, which we carry out step by step.
 <span class='latex-texttt'>BaseEntity</span> ,  <span class='latex-texttt'>User</span> , and  <span class='latex-texttt'>PasswordManager</span>  can be taken over without changes.
For  <span class='latex-texttt'>EntityManagerProducer</span> , we only change the name of the persistence unit
so that each service module can use a unique persistence unit name.
This makes assignment in the IDE a bit easier if we want to open multiple modules in parallel.
Since we also want to make  <span class='latex-textit'>IdeaForkMicro</span>  a bit leaner at the same time, we reduce the interceptors used in
 <span class='latex-texttt'>UserRepository</span>  to  <span class='latex-texttt'>@org.apache.deltaspike.jpa.api.transaction.Transactional</span>  and
simplify the implementation, which is shown in Listing  <a href='#!idx:/cdi_micro.html:fig:simplified_user-repository'> Simplified User Repository </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:simplified_user-repository'></a>                     <pre><code>@Transactional(qualifier = Default.class)
@Repository
public interface UserRepository extends EntityRepository&lt;User, String&gt; {
  @Query(
    value = "select u from User u where u.nickName = ?1",
    singleResult = OPTIONAL)
  User loadByNickName(String nickName);

  @Query(
    value = "select u from User u where u.email = ?1",
    singleResult = OPTIONAL)
  User loadByEmail(String email);
}
</code></pre>
                </div> The file  <span class='latex-texttt'>META-INF/beans.xml</span>  is no longer strictly required with Meecrowave.
Since CDI 1.1, this configuration file is optional, and the interceptor for  <span class='latex-texttt'>@Transactional</span>  is already preconfigured by DeltaSpike.
Without the file  <span class='latex-texttt'>beans.xml</span> , only classes annotated with CDI annotations that are valid for bean definition become CDI beans.
These annotations are also called "bean defining annotations."
These include, for example, scope, stereotype, interceptor, and decorator annotations.
For this reason, we can omit  <span class='latex-texttt'>@Exclude</span>  for the class  <span class='latex-texttt'>BaseEntity</span> .
The default behavior just described implicitly ensures
that this class and the derived  <span class='latex-textit'>IdeaFork</span>  entities are not CDI beans.<br />To be able to test the adopted classes, we add  <span class='latex-texttt'>org.apache.meecrowave:meecrowave-junit</span>  as a test dependency in addition to JUnit.
Listing  <a href='#!idx:/cdi_micro.html:fig:cdi-test_with_meecrowave'> CDI Test with Meecrowave </a>  shows a simple test case with which we can test the adopted logic.
We use the class  <span class='latex-texttt'>MonoMeecrowave.Rule</span>  in the constructor of  <span class='latex-texttt'>UserTest</span>
to have Meecrowave fill the defined injection points of the class.
In contrast to the previously used  <span class='latex-texttt'>CdiTestRunner</span>  from DeltaSpike, this step must be performed manually.
Later we will also use this  <span class='latex-texttt'>TestRule</span>  for tests of the JAX-RS endpoints, which we will add in the next step.
In the Git repository of  <span class='latex-textit'>IdeaForkMicro</span> , additional test methods are available beyond the test from Listing  <a href='#!idx:/cdi_micro.html:fig:cdi-test_with_meecrowave'> CDI Test with Meecrowave </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:cdi-test_with_meecrowave'></a>                     <pre><code>public class UserTest {
  @ClassRule
  public static final MonoMeecrowave.Rule RULE =
    new MonoMeecrowave.Rule();

  @Inject
  private UserRepository userRepository;

  @Inject
  private PasswordManager passwordManager;

  public UserTest() {
    RULE.inject(this);
  }

  @Before
  public void init() {
    List&lt;User&gt; allUsers = userRepository.findAll();
    for (User user : allUsers) {
      userRepository.attachAndRemove(user);
    }
  }

  @Test
  public void createUser() {
    String password = passwordManager.createPasswordHash("xyz");
    User user = new User("gp@test.org", password);

    User savedUser = userRepository.save(user);
    Assert.assertEquals(user, savedUser);

    User loadedUser = userRepository.loadByEmail("gp@test.org");

    assertUser(user, updatedUser);
  }

  //...
}
</code></pre>
                </div> Fundamentally, the test methods of  <span class='latex-texttt'>UserTest</span>  are about testing the CDI beans directly.
At this point, we therefore know that the adopted CDI beans work as expected.
However, if we start the application with our starter class, we find
that our new module does start but does not yet expose any functionality externally and
therefore cannot be used.
To change this, we add a JAX-RS endpoint.
As is customary with JAX-RS, we begin with a subclass of  <span class='latex-texttt'>javax.ws.rs.core.Application</span> .
In Listing  <a href='#!idx:/cdi_micro.html:fig:auto-detectable_jax-rs_application'> Auto-detectable JAX-RS Application </a> , we additionally annotate the class  <span class='latex-texttt'>UserApplication</span>  with  <span class='latex-texttt'>@javax.enterprise.context.Dependent</span> .
Using  <span class='latex-texttt'>@Dependent</span>  or also  <span class='latex-texttt'>@ApplicationScoped</span>  ensures
that Meecrowave finds and internally registers the class.
In our case, the entry path consists directly of the version number.
This is unique in  <span class='latex-textit'>IdeaForkMicro</span>  since a Meecrowave instance contains only one module in one version.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:auto-detectable_jax-rs_application'></a>                     <pre><code>@Dependent
@ApplicationPath("/v1/")
public class UserApplication extends Application {
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:user-registration'> JAX-RS Resource for User Registration </a>  shows a simple JAX-RS resource with which new users can be registered.
In our minimal example, a user is created with email, nickname, and password.
All other information is optional and can be submitted later with an update request.
This is not a best practice suggestion,
but primarily helps to keep our examples minimal while illustrating various concepts at the same time.
Therefore, we also forgo an additional layer to encapsulate the registration logic and implement the logic directly in the REST endpoint.
If we had other technologies for endpoints besides the REST API, such encapsulation would of course be preferable,
so that the actual logic does not have to be implemented multiple times.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:user-registration'></a>                     <pre><code>@Path("registration")
@ApplicationScoped
public class SimpleRegistrationResource {
  @Inject
  private UserRepository userRepository;

  @Inject
  private PasswordManager passwordManager;

  @POST
  @Consumes(MediaType.APPLICATION_JSON)
  public Response register(RegistrationRequest registrationRequest,
                           @Context UriInfo uriInfo) {

    if (userRepository.loadByEmail(
      registrationRequest.getEmail()) == null) {
        String passwordHash = passwordManager
          .createPasswordHash(registrationRequest.getPassword());

        User userToRegister = new User(
          registrationRequest.getEmail(), passwordHash);
        userToRegister.setNickName(registrationRequest.getNickName());

        User savedUser = userRepository.save(userToRegister);
        User registeredUser = userRepository.findBy(savedUser.getId());

        if (registeredUser != null) {
          return Response.created(uriInfo.getBaseUriBuilder().build())
            .entity(new PublicUserResponse(savedUser, true))
            .type(MediaType.APPLICATION_JSON_TYPE).build();
        }
    }

    return Response.status(Response.Status.CONFLICT).build();
  }
}
</code></pre>
                </div> The POST method from Listing  <a href='#!idx:/cdi_micro.html:fig:user-registration'> JAX-RS Resource for User Registration </a>  accepts  <span class='latex-texttt'>RegistrationRequest</span>  as the first parameter.
This class is a simple Java bean with the required properties for transmitting the user data.
Meecrowave converts valid JSON strings into instances of this class, provided this is possible.
For the response to the REST client, we could directly use the  <span class='latex-texttt'>User</span>  instance, since it is also automatically converted to a JSON string.
In this specific example, this would have the side effect of sending the password hash to the client.
Information like this can be filtered in various ways as needed.
We use the class  <span class='latex-texttt'>PublicUserResponse</span>  for this purpose.
It defines the same properties as the class  <span class='latex-texttt'>User</span>  except for the password property.
Furthermore, it can be explicitly controlled whether the email address should be included in the response.
This circumstance even allows dynamic limitations at runtime.
If we additionally want to customize the response in certain situations,
we use the class  <span class='latex-texttt'>javax.ws.rs.core.Response</span>  as the return type, as in Listing  <a href='#!idx:/cdi_micro.html:fig:user-registration'> JAX-RS Resource for User Registration </a> .
An example of this is changing the status code to  <span class='latex-texttt'>Response.Status.CONFLICT</span>
if there is already a registered user with the submitted email address.<br />If we restart our User-Service, not only our CDI beans are deployed but also our new JAX-RS resource.
Meecrowave outputs all active URIs during the startup process.
Thus, the first part of our User-Service module is complete, and we can add a test for the REST interface we just defined.
We collect these tests in the class  <span class='latex-texttt'>UserWorkflowTest</span> .
Here too,  <span class='latex-texttt'>MonoMeecrowave.Rule</span>  helps us. Instead of injecting CDI beans directly into our test class as before,
we use this test rule in Listing  <a href='#!idx:/cdi_micro.html:fig:jax-rs_test_with_meecrowave'> JAX-RS Test with Meecrowave </a>  to access the current port of the container.
In the  <span class='latex-texttt'>@Before</span>  callback method, we still access our  <span class='latex-texttt'>UserRepository</span>  directly
to delete the stored users before each test.
We could also go through a REST endpoint here.
We forgo this in our case because, apart from tests, we would have no use for such an endpoint.
However, all test methods strictly use the defined API of our REST resource or the resources
that we additionally define and test.
We will not go into the details of the test methods since primarily the standard client API of JAX-RS is used here.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:jax-rs_test_with_meecrowave'></a>                     <pre><code>public class UserWorkflowTest {
  @ClassRule
  public static final MonoMeecrowave.Rule RULE =
    new MonoMeecrowave.Rule();

  private static WebTarget userRegistrationTarget;
  private static Client client;

  @BeforeClass
  public static void createTarget() {
    client = ClientBuilder.newClient();

    int testHttpPort = RULE.getConfiguration().getHttpPort();
    createUserRegistrationTarget(testHttpPort);
  }

  @AfterClass
  public static void onShutdown() {
    client.close();
  }

  private static void createUserRegistrationTarget(int testHttpPort) {
    String applicationPath =
      UserApplication.class.getAnnotation(ApplicationPath.class).value();
    String userRegistrationPath =
      SimpleRegistrationResource.class.getAnnotation(Path.class).value();
    String baseUserUrl = "http://localhost:" + testHttpPort +
      applicationPath + userRegistrationPath;
    URI uri = UriBuilder.fromUri(baseUserUrl).build();
    userRegistrationTarget = client.target(uri);
  }

  @Before
  public void init() {
    UserRepository userRepository =
      BeanProvider.getContextualReference(UserRepository.class);

    List&lt;User&gt; allUsers = userRepository.findAll();
    for (User user : allUsers) {
      userRepository.attachAndRemove(user);
    }
  }

  @Test
  public void registerUser() {
    User user = new User();
    user.setEmail("gp@test.org");
    user.setPassword("xyz");

    Response response = userRegistrationTarget.request()
      .buildPost(Entity.json(user)).invoke();

    Assert.assertNotNull(response);
    Assert.assertEquals(CREATED.getStatusCode(), response.getStatus());
    User createdUser = response.readEntity(User.class);

    Assert.assertEquals("gp@test.org", createdUser.getEmail());
  }
}
</code></pre>
                </div> The functionality described so far for registering new users should be available without authentication.
In the next step, we implement a REST resource that will be used by the login page.
In previous chapters, after a successful login, we stored the current user in the  <span class='latex-texttt'>ActiveUserHolder</span>  bean and
only called protected service methods when the method  <span class='latex-texttt'>#isLoggedIn</span>  returned the value  <span class='latex-texttt'>true</span> .
This was possible because services were not encapsulated in independent modules.
Since in this chapter we are moving services into different modules, they must be secured differently.
There are various possibilities for this.
Without going into the advantages and disadvantages, we use JWT (JSON Web Token) in  <span class='latex-textit'>IdeaForkMicro</span> .
To avoid having to implement the JWT integration ourselves, we use a small add-on for JAX-RS called JWT-Authentication-Lite.
The API of this prototype consists of two annotations and one class, which are very easy to use.
Services that should only be usable with successful authentication
are additionally marked with the annotation  <span class='latex-texttt'>@AuthenticationRequired</span> .
Furthermore, all services must use the same shared secret,
which we store under the key  <span class='latex-texttt'>jwt_secret</span>  in a valid config source (from DeltaSpike).
In  <span class='latex-textit'>IdeaForkMicro</span> , we use the file  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  for this.
However, we only use a placeholder as the value, which is replaced by Maven.
Thus, we could for example automatically adjust the shared secret per stage via a build pipeline.
Alternatively, we could of course perform the configuration using system properties, for example.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The  <span class='latex-texttt'>Login</span>  resource represents a special case, because the JWT token must be generated in the background here.
We can accomplish this with the help of the second annotation called  <span class='latex-texttt'>@LoginEntryPoint</span> .
Listing  <a href='#!idx:/cdi_micro.html:fig:simple-login'> Simple Login </a>  shows a simple implementation of the  <span class='latex-texttt'>Login</span>  resource.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:simple-login'></a>                     <pre><code>@Path("user-action")
@ApplicationScoped
public class SimpleLoginResource {
  @Inject
  private UserRepository userRepository;

  @Inject
  private PasswordManager passwordManager;

  @Inject
  private IdentityHolder identityHolder;

  @LoginEntryPoint
  @POST
  @Path("/login")
  @Consumes(MediaType.APPLICATION_JSON)
  public Response login(LoginRequest loginRequest,
                        @Context UriInfo uriInfo) {

    if (loginRequest.getEmail() == null ||
        loginRequest.getPassword() == null) {
      return Response.status(
        Response.Status.BAD_REQUEST.getStatusCode()).build();
    }

    User loadedUser = userRepository.loadByEmail(loginRequest.getEmail());

    if (loadedUser == null) {
      return Response.status(
        Response.Status.BAD_REQUEST.getStatusCode()).build();
    }

    String passwordHash = passwordManager
      .createPasswordHash(loginRequest.getPassword());

    if (passwordHash.equals(loadedUser.getPassword())) {
      try {
        identityHolder.setAuthenticatedEMail(loginRequest.getEmail());

        return Response.ok().build();
      } catch (Exception e) {
        return Response.status(
          Response.Status.INTERNAL_SERVER_ERROR).build();
      }
    }
    return Response.status(Response.Status.UNAUTHORIZED).build();
  }
}

public class LoginRequest {
    private String email;
    private String password;

    //+ getters and setters
}
</code></pre>
                </div>
The beans  <span class='latex-texttt'>UserRepository</span>  and  <span class='latex-texttt'>PasswordManager</span>  are already familiar from previous chapters.
Both were taken over from  <span class='latex-textit'>IdeaForkLite</span>  without changes.
 <span class='latex-texttt'>IdentityHolder</span> , on the other hand, is a request-scoped bean
that is included in JWT-Authentication-Lite.
If a stored user is found for the submitted email address and the password hash also matches,
we can pass the email address to  <span class='latex-texttt'>IdentityHolder</span> .
In the background, a JWT token is generated with this email address and included in the HTTP header.
For every subsequent request to JAX-RS resources protected by  <span class='latex-texttt'>@AuthenticationRequired</span> ,
this token must be sent again.
JWT-Authentication-Lite verifies the JWT token with each request using the shared secret.
The token contains the email address and a timestamp for the time-limited validity as metadata.
Only when a token has been successfully verified and is still valid
is the email address taken over into the  <span class='latex-texttt'>IdentityHolder</span>  bean for this request.
Similar to an HTTP session, the validity is extended
when a token is used within a certain time window.
However, it should be noted that a new token with a new validity period is automatically issued.
For clients, this makes no difference, since they should normally always use the transmitted token and
the exact content is not relevant, since the token must be sent unchanged again with the next request.
In the case of  <span class='latex-textit'>IdeaForkMicro</span> , tokens are only transmitted during communication between different services.
If we had, for example, a JavaScript application running in the browser that communicates directly with the REST resources,
additional security such as HTTPS instead of HTTP would be advisable.
Since we stay with JSF for the  <span class='latex-textit'>IdeaFork</span>  UI, this is not strictly necessary for the entire application.
Especially if only the server on which the  <span class='latex-textit'>IdeaFork</span>  UI is deployed is externally accessible.
<div class="tip"><b>Tip: </b>The manual JWT processing in <span class='latex-textit'>IdeaForkMicro</span> is intentionally simplified for illustration. MicroProfile JWT standardizes token propagation, validation, and extraction. In Quarkus (Chapter <a href='#!idx:/quarkus.html:10.6'>10.6</a>), the <span class='latex-texttt'>JsonWebToken</span> is automatically extracted from the HTTP header and injected as a CDI bean &mdash; the manual <span class='latex-texttt'>IdentityHolder</span> code is completely eliminated.</div>
After this brief JWT excursion, it appears that  <span class='latex-textit'>IdeaForkMicro</span>  is more complex than  <span class='latex-textit'>IdeaForkLite</span> ,
since in  <span class='latex-textit'>IdeaForkLite</span>  we did not have to worry about tokens, for example.
This is one of the consequences of splitting into modular services and
has nothing directly to do with the characteristics of CDI or JAX-RS.
Apart from the possible scalability per service,
we will also see further advantages of such modularization throughout the chapter.
At the end of the chapter, we will integrate the endpoints just presented into the UI module.
For now, we add tests for our login logic.
Listing  <a href='#!idx:/cdi_micro.html:fig:simple_login_test-target'> Simple Login Test Target </a>  shows the method for creating the login target,
which we add to the class  <span class='latex-texttt'>UserWorkflowTest</span>  and call in the method  <span class='latex-texttt'>#createTarget</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:simple_login_test-target'></a>                     <pre><code>private static void createLoginTarget(int testHttpPort) {
  String applicationPath =
    UserApplication.class.getAnnotation(ApplicationPath.class).value();
  String loginPath =
    SimpleLoginResource.class.getAnnotation(Path.class).value();

  String baseUserUrl = "http://localhost:" + testHttpPort +
    applicationPath + loginPath + "/login";
  URI uri = UriBuilder.fromUri(baseUserUrl).build();
  loginTarget = client.target(uri);
}
</code></pre>
                </div> The basic logic of this method has already been used for  <span class='latex-texttt'>#createUserRegistrationTarget</span> .
The main difference is that we specify the last part of the path as a fixed value.
If we later changed this part of the path in  <span class='latex-texttt'>SimpleLoginResource</span> , we would have to update the change in every test.
Listing  <a href='#!idx:/cdi_micro.html:fig:dynamic_login_test-target'> Dynamic Login Test Target </a>  shows how this can be avoided with a few additional lines
by dynamically searching for  <span class='latex-texttt'>@LoginEntryPoint</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:dynamic_login_test-target'></a>                     <pre><code>private static void createLoginTarget(int testHttpPort) {
  String applicationPath =
    UserApplication.class.getAnnotation(ApplicationPath.class).value();
  String loginPath =
    SimpleLoginResource.class.getAnnotation(Path.class).value();

  for (Method method : SimpleLoginResource.class.getDeclaredMethods()) {
    if (method.isAnnotationPresent(LoginEntryPoint.class)) {
      Path path = method.getAnnotation(Path.class);
      if (path != null) {
        loginPath += path.value();
        break;
      }
    }
  }

  String baseUserUrl = "http://localhost:" + testHttpPort +
    applicationPath + loginPath;
  URI uri = UriBuilder.fromUri(baseUserUrl).build();
  loginTarget = client.target(uri);
}
</code></pre>
                </div> Using  <span class='latex-texttt'>loginTarget</span> , we can send a request to the login resource in our tests after a successful registration.
In Listing  <a href='#!idx:/cdi_micro.html:fig:user-login_test'> User Login Test </a> , the last step verifies whether a token was issued.
Here too, we use the standard client API of JAX-RS.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:user-login_test'></a>                     <pre><code>@Test
public void loginUser() {
  registerUser();
  User user = new User("gp@test.org", "xyz");

  Response response =
    loginTarget.request().buildPost(Entity.json(user)).invoke();
  String token = response.getHeaderString(HttpHeaders.AUTHORIZATION);
  Assert.assertNotNull(token);
}

private Response registerUser() {
  User user = new User();
  user.setEmail("gp@test.org");
  user.setPassword("xyz");

  Response response = userRegistrationTarget.request()
    .buildPost(Entity.json(user)).invoke();

  Assert.assertNotNull(response);
  Assert.assertEquals(CREATED.getStatusCode(), response.getStatus());
  User createdUser = response.readEntity(User.class);

  Assert.assertEquals("gp@test.org", createdUser.getEmail());
  return response;
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:test_invalid_login'> Test of an Invalid Login </a>  finally tests a login request with an incorrect password.
In this case, HTTP 401 (Unauthorized) is returned by our JAX-RS resource.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:test_invalid_login'></a>                     <pre><code>  @Test
  public void failedLogin() {
    registerUser();

    User user = new User("gp@test.org", "wrong");

    Response response = loginTarget.request()
      .buildPost(Entity.json(user)).invoke();
    Assert.assertNotNull(response);
    Assert.assertEquals(
      UNAUTHORIZED.getStatusCode(), response.getStatus());
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.8' ><span class='entry-number'>8.8</span> Asynchronous CDI Events</a> </h2>
 Up to this point, we could have implemented the entire functionality with any EE v6 or v7 server.
As mentioned at the beginning, the goal of initiatives such as the
Micro-Profile and Meecrowave is not only to provide the most efficient runtime environment possible,
but also the most up-to-date one. In the case of CDI, version 2.0 was finalized several months before Java EE 8, and
production-ready implementations were available within just a few weeks.
However, until all EE servers have integrated all specifications of a new EE version,
considerably more time typically passes.
EE 8 promises to somewhat defuse this often-criticized aspect, since its scope was deliberately kept smaller than, for example, EE 6.
With servers like Meecrowave, however, we have the advantage of staying up to date and
being able to use new features shortly after the specification is completed.
In  <span class='latex-textit'>IdeaForkMicro</span> , we take advantage of this circumstance to implement asynchronous events using the new built-in mechanisms of CDI 2.0.
For this, we use an injection point of type  <span class='latex-texttt'>javax.enterprise.event.Event</span>  as usual in Listing  <a href='#!idx:/cdi_micro.html:fig:fire_async_cdi-events'> Firing Asynchronous CDI Events </a> .
Instead of  <span class='latex-texttt'>#fire</span> , however, we call the new method  <span class='latex-texttt'>#fireAsync</span> .
A little later we will see
why in Listing  <a href='#!idx:/cdi_micro.html:fig:fire_async_cdi-events'> Firing Asynchronous CDI Events </a>  we need to pass the current token to the  <span class='latex-texttt'>UserChangedEvent</span>  instance.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:fire_async_cdi-events'></a>                     <pre><code>@ApplicationScoped
public class UserChangeBroadcaster {
  @Inject
  private AuthenticationManager authenticationManager;

  @Inject
  private Event&lt;UserChangedEvent&gt; userChangedEvent;

  @Inject
  private IdentityHolder identityHolder;

  public void onUserChange(User user) {
    try {
      if (user.getVersion() == 0) {
        String tmpToken =
          authenticationManager.createNewToken(user.getEmail());
        userChangedEvent.fireAsync(
          new UserRegistrationEvent(user, tmpToken));
      } else {
        userChangedEvent.fireAsync(
          new UserChangedEvent(user, identityHolder.getCurrentToken()));
      }
    } catch (Exception e) {
      throw ExceptionUtils.throwAsRuntimeException(e);
    }
  }
}
</code></pre>
                </div> The second difference is found on the observer side.
As shown in Listing  <a href='#!idx:/cdi_micro.html:fig:observer_for_async_events'> CDI Observer for Asynchronous Events </a> , for an observer of asynchronous CDI events,  <span class='latex-texttt'>@ObservesAsync</span>  must be used instead of  <span class='latex-texttt'>@Observes</span> .
Thus, event classes can be used for both synchronous and asynchronous events.
Only through the corresponding  <span class='latex-texttt'>fire</span>  method and
the matching annotation on the observer side is the distinction made.
If at a later point, for example, a synchronous event is changed to an asynchronous one,
it is not sufficient to simply change the method call to  <span class='latex-texttt'>#fireAsync</span> .
If the switch to  <span class='latex-texttt'>@ObservesAsync</span>  is omitted, events will no longer be delivered,
because there are then no methods with  <span class='latex-texttt'>@ObservesAsync</span> .
If we were to call both  <span class='latex-texttt'>#fireAsync</span>  and  <span class='latex-texttt'>#fire</span>  one after the other, we can use either
 <span class='latex-texttt'>@ObservesAsync</span>  or  <span class='latex-texttt'>@Observes</span>  on the observer side without having to consider the  <span class='latex-texttt'>fire</span>  method used.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:observer_for_async_events'></a>                     <pre><code>@ApplicationScoped
public class UserActivityObserver {
  @Inject
  private UserActionRepository userActionRepository;

  public void onUserActionEvent(
    @ObservesAsync UserActionEvent userActionEvent) {
      userActionRepository.save(userActionEvent.getUserAction());
  }
}
</code></pre>
                </div> In the following sections, there will be further notes on CDI 2.0.
Asynchronous events and the event prioritization used a bit later
represent the most interesting innovation in CDI 2.0 for  <span class='latex-textit'>IdeaForkMicro</span> .<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.9' ><span class='entry-number'>8.9</span> Remote Yet So Close</a> </h2>
 So far, we have implemented all described steps in the User-Service module.
As mentioned at the beginning, there will be multiple modules in  <span class='latex-textit'>IdeaForkMicro</span> .
The next service modules are the Notification-Service for sending email notifications and the Archive-Service,
through which we separately archive changes to entities.
Both service modules have not yet been implemented at this point.
However, the interface of the modules is already foreseeable.
So far, we have already used  <span class='latex-texttt'>RegistrationRequest</span>  in the endpoint  <span class='latex-texttt'>SimpleRegistrationResource</span> .
This Java bean defines the properties  <span class='latex-texttt'>email</span> ,  <span class='latex-texttt'>nickName</span> ,  <span class='latex-texttt'>firstName</span> ,  <span class='latex-texttt'>lastName</span> , and  <span class='latex-texttt'>password</span> .
Only the latter is defined in the class  <span class='latex-texttt'>RegistrationRequest</span>  itself.
The remaining properties are contained in a base class called  <span class='latex-texttt'>UserRequest</span> .
 <span class='latex-texttt'>UserRequest</span>  can thus also be reused for the message to the Notification-Service.
Listing  <a href='#!idx:/cdi_micro.html:fig:rest-client_as_partial-bean'> REST Resource Client as Partial-Bean </a>  shows how we want to communicate with the Notification-Service that is yet to be created.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:rest-client_as_partial-bean'></a>                     <pre><code>@ApplicationScoped
@ResourceClient(name = "notifications", version = "v1")
public interface NotificationResource {
  @POST
  @Path("/welcome")
  void sendWelcomeMessage(UserRequest notificationRequest);
}
</code></pre>
                </div> The annotation  <span class='latex-texttt'>@ResourceClient</span>  from Listing  <a href='#!idx:/cdi_micro.html:fig:rest-client_as_partial-bean'> REST Resource Client as Partial-Bean </a> is provided by the CDI extension Remote-Access-Lite and
is based on the Partial-Bean concept of DeltaSpike.
The interface  <span class='latex-texttt'>NotificationResource</span>  can be injected and used like a regular CDI bean.
In the specific example, when  <span class='latex-texttt'>NotificationResource#sendWelcomeMessage</span>  is called, the service
with the name "notifications" in version "v1" is looked up and a POST request is sent to "/welcome."
 <span class='latex-texttt'>@POST</span>  and  <span class='latex-texttt'>@Path</span>  are the already familiar JAX-RS annotations.
Consequently, only  <span class='latex-texttt'>@ResourceClient</span>  is a custom annotation that enables simpler access to remote services.
In the background, the address of the service is determined, combined with the path specifications, and the request is initiated via the JAX-RS client API.
For this to be possible, each module registers itself in a decentrally distributed data structure when the application starts.
An entry is created for each REST endpoint, which is automatically replicated to all participating modules and
updated at regular intervals.
Even though we do not use a container solution such as Docker, we do not need to explicitly know information about other modules, such as ports,
because this information is also automatically registered and replicated between service instances in the background.
Armed with this knowledge, we can immediately continue with the integration of the Archive module in Listing  <a href='#!idx:/cdi_micro.html:fig:remote-historization_via_partial-bean'> Remote Archiving via Partial-Bean </a> .
In this case,  <span class='latex-texttt'>EntityChangeRequest</span>  is a Java bean with the properties
 <span class='latex-texttt'>entityAsJson</span> ,  <span class='latex-texttt'>id</span> ,  <span class='latex-texttt'>version</span> , and a read-only property  <span class='latex-texttt'>creationTimestamp</span> ,
which is used only for messages to the Archive-Service.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:remote-historization_via_partial-bean'></a>                     <pre><code>@ApplicationScoped
@ResourceClient(name = "archive", version = "v1")
public interface ArchiveResource {
  @POST
  void recordChange(EntityChangeRequest entityChangeRequest);
}
</code></pre>
                </div> If a service is not available at runtime, the CDI extension aborts processing and a warning is logged.
More comprehensive error handling is certainly possible, but is not part of the Remote-Access-Lite extension,
since it is a prototype that primarily serves the purpose
of not requiring an additional container or service discovery solution for  <span class='latex-textit'>IdeaForkMicro</span> .
Furthermore, this CDI extension once again demonstrates the diverse use cases for Partial-Beans and
other mechanisms of Apache DeltaSpike and can serve as inspiration for further CDI extensions.
<div class="tip"><b>Tip: </b>The <span class='latex-texttt'>@ResourceClient</span> pattern from DeltaSpike is standardized by the MicroProfile REST Client. Instead of a Partial-Bean proxy, you use <span class='latex-texttt'>@RegisterRestClient</span> with a typed interface &mdash; the Quarkus container generates the implementation automatically. For migrating <span class='latex-textit'>IdeaForkMicro</span> to Quarkus, this means: the interface remains nearly unchanged, only the annotations are swapped.</div>
Through the Partial-Beans  <span class='latex-texttt'>NotificationResource</span>  and
 <span class='latex-texttt'>ArchiveResource</span>  shown above, we can already implement the integration with these modules in the User-Service module
as if we already had the other two modules available.
Listing  <a href='#!idx:/cdi_micro.html:fig:forwarding_jwt-token_manually'> Manually Forwarded Token </a>  shows the call to  <span class='latex-texttt'>NotificationResource#sendWelcomeMessage</span>  and
Listing  <a href='#!idx:/cdi_micro.html:fig:archive_changes_async'> Asynchronous Archiving </a>  shows the use of  <span class='latex-texttt'>ArchiveResource#recordChange</span> .
In both listings, the call takes place in an asynchronous observer method.
In the method  <span class='latex-texttt'>onUserRegisteredEvent</span> , the current token must be set manually
because tokens are only automatically adopted in the thread where they were verified after the check.
Asynchronous observer methods, however, are executed by a different thread, and therefore the automatic mechanism does not apply here.
The token set in this way is then automatically processed again.
Specifically, it is used for the call to  <span class='latex-texttt'>NotificationResource#sendWelcomeMessage</span> .
Thus, this is only necessary when we want to communicate with another service module from a new thread.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:forwarding_jwt-token_manually'></a>                     <pre><code>@ApplicationScoped
public class RegistrationNotificationObserver {
  @Inject
  private NotificationResource notificationResource;

  @Inject
  private IdentityHolder identityHolder;

  public void onUserRegisteredEvent(
    @ObservesAsync UserRegistrationEvent userRegistrationEvent) {
      identityHolder.setCurrentToken(userRegistrationEvent.getToken());
      String userSpecificText =
        Optional.ofNullable(userRegistrationEvent.getUser().getNickName())
          .orElse(userRegistrationEvent.getUser().getEmail());
      UserRequest userRequest = new UserRequest();
      userRequest.setNickName(userSpecificText);
      this.notificationResource.sendWelcomeMessage(userRequest);
  }
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:archive_changes_async'> Asynchronous Archiving </a>  shows a similar constellation.
However, here the  <span class='latex-texttt'>ObjectMapper</span>  from Jackson is used manually
to serialize the current state of the  <span class='latex-texttt'>User</span>  instance to JSON.
Consequently, the checked exception  <span class='latex-texttt'>JsonProcessingException</span>  must be explicitly handled.
Here too, in our simplified case, it is sufficient to convert the checked exception to an unchecked exception and rethrow it.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:archive_changes_async'></a>                     <pre><code>@ApplicationScoped
public class UserChangeObserver {
  @Inject
  private IdentityHolder identityHolder;

  @Inject
  private ArchiveResource archiveResource;

  public void onUserChange(
    @ObservesAsync UserChangedEvent userChangedEvent) {
      this.identityHolder.setCurrentToken(userChangedEvent.getToken());

      ObjectMapper objectMapper = new ObjectMapper();

      try {
        User user = userChangedEvent.getUser();
        EntityChangeRequest entityChangeRequest =
          new EntityChangeRequest();
        entityChangeRequest.setId(user.getId());
        entityChangeRequest.setEntityAsJson(
          objectMapper.writeValueAsString(user));
        entityChangeRequest.setVersion(user.getVersion());

        archiveResource.recordChange(entityChangeRequest);
      } catch (JsonProcessingException e) {
        throw ExceptionUtils.throwAsRuntimeException(e);
      }
  }
}
</code></pre>
                </div> In order for changes sent via the  <span class='latex-texttt'>ArchiveResource</span>  Partial-Bean to arrive and
be processed, we create a module called History-Service.
In this module, we archive and manage changes to entities.
Fundamentally, this module is structured equivalently to the User-Service module.
Configuration, starter class, and a JAX-RS endpoint are all implemented here following the previously described approach.
Listing  <a href='#!idx:/cdi_micro.html:fig:archive_changes_in_jax-rs_endpoint'> JAX-RS Endpoint for Archiving </a>  shows that the JAX-RS resource is also remarkably simple to implement here.
The method  <span class='latex-texttt'>#archiveEntity</span>  annotated with  <span class='latex-texttt'>@POST</span>  converts the transmitted instance of type  <span class='latex-texttt'>EntityChangeRequest</span> into a JPA entity of type  <span class='latex-texttt'>EntityChange</span>  and saves it using the injected  <span class='latex-texttt'>EntityChangeRepository</span>  instance.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:archive_changes_in_jax-rs_endpoint'></a>                     <pre><code>@AuthenticationRequired
@Path("archive")

@ApplicationScoped
public class EntityArchiveResource {
  @Inject
  private EntityChangeRepository entityChangeRepository;

  @POST
  public void archiveEntity(EntityChangeRequest entityChangeRequest) {
    EntityChange entityChange = new EntityChange(
      entityChangeRequest.id,
      entityChangeRequest.version,
      entityChangeRequest.entityAsJson,
      entityChangeRequest.creationTimestamp);

      entityChangeRepository.save(entityChange);
  }

  //...
}
</code></pre>
                </div> However, the modularization reveals that certain code duplications are already creeping in.
Since modules are independent and can also pursue their own concepts, it is often recommended not to use shared code.
In our case, this means that every module in which we use JPA contains a copy of the class  <span class='latex-texttt'>BaseEntity</span> .
Generic libraries could be shared between modules like other dependencies.
In  <span class='latex-textit'>IdeaForkMicro</span> , however, we forgo reusability of this one class.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.10' ><span class='entry-number'>8.10</span> Diversity per Module</a> </h2>
 In addition to the  <span class='latex-texttt'>ArchiveResource</span>  Partial-Bean, we have also already integrated a Partial-Bean called  <span class='latex-texttt'>NotificationResource</span> .
Currently, only the corresponding  <span class='latex-texttt'>Notification</span>  module is still missing.
We create this in the following step.
Here too, we create a class for easy manual startup and call it  <span class='latex-texttt'>DevNotificationServerStarter</span> .
As already mentioned, the starter classes for Meecrowave are structured identically.
The only difference lies in the configuration of the service name and port.
However, there is one special feature in the Notification-Service module.
We adopt the integration of Spring-Mail from  <span class='latex-textit'>IdeaForkLite</span> , which was implemented using our CDI-Spring-Bridge.
We expose the module's functionality, as with the User-Service module,
via a JAX-RS endpoint for other parts of the application.
Listing  <a href='#!idx:/cdi_micro.html:fig:send_notifications'> JAX-RS Endpoint for Sending Emails </a>  shows the injection and use of  <span class='latex-texttt'>MailService</span> ,
which as before uses the Spring bean  <span class='latex-texttt'>SpringMailSender</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:send_notifications'></a>                     <pre><code>@AuthenticationRequired
@Path("notifications")

@ApplicationScoped
public class NotificationResource {
  @Inject
  private IdentityHolder identityHolder;

  @Inject
  private MailService mailService;

  @POST
  @Path("/welcome")
  public void onNotification(RecipientDetails recipientDetails) {
    mailService.sendWelcomeMessage(recipientDetails.nickName);
  }
}
</code></pre>
                </div> Since we use Spring-Mail or Spring only in this module, we can limit the associated build configuration and
functionality to this module.
Furthermore, until now we had to explicitly remove  <span class='latex-texttt'>SpringMailSender</span>  from the CDI container using  <span class='latex-texttt'>@Exclude</span> ,
since at runtime Spring should manage this bean.
Since CDI 1.1, we could also use  <span class='latex-texttt'>@javax.enterprise.inject.Vetoed</span>  for this purpose.
Alternatively, we can omit the file  <span class='latex-texttt'>META-INF/beans.xml</span>  or
extend the  <span class='latex-texttt'>beans</span>  tag in this file with the attribute  <span class='latex-texttt'>bean-discovery-mode</span>  and
use the value "annotated" instead of "all."
In both cases, as explained at the beginning of the chapter, only classes with the so-called "bean defining annotations" are considered.
Also in the file  <span class='latex-texttt'>beans.xml</span> , another alternative is available.
Through the  <span class='latex-texttt'>scan</span>  and  <span class='latex-texttt'>exclude</span>  tags, parts of the BDAs can be omitted via configuration.
CDI 2.0 goes even one step further and introduces the  <span class='latex-texttt'>&lt;trim/&gt;</span>  tag as a simple marker tag.
With this, beans are excluded from the CDI container only
if after the startup process they have been made neither a CDI bean through an explicit (CDI) annotation nor dynamically through a CDI extension.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> At this point, we already have three modules, with the User-Service module communicating with the other two modules.
Via the  <span class='latex-texttt'>IdentityHolder</span> , we accessed the current token or
set the authenticated email address for the current thread after a successful login.
This email address is also provided by the  <span class='latex-texttt'>IdentityHolder</span>  for subsequent requests with a JWT token
once the sent token has been successfully verified.
Listing  <a href='#!idx:/cdi_micro.html:fig:load_current_user_details'> Loading Current User Details </a>  demonstrates this using the  <span class='latex-texttt'>UserActionResource</span> , which is added in the User-Service module.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:load_current_user_details'></a>                     <pre><code>@AuthenticationRequired
@Path("user-action")

@ApplicationScoped
public class UserActionResource {
  @Inject
  private UserRepository userRepository;

  @Inject
  private UserActionRepository userActionRepository;

  @Inject
  private IdentityHolder identityHolder;

  @GET
  public UserActionResponse loadCurrentUserDetails() {
    User user = userRepository.loadByEmail(
      identityHolder.getAuthenticatedEMail());

    List&lt;UserAction&gt; result = Optional
      .ofNullable(userActionRepository.loadLatestActivities(user, 10))
      .orElse(emptyList());
    List&lt;UserActionEntry&gt; userActionEntryList =
      result.stream().map(UserActionEntry::new).collect(toList());
    return new UserActionResponse(user, userActionEntryList);
  }
}
</code></pre>
                </div> In the method  <span class='latex-texttt'>#loadCurrentUserDetails</span> , we use the value
returned by  <span class='latex-texttt'>IdentityHolder#getAuthenticatedEMail</span>
to load the corresponding user, and in the next step we can additionally load the user actions for this user.
All of these user details will be displayed at the end of the chapter in the user profile area of  <span class='latex-textit'>IdeaForkLite</span> .
User actions up to this point include only user logins.
The Git repository of  <span class='latex-textit'>IdeaForkMicro</span>  also contains a similarly structured  <span class='latex-texttt'>SimpleLogoutResource</span>  class in the User-Service module,
which additionally accepts user logouts via the REST interface and internally forwards an asynchronous  <span class='latex-texttt'>UserActionEvent</span> ,
which ultimately causes the  <span class='latex-texttt'>UserActivityObserver</span>  to also save these events.
The User-Service module itself is stateless, so an explicit logout has no further effects.
In the UI part of the application, which we will come to a bit later, things are different.
Here, at a minimum, the JWT token must be discarded upon logout.
In order for us to additionally display logout events in the user profile,
the aforementioned logout request to the User module must be explicitly performed.
The delivery of this event leads in our case to an additional user action entry,
but has no further effects in the UI module beyond that.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> If no token or an expired token is transmitted to the User-Service module,
requests are only accepted by the Login and Register entry points.
If the behavior with an expired token is to be explicitly tested, we need to customize the  <span class='latex-texttt'>TokenExpirationManager</span>  of the CDI extension.
In Listing  <a href='#!idx:/cdi_micro.html:fig:test_token_expiration_manager'> TokenExpirationManager for Tests </a> , we use the class  <span class='latex-texttt'>TestTokenExpirationManager</span>  for this purpose,
which extends  <span class='latex-texttt'>TokenExpirationManager</span> , is annotated with  <span class='latex-texttt'>@Specializes</span> , and is only available in the test classpath.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:test_token_expiration_manager'></a>                     <pre><code>@Specializes
public class TestTokenExpirationManager extends TokenExpirationManager {
  @Override
  public long getExpirationTimeInMilliSeconds() {
    expirationTimeInMilliSeconds = globalExpirationTimeInMilliSeconds;
    return super.getExpirationTimeInMilliSeconds();
  }

  public static int replaceExpirationTimeInMilliSeconds(
    int expirationTimeInMilliSeconds) {
      int oldValue = globalExpirationTimeInMilliSeconds;
      globalExpirationTimeInMilliSeconds = expirationTimeInMilliSeconds;
      initTokenRenewTimeframe();
      return oldValue;
  }
}
</code></pre>
                </div> Via the method  <span class='latex-texttt'>#replaceExpirationTimeInMilliSeconds</span> , in Listing  <a href='#!idx:/cdi_micro.html:fig:test_expired_token'> Testing Expired Tokens </a>  the token's validity is artificially reduced
so that in the method  <span class='latex-texttt'>#forcedPause</span> , instead of several minutes, only a few milliseconds need to be waited
before testing can continue with a deliberately expired token.
In the specific case, the status  <span class='latex-texttt'>UNAUTHORIZED</span>  should be returned to the client when calling a JAX-RS endpoint.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:test_expired_token'></a>                     <pre><code>@Test
public void updateUserDetailsAfterTokenExpiration() {
  int previousExpirationTime = TestTokenExpirationManager
    .replaceExpirationTimeInMilliSeconds(1);

  try {
    registerUser();
    String token = loginUser();

    forcedPause(10L);

    Response response = userTarget.request()
      .header(HttpHeaders.AUTHORIZATION, token)
      .buildPost(Entity.json(createTestUser())).invoke();

    Assert.assertNotNull(response);
    Assert.assertEquals(
      UNAUTHORIZED.getStatusCode(), response.getStatus());
  } finally {
    TestTokenExpirationManager
      .replaceExpirationTimeInMilliSeconds(previousExpirationTime);
  }
}
</code></pre>
                </div> If the automatic token renewal is also to be tested,
we need to increase the validity duration somewhat and,
as in Listing  <a href='#!idx:/cdi_micro.html:fig:test_token-renewal'> Testing Token Renewal </a> , wait slightly less than the validity duration after the first request
before sending the second request.
From this we receive a new token, with which a third request is sent.
If we wait again until just before the token expires between the second and third request,
we are clearly beyond the validity duration of the first token,
but the newly issued token is still valid, and therefore this third request must also succeed.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:test_token-renewal'></a>                     <pre><code>@Test
public void renewToken() {
  int expirationTime = 3000;
  int previousExpirationTime = TestTokenExpirationManager
    .replaceExpirationTimeInMilliSeconds(expirationTime);

  try {
    registerUser();
    String token = loginUser();

    forcedPause(expirationTime - 1000L);
    String newToken = updateUserWithTokenUpdate(token);
    forcedPause(expirationTime - 1000L);
    Assert.assertNotEquals(token, newToken);

    User loadedUser = updateUser(newToken);

    Assert.assertNotNull(loadedUser);
  } finally {
    TestTokenExpirationManager
      .replaceExpirationTimeInMilliSeconds(previousExpirationTime);
  }
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.11' ><span class='entry-number'>8.11</span> Everything in Its Time</a> </h2>
 Next up is the Config-Service module.
Here too, there is barely any difference.
The existing functionality is again taken over from  <span class='latex-textit'>IdeaForkLite</span>  and
made available to other parts of the application with a JAX-RS resource.
However, the initialization during service startup is somewhat different.
On the one hand, in  <span class='latex-textit'>IdeaForkLite</span>  we have already dynamically added a custom config source
to use the database as an additional configuration source, and
in the case of the project stage  <span class='latex-texttt'>Development</span> , we manually created a configuration entry.
Until now, we have used a JSF add-on for this purpose.
Our service modules, however, can no longer use this trick.
Fortunately, CDI itself has provided a remedy here since version 1.1.
Listing  <a href='#!idx:/cdi_micro.html:fig:cdi-startup_event'> CDI 1.1 Container Startup Event </a>  shows how in the class  <span class='latex-texttt'>IdeaForkConfigServiceStartupObserver</span> , an observer method
can monitor the start of the application scope using the predefined qualifier  <span class='latex-texttt'>@Initialized</span> .
As is usual with observer methods, additional parameters are optional injection points.
In our case, we have  <span class='latex-texttt'>DataBaseAwareConfigSource</span>  injected and
register this additional config source as before via  <span class='latex-texttt'>ConfigResolver#addConfigSources</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:cdi-startup_event'></a>                     <pre><code>@ApplicationScoped
public class IdeaForkConfigServiceStartupObserver {
  protected void onStartup(@Observes @Initialized(ApplicationScoped.class)
                           Object ideaForkStartedEvent,
                           DataBaseAwareConfigSource configSource) {

    ConfigResolver
      .addConfigSources(Arrays.&lt;ConfigSource&gt;asList(configSource));
  }
}
</code></pre>
                </div> Of course, there can be multiple observer methods for this event.
So in Listing  <a href='#!idx:/cdi_micro.html:fig:unordered_startup-event'> Unordered Container Startup Event </a> , we add another observer
to dynamically set a configuration value depending on the project stage.
There are various possibilities for this.
We fall back on the already introduced  <span class='latex-texttt'>@Exclude</span>  and
additionally have  <span class='latex-texttt'>ConfigRepository</span>  injected as a parameter of the observer method.
In the observer method itself, we then simply save the configuration entry to the database using  <span class='latex-texttt'>ConfigRepository</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:unordered_startup-event'></a>                     <pre><code>@Exclude(exceptIfProjectStage = ProjectStage.Development.class)
@ApplicationScoped
public class DevIdeaForkConfigServiceStartupObserver {
  protected void onStartup(@Observes @Initialized(ApplicationScoped.class)
                           Object ideaForkStartedEvent,
                           ConfigRepository configRepository) {

    configRepository.save(
      new ConfigEntry("maxNumberOfHighestRatedCategories", "10"));
  }
}
</code></pre>
                </div> When we have multiple observers for the same event, as is the case with the ones just shown, the order may be important.
If we want to ensure that the new config source is added before the configuration value is saved in our example,
we can use a new feature of CDI 2.0.
With the additional use of  <span class='latex-texttt'>@javax.annotation.Priority</span> , the invocation order of observer methods can be controlled.
Listing  <a href='#!idx:/cdi_micro.html:fig:ordered_startup-event'> Ordered Container Startup Events </a>  shows this for our two observer methods.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:ordered_startup-event'></a>                     <pre><code>protected void onStartup(
  @Observes @Initialized(ApplicationScoped.class) @Priority(1)
  Object ideaForkStartedEvent,
  DataBaseAwareConfigSource configSource) {
    //...
}

protected void onStartup(
  @Observes @Initialized(ApplicationScoped.class) @Priority(2)
  Object ideaForkStartedEvent,
  ConfigRepository configRepository) {
    //...
}
</code></pre>
                </div> Before we can use the Config-Service, we adopt the Partial-Bean approach from  <span class='latex-textit'>IdeaForkLite</span> ,
with which we can implement type-safe configurations via  <span class='latex-texttt'>@TypedConfig</span> .
Additionally, in Listing  <a href='#!idx:/cdi_micro.html:fig:improved_version_of_TypedConfig'> Extension of the TypedConfig Annotation </a> , we extend the annotation with the annotation attribute  <span class='latex-textit'>remote</span>
to be able to distinguish between local and centralized configuration.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:improved_version_of_TypedConfig'></a>                     <pre><code>@PartialBeanBinding
@Retention(RUNTIME)
@Target(TYPE)
public @interface TypedConfig {
  boolean remote() default false;
}
</code></pre>
                </div> In the class  <span class='latex-texttt'>TypedConfigHandler</span> , we delegate to the  <span class='latex-texttt'>ConfigResolver</span>  from DeltaSpike as before and
only to the Config-Service client shown in the listing when the value of  <span class='latex-texttt'>remote</span>  is explicitly set to  <span class='latex-texttt'>true</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:'></a>                     <pre><code>@ResourceClient(name = "configs", version = "v1")
public interface ConfigService {
  @GET
  @Path("/{key}")
  String loadForKey(@PathParam("key") String key);
}
</code></pre>
                </div> As the excerpt of Listing  <a href='#!idx:/cdi_micro.html:fig:typed_config-handler_with_remote-support'> Typed Config Handler with Remote Support </a>  shows,
the  <span class='latex-texttt'>ConfigService</span>  bean is directly injected.
Loaded values continue to be cached with a time limit.
The corresponding functionality was also taken over from  <span class='latex-textit'>IdeaForkLite</span> .
Since this module would rarely if ever change,
we could also keep it outside of  <span class='latex-textit'>IdeaForkLite</span>  and add it to  <span class='latex-textit'>IdeaForkLite</span>  only as a regular dependency.
So that we can still place this functionality in the same Git repository without an additional build step,
we exceptionally import the entire type-safe configuration mechanism into a separate Maven module
that may be used by all other modules.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:typed_config-handler_with_remote-support'></a>                     <pre><code>@TypedConfig
@ConfigScoped
@SuppressWarnings("unused")
public class TypedConfigHandler implements InvocationHandler {
  @Inject
  private ConfigService configService;

  private Map&lt;String, Object&gt; loadedValues =
    new ConcurrentHashMap&lt;String, Object&gt;();

  public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {
      String key = method.getName();
      Object result = loadedValues.get(key);

      if (result != null) {
        return result;
      }

      String loadedValue = null;

      TypedConfig typedConfig =
        proxy.getClass().getAnnotation(TypedConfig.class);
      if (typedConfig != null && typedConfig.remote()) {
        loadedValue = configService.loadForKey(key);
      }

      if (loadedValue == null) {
        loadedValue = ConfigResolver
          .getProjectStageAwarePropertyValue(key);
      }
      final Class&lt;?&gt; configType = method.getReturnType();
      result = parseValue(loadedValue, configType);

      loadedValues.put(key, result);
      return result;
  }

  //...
}
</code></pre>
                </div> The last backend module to be created is the Idea module.
As before, we import the functionality from  <span class='latex-textit'>IdeaForkLite</span>  and can take over large parts unchanged.
The first adjustment is in the type-safe configuration.
We add the type-safe configuration called  <span class='latex-texttt'>IdeaConfig</span>  from Listing  <a href='#!idx:/cdi_micro.html:fig:typed_config_as_partial-bean'> Type-safe Configuration as Partial-Bean </a>  and
set the attribute  <span class='latex-textit'>remote</span>  to  <span class='latex-texttt'>true</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:typed_config_as_partial-bean'></a>                     <pre><code>@TypedConfig(remote = true)
public interface IdeaConfig {
  Integer maxNumberOfHighestRatedCategories();
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:typed-config_usage'> Usage of the Type-safe Configuration </a>  shows that there is no difference in usage.
 <span class='latex-texttt'>IdeaConfig</span>  is injected and
by calling  <span class='latex-texttt'>IdeaConfig#maxNumberOfHighestRatedCategories</span> , the configuration value for the key
 <span class='latex-texttt'>maxNumberOfHighestRatedCategories</span>  is loaded.
As already described, in this example, the JAX-RS endpoint of the Config-Service module is queried first in the background, and
only when it does not return a value are the other config sources consulted.
We could also integrate the  <span class='latex-texttt'>ConfigService</span>  Partial-Bean directly via a config source.
However, this would trigger a remote query for every config lookup.
For this reason, we stick with the previously described two-tier approach in  <span class='latex-texttt'>TypedConfigHandler</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:typed-config_usage'></a>                     <pre><code>@AuthenticationRequired
@Path("categories")

@ApplicationScoped
public class CategoryResource {
  @Inject
  private IdeaRepository ideaRepository;

  @Inject
  private IdeaConfig ideaConfig;

  @GET
  @Path("top")
  public List&lt;CategoryView&gt; getHighestRatedCategories() {
    List&lt;CategoryView&gt; result = ideaRepository.getHighestRatedCategories(
      ideaConfig.maxNumberOfHighestRatedCategories());
    return result;
  }
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:adjusted_IdeaRepository'> Adjusted IdeaRepository </a>  shows the corresponding adjustments and simplifications in the class  <span class='latex-texttt'>IdeaRepository</span> .
This also makes it clear why in  <span class='latex-textit'>IdeaForkMicro</span>  the configured value is not loaded within  <span class='latex-texttt'>IdeaRepository</span>  itself.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:adjusted_IdeaRepository'></a>                     <pre><code>@Transactional(qualifier = Default.class)
@Repository
public interface IdeaRepository extends EntityRepository&lt;Idea, String&gt; {
  @Query("select i from Idea i where i.authorEmail = ?1")
  List&lt;Idea&gt; loadAllOfAuthor(String email);

  @Query("select new at.irian.cdiatwork.ideafork.idea.domain.CategoryView(
    i.category, count(i.category)) from Idea i group by i.category
    order by count(i.category) desc")
  List&lt;CategoryView&gt; getHighestRatedCategories(
    @MaxResults int maxNumberOfHighestRatedCategories);

  @Query("select i from Idea i where i.topic like CONCAT('', ?1, '') or
    i.category like CONCAT('', ?1, '')")
  List&lt;Idea&gt; search(String searchText);
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.12' ><span class='entry-number'>8.12</span> Integration</a> </h2>
 In the UI module of  <span class='latex-textit'>IdeaForkMicro</span> , only a few changes are strictly necessary.
At this point, all REST endpoints are implemented in the Git repository.
This includes  <span class='latex-texttt'>CategoryResource</span>  as well. The implementation details are not relevant at this point.
Once we know that we can query categories via the path "/categories/v1/top,"
the integration of this remote service, as shown in Listing  <a href='#!idx:/cdi_micro.html:fig:rest-client_as_partial-bean_ui'> REST Resource Client as Partial-Bean in the UI </a> ,
is equivalent to the previous implementations.
The additionally used annotation  <span class='latex-texttt'>@TypedCollection</span> is also provided by the Remote-Access-Lite extension and
serves in the background as additional information for the  <span class='latex-texttt'>ObjectMapper</span>  from Jackson while reading the JSON string.
All other annotations are ones we have already encountered or are standard JAX-RS annotations.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:rest-client_as_partial-bean_ui'></a>                     <pre><code>@ResourceClient(name = "categories", version = "v1")
public interface CategoryService {
  @GET
  @Path("/top")
  @TypedCollection(Category.class)
  List&lt;Category&gt; getHighestRatedCategories();
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:using_partial-bean_CategoryService'> Integration of CategoryService </a>  illustrates the use of  <span class='latex-texttt'>CategoryService</span>  in  <span class='latex-texttt'>IndexViewCtrl</span> .
Also new in Listing  <a href='#!idx:/cdi_micro.html:fig:using_partial-bean_CategoryService'> Integration of CategoryService </a>  is the use of  <span class='latex-texttt'>JsfIdentityHolder</span> ,
which replaces the previous  <span class='latex-texttt'>ActiveUserHolder</span> .
This is a specialized variant of  <span class='latex-texttt'>IdentityHolder</span>
that is stored in the session scope and is also available for EL expressions through  <span class='latex-texttt'>@Named</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:using_partial-bean_CategoryService'></a>                     <pre><code>@ViewController
public class IndexViewCtrl implements Serializable {
  @Inject
  private IdeaPromotionService ideaPromotionService;

  @Inject
  private CategoryService categoryService;

  @Inject
  private JsfIdentityHolder identityHolder;

  private List&lt;Category&gt; categories;
  private int categoryCount;

  private List&lt;Idea&gt; promotedIdeas;
  private int promotedIdeaCount;

  @PreRenderView
  public void onPreRenderView() {
    if (identityHolder.isAuthenticated()) {
      promotedIdeas = Optional
        .ofNullable(ideaPromotionService.loadRecentlyPromotedIdeas())
        .orElse(emptyList());
      categories = Optional
        .ofNullable(categoryService.loadHighestRatedCategories())
        .orElse(emptyList());

      categoryCount = categories.size();
      promotedIdeaCount = promotedIdeas.size();
    }
  }

  //...
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:ui_specific_partial-bean_holder'> UI-specific IdentityHolder </a>  illustrates,
in addition to the implementation of  <span class='latex-texttt'>JsfIdentityHolder</span> , the signaling of a user logout
that is triggered either automatically by a session timeout or manually.
A manual logout leads to the reset of the token.
In  <span class='latex-textit'>IdeaForkMicro</span> ,  <span class='latex-texttt'>JsfIdentityHolder</span>  is the only session-scoped instance
that continues to exist after a manual logout until the session timeout, but is completely empty and therefore consumes hardly any memory.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:ui_specific_partial-bean_holder'></a>                     <pre><code>@Named("identityHolder")
@Specializes
@SessionScoped
public class JsfIdentityHolder extends IdentityHolder
  implements Serializable {
    private boolean logoutSent = false;

    public boolean isAuthenticated() {
      return getCurrentToken() != null;
    }

    @Inject
    private UserActionService.LogoutService logoutService;

    @PreDestroy
    protected void onTimeout() {
      onLogout(false);
    }

    @Override
    public void setCurrentToken(String currentToken) {
      super.setCurrentToken(currentToken);
      this.logoutSent = false;
    }

    public void onLogout(boolean manualLogout) {
      try {
        if (logoutSent) {
          return;
        }

        if (manualLogout) {
          logoutService.logout("LOGOUT");
        } else {
          logoutService.logout("AUTO_LOGOUT");
        }
      } finally {
        logoutSent = true;
        reset();
      }
    }
}
</code></pre>
                </div> In Listing  <a href='#!idx:/cdi_micro.html:fig:nested_partial-bean'> Nested Partial-Bean </a> , it is apparent
that  <span class='latex-texttt'>UserActionService.LogoutService#logout</span>  is also a Partial-Bean method
that is forwarded by the Remote-Access-Lite extension to the corresponding JAX-RS endpoint of the User-Service module.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:nested_partial-bean'></a>                     <pre><code>public interface UserActionService {
  @ResourceClient(name = "user-action", version = "v1")
  interface LoginService {
    @POST
    @Path("/login")
    void login(User user);
  }

  @ResourceClient(name = "user-action", version = "v1")
  interface LogoutService {
    @POST
    @Path("/logout")
    void logout(@QueryParam("type") String logoutType);
  }

  @ResourceClient(name = "user-action", version = "v1")
  interface UserStatsService {
    @GET
    ProfileActivity loadLatestActivities();
  }
}
</code></pre>
                </div> A manual logout in  <span class='latex-textit'>IdeaForkMicro</span>  is initiated by the  <span class='latex-texttt'>MenuController</span> .
Listing  <a href='#!idx:/cdi_micro.html:fig:controller_for_manual_logout'> UI Controller for Manual Logout </a>  illustrates the corresponding excerpt.
After the user logout is signaled to the backend, all server-side windows in the affected session are closed.
In the case of a session timeout, this happens automatically and therefore does not need to be explicitly handled.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:controller_for_manual_logout'></a>                     <pre><code>@Named("menuBean")
@Model
public class MenuController {
  @Inject
  private JsfIdentityHolder identityHolder;

  @Inject
  private WindowContext windowContext;

  public Class&lt;? extends ViewConfig&gt; logout() {
    try {
      identityHolder.onLogout(true);
    } finally {
      resetWindowContext();
    }
    return Pages.User.Login.class;
  }

  private void resetWindowContext() {
    String currentWindowId = windowContext.getCurrentWindowId();
    windowContext.closeWindow(currentWindowId);
    windowContext.activateWindow(currentWindowId);
  }

  //...
}
</code></pre>
                </div> The remaining changes in the UI module are summarized in a commit in the Git repository of  <span class='latex-textit'>IdeaForkMicro</span>  and
are largely equivalent to the integration of the backend modules just presented.
All changes are designed so that the XHTML pages have barely changed and
the view controllers are also nearly identical.
Primarily, properties have changed in some cases where properties in the JSON response are named differently.
Additionally, as already mentioned,  <span class='latex-texttt'>activeUserHolder</span>  was switched to the new  <span class='latex-texttt'>identityHolder</span> .<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.13' ><span class='entry-number'>8.13</span> No Advantage Without Disadvantage</a> </h2>
 The split into independent modules has, however, introduced a small disadvantage.
Using Bean Validation constraints across layer boundaries is no longer possible without shared code.
If, for example, we want to validate a new instance of  <span class='latex-texttt'>Idea</span> , we must implement this in the UI module.
Listing  <a href='#!idx:/cdi_micro.html:fig:ui-validation_via_bv-constraints'> UI Validation with Bean Validation Constraints </a>  shows an excerpt from the  <span class='latex-texttt'>Idea</span>  class of the UI module as a representative example.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:ui-validation_via_bv-constraints'></a>                     <pre><code>public class Idea {
  private String id;

  @NotNull
  @Size(min = 1, max = 64)
  private String topic;

  @NotNull
  @Size(min = 1, max = 64)
  private String category;

  private String description;
  private String baseIdeaId;

  //...
}
</code></pre>
                </div> Instances of  <span class='latex-texttt'>Idea</span>  are validated automatically by JSF as before.
In the Idea-Service module, however, we should at least repeat a minimal validation.
Instead of the manual  <span class='latex-texttt'>IdeaValidator</span> , we also want to use Bean Validation constraints here.
Therefore, we extend the JPA entity  <span class='latex-texttt'>Idea</span> , not to be confused with the class of the same name in the UI module,
with the corresponding constraints.
Additionally, we must activate the  <span class='latex-texttt'>validation-mode</span>  called  <span class='latex-texttt'>CALLBACK</span>  in the  <span class='latex-texttt'>persistence.xml</span>  file of the service module.
This ensures that the JPA provider has entities validated by the Bean Validation provider before persistence and only saves them
when no constraint violations have been found.
This additionally ensures, for example,
that in our case imported  <span class='latex-texttt'>Idea</span>  instances also undergo a rudimentary check.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> A further disadvantage arises with the  <span class='latex-texttt'>@UniqueUser</span>  constraint.
The constraint validator used previously executes a database query for UI validation.
In  <span class='latex-textit'>IdeaForkMicro</span> , this would mean that we would need a remote call to the User-Service module for UI validation.
For this reason, we forgo this constraint in  <span class='latex-textit'>IdeaForkMicro</span> .
In the current version in the Git repository of  <span class='latex-textit'>IdeaForkMicro</span>, in such a case the REST resource returns the HTTP status code 409 ("Conflict") to the UI module.
Furthermore, we limit ourselves to displaying a simple error message
that is also shown for other registration errors.
If, however, a detailed error message is to be displayed,
we would need to use different error codes or
the Idea-Service module would need to return the error description as a valid response.
Here too, it is evident that the complexity of  <span class='latex-textit'>IdeaForkMicro</span>  has increased somewhat compared to  <span class='latex-textit'>IdeaForkLite</span> .<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.14' ><span class='entry-number'>8.14</span> The Journey Is the Destination</a> </h2>
 In this chapter, we have seen how easily CDI-based applications can be split into independent services.
Even topics like "Service Discovery,"
which are currently neither part of CDI nor Java EE, can be easily added with the help of a CDI extension.
The additional complexity that we have seen throughout the chapter and
further topics such as the use of container solutions (such as Docker),
the implementation of additional infrastructure components (such as build pipelines),
specialized monitoring (for example in conjunction with a circuit breaker mechanism), and
several other topics are independent of CDI and are currently primarily provided by proprietary projects.
The path to an application that covers all these aspects is therefore still somewhat longer, and
the goal with Java EE is currently only achievable with additional extensions.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Since this chapter was first published, the micro-deployment landscape has fundamentally changed. MicroProfile has established itself as an official standard and is natively supported by runtimes such as Quarkus, Open Liberty, and Helidon. Meecrowave and WildFly Swarm, used in this chapter, have been superseded by their successors – Meecrowave remains part of the Apache ecosystem, while WildFly Swarm has evolved into WildFly Bootable JAR. Quarkus has emerged as the leading runtime for CDI-based microservices and is covered in Chapter <a href='#!idx:/quarkus.html:10' style='color:#2e7d32;'>10</a>. The service discovery topic has also been largely resolved through Kubernetes and container orchestration. The CDI integration patterns presented in this chapter – particularly Partial Beans for remote clients and the CDI/Spring Bridge – remain relevant as architectural approaches, however.</div>
<div class="tip"><b>Tip: </b><b>What comes next?</b> <span class='latex-textit'>IdeaForkMicro</span> demonstrated that CDI-based microservices work outside an application server. Chapter <a href='#!idx:/upgrade.html:9'>9</a> covers the migration from Java EE to Jakarta EE, Chapter <a href='#!idx:/quarkus.html:10'>10</a> shows the switch to Quarkus with build-time optimization and native images, and Chapter <a href='#!idx:/angular.html:11'>11</a> replaces the JSF frontend with an Angular SPA. Together, these chapters form the complete modernization path.</div>
</section>
<section class="chapter-section" id="chapter-9">
<h1> <a class='latex-index-anchor' name='!idx:/upgrade.html:9'><span class='entry-number'>9</span> From Java EE to Jakarta EE</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> This chapter was written by Claude (Anthropic) based on the previous chapters. It describes the evolution of CDI and Jakarta EE since this book was first published. The code examples are based on IdeaFork but have been adapted to current specifications.
</div>
<a name = '!idx:/upgrade.html:chap:javaee-to-jakartaee'> </a><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.1'><span class='entry-number'>9.1</span> A New Chapter</a> </h2>
 In the previous chapters, we explored CDI 1.0 through 2.0 in the context of Java EE 6 and Java EE 7.
We saw how <span class='latex-textit'>IdeaFork</span> could be implemented step by step using the core concepts of CDI,
portable extensions, and Apache DeltaSpike.
Since this book was first published, however, the Java EE ecosystem has undergone a fundamental transformation.
The platform was transferred to the Eclipse Foundation and has since been known as Jakarta EE.
CDI has now reached version 4.1 and is part of Jakarta EE 11.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In this chapter, we guide the migration of <span class='latex-textit'>IdeaFork</span> from Java EE to Jakarta EE.
We examine the most important changes in CDI 3.0, 4.0, and 4.1 and highlight
their impact on existing projects.
We focus on the aspects that are most relevant for day-to-day work with CDI.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The migration from Java EE to Jakarta EE is a necessary step for many projects,
since Java EE 8 was the last version under the old namespace.
New features and bug fixes are developed exclusively under the Jakarta EE namespace.
Anyone who wants to benefit from improvements in CDI and other specifications in the long term
cannot avoid a migration.<br /> <h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.2'><span class='entry-number'>9.2</span> From javax to jakarta</a> </h2>
 The most visible change in the migration to Jakarta EE 9 and later is the switch of the package name
from <span class='latex-texttt'>javax</span> to <span class='latex-texttt'>jakarta</span>.
This change was necessary because Oracle did not release the <span class='latex-texttt'>javax</span> namespace when handing over to the Eclipse Foundation.
For CDI, this means that from CDI 3.0 onward, all imports must be updated.
This affects not only CDI-specific annotations but all Java EE APIs
used in an application.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Let us look at the impact on <span class='latex-textit'>IdeaFork</span> with a concrete example.
Listing <a href='#!idx:/upgrade.html:fig:javax-to-jakarta-before'> IdeaManager with javax Imports </a> shows the previous version of our <span class='latex-texttt'>IdeaManager</span> class
with the classic <span class='latex-texttt'>javax</span> imports.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:javax-to-jakarta-before'></a>                     <pre><code>import javax.inject.Inject;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Event;

@ApplicationScoped
public class IdeaManager {
    @Inject
    private IdeaRepository ideaRepository;

    @Inject
    private Event&lt;IdeaChangedEvent&gt; ideaChangedEvent;

    public Idea createIdea(Idea idea) {
        Idea savedIdea = ideaRepository.save(idea);
        ideaChangedEvent.fire(new IdeaChangedEvent(savedIdea));
        return savedIdea;
    }

    //...
}
</code></pre>
                </div>
Listing <a href='#!idx:/upgrade.html:fig:javax-to-jakarta-after'> IdeaManager with jakarta Imports </a> shows the updated version with the new <span class='latex-texttt'>jakarta</span> imports.
As can be seen, only the package name in the import statements changes.
The remaining code stays completely identical.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:javax-to-jakarta-after'></a>                     <pre><code>import jakarta.inject.Inject;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Event;

@ApplicationScoped
public class IdeaManager {
    @Inject
    private IdeaRepository ideaRepository;

    @Inject
    private Event&lt;IdeaChangedEvent&gt; ideaChangedEvent;

    public Idea createIdea(Idea idea) {
        Idea savedIdea = ideaRepository.save(idea);
        ideaChangedEvent.fire(new IdeaChangedEvent(savedIdea));
        return savedIdea;
    }

    //...
}
</code></pre>
                </div>
In addition to the Java imports, the configuration file <span class='latex-texttt'>beans.xml</span> must also be updated.
The XML namespace and the schema location change accordingly.
Listing <a href='#!idx:/upgrade.html:fig:beans-xml-before'> beans.xml with javax Namespace </a> shows the previous version.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:beans-xml-before'></a>                     <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
           http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd"
       bean-discovery-mode="all"
       version="2.0"&gt;

    &lt;interceptors&gt;
        &lt;class&gt;at.irian.cdiatwork.ideafork.core.impl.MonitorInterceptor&lt;/class&gt;
    &lt;/interceptors&gt;
&lt;/beans&gt;
</code></pre>
                </div>
Listing <a href='#!idx:/upgrade.html:fig:beans-xml-after'> beans.xml with jakarta Namespace </a> shows the updated version for Jakarta EE.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:beans-xml-after'></a>                     <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="https://jakarta.ee/xml/ns/jakartaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee
           https://jakarta.ee/xml/ns/jakartaee/beans_4_0.xsd"
       bean-discovery-mode="annotated"
       version="4.0"&gt;

    &lt;interceptors&gt;
        &lt;class&gt;at.irian.cdiatwork.ideafork.core.impl.MonitorInterceptor&lt;/class&gt;
    &lt;/interceptors&gt;
&lt;/beans&gt;
</code></pre>
                </div>
The third area affected by the namespace migration is the Maven coordinates.
The CDI API is published under new coordinates.
Listing <a href='#!idx:/upgrade.html:fig:maven-dependency-before'> Maven Dependency with javax Coordinates </a> shows the previous dependency.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:maven-dependency-before'></a>                     <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.enterprise&lt;/groupId&gt;
    &lt;artifactId&gt;cdi-api&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div>
Listing <a href='#!idx:/upgrade.html:fig:maven-dependency-after'> Maven Dependency with jakarta Coordinates </a> shows the updated dependency for CDI 4.1.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:maven-dependency-after'></a>                     <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;jakarta.enterprise&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.enterprise.cdi-api&lt;/artifactId&gt;
    &lt;version&gt;4.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div>
<div class="tip"><b>Tip: </b>There are tools such as the Eclipse Transformer that can automate the migration process. For smaller projects like <span class='latex-textit'>IdeaFork</span>, a manual migration is often more efficient. The Eclipse Transformer can be particularly helpful for larger projects with many modules and dependencies, as it can transform both source code and binary files.</div>
<div class="tip"><b>Tip: </b><b>Automated migration tools:</b> For the <span class='latex-texttt'>javax</span> &rarr; <span class='latex-texttt'>jakarta</span> migration, automated tools are available:<br />
&bull; <b>Eclipse Transformer:</b> Transforms bytecode, source code, and configuration files. Invocation: <span class='latex-texttt'>java -jar transformer.jar input.war output.war</span><br />
&bull; <b>OpenRewrite:</b> Maven plugin for automated refactoring: <span class='latex-texttt'>mvn rewrite:run -Drewrite.activeRecipes=org.openrewrite.java.migrate.jakarta.JavaxMigrationToJakarta</span><br />
&bull; <b>IntelliJ Migration Tool:</b> Refactor &rarr; Migrate Packages and Classes (from IntelliJ 2021.3)<br />
For large projects like <span class='latex-textit'>IdeaFork</span>, a combination is recommended: automated migration followed by manual review of the <span class='latex-texttt'>beans.xml</span> schema versions and CDI-specific configurations.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.3'><span class='entry-number'>9.3</span> CDI Lite and CDI Full</a> </h2>
 With CDI 4.0, which was released as part of Jakarta EE 10, a fundamental architectural split was introduced.
The specification was formally divided into two parts: CDI Lite and CDI Full.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> At this point, an important clarification is needed.
In the chapter <a href='#!idx:/cdi_lite.html:chap:cdi_lite'> CDI Lite </a> of this book, we described a lightweight approach to developing CDI applications.
There, the goal was to simplify the implementation of <span class='latex-textit'>IdeaFork</span>
by keeping only the actually needed CDI concepts and removing unnecessary abstractions.
The CDI Lite specification starting from CDI 4.0, on the other hand, defines something fundamentally different:
a formally specified subset of the CDI API, specifically optimized for build-time compilation.
Despite the identical name, these are two different concepts.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI Lite covers the core area of CDI functionality and is designed
so that it can also be used in environments that do not require a full Java EE runtime.
In particular, CDI Lite enables the processing of CDI metadata at build time.
Frameworks like Quarkus use this approach to drastically reduce application startup times
by performing expensive reflection-based operations during the build process.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI Lite includes the following core features:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
- <span class='latex-texttt'>@Inject</span> and <span class='latex-texttt'>@Produces</span> for dependency injection and producer methods<br />
- <span class='latex-texttt'>@Observes</span> and <span class='latex-texttt'>@ObservesAsync</span> for synchronous and asynchronous events<br />
- Scopes: <span class='latex-texttt'>@RequestScoped</span>, <span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@Dependent</span>, and <span class='latex-texttt'>@Singleton</span><br />
- Qualifiers and stereotypes<br />
- Interceptors with <span class='latex-texttt'>@AroundInvoke</span> and <span class='latex-texttt'>@AroundConstruct</span><br />
- Build Compatible Extensions (new in CDI 4.0)<br />
- Programmatic bean lookup via <span class='latex-texttt'>Instance&lt;T&gt;</span><br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI Full extends CDI Lite with the following features:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
- Decorators with <span class='latex-texttt'>@Decorated</span> and <span class='latex-texttt'>@Delegate</span><br />
- <span class='latex-texttt'>@Specializes</span> for bean specialization<br />
- <span class='latex-texttt'>@ConversationScoped</span> and <span class='latex-texttt'>@SessionScoped</span><br />
- Portable Extensions (the classic <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span> interface)<br />
- Passivation and passivation-capable scopes<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For <span class='latex-textit'>IdeaFork</span>, this split means that some of the features used in the previous chapters require CDI Full.
This includes in particular the decorators that we used in the chapter <a href='#!idx:/java_ee.html:chap:cdi-java_ee'> CDI and Java EE </a> for repository extension,
as well as bean specialization from the chapter <a href='#!idx:/basics.html:chap:cdi-basics'> CDI Fundamentals </a>.
The conversation scope, which we used in <span class='latex-textit'>IdeaFork</span>, is also a CDI Full feature.
If <span class='latex-textit'>IdeaFork</span> is deployed on a full Jakarta EE server, all these features remain available.
If, however, the application is to be run in a pure CDI Lite environment,
the corresponding parts must be adapted.
The simplifications already carried out in the chapter <a href='#!idx:/cdi_lite.html:chap:cdi_lite'> CDI Lite </a>,
such as switching from decorators to interceptors, significantly facilitate such a migration.<br /> <div class="tip"><b>Tip: </b>The term "CDI Lite" in this book (Chapter 6) refers to a lightweight approach to developing CDI applications. The CDI Lite specification starting from CDI 4.0, on the other hand, defines a subset of the CDI API optimized for build-time compilation. Despite the identical name, these are different concepts.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.4'><span class='entry-number'>9.4</span> Build Compatible Extensions</a> </h2>
 In the chapter <a href='#!idx:/extensions.html:chap:cdi-extensions'> Portable CDI Extensions </a>, we learned about the CDI lifecycle and
the implementation of portable extensions based on the <span class='latex-texttt'>Extension</span> interface.
These classic Portable Extensions continue to work in CDI Full.
With CDI 4.0, however, a new extension model was introduced:
Build Compatible Extensions. These are available in both CDI Lite and CDI Full and
offer a significantly simpler API than the previous Portable Extensions.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The key difference lies in the execution time.
Portable Extensions run exclusively at runtime, as they interact directly with the CDI container.
Build Compatible Extensions, on the other hand, are designed so that they can also be executed at build time.
In a traditional runtime environment, they are emulated at runtime by the CDI implementation.
In a build-time environment like Quarkus, they are already executed during the build process,
significantly reducing application startup time.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Build Compatible Extensions define five phases, expressed through annotations on methods:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
- <span class='latex-texttt'>@Discovery</span>: Enables registering additional types and bean classes before the bean discovery process begins.<br />
- <span class='latex-texttt'>@Enhancement</span>: Allows modification of annotations on existing bean classes, comparable to <span class='latex-texttt'>ProcessAnnotatedType</span>.<br />
- <span class='latex-texttt'>@Registration</span>: Called after bean registration and enables inspection of registered beans.<br />
- <span class='latex-texttt'>@Synthesis</span>: Allows programmatic addition of synthetic beans and observers, comparable to <span class='latex-texttt'>AfterBeanDiscovery</span>.<br />
- <span class='latex-texttt'>@Validation</span>: The final phase, in which the entire bean configuration can be validated.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> To illustrate, we migrate the <span class='latex-texttt'>EntityVetoExtension</span> from the chapter <a href='#!idx:/extensions.html:chap:cdi-extensions'> Portable CDI Extensions </a>.
As a reminder: this extension ensures that JPA entities are not registered as CDI beans.
Listing <a href='#!idx:/upgrade.html:fig:portable-extension-original'> Original EntityVetoExtension as Portable Extension </a> shows the previous implementation.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:portable-extension-original'></a>                     <pre><code>public class EntityVetoExtension implements Extension {
    public void vetoEntities(
            @Observes @WithAnnotations({Entity.class})
            ProcessAnnotatedType&lt;?&gt; pat) {
        pat.veto();
    }
}
</code></pre>
                </div>
Listing <a href='#!idx:/upgrade.html:fig:bce-entity-veto'> EntityVetoExtension as Build Compatible Extension </a> shows the equivalent implementation as a Build Compatible Extension.
The method with <span class='latex-texttt'>@Enhancement</span> is called for all classes annotated with <span class='latex-texttt'>@Entity</span>.
Instead of <span class='latex-texttt'>ProcessAnnotatedType#veto</span>, the class is made invisible to CDI by adding the <span class='latex-texttt'>@Vetoed</span> annotation.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:bce-entity-veto'></a>                     <pre><code>public class EntityVetoBuildExtension implements BuildCompatibleExtension {
    @Enhancement(types = Object.class, withAnnotations = Entity.class)
    public void vetoEntities(ClassConfig config) {
        config.addAnnotation(Vetoed.class);
    }
}
</code></pre>
                </div>
As with Portable Extensions, registration is done via the service loader mechanism.
Instead of <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>, the fully qualified name of the new interface is used.
Listing <a href='#!idx:/upgrade.html:fig:bce-registration'> Registration of a Build Compatible Extension </a> shows the corresponding configuration file.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:bce-registration'></a>                     <pre><code># META-INF/services/jakarta.enterprise.inject.build.compatible.spi.BuildCompatibleExtension
at.irian.cdiatwork.ideafork.core.EntityVetoBuildExtension
</code></pre>
                </div>
The comparison of the two approaches shows that the Build Compatible Extension API is conceptually simpler.
Instead of observer methods with special event types, directly annotated methods are used.
Filtering is done via attributes of the phase annotations instead of <span class='latex-texttt'>@WithAnnotations</span>.
For most use cases in <span class='latex-textit'>IdeaFork</span>, such as vetoing entities or
programmatic registration of additional beans, Build Compatible Extensions offer a comfortable alternative.<br /> <div class="tip"><b>Tip: </b>Build Compatible Extensions offer a simpler API than Portable Extensions. For most use cases in <span class='latex-textit'>IdeaFork</span>, migrating to Build Compatible Extensions would be recommended. Portable Extensions, however, remain available in CDI Full and are still the right choice for advanced scenarios that require direct access to the <span class='latex-texttt'>BeanManager</span> at runtime.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.5'><span class='entry-number'>9.5</span> New Rules</a> </h2>
 In addition to the structural changes described so far, CDI 4.0 also brings a significant behavioral change:
the default value for the bean discovery mode has been changed from <span class='latex-texttt'>all</span> to <span class='latex-texttt'>annotated</span>.
This change has far-reaching consequences for existing applications.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In the previous mode <span class='latex-texttt'>all</span>, all classes in a Bean Deployment Archive were considered potential CDI beans.
In mode <span class='latex-texttt'>annotated</span>, only classes with a so-called Bean Defining Annotation are discovered.
These include scope annotations such as <span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@RequestScoped</span>, or <span class='latex-texttt'>@Dependent</span>,
stereotype annotations, interceptor and decorator annotations.
Classes without such an annotation are no longer automatically discovered by the CDI container.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> For <span class='latex-textit'>IdeaFork</span>, this means that some classes that were previously treated implicitly as CDI beans
now require an explicit scope annotation.
Listing <a href='#!idx:/upgrade.html:fig:bean-discovery-annotated'> Class with Explicit Bean Defining Annotation </a> shows an example from <span class='latex-textit'>IdeaFork</span>,
where the <span class='latex-texttt'>PasswordManager</span> class needs to be augmented with <span class='latex-texttt'>@Dependent</span>
so that it continues to be discovered by the CDI container.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:bean-discovery-annotated'></a>                     <pre><code>import jakarta.enterprise.context.Dependent;

@Dependent
public class PasswordManager {
    public String createPasswordHash(String password) {
        //...
    }

    public boolean isValidPassword(String password, String passwordHash) {
        //...
    }
}
</code></pre>
                </div>
In <span class='latex-textit'>IdeaFork</span>, most beans are already annotated with scope annotations,
since we placed value on explicit configuration from the start.
Only helper classes like <span class='latex-texttt'>PasswordManager</span>, which previously managed without a scope annotation,
need to be updated accordingly.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI 4.1 also introduces the ability to apply <span class='latex-texttt'>@Priority</span> directly to producer methods.
Previously, it was necessary to activate alternative beans with <span class='latex-texttt'>@Alternative</span> and <span class='latex-texttt'>@Priority</span> at the class level.
With CDI 4.1, producer methods can be directly prioritized as well.
Listing <a href='#!idx:/upgrade.html:fig:priority-producer'> Producer Method with @Priority </a> shows an example
where an alternative <span class='latex-texttt'>ObjectConverter</span> is provided via a prioritized producer method.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:priority-producer'></a>                     <pre><code>import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Alternative;
import jakarta.enterprise.inject.Produces;

@ApplicationScoped
public class TestObjectConverterProducer {

    @Produces
    @Alternative
    @Priority(100)
    @ApplicationScoped
    public ObjectConverter createTestConverter() {
        return new ObjectConverter(/*test configuration*/);
    }
}
</code></pre>
                </div>
As a further addition in CDI 4.1, the Method Invokers API should be mentioned.
This API enables frameworks to invoke methods on CDI beans in a standardized and optimized way.
For application developers, this API is typically not directly relevant;
however, it forms the foundation for more efficient framework integrations.<br /> <div class="tip"><b>Tip: </b><b>CDI 4.1 &mdash; Additions:</b> CDI 4.1 (part of Jakarta EE 11) brings incremental improvements: enhanced programmatic lookup methods on <span class='latex-texttt'>Instance&lt;T&gt;</span>, clearer specification of <span class='latex-texttt'>@Priority</span> behavior for producers and stereotypes, and the Method Invokers API for Build Compatible Extensions. These changes are backward compatible &mdash; existing CDI 4.0 code works without modifications.</div>
<div class="tip"><b>Tip: </b>When migrating from <span class='latex-texttt'>bean-discovery-mode="all"</span> to <span class='latex-texttt'>"annotated"</span>, it is recommended to first preserve the existing behavior and switch the mode gradually. As a first step, <span class='latex-texttt'>bean-discovery-mode="all"</span> can be explicitly set in the <span class='latex-texttt'>beans.xml</span>. After that, the missing Bean Defining Annotations can be added class by class before finally switching the mode to <span class='latex-texttt'>"annotated"</span>.</div>
<h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.6'><span class='entry-number'>9.6</span> DeltaSpike 2.0</a> </h2>
 Apache DeltaSpike, which we used extensively in the chapter <a href='#!idx:/deltaspike.html:chap:deltaspike'> Apache DeltaSpike </a> and in the following chapters,
has also been migrated to the Jakarta namespace with version 2.0.
DeltaSpike 2.0.x requires at least Java 11 and Jakarta EE 9.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The good news is that the API of DeltaSpike 2.0 is functionally largely identical to DeltaSpike 1.x.
All modules that we used in <span class='latex-textit'>IdeaFork</span> remain available unchanged.
The <span class='latex-texttt'>ConfigResolver</span>, which we used in <span class='latex-textit'>IdeaForkMicro</span> for port configuration,
the <span class='latex-texttt'>BeanProvider</span> for programmatic access to CDI beans,
and the <span class='latex-texttt'>ViewConfig</span> mechanisms for type-safe navigation all work the same way.
Only the imports now use the <span class='latex-texttt'>jakarta</span> namespace.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/upgrade.html:fig:deltaspike-maven'> DeltaSpike 2.0 Maven Dependency </a> shows the updated Maven dependency for DeltaSpike Core.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:deltaspike-maven'></a>                     <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.core&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-core-api&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.core&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-core-impl&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div>
All DeltaSpike-specific annotations such as <span class='latex-texttt'>@Exclude</span>, <span class='latex-texttt'>@ViewAccessScoped</span>,
<span class='latex-texttt'>@WindowScoped</span>, and <span class='latex-texttt'>@GroupedConversationScoped</span> are also available in DeltaSpike 2.0.
The DeltaSpike-specific scope implementations, which we learned about in <span class='latex-textit'>IdeaFork</span> as alternatives to the CDI conversation scope,
work unchanged under the Jakarta namespace.
The DeltaSpike Data modules and the Test Control modules, which we used for JUnit integration,
are also available in updated versions.<br /> <div class="tip"><b>Tip: </b>Since DeltaSpike 2.0 is API-compatible with DeltaSpike 1.x (apart from the namespace change), the migration can be performed simultaneously with the javax-to-jakarta migration. It is recommended to combine both migrations in a single step to minimize the testing effort.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.7'><span class='entry-number'>9.7</span> The CDI Implementations</a> </h2>
 In the chapter <a href='#!idx:/introduction.html:1'> Introduction to CDI </a>, we introduced Weld and OpenWebBeans as the two primary CDI implementations.
Both projects have supported the evolution of the CDI specification and support the current versions.
In the previous chapters, we could run <span class='latex-textit'>IdeaFork</span> with both implementations.
This continues to be possible with the current versions.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/upgrade.html:fig:impl-version-table'> CDI Implementation Version Overview </a> shows the mapping between CDI versions,
implementation versions, and the corresponding Jakarta EE versions.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:impl-version-table'></a>                     <pre><code>CDI Specification    Weld           OpenWebBeans    Jakarta EE
CDI 1.0              1.x            1.x             Java EE 6
CDI 1.1              2.x            1.x             Java EE 7
CDI 2.0              3.x            2.x             Java EE 8
CDI 3.0              4.x            2.x             Jakarta EE 9/9.1
CDI 4.0              5.x            4.x             Jakarta EE 10
CDI 4.1              6.x            -               Jakarta EE 11
</code></pre>
                </div>
Weld 6.x, the current major version of JBoss Weld, implements CDI 4.1 and requires at least Java 11.
Weld is used in WildFly and GlassFish as the default CDI implementation.
Through active development, Weld supports all new features of CDI 4.0 and 4.1,
including Build Compatible Extensions and the Method Invokers API.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Apache OpenWebBeans 4.x implements CDI 4.0 and also requires Java 11.
OpenWebBeans is used in Apache TomEE as the default CDI implementation.
For projects that have previously used Apache Meecrowave or TomEE as their runtime environment,
OpenWebBeans 4.x offers a seamless upgrade path.
Both implementations fully support the Jakarta EE namespace.<br /> <div class="tip"><b>Tip: </b>For projects currently based on Weld 1.x or 2.x, a gradual update through intermediate versions is recommended to identify compatibility issues early. The jump from Weld 3.x to 4.x includes the namespace change and should be performed together with the javax-to-jakarta migration.</div>
<div class="tip"><b>Tip: </b><b>Compatibility matrix &mdash; Which versions go together?</b><br />
&bull; <b>CDI 1.0 / 1.1:</b> Weld 1.x&ndash;2.x, OWB 1.x &mdash; Java EE 6&ndash;7, Java 6&ndash;8<br />
&bull; <b>CDI 2.0:</b> Weld 3.x, OWB 2.x &mdash; Java EE 8, Java 8&ndash;11<br />
&bull; <b>CDI 3.0:</b> Weld 4.x, OWB 2.0.27+ &mdash; Jakarta EE 9, Java 11+<br />
&bull; <b>CDI 4.0 / 4.1:</b> Weld 5.x, OWB 4.x &mdash; Jakarta EE 10+, Java 17+<br />
&bull; <b>Quarkus (ArC):</b> Custom CDI Lite implementation, no Weld/OWB &mdash; Java 17+<br />
When migrating an existing application, not only the namespace must be changed, but the implementation versions must also match each other.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.8'><span class='entry-number'>9.8</span> Upgrading IdeaFork</a> </h2>
 To conclude this chapter, we summarize the individual migration steps for <span class='latex-textit'>IdeaFork</span> in a concrete checklist.
These steps are listed in the recommended order and can serve as a guide for migrating your own projects.
Listing <a href='#!idx:/upgrade.html:fig:migration-checklist'> Migration Checklist for IdeaFork </a> shows the complete overview.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:migration-checklist'></a>                     <pre><code>Migration Checklist: IdeaFork to Jakarta EE
================================================

1. Update Maven dependencies
   - javax.enterprise:cdi-api:2.0
     -> jakarta.enterprise:jakarta.enterprise.cdi-api:4.1.0
   - javax:javaee-web-api:7.0
     -> jakarta.platform:jakarta.jakartaee-web-api:10.0.0
   - DeltaSpike 1.x -> DeltaSpike 2.0.0

2. Change all javax imports to jakarta
   - javax.inject.*          -> jakarta.inject.*
   - javax.enterprise.*      -> jakarta.enterprise.*
   - javax.annotation.*      -> jakarta.annotation.*
   - javax.persistence.*     -> jakarta.persistence.*
   - javax.faces.*           -> jakarta.faces.*
   - javax.ws.rs.*           -> jakarta.ws.rs.*
   - javax.validation.*      -> jakarta.validation.*

3. Update beans.xml
   - XML namespace:  xmlns.jcp.org -> jakarta.ee
   - Schema location: beans_2_0.xsd -> beans_4_0.xsd
   - version="2.0" -> version="4.0"

4. Review bean discovery mode
   - Default from CDI 4.0: "annotated" instead of "all"
   - Add scope annotations to classes without them
   - Alternative: explicitly set bean-discovery-mode="all"

5. Verify IdeaFork-specific features
   - Decorators (GenericRepositoryDecorator, etc.)
   - Interceptors (MonitorInterceptor, EntityProcessor)
   - Producer methods (EntityManagerProducer, etc.)
   - Event observers (IdeaChangedEvent, etc.)

6. Update CDI implementation
   - Weld: 1.x/2.x/3.x -> 6.x (for CDI 4.1)
   - OpenWebBeans: 1.x/2.x -> 4.x (for CDI 4.0)

7. Update DeltaSpike
   - Core, JPA, Data, JSF, Test-Control -> 2.0.x
   - Verify @Exclude, @ViewAccessScoped, @WindowScoped
   - Verify ConfigResolver configuration
</code></pre>
                </div>
When carrying out these steps, each step should be tested individually
before proceeding to the next.
Especially after the namespace change (steps 1-3), it is recommended
to run the existing test suite completely to identify errors early.
The JUnit tests used in <span class='latex-textit'>IdeaFork</span> with the DeltaSpike <span class='latex-texttt'>CdiTestRunner</span> and
the Meecrowave-based tests in <span class='latex-textit'>IdeaForkMicro</span> provide a good foundation here.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The migration of <span class='latex-textit'>IdeaFork</span> demonstrates that while the transition from Java EE to Jakarta EE requires some mechanical changes,
the fundamental architecture of a CDI-based application remains stable.
The core philosophy of CDI, type-safe dependency injection based on annotations,
has proven to be a solid foundation across all versions.
With CDI 4.0 and 4.1, the specification was enriched with modern concepts such as Build Compatible Extensions and
the formal split into CDI Lite and CDI Full,
without abandoning the proven fundamentals.
The concepts and patterns developed in the previous chapters retain their validity under Jakarta EE and
continue to form the basis for the successful development of modern CDI applications.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div class="tip"><b>Tip: </b><b>Common migration errors and their solutions:</b><br />
&bull; <b><span class='latex-texttt'>ClassNotFoundException: javax.enterprise.*</span></b> &mdash; The dependencies were switched to <span class='latex-texttt'>jakarta.*</span>, but the source code still uses the old namespace. Solution: Update all imports (manually or with Eclipse Transformer / OpenRewrite).<br />
&bull; <b>Split package error (Java Module System):</b> Two JARs provide the same package (<span class='latex-texttt'>javax.inject</span> and <span class='latex-texttt'>jakarta.inject</span> simultaneously on the classpath). Solution: Ensure that only one variant is on the classpath.<br />
&bull; <b><span class='latex-texttt'>beans.xml</span> schema mismatch:</b> The schema URL must match the CDI version &mdash; <span class='latex-texttt'>xmlns.jcp.org</span> (CDI 1.x&ndash;2.x) vs. <span class='latex-texttt'>jakarta.ee</span> (CDI 3.0+). Solution: Update the schema version in <span class='latex-texttt'>beans.xml</span>.<br />
&bull; <b>Bean discovery mode change:</b> Starting with CDI 4.0, <span class='latex-texttt'>"annotated"</span> is the default instead of <span class='latex-texttt'>"all"</span>. Beans without a scope annotation are no longer discovered. Solution: Explicitly set <span class='latex-texttt'>bean-discovery-mode="all"</span> or add the missing annotations.</div>
<b>Sources:</b><br />
- jakarta.ee<br />
- cdi-spec.org<br />
- weld.cdi-spec.org<br />
- openwebbeans.apache.org<br />
- deltaspike.apache.org<br />
- wildfly.org<br />
- glassfish.org<br />
- tomee.apache.org<br />
- quarkus.io<br />
- projects.eclipse.org/projects/technology.transformer<br />
</section>
<section class="chapter-section" id="chapter-10">
<h1> <a class='latex-index-anchor' name='!idx:/quarkus.html:10'><span class='entry-number'>10</span> Migration to Quarkus</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> This chapter was written by Claude (Anthropic) based on the previous chapters. It describes the migration of a CDI/DeltaSpike application to Quarkus. The code examples are based on IdeaFork but have been adapted to the Quarkus platform.
</div>
<a name = '!idx:/quarkus.html:chap:quarkus-migration'> </a><h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.1'><span class='entry-number'>10.1</span> A New Target</a> </h2>
 In the previous chapters we first got to know CDI in the context of Java EE and
in Chapter 9 we accompanied the transition to Jakarta EE.
Throughout this journey the fundamental architecture remained the same:
an application server runs the application and provides the CDI container at runtime.
Quarkus takes a fundamentally different approach.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Quarkus is a Java framework specifically designed for cloud-native applications and GraalVM Native Images.
Unlike traditional application servers, Quarkus shifts as much work as possible from runtime to the build phase.
Dependency injection, configuration resolution, and
bean discovery do not take place when the application starts,
but rather at compile time.
The result is extremely fast startup times and low memory consumption.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The heart of CDI support in Quarkus is <span class='latex-textit'>ArC</span>,
a CDI Lite compatible implementation
optimized for build-time processing.
ArC implements the CDI Lite specification and additionally provides some Quarkus-specific extensions.
Unlike Weld or OpenWebBeans,
which implement the full CDI Full standard,
ArC deliberately focuses on the features relevant to microservices.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In this chapter we accompany the migration of <span class='latex-textit'>IdeaFork</span> to Quarkus.
We examine the differences to CDI Full,
show which DeltaSpike features can be replaced by MicroProfile and Quarkus equivalents, and
discuss the specifics to consider when creating Native Images.
<br /> <div class="tip"><b>Tip: </b> Quarkus offers a <span class='latex-texttt'>Dev Mode</span> with live reload
that significantly accelerates development.
Changes to the code take effect immediately without restarting the application.
Combined with the fast build-time CDI processing by ArC, this results in a very short feedback cycle.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.2'><span class='entry-number'>10.2</span> From CDI Full to ArC</a> </h2>
 ArC is based on the CDI Lite specification, which we already got to know in Chapter 9.
Unlike CDI Full, ArC has some different rules
that must be considered during migration.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The most important difference concerns the <span class='latex-texttt'>beans.xml</span> file.
In a CDI Full environment, <span class='latex-texttt'>beans.xml</span> controls the bean discovery mode and
can declare interceptors, decorators, and alternatives.
In Quarkus, the content of <span class='latex-texttt'>beans.xml</span> is largely ignored.
The file can still be present but only serves as a marker
to identify an archive as a Bean Deployment Archive.
Listing <a href='#!idx:/quarkus.html:fig:beans-xml-cdi-full'> beans.xml in CDI Full </a> shows the previous configuration,
Listing <a href='#!idx:/quarkus.html:fig:beans-xml-quarkus'> beans.xml in Quarkus </a> shows the simplified Quarkus variant.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:beans-xml-cdi-full'></a>                     <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="https://jakarta.ee/xml/ns/jakartaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee
           https://jakarta.ee/xml/ns/jakartaee/beans_4_0.xsd"
       bean-discovery-mode="all"
       version="4.0"&gt;

    &lt;interceptors&gt;
        &lt;class&gt;at.irian.cdiatwork.ideafork.core.impl.MonitorInterceptor&lt;/class&gt;
    &lt;/interceptors&gt;

    &lt;decorators&gt;
        &lt;class&gt;at.irian.cdiatwork.ideafork.core.impl.GenericRepositoryDecorator&lt;/class&gt;
    &lt;/decorators&gt;
&lt;/beans&gt;
</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:beans-xml-quarkus'></a>                     <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="https://jakarta.ee/xml/ns/jakartaee"
       version="4.0"&gt;
    &lt;!-- Inhalt wird von Quarkus/ArC ignoriert --&gt;
    &lt;!-- Interceptoren und Decoratoren werden via @Priority aktiviert --&gt;
&lt;/beans&gt;
</code></pre>
                </div>
<div class="tip"><b>Tip: </b> In Quarkus, <span class='latex-texttt'>beans.xml</span> is optional.
Quarkus automatically scans all classes in the application module.
For external libraries, a <span class='latex-texttt'>beans.xml</span> in the archive or
the Jandex index (<span class='latex-texttt'>META-INF/jandex.idx</span>) can be used
to make the contained classes visible to ArC.</div>
The bean discovery mode in Quarkus is fixed to <span class='latex-texttt'>annotated</span>.
Switching to <span class='latex-texttt'>all</span> is not possible.
This means that every bean must carry a scope annotation such as
<span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@RequestScoped</span>, or <span class='latex-texttt'>@Dependent</span>
to be detected by ArC.
Classes without a scope annotation that were recognized as <span class='latex-texttt'>@Dependent</span> beans in CDI Full with <span class='latex-texttt'>bean-discovery-mode="all"</span>
must be explicitly annotated for Quarkus.
Listing <a href='#!idx:/quarkus.html:fig:discovery-annotated'> Explicit Scope Annotation </a> shows an example.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:discovery-annotated'></a>                     <pre><code>// Ohne Scope-Annotation: wird von ArC NICHT erkannt
public class IdeaValidator {
    public boolean isValid(Idea idea) {
        return idea.getTitle() != null;
    }
}

// Mit Scope-Annotation: wird von ArC erkannt
@Dependent
public class IdeaValidator {
    public boolean isValid(Idea idea) {
        return idea.getTitle() != null;
    }
}
</code></pre>
                </div>
Another difference concerns the concept of Bean Archives.
In CDI Full, Bean Deployment Archives define visibility boundaries:
beans from an archive without <span class='latex-texttt'>beans.xml</span> are not visible to other archives.
In Quarkus, there are no such visibility boundaries.
All beans annotated with a scope annotation or otherwise registered are globally visible.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> ArC offers another practical advantage:
no-arg constructors are automatically generated.
In CDI Full, a bean with an <span class='latex-texttt'>@Inject</span> constructor additionally requires a parameterless constructor
(or more precisely, a constructor that can be called by the container).
In Quarkus this is not required.
Listing <a href='#!idx:/quarkus.html:fig:no-arg-constructor'> Automatic Constructor Generation </a> shows the difference.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:no-arg-constructor'></a>                     <pre><code>// CDI Full: no-arg-Konstruktor erforderlich
@ApplicationScoped
public class IdeaService {
    private IdeaRepository repository;

    protected IdeaService() {} // fuer den CDI-Proxy

    @Inject
    public IdeaService(IdeaRepository repository) {
        this.repository = repository;
    }
}

// Quarkus/ArC: no-arg-Konstruktor wird automatisch generiert
@ApplicationScoped
public class IdeaService {
    private IdeaRepository repository;

    @Inject
    public IdeaService(IdeaRepository repository) {
        this.repository = repository;
    }
}
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> Private injection points should be avoided in Quarkus.
ArC must use special reflection mechanisms to access private fields,
which affects both performance and native image compatibility.
Use package-private visibility or constructor injection instead.</div>
Listing <a href='#!idx:/quarkus.html:fig:private-injection'> Private vs. Package-Private Injection </a> shows the difference.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:private-injection'></a>                     <pre><code>// Zu vermeiden: private Injection
@ApplicationScoped
public class IdeaService {
    @Inject
    private IdeaRepository repository; // verursacht Reflection-Overhead
}

// Besser: package-private Injection
@ApplicationScoped
public class IdeaService {
    @Inject
    IdeaRepository repository; // kein Reflection erforderlich
}
</code></pre>
                </div>
<div class="tip"><b>Tip: </b>When Quarkus serves as a REST backend for a separate frontend (Angular, React), CORS (Cross-Origin Resource Sharing) must be configured. Typical settings in <span class='latex-texttt'>application.properties</span> include <span class='latex-texttt'>quarkus.http.cors=true</span> and <span class='latex-texttt'>quarkus.http.cors.origins</span>. Important: <span class='latex-texttt'>PATCH</span> must be explicitly listed in <span class='latex-texttt'>quarkus.http.cors.methods</span> &mdash; a default list of <span class='latex-texttt'>GET, POST, PUT, DELETE</span> is not sufficient. If <span class='latex-texttt'>PATCH</span> is missing, the preflight request fails and the browser blocks the request without a meaningful error message.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.3'><span class='entry-number'>10.3</span> Scopes in Quarkus</a> </h2>
 In the previous chapters we got to know various CDI scopes:
from <span class='latex-texttt'>@ApplicationScoped</span> and <span class='latex-texttt'>@RequestScoped</span> to <span class='latex-texttt'>@SessionScoped</span> and <span class='latex-texttt'>@ConversationScoped</span>, as well as
the DeltaSpike-specific scopes like <span class='latex-texttt'>@ViewAccessScoped</span> and <span class='latex-texttt'>@WindowScoped</span>.
In Quarkus only a subset of these scopes is available.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The following scopes are fully supported by Quarkus:
<span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@Singleton</span>, <span class='latex-texttt'>@RequestScoped</span>, and <span class='latex-texttt'>@Dependent</span>.
These cover most use cases in microservice architectures.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> <span class='latex-texttt'>@SessionScoped</span> is only available in Quarkus
when the <span class='latex-texttt'>quarkus-undertow</span> extension (servlet support) is enabled.
Since Quarkus applications typically rely on RESTful architectures and work statelessly,
<span class='latex-texttt'>@SessionScoped</span> is rarely needed.<br /> <div class="tip"><b>Tip: </b> If <span class='latex-texttt'>@SessionScoped</span> is needed,
the <span class='latex-texttt'>quarkus-undertow</span> dependency can be added to the <span class='latex-texttt'>pom.xml</span>.
In most cases, however, it is recommended
to design the application statelessly and manage session data in an external store (e.g., Redis).</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> <span class='latex-texttt'>@ConversationScoped</span> is not supported by Quarkus.
In <span class='latex-textit'>IdeaFork</span> we did not use <span class='latex-texttt'>@ConversationScoped</span> directly,
but the concept was introduced in Chapter 3 as an alternative to <span class='latex-texttt'>@SessionScoped</span>.
When migrating to Quarkus, this scope must be replaced by <span class='latex-texttt'>@RequestScoped</span> in combination with explicit state passing.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> The DeltaSpike scopes <span class='latex-texttt'>@ViewAccessScoped</span>,
<span class='latex-texttt'>@WindowScoped</span>, and <span class='latex-texttt'>@GroupedConversationScoped</span> have no equivalent in Quarkus.
These scopes are tightly coupled to JSF and the concept of browser windows.
When migrating to Quarkus, the architecture must be redesigned for REST-based,
stateless communication.</div>
 Quarkus additionally offers the <span class='latex-texttt'>@TransactionScoped</span> scope,
which is used in <span class='latex-textit'>IdeaForkMicro</span> for EntityManager producers.
This scope is bound to the lifecycle of a JTA transaction and
is natively supported by Quarkus.
Listing <a href='#!idx:/quarkus.html:fig:transaction-scoped'> @TransactionScoped EntityManager </a> shows the pattern.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:transaction-scoped'></a>                     <pre><code>// IdeaForkMicro-Pattern: @TransactionScoped EntityManager
import jakarta.transaction.TransactionScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

@ApplicationScoped
public class EntityManagerProducer {
    @PersistenceContext
    EntityManager em;

    @Produces
    @TransactionScoped
    public EntityManager createEntityManager() {
        return em;
    }
}

// In Quarkus: entfaellt - Panache verwaltet den EntityManager
// Bei Bedarf kann @Inject EntityManager direkt verwendet werden
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> In <span class='latex-textit'>IdeaForkMicro</span> a custom <span class='latex-texttt'>@ConfigScoped</span> scope is used
that creates a new bean instance whenever the configuration changes.
This custom scope has no direct equivalent in Quarkus.
As an alternative, <span class='latex-texttt'>@ApplicationScoped</span> can be used in combination with
<span class='latex-texttt'>@ConfigProperty</span> and an <span class='latex-texttt'>@Observes StartupEvent</span> handler
that loads the configuration at startup.
Dynamic configuration changes at runtime require a custom mechanism,
for example via Quarkus Dev Services or a MicroProfile Config watcher.</div>
Listing <a href='#!idx:/quarkus.html:fig:scope-migration'> Scope Migration </a> shows typical adjustments during scope migration.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:scope-migration'></a>                     <pre><code>// Vorher: @SessionScoped (zustandsbehaftet)
@SessionScoped
public class UserSession implements Serializable {
    private User currentUser;

    public void login(User user) {
        this.currentUser = user;
    }

    public User getCurrentUser() {
        return currentUser;
    }
}

// Nachher: zustandsloser Ansatz mit JWT
@RequestScoped
public class UserContext {
    @Inject
    JsonWebToken jwt;

    public String getCurrentUserId() {
        return jwt.getSubject();
    }
}
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b>JAX-RS does not define a <span class='latex-texttt'>@PATCH</span> annotation in older specifications. However, Quarkus REST (formerly RESTEasy Reactive) fully supports it. For partial updates &mdash; e.g., toggling a boolean field without sending the entire entity &mdash; the endpoint can accept a <span class='latex-texttt'>Map&lt;String, Object&gt;</span> parameter. This loses compile-time type safety but matches how JavaScript frontends typically send partial JSON: <span class='latex-texttt'>{ "completed": true }</span> instead of the full entity.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.4'><span class='entry-number'>10.4</span> Configuration with MicroProfile Config</a> </h2>
 In Chapter 5 we got to know the DeltaSpike ConfigResolver and <span class='latex-texttt'>@ConfigProperty</span>
for managing application configurations in a type-safe manner.
Quarkus uses MicroProfile Config as the configuration standard instead.
The concepts are similar but differ in some details.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The most important difference:
the DeltaSpike annotation <span class='latex-texttt'>@ConfigProperty</span> comes from the package
<span class='latex-texttt'>org.apache.deltaspike.core.api.config</span>,
while the MicroProfile variant is defined in <span class='latex-texttt'>org.eclipse.microprofile.config.inject</span>.
Listing <a href='#!idx:/quarkus.html:fig:config-property-migration'> @ConfigProperty Migration </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:config-property-migration'></a>                     <pre><code>// Vorher: DeltaSpike @ConfigProperty
import org.apache.deltaspike.core.api.config.ConfigProperty;
import jakarta.inject.Inject;

@ApplicationScoped
public class IdeaServiceConfig {
    @Inject
    @ConfigProperty(name = "ideafork.max.ideas")
    private Integer maxIdeas;
}

// Nachher: MicroProfile @ConfigProperty
import org.eclipse.microprofile.config.inject.ConfigProperty;

@ApplicationScoped
public class IdeaServiceConfig {
    @ConfigProperty(name = "ideafork.max.ideas")
    Integer maxIdeas; // @Inject ist optional in Quarkus
}
</code></pre>
                </div>
<div class="tip"><b>Tip: </b> In Quarkus, <span class='latex-texttt'>@Inject</span> is optional with <span class='latex-texttt'>@ConfigProperty</span>.
The <span class='latex-texttt'>@ConfigProperty</span> annotation is directly recognized by Quarkus and the value is injected automatically.
This simplifies the code but differs from standard MicroProfile behavior,
where <span class='latex-texttt'>@Inject</span> is required.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> Missing configuration values cause a startup failure in Quarkus.
Unlike DeltaSpike, where missing values could be injected as <span class='latex-texttt'>null</span>,
Quarkus enforces the specification of all configured properties.
Use <span class='latex-texttt'>Optional&lt;T&gt;</span> or the <span class='latex-texttt'>defaultValue</span> parameter to define optional configurations.</div>
The DeltaSpike class <span class='latex-texttt'>ConfigResolver</span> can be replaced by <span class='latex-texttt'>ConfigProvider.getConfig()</span> from the MicroProfile Config API.
Listing <a href='#!idx:/quarkus.html:fig:config-resolver-migration'> ConfigResolver Migration </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:config-resolver-migration'></a>                     <pre><code>// Vorher: DeltaSpike ConfigResolver
import org.apache.deltaspike.core.api.config.ConfigResolver;

String dbUrl = ConfigResolver
    .resolve("ideafork.db.url")
    .withDefault("jdbc:h2:mem:ideafork")
    .getValue();

// Nachher: MicroProfile ConfigProvider
import org.eclipse.microprofile.config.ConfigProvider;

String dbUrl = ConfigProvider.getConfig()
    .getOptionalValue("ideafork.db.url", String.class)
    .orElse("jdbc:h2:mem:ideafork");
</code></pre>
                </div>
 DeltaSpike uses the concept of <span class='latex-texttt'>ProjectStage</span>
to provide different configurations for different environments.
Quarkus replaces this concept with profiles.
Configuration values can be prefixed with a profile identifier
that is only active in the respective environment.
Listing <a href='#!idx:/quarkus.html:fig:project-stage-migration'> ProjectStage to Quarkus Profiles </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:project-stage-migration'></a>                     <pre><code># Vorher: DeltaSpike ProjectStage (apache-deltaspike.properties)
ideafork.db.url=jdbc:h2:mem:ideafork
ideafork.db.url.Production=jdbc:postgresql://prod-server/ideafork

# Nachher: Quarkus Profile (application.properties)
ideafork.db.url=jdbc:h2:mem:ideafork
%prod.ideafork.db.url=jdbc:postgresql://prod-server/ideafork
%dev.ideafork.db.url=jdbc:h2:mem:ideafork-dev
%test.ideafork.db.url=jdbc:h2:mem:ideafork-test
</code></pre>
                </div>
 The DeltaSpike annotation <span class='latex-texttt'>@Exclude</span>,
which we used in Chapter 5 to exclude beans based on the ProjectStage,
is replaced in Quarkus by <span class='latex-texttt'>@IfBuildProfile</span> and <span class='latex-texttt'>@UnlessBuildProfile</span>.
Listing <a href='#!idx:/quarkus.html:fig:exclude-migration'> @Exclude to @IfBuildProfile </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:exclude-migration'></a>                     <pre><code>// Vorher: DeltaSpike @Exclude
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.projectstage.ProjectStage;

@ApplicationScoped
@Exclude(ifProjectStage = ProjectStage.Production.class)
public class MockIdeaRepository implements IdeaRepository {
    //...
}

// Nachher: Quarkus @UnlessBuildProfile
import io.quarkus.arc.profile.UnlessBuildProfile;

@ApplicationScoped
@UnlessBuildProfile("prod")
public class MockIdeaRepository implements IdeaRepository {
    //...
}
</code></pre>
                </div>
 The DeltaSpike <span class='latex-texttt'>@Configuration</span> interfaces can be replaced in Quarkus by
<span class='latex-texttt'>@ConfigMapping</span> interfaces from SmallRye Config.
Listing <a href='#!idx:/quarkus.html:fig:config-mapping'> @Configuration to @ConfigMapping </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:config-mapping'></a>                     <pre><code>// Vorher: DeltaSpike @Configuration
import org.apache.deltaspike.core.api.config.Configuration;
import org.apache.deltaspike.core.api.config.ConfigProperty;

@Configuration(prefix = "ideafork.")
public interface IdeaForkConfig {
    @ConfigProperty(name = "max.ideas", defaultValue = "100")
    Integer maxIdeas();

    @ConfigProperty(name = "admin.email")
    String adminEmail();
}

// Nachher: SmallRye @ConfigMapping
import io.smallrye.config.ConfigMapping;
import io.smallrye.config.WithDefault;

@ConfigMapping(prefix = "ideafork")
public interface IdeaForkConfig {
    @WithDefault("100")
    Integer maxIdeas();

    String adminEmail();
}
</code></pre>
                </div>
 In <span class='latex-textit'>IdeaForkMicro</span> the DeltaSpike <span class='latex-texttt'>PropertyFileConfig</span> SPI is used
to register configuration files programmatically.
Listing <a href='#!idx:/quarkus.html:fig:property-file-config'> PropertyFileConfig to Quarkus </a> shows the conversion to the MicroProfile Config standard.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:property-file-config'></a>                     <pre><code>// Vorher: DeltaSpike PropertyFileConfig
import org.apache.deltaspike.core.api.config.PropertyFileConfig;

public class IdeaForkConfig implements PropertyFileConfig {
    @Override
    public String getPropertyFileName() {
        return "ideafork-custom.properties";
    }

    @Override
    public boolean isOptional() {
        return true;
    }
}

// Nachher: MicroProfile ConfigSource
import org.eclipse.microprofile.config.spi.ConfigSource;
import java.util.Map;
import java.util.Properties;

public class IdeaForkConfigSource implements ConfigSource {
    private final Map&lt;String, String&gt; properties;

    public IdeaForkConfigSource() {
        Properties props = new Properties();
        // Properties aus Datei laden
        this.properties = Map.copyOf(/* ... */);
    }

    @Override
    public Map&lt;String, String&gt; getProperties() {
        return properties;
    }

    @Override
    public String getValue(String key) {
        return properties.get(key);
    }

    @Override
    public String getName() {
        return "ideafork-custom";
    }
}
// registriert via META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource
</code></pre>
                </div>
<div class="tip"><b>Tip: </b> In DeltaSpike, <span class='latex-texttt'>ConfigSource</span> implementations can also be dynamically registered at runtime.
In Quarkus, registration must be done statically via the Service Provider Interface
(<span class='latex-texttt'>META-INF/services</span>),
since configuration is resolved at build time.
Dynamic configuration sources that are added at runtime are not possible in Quarkus.</div>
<div class="tip"><b>Tip: </b><b>Quarkus Dev Services:</b> In development mode (<span class='latex-texttt'>mvn quarkus:dev</span>), Quarkus automatically starts Docker containers for required infrastructure: PostgreSQL, MySQL, MongoDB, Kafka, Keycloak, and more. No configuration is needed &mdash; Quarkus detects the used extensions and provisions the appropriate containers. For <span class='latex-textit'>IdeaFork</span> this means: a simple <span class='latex-texttt'>quarkus-jdbc-postgresql</span> in the <span class='latex-texttt'>pom.xml</span> suffices, and a PostgreSQL instance is automatically available.</div>
<div class="tip"><b>Tip: </b><b>Continuous Testing:</b> In dev mode (<span class='latex-texttt'>mvn quarkus:dev</span>), Quarkus automatically runs tests on every code change. Pressing <span class='latex-texttt'>r</span> in the terminal runs all tests, <span class='latex-texttt'>f</span> reruns only failed tests. This enables a fast development cycle without manually triggering test suites &mdash; comparable to the workflow that DeltaSpike Test-Control provides for CDI tests, but integrated into the entire development workflow.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.5'><span class='entry-number'>10.5</span> Build-Time Extensions</a> </h2>
 In Chapter 4 we got to know Portable CDI Extensions,
with which we could dynamically extend the CDI container at runtime.
This chapter shows why this concept works fundamentally differently in Quarkus.<br /> <div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> Portable CDI Extensions (the <span class='latex-texttt'>Extension</span> interface from CDI Full)
are not supported by Quarkus.
ArC processes all beans at build time, not at runtime.
Runtime-based extensions that dynamically react to container events like
<span class='latex-texttt'>ProcessAnnotatedType</span> or <span class='latex-texttt'>AfterBeanDiscovery</span>
cannot be used.</div>
Quarkus replaces Portable CDI Extensions with its own extension model
consisting of two modules:
a <span class='latex-textit'>deployment module</span> that runs at build time,
and a <span class='latex-textit'>runtime module</span> that provides the generated code at runtime.
The build-time logic is defined in methods annotated with <span class='latex-texttt'>@BuildStep</span>.
These methods consume and produce so-called <span class='latex-texttt'>BuildItem</span> objects
that control the build process.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The following table shows the mapping of the most important CDI extension events
to their Quarkus equivalents:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<span class='latex-texttt'>ProcessAnnotatedType</span> → <span class='latex-texttt'>AnnotationsTransformerBuildItem</span><br />
<span class='latex-texttt'>ProcessBeanAttributes</span> → <span class='latex-texttt'>BeanDefiningAnnotationBuildItem</span><br />
<span class='latex-texttt'>AfterBeanDiscovery.addBean()</span> → <span class='latex-texttt'>SyntheticBeanBuildItem</span><br />
<span class='latex-texttt'>AfterBeanDiscovery.addObserverMethod()</span> → <span class='latex-texttt'>SyntheticObserverBuildItem</span><br />
<span class='latex-texttt'>ProcessInjectionTarget</span> → <span class='latex-texttt'>InjectionPointTransformerBuildItem</span><br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Chapter 4 we showed an example
where a CDI Extension automatically vetoed entity classes as CDI beans.
Listing <a href='#!idx:/quarkus.html:fig:extension-cdi-full'> Entity Veto as Portable Extension </a> shows the original CDI Full version,
Listing <a href='#!idx:/quarkus.html:fig:extension-quarkus'> Entity Veto as Quarkus BuildStep </a> shows the Quarkus variant.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:extension-cdi-full'></a>                     <pre><code>// CDI Full: Portable Extension
public class EntityVetoExtension implements Extension {
    &lt;T&gt; void vetoEntities(
            @Observes ProcessAnnotatedType&lt;T&gt; pat) {
        if (pat.getAnnotatedType().isAnnotationPresent(Entity.class)) {
            pat.veto();
        }
    }
}
// registriert via META-INF/services/jakarta.enterprise.inject.spi.Extension
</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:extension-quarkus'></a>                     <pre><code>// Quarkus: BuildStep in einem Deployment-Modul
public class EntityVetoProcessor {
    @BuildStep
    AnnotationsTransformerBuildItem vetoEntities() {
        return new AnnotationsTransformerBuildItem(
            new AnnotationsTransformer() {
                @Override
                public boolean appliesTo(AnnotationTarget.Kind kind) {
                    return kind == AnnotationTarget.Kind.CLASS;
                }

                @Override
                public void transform(TransformationContext ctx) {
                    if (ctx.getTarget().asClass()
                            .hasAnnotation(DotName.createSimple(
                                "jakarta.persistence.Entity"))) {
                        ctx.transform().add(Vetoed.class).done();
                    }
                }
            });
    }
}
</code></pre>
                </div>
<div class="tip"><b>Tip: </b> Quarkus also supports the Build Compatible Extensions from CDI 4.0
(see Section 9.4) as an alternative.
These can be registered in Quarkus as <span class='latex-texttt'>@BuildCompatibleExtension</span> and
provide a standardized way to write build-time extensions
that also work outside of Quarkus.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.6'><span class='entry-number'>10.6</span> Replacing DeltaSpike Modules</a> </h2>
 In Chapter 5 we got to know various DeltaSpike modules
that extend CDI with additional functionality.
When migrating to Quarkus, these modules must be replaced by Quarkus or MicroProfile equivalents.
This section shows the most important migration steps for each module.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> <b>Data Module:</b> The DeltaSpike Data module provides the <span class='latex-texttt'>@Repository</span> pattern,
with which data access classes are automatically implemented.
In Quarkus this is replaced by Panache.
Listing <a href='#!idx:/quarkus.html:fig:data-module-migration'> Data Module Migration </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:data-module-migration'></a>                     <pre><code>// Vorher: DeltaSpike @Repository
import org.apache.deltaspike.data.api.AbstractEntityRepository;
import org.apache.deltaspike.data.api.Repository;

@Repository
public abstract class IdeaRepository
        extends AbstractEntityRepository&lt;Idea, Long&gt; {

    public abstract List&lt;Idea&gt; findByTitle(String title);
}

// Nachher: Quarkus Panache
import io.quarkus.hibernate.orm.panache.PanacheRepository;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class IdeaRepository implements PanacheRepository&lt;Idea&gt; {

    public List&lt;Idea&gt; findByTitle(String title) {
        return find("title", title).list();
    }
}
</code></pre>
                </div>
<div class="tip"><b>Tip: </b>When using <span class='latex-texttt'>PanacheEntityBase</span> with <span class='latex-texttt'>@SequenceGenerator</span>, set <span class='latex-texttt'>allocationSize=1</span> for predictable IDs during development. If <span class='latex-texttt'>import.sql</span> seeds data with explicit IDs, the sequence must be restarted above the highest seed ID (<span class='latex-texttt'>ALTER SEQUENCE ... RESTART WITH ...</span>) to avoid primary key collisions.</div>
 <b>Security Module:</b> The DeltaSpike Security module with <span class='latex-texttt'>@Secured</span> and the <span class='latex-texttt'>SecurityViolationHandler</span>
is replaced in Quarkus by the standard Jakarta Security annotations <span class='latex-texttt'>@RolesAllowed</span> and <span class='latex-texttt'>@Authenticated</span>
in combination with MicroProfile JWT.
Listing <a href='#!idx:/quarkus.html:fig:security-migration'> Security Migration </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:security-migration'></a>                     <pre><code>// Vorher: DeltaSpike @Secured
import org.apache.deltaspike.security.api.authorization.Secured;

@ApplicationScoped
public class IdeaManager {
    @Secured(IdeaAccessDecisionVoter.class)
    public Idea createIdea(Idea idea) {
        //...
    }
}

// Nachher: Jakarta Security + MicroProfile JWT
import jakarta.annotation.security.RolesAllowed;

@ApplicationScoped
public class IdeaManager {
    @RolesAllowed("user")
    public Idea createIdea(Idea idea) {
        //...
    }
}
</code></pre>
                </div>
 <b>Scheduler Module:</b> The DeltaSpike Scheduler module integrates Quartz at class level.
Quarkus offers a simplified method-level annotation with <span class='latex-texttt'>@Scheduled</span>.
Listing <a href='#!idx:/quarkus.html:fig:scheduler-migration'> Scheduler Migration </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:scheduler-migration'></a>                     <pre><code>// Vorher: DeltaSpike @Scheduled (Klassen-Ebene)
import org.apache.deltaspike.scheduler.api.Scheduled;
import org.quartz.Job;
import org.quartz.JobExecutionContext;

@Scheduled(cronExpression = "0 0/5 * * * ?")
public class IdeaCleanupJob implements Job {
    @Inject
    private IdeaRepository repository;

    @Override
    public void execute(JobExecutionContext ctx) {
        repository.deleteExpiredIdeas();
    }
}

// Nachher: Quarkus @Scheduled (Methoden-Ebene)
import io.quarkus.scheduler.Scheduled;

@ApplicationScoped
public class IdeaCleanupJob {
    @Inject
    IdeaRepository repository;

    @Scheduled(cron = "0 0/5 * * * ?")
    void cleanupExpiredIdeas() {
        repository.deleteExpiredIdeas();
    }
}
</code></pre>
                </div>
 <b>Test-Control Module:</b> The DeltaSpike <span class='latex-texttt'>CdiTestRunner</span> is replaced by <span class='latex-texttt'>@QuarkusTest</span>.
Listing <a href='#!idx:/quarkus.html:fig:test-migration'> Test Migration </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:test-migration'></a>                     <pre><code>// Vorher: DeltaSpike CdiTestRunner
import org.apache.deltaspike.testcontrol.api.junit.CdiTestRunner;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(CdiTestRunner.class)
public class IdeaServiceTest {
    @Inject
    private IdeaService ideaService;

    @Test
    public void testCreateIdea() {
        //...
    }
}

// Nachher: Quarkus @QuarkusTest
import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

@QuarkusTest
public class IdeaServiceTest {
    @Inject
    IdeaService ideaService;

    @Test
    void testCreateIdea() {
        //...
    }
}
</code></pre>
                </div>
 <b>BeanProvider:</b> The DeltaSpike <span class='latex-texttt'>BeanProvider</span> for programmatic bean lookups is replaced in Quarkus by
<span class='latex-texttt'>Arc.container().instance()</span>.
Listing <a href='#!idx:/quarkus.html:fig:bean-provider-migration'> BeanProvider Migration </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:bean-provider-migration'></a>                     <pre><code>// Vorher: DeltaSpike BeanProvider
import org.apache.deltaspike.core.api.provider.BeanProvider;

IdeaService service = BeanProvider
    .getContextualReference(IdeaService.class);

// Nachher: Quarkus Arc
import io.quarkus.arc.Arc;

IdeaService service = Arc.container()
    .instance(IdeaService.class).get();
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> For programmatic bean lookups in Quarkus, the <span class='latex-texttt'>@Unremovable</span> annotation must be used.
ArC removes all beans at build time
that have no detectable injection point.
A bean that is resolved exclusively via <span class='latex-texttt'>Arc.container().instance()</span>
has no such injection point and will therefore be removed.
Listing <a href='#!idx:/quarkus.html:fig:unremovable'> @Unremovable for Programmatic Lookups </a> shows the solution.</div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:unremovable'></a>                     <pre><code>// Ohne @Unremovable: Bean wird von ArC entfernt
@ApplicationScoped
public class DynamicProcessor {
    //...
}

// Mit @Unremovable: Bean bleibt erhalten
import io.quarkus.arc.Unremovable;

@ApplicationScoped
@Unremovable
public class DynamicProcessor {
    //...
}
</code></pre>
                </div>
 <b>Partial Bean Module:</b> In <span class='latex-textit'>IdeaForkMicro</span> the DeltaSpike <span class='latex-texttt'>@PartialBeanBinding</span> is used extensively
to create proxy-based beans from pure interfaces.
This pattern is used among other things for <span class='latex-texttt'>@TypedConfig</span> interfaces
and <span class='latex-texttt'>@ResourceClient</span> REST clients.
In Quarkus there is no direct equivalent for <span class='latex-texttt'>@PartialBeanBinding</span>,
but the underlying use cases are covered by specialized Quarkus features.
Listing <a href='#!idx:/quarkus.html:fig:partial-bean-migration'> @PartialBeanBinding Migration </a> shows the conversion of the most important patterns.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:partial-bean-migration'></a>                     <pre><code>// Vorher: DeltaSpike @TypedConfig via @PartialBeanBinding
import org.apache.deltaspike.core.api.config.ConfigProperty;
import at.irian.cdiatwork.ideafork.ee.config.TypedConfig;

@TypedConfig // basiert auf @PartialBeanBinding
public interface IdeaForkAppConfig {
    @ConfigProperty(name = "ideafork.max.ideas")
    Integer maxIdeas();

    @ConfigProperty(name = "ideafork.admin.email")
    String adminEmail();
}

// Nachher: SmallRye @ConfigMapping (siehe Abschnitt 10.4)
import io.smallrye.config.ConfigMapping;
import io.smallrye.config.WithDefault;

@ConfigMapping(prefix = "ideafork")
public interface IdeaForkAppConfig {
    @WithDefault("100")
    Integer maxIdeas();

    String adminEmail();
}
</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:resource-client-migration'></a>                     <pre><code>// Vorher: DeltaSpike @ResourceClient via @PartialBeanBinding
import at.irian.cdiatwork.ideafork.ee.rest.ResourceClient;

@ResourceClient // basiert auf @PartialBeanBinding
public interface IdeaServiceClient {
    @GET
    @Path("/ideas")
    List&lt;Idea&gt; getAllIdeas();

    @POST
    @Path("/ideas")
    Idea createIdea(Idea idea);
}

// Nachher: Quarkus REST Client
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;

@RegisterRestClient(configKey = "idea-service")
@Path("/ideas")
public interface IdeaServiceClient {
    @GET
    List&lt;Idea&gt; getAllIdeas();

    @POST
    Idea createIdea(Idea idea);
}
// Konfiguration via application.properties:
// quarkus.rest-client.idea-service.url=http://localhost:8080
</code></pre>
                </div>
<div class="tip"><b>Tip: </b> The Quarkus REST Client is based on MicroProfile REST Client and offers additional features
such as automatic service discovery, fault tolerance integration, and reactive variants.
The <span class='latex-texttt'>quarkus-rest-client</span> or <span class='latex-texttt'>quarkus-rest-client-reactive</span> dependency is required.</div>
 <b>Spring-CDI Bridge:</b> <span class='latex-textit'>IdeaForkMicro</span> uses a Spring-CDI bridge
that allows Spring beans and CDI beans to be used in the same deployment.
This pattern is frequently used in incremental migrations
when not all modules can be converted simultaneously.<br /> <div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> Quarkus does not offer a Spring-CDI bridge.
Instead, Quarkus provides the <span class='latex-texttt'>quarkus-spring-di</span> compatibility layer,
which translates a subset of Spring DI annotations (<span class='latex-texttt'>@Autowired</span>,
<span class='latex-texttt'>@Component</span>, <span class='latex-texttt'>@Service</span>, <span class='latex-texttt'>@Repository</span>, <span class='latex-texttt'>@Configuration</span>)
directly into ArC beans.
This allows a migration from Spring annotations to CDI without simultaneous use of both containers.
For full coexistence of Spring and CDI, Quarkus provides no mechanism.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.7'><span class='entry-number'>10.7</span> Interceptors and Decorators</a> </h2>
 Interceptors and decorators are among the central concepts of CDI
that we covered extensively in Chapters 3 and 4.
In Quarkus, both concepts work in principle,
but with some important differences compared to the CDI Full environment.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> The most important difference:
activation via <span class='latex-texttt'>beans.xml</span> does not work in Quarkus.
Instead, every interceptor must be annotated with <span class='latex-texttt'>@Priority</span>
to activate it globally.
This corresponds to the approach that CDI 1.1 introduced as an alternative to the <span class='latex-texttt'>beans.xml</span> declaration.
Listing <a href='#!idx:/quarkus.html:fig:interceptor-migration'> Interceptor Migration </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:interceptor-migration'></a>                     <pre><code>// Vorher: Aktivierung ueber beans.xml + Interceptor-Klasse
@Monitored
@Interceptor
public class MonitorInterceptor {
    @AroundInvoke
    public Object monitor(InvocationContext ctx) throws Exception {
        long start = System.currentTimeMillis();
        try {
            return ctx.proceed();
        } finally {
            long duration = System.currentTimeMillis() - start;
            Logger.getLogger(ctx.getTarget().getClass().getName())
                .info(ctx.getMethod().getName() + " took " + duration + "ms");
        }
    }
}

// Nachher: Aktivierung ueber @Priority
@Monitored
@Interceptor
@Priority(Interceptor.Priority.APPLICATION)
public class MonitorInterceptor {
    @AroundInvoke
    public Object monitor(InvocationContext ctx) throws Exception {
        long start = System.currentTimeMillis();
        try {
            return ctx.proceed();
        } finally {
            long duration = System.currentTimeMillis() - start;
            Logger.getLogger(ctx.getTarget().getClass().getName())
                .info(ctx.getMethod().getName() + " took " + duration + "ms");
        }
    }
}
</code></pre>
                </div>
<div class="tip"><b>Tip: </b> <span class='latex-texttt'>@AroundInvoke</span> works identically in Quarkus as in CDI Full.
Existing interceptor logic can be carried over unchanged.
Only the activation method changes from <span class='latex-texttt'>beans.xml</span> to <span class='latex-texttt'>@Priority</span>.</div>
Decorators are also supported by Quarkus.
As with interceptors, activation must be done via <span class='latex-texttt'>@Priority</span>
instead of the <span class='latex-texttt'>beans.xml</span> declaration.
One limitation is that
built-in CDI beans like <span class='latex-texttt'>Event</span> cannot be decorated.<br /> <div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> <span class='latex-texttt'>InterceptionFactory</span>,
which we got to know in Chapter 4 as a programmatic alternative to interceptor binding,
is not supported by Quarkus.
As an alternative, Quarkus offers <span class='latex-texttt'>InterceptionProxy</span>,
which allows interceptors to be programmatically bound to individual bean instances.</div>
<div class="tip"><b>Tip: </b>Quarkus ArC has offered experimental support for decorators since version 3.x. This must be explicitly enabled (<span class='latex-texttt'>quarkus.arc.transform-unproxyable-classes=true</span>). However, the support is not complete &mdash; in particular, decorators with generic types can cause problems. For critical use cases, the interceptor pattern remains the recommended reliable alternative.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.8'><span class='entry-number'>10.8</span> Native Images with GraalVM</a> </h2>
 One of the main reasons for using Quarkus is the ability
to compile Java applications as Native Images.
GraalVM Native Image translates Java bytecode into native machine code and
produces a single executable file without dependency on a JVM.
The result is startup times in the millisecond range and drastically reduced memory consumption.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Native Images are based on the <span class='latex-textit'>closed-world assumption</span>:
all code reachable at runtime must be known at build time.
Reflection, dynamic class loading, and other dynamic Java features only work
if the affected classes are explicitly registered.
ArC is optimized for this model since it already resolves all beans at build time.<br /> <div class="tip"><b>Tip: </b> Use <span class='latex-texttt'>@RegisterForReflection</span>
to register classes for reflection in the Native Image.
This is especially important for DTOs and entity classes
that are used via JSON serialization or JPA.
Listing <a href='#!idx:/quarkus.html:fig:register-reflection'> @RegisterForReflection </a> shows the usage.</div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:register-reflection'></a>                     <pre><code>import io.quarkus.runtime.annotations.RegisterForReflection;

@RegisterForReflection
public class IdeaDto {
    private String title;
    private String description;

    // Getter und Setter
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    public String getDescription() { return description; }
    public void setDescription(String description) {
        this.description = description;
    }
}
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> Static singleton fields that are initialized at runtime
can lead to unexpected results in the Native Image.
GraalVM initializes certain classes at build time,
causing runtime values to be frozen as build-time constants.
Use CDI beans with <span class='latex-texttt'>@ApplicationScoped</span> instead.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b> Private CDI fields increase the Native Image size,
as ArC must generate additional reflection metadata.
Use package-private fields for injection points
to minimize the image size.</div>
<div class="tip"><b>Tip: </b><b>Common issues with Native Images:</b><br />
&bull; <b>Reflection:</b> Classes loaded via reflection (e.g., JPA entities) must be registered in <span class='latex-texttt'>reflect-config.json</span>. Quarkus handles this automatically for annotated classes, but custom dynamic calls require <span class='latex-texttt'>@RegisterForReflection</span>.<br />
&bull; <b>Resources:</b> Files loaded at runtime must be included via <span class='latex-texttt'>quarkus.native.resources.includes</span>.<br />
&bull; <b>Serialization:</b> Classes that are serialized require explicit registration via <span class='latex-texttt'>@RegisterForReflection(serialization = true)</span>.<br />
&bull; <b>Startup time:</b> A native image of <span class='latex-textit'>IdeaFork</span> typically starts in under 100ms &mdash; compared to several seconds in JVM mode.</div>
 For application startup, Quarkus offers the <span class='latex-texttt'>StartupEvent</span> event,
which replaces the CDI Full approach with <span class='latex-texttt'>@Initialized(ApplicationScoped.class)</span>.
Listing <a href='#!idx:/quarkus.html:fig:startup-event'> StartupEvent Instead of @Initialized </a> shows the conversion.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:startup-event'></a>                     <pre><code>// Vorher: CDI Full @Initialized
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.context.Initialized;
import jakarta.enterprise.event.Observes;

@ApplicationScoped
public class AppInitializer {
    void onStartup(
            @Observes @Initialized(ApplicationScoped.class) Object event) {
        // Initialisierungslogik
    }
}

// Nachher: Quarkus StartupEvent
import io.quarkus.runtime.StartupEvent;
import jakarta.enterprise.event.Observes;

@ApplicationScoped
public class AppInitializer {
    void onStartup(@Observes StartupEvent event) {
        // Initialisierungslogik
    }
}
</code></pre>
                </div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.9'><span class='entry-number'>10.9</span> Migrating IdeaFork to Quarkus</a> </h2>
 After examining the individual migration aspects,
we summarize the steps for migrating <span class='latex-textit'>IdeaFork</span> to Quarkus in a checklist.
The checklist follows the structure of Section 9.8 and
supplements the Jakarta EE migration described there with the Quarkus-specific adjustments.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/quarkus.html:fig:migration-checklist'> IdeaFork Quarkus Migration Checklist </a> shows the essential steps.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:migration-checklist'></a>                     <pre><code>IdeaFork Quarkus-Migrations-Checkliste
======================================

1. Maven-Abhaengigkeiten umstellen
   - Jakarta EE BOM     -> io.quarkus.platform:quarkus-bom
   - DeltaSpike Core    -> (entfaellt, durch Quarkus/ArC abgedeckt)
   - DeltaSpike Data    -> io.quarkus:quarkus-hibernate-orm-panache
   - DeltaSpike Security -> io.quarkus:quarkus-smallrye-jwt
   - DeltaSpike Scheduler -> io.quarkus:quarkus-scheduler
   - DeltaSpike Test-Control -> io.quarkus:quarkus-junit5

2. beans.xml bereinigen
   - Interceptor- und Decorator-Deklarationen entfernen
   - Datei kann geloescht oder als leeres Skelett beibehalten werden
   - Interceptoren/Decoratoren stattdessen mit @Priority aktivieren

3. Scopes pruefen und anpassen
   - Alle Beans muessen eine Scope-Annotation tragen
   - @SessionScoped -> @RequestScoped + JWT oder externer State
   - @ConversationScoped -> @RequestScoped + explizite Zustandsuebergabe
   - @TransactionScoped EntityManager -> Panache oder @Inject EntityManager
   - Custom-Scopes (@ConfigScoped) -> @ApplicationScoped + manuelle Aktualisierung
   - DeltaSpike-Scopes entfernen (kein Aequivalent in Quarkus)

4. Konfiguration migrieren
   - DeltaSpike @ConfigProperty -> MicroProfile @ConfigProperty
   - ConfigResolver -> ConfigProvider.getConfig()
   - ProjectStage -> Quarkus-Profile (%dev., %test., %prod.)
   - @Exclude -> @IfBuildProfile / @UnlessBuildProfile
   - PropertyFileConfig -> MicroProfile ConfigSource SPI
   - apache-deltaspike.properties -> application.properties
   - Dynamische ConfigSource-Registrierung entfaellt (nur statisch via SPI)

5. DeltaSpike-Module ersetzen
   - @Repository -> PanacheRepository
   - @Secured -> @RolesAllowed / @Authenticated
   - @Scheduled (Klasse) -> @Scheduled (Methode)
   - CdiTestRunner -> @QuarkusTest
   - BeanProvider -> Arc.container().instance()
   - @PartialBeanBinding/@TypedConfig -> @ConfigMapping (SmallRye)
   - @PartialBeanBinding/@ResourceClient -> @RegisterRestClient (MicroProfile)
   - Spring-CDI-Bridge -> quarkus-spring-di (Kompatibilitaetsschicht)

6. Extensions migrieren
   - Portable CDI Extensions -> Quarkus @BuildStep
   - Alternativ: Build Compatible Extensions (CDI 4.0)
   - META-INF/services-Eintraege aktualisieren

7. Interceptoren und Decoratoren anpassen
   - beans.xml-Deklarationen entfernen
   - @Priority zu allen Interceptoren/Decoratoren hinzufuegen
   - InterceptionFactory -> InterceptionProxy

8. Native-Image-Kompatibilitaet sicherstellen
   - @RegisterForReflection fuer DTOs und Entities
   - Private Injection-Points auf package-private umstellen
   - Statische Singletons durch CDI-Beans ersetzen
   - @Observes StartupEvent statt @Initialized verwenden

9. Tests migrieren
   - @RunWith(CdiTestRunner.class) -> @QuarkusTest
   - JUnit 4 -> JUnit 5
   - Meecrowave-Tests -> @QuarkusTest mit REST-Assured
</code></pre>
                </div>
As with the Jakarta EE migration in Chapter 9, it is recommended
to carry out the steps individually and run the test suite after each step.
The migration to Quarkus is more extensive than the pure namespace migration,
as not only imports but also architectural decisions are affected.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/quarkus.html:fig:pom-migration'> pom.xml Conversion </a> shows the essential changes to the Maven configuration.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:pom-migration'></a>                     <pre><code>&lt;!-- Vorher: Jakarta EE + DeltaSpike --&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;
            &lt;artifactId&gt;jakarta.jakartaee-bom&lt;/artifactId&gt;
            &lt;version&gt;10.0.0&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;!-- Nachher: Quarkus BOM --&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkus.platform&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-bom&lt;/artifactId&gt;
            &lt;version&gt;3.17.5&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
                </div>
The migration of <span class='latex-textit'>IdeaFork</span> to Quarkus demonstrates
that the transition from a CDI Full/DeltaSpike application to a Quarkus-based microservice
is significantly more far-reaching than the pure namespace migration to Jakarta EE.
While the core CDI concepts developed in the previous chapters, such as
type-safe injection, qualifiers, interceptors, and events, remain valid in Quarkus,
the build-time processing by ArC and the focus on cloud-native architectures
require a rethinking of the application structure.
DeltaSpike features that are tightly coupled to CDI Full or JSF
must be replaced by MicroProfile and Quarkus-specific alternatives.
The effort is rewarded, however, by the benefits:
fast startup times, low memory consumption, and the ability
to deliver Java applications as Native Images.
<br /> <h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.10'><span class='entry-number'>10.10</span> Sources</a> </h2>
<b>Sources:</b><br />
- quarkus.io<br />
- quarkus.io/guides/cdi-reference<br />
- microprofile.io<br />
- jakarta.ee<br />
- cdi-spec.org<br />
- deltaspike.apache.org<br />
- smallrye.io<br />
- graalvm.org<br />
</section>
<section class="chapter-section" id="chapter-11">
<h1> <a class='latex-index-anchor' name='!idx:/angular.html:11'><span class='entry-number'>11</span> From JSF to Angular</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> This chapter was written by Claude (Anthropic) based on the previous chapters. It describes the migration of IdeaFork's JSF frontend to an Angular Single-Page Application. The code examples are based on the IdeaForkMicro modules from Chapter 8.
</div>
<a name = '!idx:/angular.html:chap:angular-migration'> </a><h2><a class='latex-index-anchor' name='!idx:/angular.html:11.1'><span class='entry-number'>11.1</span> A New Frontend</a> </h2>
 In the previous chapters we have progressively modernized the backend of <span class='latex-textit'>IdeaFork</span>:
Chapter 9 accompanied the migration to Jakarta EE, Chapter 10 completed the switch to Quarkus.
In Chapter 10 it was explicitly warned that the DeltaSpike scopes
<span class='latex-texttt'>@ViewAccessScoped</span>, <span class='latex-texttt'>@WindowScoped</span> and
<span class='latex-texttt'>@GroupedConversationScoped</span> have no equivalent in Quarkus,
as they are tightly coupled to JSF and the concept of browser windows.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
This warning highlights the fundamental architectural shift:
JSF is a server-side UI framework where state is maintained on the server.
Every user interaction generates an HTTP postback, the server renders the new page and sends the complete HTML back.
The DeltaSpike scopes like <span class='latex-texttt'>@ViewAccessScoped</span> manage state
between consecutive requests in server memory.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Angular takes a fundamentally different approach:
As a Single-Page Application (SPA) the entire UI logic runs in the user's browser.
The server delivers the Angular application as static files on the first request,
after which the application communicates with the backend solely via REST APIs.
State is managed client-side — in components, services and signals.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The decisive advantage for our migration:
The REST backend already exists.
In Chapter 8 we exposed the backend services as
REST endpoints with <span class='latex-textit'>IdeaForkMicro</span> and accessed them via <span class='latex-texttt'>@ResourceClient</span> interfaces.
In Chapter 10 these services were migrated to Quarkus.
Angular now replaces only the JSF UI layer and calls the same REST APIs directly.
<div class="tip"><b>Tip: </b>During development the Angular CLI dev server
can be configured with a proxy to the Quarkus backend.
In the file <span class='latex-texttt'>proxy.conf.json</span> the path
<span class='latex-texttt'>/api/*</span> is redirected to the Quarkus server (e.g.
<span class='latex-texttt'>http://localhost:8080</span>),
so that Angular and Quarkus can be developed and tested independently.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
An Angular project is created with the Angular CLI (<span class='latex-texttt'>ng new ideafork-ui</span>),
started in development mode with <span class='latex-texttt'>ng serve</span> and compiled for production
with <span class='latex-texttt'>ng build</span>.
The central configuration file is <span class='latex-texttt'>app.config.ts</span>, where Router,
HttpClient and Interceptors are registered.
This file serves a similar role to the
<span class='latex-texttt'>beans.xml</span> and <span class='latex-texttt'>web.xml</span> of a Java EE application:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-app-config'></a>                     <pre><code>// app.config.ts (Angular)
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { routes } from './app.routes';
import { authInterceptor } from './auth/auth.interceptor';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(withInterceptors([authInterceptor]))
  ]
};</code></pre>
                </div>
The routes are defined in Section 11.3, the interceptor in Section 11.6.
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.2'><span class='entry-number'>11.2</span> From JSF Pages to Angular Components</a> </h2>
In <span class='latex-textit'>IdeaFork</span> the UI consists of XHTML Facelets pages
that receive a uniform structure through a master template (<span class='latex-texttt'>main-template.xhtml</span> with
<span class='latex-texttt'>ui:insert</span>).
Each page is controlled by a CDI bean annotated with <span class='latex-texttt'>@Named</span>
and bound to the UI via EL expressions (<span class='latex-texttt'>#{bean.property}</span>).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Before we look at the Angular side, a brief overview for Java developers:
Angular uses <span class='latex-textit'>TypeScript</span>, a typed superset of JavaScript.
Decorators (<span class='latex-texttt'>@Component</span>) work like Java annotations,
generics use the same <span class='latex-texttt'>&lt;T&gt;</span> syntax,
arrow functions (<span class='latex-texttt'>=&gt;</span>) correspond to lambdas,
and types come after the name (<span class='latex-texttt'>name: string</span> instead of <span class='latex-texttt'>String name</span>).
Dependency injection follows a familiar pattern:
<span class='latex-texttt'>inject(Service)</span> corresponds to CDI's <span class='latex-texttt'>@Inject</span>,
<span class='latex-texttt'>@Injectable({ providedIn: 'root' })</span> corresponds to <span class='latex-texttt'>@ApplicationScoped</span>,
and Angular's injector hierarchy (Root → Route → Component) mirrors CDI's scope hierarchy.
<span class='latex-texttt'>standalone: true</span> means that a component works without module registration —
comparable to annotated bean discovery without <span class='latex-texttt'>beans.xml</span> entries.
For templates: <span class='latex-texttt'>{{ }}</span> = output (like <span class='latex-texttt'>h:outputText</span>),
<span class='latex-texttt'>[prop]="expr"</span> = property binding (data to child element),
<span class='latex-texttt'>(event)="fn()"</span> = event binding (like <span class='latex-texttt'>action="#{...}"</span>).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
In Angular each page is represented by a standalone component.
A component consists of a TypeScript class (logic),
an HTML template (presentation) and optional CSS (styling).
The master template is replaced by a layout component with <span class='latex-texttt'>&lt;router-outlet /&gt;</span>,
where the Angular Router inserts the respective page component into the outlet.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The following code examples use Angular's <span class='latex-textit'>Signals</span> — a reactive primitive
available since Angular 16. A signal wraps a value and notifies
the framework on changes. <span class='latex-texttt'>signal&lt;Idea[]&gt;([])</span> creates a signal with
an initial value (empty array). Read with parentheses: <span class='latex-texttt'>ideas()</span>,
write with <span class='latex-texttt'>ideas.set(newValue)</span>.
<span class='latex-texttt'>computed(() =&gt; ...)</span> derives a value that auto-updates.
The comparison to JSF: there the server re-renders the entire page on every postback.
Angular uses signals to update only the affected template parts.
<div class="tip"><b>Tip: </b>Signals have been the recommended approach for reactive state since Angular 16.
The <span class='latex-texttt'>signal()</span> function is conceptually similar to a CDI producer
that propagates its value via <span class='latex-texttt'>@Observes</span> —
only client-side and in real time.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The following comparison shows the IdeaFork home page — first as a JSF page,
then as an Angular component:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-index-page'></a>                     <pre><code>&lt;!-- index.xhtml (JSF) --&gt;
&lt;ui:composition template="/main-template.xhtml"&gt;
  &lt;ui:define name="content"&gt;
    &lt;h:form id="ideaForm"&gt;
      &lt;h:outputText value="#{ideaController.welcomeMessage}" /&gt;
      &lt;ui:repeat var="idea" value="#{ideaController.ideas}"&gt;
        &lt;div class="idea-card"&gt;
          &lt;h3&gt;#{idea.title}&lt;/h3&gt;
          &lt;p&gt;#{idea.description}&lt;/p&gt;
        &lt;/div&gt;
      &lt;/ui:repeat&gt;
    &lt;/h:form&gt;
  &lt;/ui:define&gt;
&lt;/ui:composition&gt;</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-index-component'></a>                     <pre><code>// home.component.ts (Angular)
@Component({
  selector: 'app-home',
  standalone: true,
  imports: [CommonModule],
  template: `
    &lt;p&gt;{{ welcomeMessage }}&lt;/p&gt;
    @for (idea of ideas(); track idea.id) {
      &lt;div class="idea-card"&gt;
        &lt;h3&gt;{{ idea.title }}&lt;/h3&gt;
        &lt;p&gt;{{ idea.description }}&lt;/p&gt;
      &lt;/div&gt;
    }
  `
})
export class HomeComponent implements OnInit {
  welcomeMessage = 'Welcome to IdeaFork';
  ideas = signal&lt;Idea[]&gt;([]);

  private ideaService = inject(IdeaService);

  ngOnInit() {
    this.ideaService.getIdeas().subscribe(
      data =&gt; this.ideas.set(data)
    );
  }
}</code></pre>
                </div>
The EL expressions (<span class='latex-texttt'>#{...}</span>) are replaced by Angular template bindings
(<span class='latex-texttt'>{{ ... }}</span>).
The JSF component <span class='latex-texttt'>ui:repeat</span> is replaced by the new Angular control flow
<span class='latex-texttt'>@for</span>, which since Angular 17 supersedes the previous
<span class='latex-texttt'>*ngFor</span> approach.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
JSF composite components like <span class='latex-texttt'>formGroup.xhtml</span> become
reusable Angular components.
In <span class='latex-textit'>IdeaFork</span> the composite component encapsulates a label with a
conditional input field (text, password or textarea):
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-composite-component'></a>                     <pre><code>&lt;!-- formGroup.xhtml (JSF Composite Component) --&gt;
&lt;cc:interface&gt;
  &lt;cc:attribute name="label" /&gt;
  &lt;cc:attribute name="value" /&gt;
  &lt;cc:attribute name="type" default="text" /&gt;
&lt;/cc:interface&gt;
&lt;cc:implementation&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel value="#{cc.attrs.label}" /&gt;
    &lt;h:inputSecret value="#{cc.attrs.value}"
                   rendered="#{cc.attrs.type == 'password'}" /&gt;
    &lt;h:inputText value="#{cc.attrs.value}"
                 rendered="#{cc.attrs.type == 'text'}" /&gt;
    &lt;h:inputTextarea value="#{cc.attrs.value}"
                     rendered="#{cc.attrs.type == 'textarea'}" /&gt;
  &lt;/div&gt;
&lt;/cc:implementation&gt;</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-form-field-component'></a>                     <pre><code>// form-field.component.ts (Angular)
@Component({
  selector: 'app-form-field',
  standalone: true,
  imports: [ReactiveFormsModule],
  template: `
    &lt;div class="form-group"&gt;
      &lt;label&gt;{{ label() }}&lt;/label&gt;
      @switch (type()) {
        @case ('password') {
          &lt;input type="password" [formControl]="control()" /&gt;
        }
        @case ('textarea') {
          &lt;textarea [formControl]="control()"&gt;&lt;/textarea&gt;
        }
        @default {
          &lt;input type="text" [formControl]="control()" /&gt;
        }
      }
    &lt;/div&gt;
  `
})
export class FormFieldComponent {
  label = input.required&lt;string&gt;();
  type = input&lt;string&gt;('text');
  control = input.required&lt;FormControl&gt;();
}</code></pre>
                </div>
The JSF <span class='latex-texttt'>rendered</span> attributes are replaced by Angular's
<span class='latex-texttt'>@switch</span> control flow.
Input values are no longer bound to a backing bean via EL bindings,
but controlled through Angular Reactive Forms (<span class='latex-texttt'>FormControl</span>).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The syntax <span class='latex-texttt'>input.required&lt;string&gt;()</span> in the <span class='latex-texttt'>FormFieldComponent</span>
uses signal-based inputs (since Angular 17). They correspond to
<span class='latex-texttt'>cc:attribute</span> in JSF composite components — the parent component passes
the value via <span class='latex-texttt'>[label]="'Title'"</span>.
The <span class='latex-texttt'>subscribe()</span> method that appears in later examples
starts the asynchronous REST call — Observables are covered in detail in Section 11.7.
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.3'><span class='entry-number'>11.3</span> Navigation: ViewConfig to Angular Router</a> </h2>
In <span class='latex-textit'>IdeaFork</span> navigation is defined through the DeltaSpike
<span class='latex-texttt'>ViewConfig</span> class hierarchy.
Each page is represented as an interface in a nested structure
that describes folder and page relationships in a type-safe manner.
Navigation occurs by having a controller return the corresponding
<span class='latex-texttt'>ViewConfig</span> class:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-viewconfig'></a>                     <pre><code>// ViewConfig-Hierarchie (DeltaSpike)
public interface Pages extends ViewConfig {
    @View(navigation = REDIRECT)
    class Index implements Pages {}

    interface Idea extends Pages {
        class List implements Idea {}
        class Detail implements Idea {}
    }

    interface User extends Pages {
        class Login implements User {}
        class Registration implements User {}
    }

    interface Promotion extends Pages {
        @View(name = "step1")
        class Step1 implements Promotion {}
        @View(name = "step2")
        class Step2 implements Promotion {}
        @View(name = "step3")
        class Step3 implements Promotion {}
    }
}</code></pre>
                </div>
In Angular navigation is defined through a <span class='latex-texttt'>Routes</span> array
that maps each URL to a standalone component.
Lazy loading with <span class='latex-texttt'>loadComponent</span> ensures that components
are only loaded on demand — a concept that does not exist in JSF,
where all pages are served by the server:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-routes'></a>                     <pre><code>// app.routes.ts (Angular)
export const routes: Routes = [
  { path: '', redirectTo: 'home', pathMatch: 'full' },
  {
    path: 'home',
    loadComponent: () =&gt;
      import('./home/home.component').then(m =&gt; m.HomeComponent)
  },
  {
    path: 'ideas',
    children: [
      {
        path: '',
        loadComponent: () =&gt;
          import('./idea/idea-list.component').then(m =&gt; m.IdeaListComponent)
      },
      {
        path: ':id',
        loadComponent: () =&gt;
          import('./idea/idea-detail.component').then(m =&gt; m.IdeaDetailComponent)
      }
    ]
  },
  {
    path: 'user',
    children: [
      { path: 'login', loadComponent: () =&gt;
          import('./user/login.component').then(m =&gt; m.LoginComponent) },
      { path: 'register', loadComponent: () =&gt;
          import('./user/registration.component').then(m =&gt; m.RegistrationComponent) }
    ]
  },
  {
    path: 'promotion',
    canActivate: [authGuard],
    children: [
      { path: 'step1', loadComponent: () =&gt;
          import('./promotion/step1.component').then(m =&gt; m.Step1Component) },
      { path: 'step2', loadComponent: () =&gt;
          import('./promotion/step2.component').then(m =&gt; m.Step2Component) },
      { path: 'step3', loadComponent: () =&gt;
          import('./promotion/step3.component').then(m =&gt; m.Step3Component) }
    ]
  }
];</code></pre>
                </div>
The type-safe navigation via <span class='latex-texttt'>ViewConfig</span> classes is replaced by
<span class='latex-texttt'>Router.navigate()</span>.
While in JSF a controller method returns a ViewConfig class
and the DeltaSpike navigation handler performs the redirect,
Angular navigates client-side without a server round-trip:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-navigation'></a>                     <pre><code>// Navigation in JSF (DeltaSpike)
@Named
@ViewAccessScoped
public class IdeaController implements Serializable {
    public Class&lt;? extends ViewConfig&gt; showDetail(Idea idea) {
        this.selectedIdea = idea;
        return Pages.Idea.Detail.class;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-navigation'></a>                     <pre><code>// Navigation in Angular
@Component({ /* ... */ })
export class IdeaListComponent {
  private router = inject(Router);

  showDetail(idea: Idea) {
    this.router.navigate(['/ideas', idea.id]);
  }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>For type-safe navigation, route constants can be defined in Angular
to avoid manually assembling URL strings:
<span class='latex-texttt'>export const ROUTES = { ideas: '/ideas', ideaDetail: (id: number) =&gt; &#96;/ideas/${id}&#96; }</span>.
This provides similar safety to the DeltaSpike ViewConfig hierarchy.</div>
<div class="tip"><b>Tip: </b>Static routes like <span class='latex-texttt'>/tasks/new</span> must be defined before parameterized routes like <span class='latex-texttt'>/tasks/:id</span>. Otherwise the router matches the string &ldquo;new&rdquo; as the <span class='latex-texttt'>:id</span> parameter, leading to a failed API lookup for a task with ID &ldquo;new&rdquo;.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.4'><span class='entry-number'>11.4</span> Scopes and Lifecycle</a> </h2>
In Chapter 10 it was warned that the DeltaSpike scopes
<span class='latex-texttt'>@ViewAccessScoped</span>, <span class='latex-texttt'>@WindowScoped</span> and
<span class='latex-texttt'>@GroupedConversationScoped</span> have no equivalent in Quarkus.
With the switch to Angular these scopes now receive appropriate counterparts —
albeit client-side rather than server-side:
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<b>@ViewAccessScoped</b> — In <span class='latex-textit'>IdeaFork</span> ten view controllers
use this scope (see Chapter 5).
A <span class='latex-texttt'>@ViewAccessScoped</span> bean exists as long as it is accessed in consecutive
JSF requests.
In Angular this scope is naturally mapped by the component lifecycle:
A component is created by the router when the user navigates to the corresponding route,
and destroyed when they leave it. State lives in the component's fields.
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-viewaccessscoped'></a>                     <pre><code>// JSF: @ViewAccessScoped Controller
@Named
@ViewAccessScoped
public class IdeaListController implements Serializable {
    @Inject
    private IdeaRepository ideaRepository;

    private List&lt;Idea&gt; ideas;

    @PreRenderView
    public void init() {
        this.ideas = ideaRepository.findAll();
    }

    public List&lt;Idea&gt; getIdeas() {
        return ideas;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-component-lifecycle'></a>                     <pre><code>// Angular: Komponenten-Lebenszyklus
@Component({
  selector: 'app-idea-list',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './idea-list.component.html'
})
export class IdeaListComponent implements OnInit {
  ideas = signal&lt;Idea[]&gt;([]);

  private ideaService = inject(IdeaService);

  ngOnInit() {
    this.ideaService.getIdeas().subscribe(
      data =&gt; this.ideas.set(data)
    );
  }
}</code></pre>
                </div>
<b>@WindowScoped</b> — The classes <span class='latex-texttt'>BackNavigator</span> and
<span class='latex-texttt'>EntryPointHandler</span> use <span class='latex-texttt'>@WindowScoped</span>
to hold state per browser window.
In Angular this is mapped by a service with <span class='latex-texttt'>providedIn: 'root'</span>.
Since an Angular application is already isolated per browser tab,
a root singleton corresponds to a <span class='latex-texttt'>@WindowScoped</span> bean:
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<b>@GroupedConversationScoped</b> — The promotion wizard uses this scope
to hold state across multiple wizard steps.
In Angular this is mapped by a service scoped to the feature route subtree
that is reset when leaving the wizard:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-grouped-conversation'></a>                     <pre><code>// JSF: @GroupedConversationScoped Wizard
@Named
@GroupedConversationScoped
public class PromotionWizardController implements Serializable {
    @Inject
    private GroupedConversation conversation;

    private Idea selectedIdea;
    private PromotionType promotionType;

    public Class&lt;? extends ViewConfig&gt; nextStep() {
        return Pages.Promotion.Step2.class;
    }

    public Class&lt;? extends ViewConfig&gt; finish() {
        conversation.close();
        return Pages.Idea.List.class;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-wizard-service'></a>                     <pre><code>// Angular: Wizard-Service mit Route-Scoping
@Injectable()
export class PromotionWizardService implements OnDestroy {
  selectedIdea = signal&lt;Idea | null&gt;(null);
  promotionType = signal&lt;PromotionType | null&gt;(null);

  reset() {
    this.selectedIdea.set(null);
    this.promotionType.set(null);
  }

  ngOnDestroy() {
    this.reset();
  }
}</code></pre>
                </div>
<b>@SessionScoped</b> — The <span class='latex-texttt'>JsfIdentityHolder</span> manages the
user identity in the HTTP session.
In Angular this is replaced by an <span class='latex-texttt'>AuthService</span> with
<span class='latex-texttt'>providedIn: 'root'</span>,
which stores a JWT in <span class='latex-texttt'>localStorage</span>.
State is provided reactively via signals.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The JSF lifecycle annotation <span class='latex-texttt'>@PreRenderView</span> is replaced by the Angular lifecycle hook
<span class='latex-texttt'>ngOnInit()</span>, which is called once the component is initialized.
<div class="tip"><b>Tip: </b>Angular's dependency injection hierarchy allows
scoping services to route subtrees — similar to
<span class='latex-texttt'>@GroupedConversationScoped</span>.
By specifying <span class='latex-texttt'>providers: [PromotionWizardService]</span>
in the route configuration, a new instance is created per wizard run.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b>Unlike CDI scopes that are managed by the container,
Angular services with <span class='latex-texttt'>providedIn: 'root'</span> are singletons by default
that exist for the entire lifetime of the application.
Explicit cleanup via <span class='latex-texttt'>ngOnDestroy()</span> or resetting
signals is the developer's responsibility.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The following example shows the concrete route configuration for the promotion wizard
with a route-scoped provider:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-route-providers'></a>                     <pre><code>// app.routes.ts (excerpt): Route-scoped Service
{
  path: 'promotion',
  providers: [PromotionWizardService],
  canActivate: [authGuard],
  children: [
    { path: 'step1', loadComponent: () =&gt;
        import('./promotion/step1.component').then(m =&gt; m.Step1Component) },
    { path: 'step2', canActivate: [wizardStepGuard], loadComponent: () =&gt;
        import('./promotion/step2.component').then(m =&gt; m.Step2Component) },
    { path: 'step3', canActivate: [wizardStepGuard], loadComponent: () =&gt;
        import('./promotion/step3.component').then(m =&gt; m.Step3Component) }
  ]
}</code></pre>
                </div>
By specifying <span class='latex-texttt'>providers: [PromotionWizardService]</span> on the
<span class='latex-texttt'>promotion</span> path, Angular creates a separate injector level
for this route subtree. When leaving the subtree, the instance is destroyed —
the exact behavior of <span class='latex-texttt'>@GroupedConversationScoped</span>.
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.5'><span class='entry-number'>11.5</span> Forms and Validation</a> </h2>
In JSF forms are built with <span class='latex-texttt'>h:form</span>,
<span class='latex-texttt'>h:inputText</span> and <span class='latex-texttt'>h:commandButton</span>.
Validation is performed server-side via Bean Validation
(<span class='latex-texttt'>@NotNull</span>, <span class='latex-texttt'>@Size</span>) —
the results are only visible after the postback.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Angular Reactive Forms offer a client-side alternative:
<span class='latex-texttt'>FormGroup</span> and <span class='latex-texttt'>FormControl</span> define
the form structure in TypeScript, <span class='latex-texttt'>Validators</span> replace the
Bean Validation annotations.
Validation occurs in real-time during input.
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-create-idea-form'></a>                     <pre><code>&lt;!-- JSF: Idee erstellen --&gt;
&lt;h:form id="createIdeaForm"&gt;
  &lt;if:formGroup label="Titel"
                value="#{ideaController.newIdea.title}" /&gt;
  &lt;if:formGroup label="Kategorie"
                value="#{ideaController.newIdea.category}" /&gt;
  &lt;if:formGroup label="Beschreibung" type="textarea"
                value="#{ideaController.newIdea.description}" /&gt;
  &lt;h:commandButton value="Erstellen"
                   action="#{ideaController.createIdea}" /&gt;
  &lt;h:messages globalOnly="true" /&gt;
&lt;/h:form&gt;</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-create-idea-form'></a>                     <pre><code>// Angular: Idee erstellen
@Component({
  selector: 'app-create-idea',
  standalone: true,
  imports: [ReactiveFormsModule, FormFieldComponent],
  template: `
    &lt;form [formGroup]="ideaForm" (ngSubmit)="onSubmit()"&gt;
      &lt;app-form-field label="Titel"
                      [control]="ideaForm.controls.title" /&gt;
      &lt;app-form-field label="Kategorie"
                      [control]="ideaForm.controls.category" /&gt;
      &lt;app-form-field label="Beschreibung" type="textarea"
                      [control]="ideaForm.controls.description" /&gt;
      &lt;button type="submit" [disabled]="ideaForm.invalid"&gt;
        Erstellen
      &lt;/button&gt;
    &lt;/form&gt;
  `
})
export class CreateIdeaComponent {
  private ideaService = inject(IdeaService);
  private router = inject(Router);

  ideaForm = new FormGroup({
    title: new FormControl('', [Validators.required, Validators.minLength(3)]),
    category: new FormControl('', Validators.required),
    description: new FormControl('')
  });

  onSubmit() {
    if (this.ideaForm.valid) {
      this.ideaService.createIdea(this.ideaForm.value as Idea).subscribe(
        () =&gt; this.router.navigate(['/ideas'])
      );
    }
  }
}</code></pre>
                </div>
Error messages in JSF are managed via <span class='latex-texttt'>FacesMessage</span> and
the DeltaSpike abstraction <span class='latex-texttt'>JsfMessage&lt;T&gt;</span> with
<span class='latex-texttt'>@MessageBundle</span>.
In Angular this is replaced by a notification service
that provides messages as signals:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-registration-form'></a>                     <pre><code>// JSF: Registrierung mit Bean Validation
@Named
@ViewAccessScoped
public class RegistrationController implements Serializable {
    @NotNull
    @Size(min = 3, max = 50)
    private String username;

    @NotNull
    @Size(min = 8)
    private String password;

    @Inject
    private JsfMessage&lt;RegistrationMessages&gt; messages;

    public Class&lt;? extends ViewConfig&gt; register() {
        if (userService.register(username, password)) {
            return Pages.User.Login.class;
        }
        messages.addError().registrationFailed();
        return null;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-registration-form'></a>                     <pre><code>// Angular: Registrierung mit Reactive Forms
@Component({
  selector: 'app-registration',
  standalone: true,
  imports: [ReactiveFormsModule],
  templateUrl: './registration.component.html'
})
export class RegistrationComponent {
  private userService = inject(UserService);
  private router = inject(Router);
  private notifications = inject(NotificationService);

  form = new FormGroup({
    username: new FormControl('', [
      Validators.required,
      Validators.minLength(3),
      Validators.maxLength(50)
    ]),
    password: new FormControl('', [
      Validators.required,
      Validators.minLength(8)
    ])
  });

  onRegister() {
    if (this.form.valid) {
      this.userService.register(this.form.value).subscribe({
        next: () =&gt; this.router.navigate(['/user/login']),
        error: () =&gt; this.notifications.error('Registrierung fehlgeschlagen')
      });
    }
  }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Angular Reactive Forms provide real-time validation feedback
without a server round-trip — unlike JSF where validation only runs on postback.
The Bean Validation annotations <span class='latex-texttt'>@NotNull</span> and
<span class='latex-texttt'>@Size</span> are replaced by Angular validators
<span class='latex-texttt'>Validators.required</span>,
<span class='latex-texttt'>Validators.minLength()</span> and
<span class='latex-texttt'>Validators.maxLength()</span>.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.6'><span class='entry-number'>11.6</span> Frontend Security</a> </h2>
Page security in <span class='latex-textit'>IdeaFork</span> is handled via the DeltaSpike annotation
<span class='latex-texttt'>@Secured</span> in combination with an
<span class='latex-texttt'>AccessDecisionVoter</span>.
The <span class='latex-texttt'>JsfIdentityHolder</span> (annotated with
<span class='latex-texttt'>@SessionScoped</span> and <span class='latex-texttt'>@Specializes</span>)
stores the user identity in the HTTP session.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
In Angular a functional route guard takes over access control.
The <span class='latex-texttt'>AuthService</span> manages the JWT and provides login state
reactively via signals:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-auth-guard'></a>                     <pre><code>// auth.guard.ts (Angular)
export const authGuard: CanActivateFn = (route, state) =&gt; {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isAuthenticated()) {
    return true;
  }
  return router.createUrlTree(['/user/login'], {
    queryParams: { returnUrl: state.url }
  });
};</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-auth-interceptor'></a>                     <pre><code>// auth.interceptor.ts (Angular)
export const authInterceptor: HttpInterceptorFn = (req, next) =&gt; {
  const authService = inject(AuthService);
  const token = authService.getToken();

  if (token) {
    const cloned = req.clone({
      setHeaders: { Authorization: `Bearer ${token}` }
    });
    return next(cloned);
  }
  return next(req);
};</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-auth-service'></a>                     <pre><code>// auth.service.ts (Angular)
@Injectable({ providedIn: 'root' })
export class AuthService {
  private currentUser = signal&lt;User | null&gt;(null);

  isAuthenticated = computed(() =&gt; this.currentUser() !== null);
  user = this.currentUser.asReadonly();

  private http = inject(HttpClient);
  private router = inject(Router);

  login(username: string, password: string): Observable&lt;void&gt; {
    return this.http.post&lt;{ token: string; user: User }&gt;(
      '/api/auth/login', { username, password }
    ).pipe(
      tap(response =&gt; {
        localStorage.setItem('jwt', response.token);
        this.currentUser.set(response.user);
      }),
      map(() =&gt; void 0)
    );
  }

  logout() {
    localStorage.removeItem('jwt');
    this.currentUser.set(null);
    this.router.navigate(['/user/login']);
  }

  getToken(): string | null {
    return localStorage.getItem('jwt');
  }
}</code></pre>
                </div>
The login flow changes fundamentally:
Instead of a JSF form postback where the server updates the session and
performs a redirect, the Angular application sends a REST call to the
login endpoint of the Quarkus backend.
The backend returns a JWT which is stored in <span class='latex-texttt'>localStorage</span>.
The <span class='latex-texttt'>authInterceptor</span> automatically attaches the token to all
outgoing HTTP requests.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The DeltaSpike <span class='latex-texttt'>EntryPointHandler</span>, which in <span class='latex-textit'>IdeaFork</span>
ensures that the promotion wizard can only be reached through the defined entry point,
is replaced in Angular by a specific route guard
that checks the wizard state (see Section 11.8).
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b>Client-side route guards are not a security boundary.
They improve the user experience by redirecting unauthorized users
to the login page, but an attacker can bypass them.
The Quarkus backend must always enforce authorization via
<span class='latex-texttt'>@RolesAllowed</span>, as shown in Chapter 10.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.7'><span class='entry-number'>11.7</span> REST Communication</a> </h2>
In <span class='latex-textit'>IdeaForkMicro</span> the REST calls between modules are abstracted via
<span class='latex-texttt'>@ResourceClient</span> interfaces (see Chapter 8).
These DeltaSpike partial bean proxies generate an implementation
of the interface at runtime that executes the REST calls.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Angular's <span class='latex-texttt'>HttpClient</span> returns <span class='latex-texttt'>Observable&lt;T&gt;</span> —
conceptually comparable to Java's <span class='latex-texttt'>CompletableFuture&lt;T&gt;</span>, but more flexible.
An Observable represents an asynchronous data stream.
<span class='latex-texttt'>.subscribe()</span> starts the operation and receives the result
(comparable to calling <span class='latex-texttt'>.get()</span> on a Future).
<span class='latex-texttt'>.pipe()</span> chains transformation operators
(like <span class='latex-texttt'>.map()</span>/<span class='latex-texttt'>.filter()</span> in Java Streams).
The key difference from <span class='latex-texttt'>@ResourceClient</span>:
the DeltaSpike proxy blocks the calling thread until the response arrives;
an Observable is non-blocking — the UI stays responsive.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
In Angular the <span class='latex-texttt'>HttpClient</span> takes over this task.
Each <span class='latex-texttt'>@ResourceClient</span> interface becomes an Angular
<span class='latex-texttt'>@Injectable</span> service that uses the <span class='latex-texttt'>HttpClient</span>.
The decisive advantage: The REST APIs already exist from
<span class='latex-textit'>IdeaForkMicro</span> and Quarkus — Angular calls them directly.
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-resource-client'></a>                     <pre><code>// @ResourceClient (DeltaSpike Partial-Bean)
@ResourceClient(name = "ideas", version = "v1")
public interface IdeaResourceClient {
    @GET
    @Path("/")
    List&lt;Idea&gt; getAll();

    @POST
    @Path("/")
    Idea create(Idea idea);

    @GET
    @Path("/{id}")
    Idea getById(@PathParam("id") Long id);
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-idea-service'></a>                     <pre><code>// Angular: IdeaService
@Injectable({ providedIn: 'root' })
export class IdeaService {
  private http = inject(HttpClient);
  private apiUrl = '/api/ideas/v1';

  getAll(): Observable&lt;Idea[]&gt; {
    return this.http.get&lt;Idea[]&gt;(this.apiUrl);
  }

  create(idea: Idea): Observable&lt;Idea&gt; {
    return this.http.post&lt;Idea&gt;(this.apiUrl, idea);
  }

  getById(id: number): Observable&lt;Idea&gt; {
    return this.http.get&lt;Idea&gt;(`${this.apiUrl}/${id}`);
  }
}</code></pre>
                </div>
The Observable-based pattern of the <span class='latex-texttt'>HttpClient</span> enables
asynchronous processing and explicit error handling with <span class='latex-texttt'>catchError</span>.
In combination with signals, loading states and errors can be displayed reactively:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-error-handling'></a>                     <pre><code>// Angular: Fehlerbehandlung und Ladezustand
@Component({
  selector: 'app-idea-list',
  standalone: true,
  imports: [CommonModule],
  template: `
    @if (loading()) {
      &lt;div class="spinner"&gt;Laden...&lt;/div&gt;
    } @else if (error()) {
      &lt;div class="error"&gt;{{ error() }}&lt;/div&gt;
    } @else {
      @for (idea of ideas(); track idea.id) {
        &lt;div class="idea-card" (click)="showDetail(idea)"&gt;
          &lt;h3&gt;{{ idea.title }}&lt;/h3&gt;
        &lt;/div&gt;
      }
    }
  `
})
export class IdeaListComponent implements OnInit {
  ideas = signal&lt;Idea[]&gt;([]);
  loading = signal(true);
  error = signal&lt;string | null&gt;(null);

  private ideaService = inject(IdeaService);
  private router = inject(Router);

  ngOnInit() {
    this.ideaService.getAll().pipe(
      catchError(err =&gt; {
        this.error.set('Fehler beim Laden der Ideen');
        return of([]);
      }),
      finalize(() =&gt; this.loading.set(false))
    ).subscribe(data =&gt; this.ideas.set(data));
  }

  showDetail(idea: Idea) {
    this.router.navigate(['/ideas', idea.id]);
  }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Angular's typed <span class='latex-texttt'>HttpClient</span> responses
(<span class='latex-texttt'>get&lt;Idea[]&gt;(...)</span>) provide compile-time safety
similar to the typed <span class='latex-texttt'>@ResourceClient</span> interfaces.
The TypeScript compiler catches type errors at development time.</div>
<div class="tip"><b>Tip: </b>During development, Angular's dev server can proxy API calls to the backend via <span class='latex-texttt'>proxy.conf.json</span>. The key insight: if the backend serves at <span class='latex-texttt'>/api/...</span> (like Quarkus), no <span class='latex-texttt'>pathRewrite</span> is needed. If a mock server (e.g., json-server) serves without a path prefix, <span class='latex-texttt'>pathRewrite: {"^/api": ""}</span> strips the prefix. When switching from mock to real backend, only this one line in the proxy configuration changes.</div>
<div class="tip"><b>Tip: </b><b>Global error handling:</b> Instead of handling errors individually in each service, a global HTTP interceptor can respond centrally: automatically redirect to the login page on status 401, display a permission error message on 403, show a toast notification on 500. This interceptor is registered in <span class='latex-texttt'>app.config.ts</span> and intercepts all outgoing HTTP requests &mdash; comparable to a CDI interceptor for cross-cutting concerns.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.8'><span class='entry-number'>11.8</span> The Promotion Wizard</a> </h2>
The promotion wizard is the most complex UI feature in <span class='latex-textit'>IdeaFork</span>:
A three-step wizard that proposes an idea for promotion.
In the JSF version the wizard uses <span class='latex-texttt'>@GroupedConversationScoped</span>
to hold state across the three steps.
The DeltaSpike <span class='latex-texttt'>@EntryPoint</span> mechanism ensures
that the wizard can only be entered through step 1.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
In Angular the wizard is mapped by a service for state
and route guards for step control:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-promotion-wizard'></a>                     <pre><code>// JSF: Promotion-Wizard mit @GroupedConversationScoped
@Named
@GroupedConversationScoped
public class PromotionWizardBean implements Serializable {
    @Inject
    private GroupedConversation conversation;

    @Inject
    private PromotionService promotionService;

    private Idea selectedIdea;
    private PromotionType type;
    private String justification;

    // Schritt 1: Idee auswählen
    public Class&lt;? extends ViewConfig&gt; selectIdea(Idea idea) {
        this.selectedIdea = idea;
        return Pages.Promotion.Step2.class;
    }

    // Schritt 2: Typ wählen
    public Class&lt;? extends ViewConfig&gt; selectType(PromotionType type) {
        this.type = type;
        return Pages.Promotion.Step3.class;
    }

    // Schritt 3: Abschließen
    public Class&lt;? extends ViewConfig&gt; submit() {
        promotionService.promote(selectedIdea, type, justification);
        conversation.close();
        return Pages.Idea.List.class;
    }

    // Abbrechen
    public Class&lt;? extends ViewConfig&gt; cancel() {
        conversation.close();
        return Pages.Idea.List.class;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-promotion-wizard'></a>                     <pre><code>// Angular: Promotion-Wizard Service + Komponenten
@Injectable()
export class PromotionWizardService {
  selectedIdea = signal&lt;Idea | null&gt;(null);
  promotionType = signal&lt;PromotionType | null&gt;(null);
  justification = signal('');

  private promotionService = inject(PromotionService);
  private router = inject(Router);

  // Schritt 1: Idee auswählen
  selectIdea(idea: Idea) {
    this.selectedIdea.set(idea);
    this.router.navigate(['/promotion/step2']);
  }

  // Schritt 2: Typ wählen
  selectType(type: PromotionType) {
    this.promotionType.set(type);
    this.router.navigate(['/promotion/step3']);
  }

  // Schritt 3: Abschließen
  submit(): Observable&lt;void&gt; {
    return this.promotionService.promote({
      ideaId: this.selectedIdea()!.id,
      type: this.promotionType()!,
      justification: this.justification()
    }).pipe(
      tap(() =&gt; {
        this.reset();
        this.router.navigate(['/ideas']);
      })
    );
  }

  cancel() {
    this.reset();
    this.router.navigate(['/ideas']);
  }

  private reset() {
    this.selectedIdea.set(null);
    this.promotionType.set(null);
    this.justification.set('');
  }
}

// Route Guard: Wizard-Schritt-Reihenfolge erzwingen
export const wizardStepGuard: CanActivateFn = (route) =&gt; {
  const wizard = inject(PromotionWizardService);
  const router = inject(Router);
  const step = route.routeConfig?.path;

  if (step === 'step2' &amp;&amp; !wizard.selectedIdea()) {
    return router.createUrlTree(['/promotion/step1']);
  }
  if (step === 'step3' &amp;&amp; !wizard.promotionType()) {
    return router.createUrlTree(['/promotion/step2']);
  }
  return true;
};</code></pre>
                </div>
The <span class='latex-texttt'>PromotionWizardService</span> is registered as a provider
for the <span class='latex-texttt'>promotion</span> path in the route configuration.
This creates a new instance when the user enters the wizard
and automatically destroys it when they leave the wizard area —
functionally equivalent to <span class='latex-texttt'>@GroupedConversationScoped</span>.
<div class="tip"><b>Tip: </b>The Angular Router can enforce wizard step order
with <span class='latex-texttt'>canActivate</span> guards —
functionally equivalent to the <span class='latex-texttt'>@EntryPoint</span> mechanism
of <span class='latex-textit'>IdeaForkMicro</span>.
The <span class='latex-texttt'>wizardStepGuard</span> checks whether the previous steps
have been completed before allowing the next step.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The following component shows how step 1 uses the wizard service:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-wizard-step1'></a>                     <pre><code>// step1.component.ts (Angular)
@Component({
  selector: 'app-step1',
  standalone: true,
  imports: [CommonModule],
  template: `
    &lt;h2&gt;Step 1: Select Idea&lt;/h2&gt;
    @for (idea of ideas(); track idea.id) {
      &lt;div class="idea-card" (click)="select(idea)"&gt;
        &lt;h3&gt;{{ idea.title }}&lt;/h3&gt;
      &lt;/div&gt;
    }
  `
})
export class Step1Component implements OnInit {
  ideas = signal&lt;Idea[]&gt;([]);

  private wizard = inject(PromotionWizardService);
  private ideaService = inject(IdeaService);

  ngOnInit() {
    this.ideaService.getAll().subscribe(
      data =&gt; this.ideas.set(data)
    );
  }

  select(idea: Idea) {
    this.wizard.selectIdea(idea);
  }
}</code></pre>
                </div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<b>Unit tests for Angular components:</b> Angular's testing framework is based on <span class='latex-texttt'>TestBed</span>, which plays a similar role to DeltaSpike Test-Control for CDI beans: it creates an isolated test environment with controlled dependency injection.
A typical component test uses <span class='latex-texttt'>TestBed.configureTestingModule()</span> to provide only the required dependencies.
The <span class='latex-texttt'>HttpClient</span> is replaced by <span class='latex-texttt'>provideHttpClientTesting()</span>, so that REST calls can be tested without a real backend.
For signal-based components (from Angular 17), <span class='latex-texttt'>ComponentFixture.detectChanges()</span> and <span class='latex-texttt'>fixture.whenStable()</span> can be used to verify reactive state changes in tests.
<div class="tip"><b>Tip: </b>The parallel to DeltaSpike Test-Control is clear: there the CDI container is started for the test, here the Angular module. In both cases, real dependencies are replaced by mocks, and the tests run in isolation without external infrastructure.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.9'><span class='entry-number'>11.9</span> Migrating the IdeaFork Frontend</a> </h2>
The following table shows the complete mapping of all 18 XHTML pages
from <span class='latex-textit'>IdeaFork</span> to Angular components:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:migration-checklist'></a>                     <pre><code>Migration Checkliste: JSF → Angular
═══════════════════════════════════════════════════════════════
JSF-Seite / DeltaSpike-Feature     → Angular-Entsprechung
───────────────────────────────────────────────────────────────
main-template.xhtml (ui:insert)    → AppComponent + router-outlet
index.xhtml                        → HomeComponent
ideaList.xhtml                     → IdeaListComponent
ideaDetail.xhtml                   → IdeaDetailComponent
createIdea.xhtml                   → CreateIdeaComponent
login.xhtml                        → LoginComponent
registration.xhtml                 → RegistrationComponent
userProfile.xhtml                  → UserProfileComponent
promotionStep1.xhtml               → Step1Component
promotionStep2.xhtml               → Step2Component
promotionStep3.xhtml               → Step3Component
categoryList.xhtml                 → CategoryListComponent
categoryDetail.xhtml               → CategoryDetailComponent
notificationList.xhtml             → NotificationListComponent
archiveList.xhtml                  → ArchiveListComponent
adminDashboard.xhtml               → AdminDashboardComponent
settings.xhtml                     → SettingsComponent
error.xhtml                        → ErrorComponent
───────────────────────────────────────────────────────────────
ViewConfig-Hierarchie              → Routes-Array (app.routes.ts)
@Named Backing Beans               → @Injectable Services
@ViewAccessScoped                  → Komponenten-Lebenszyklus
@WindowScoped                      → providedIn: 'root' Service
@GroupedConversationScoped          → Route-scoped Service
@Secured + AccessDecisionVoter     → canActivate Guard
@ResourceClient                    → HttpClient Service
JsfMessage / @MessageBundle        → NotificationService
formGroup.xhtml (Composite)        → FormFieldComponent
EL-Ausdrücke (#{...})              → Template-Bindings ({{...}})
@PreRenderView                     → ngOnInit()
h:form + h:commandButton           → Reactive Forms + (ngSubmit)
ui:repeat                          → @for Control-Flow
rendered="#{...}"                  → @if / @switch Control-Flow
═══════════════════════════════════════════════════════════════</code></pre>
                </div>
For the integration of Angular with the Quarkus backend the
Quarkus extension <span class='latex-texttt'>quarkus-quinoa</span> offers an elegant solution.
Quinoa allows building the Angular frontend directly from the Quarkus project
and serving it as static files:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:quinoa-config'></a>                     <pre><code># application.properties (Quarkus + Quinoa)
quarkus.quinoa.enable=true
quarkus.quinoa.package-manager=npm
quarkus.quinoa.build-dir=dist/ideafork-frontend/browser
quarkus.quinoa.enable-spa-routing=true

# Entwicklungsmodus: Angular Dev-Server Proxy
%dev.quarkus.quinoa.dev-server.port=4200
%dev.quarkus.quinoa.dev-server.check-timeout=60000</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The configuration <span class='latex-texttt'>quarkus.quinoa.enable-spa-routing=true</span>
is crucial: It redirects all non-API requests to the Angular application,
so that client-side routing works correctly.
Without this setting, a direct request to e.g.
<span class='latex-texttt'>/ideas/42</span> would result in a 404 error.</div>
During development Angular CLI and Quarkus run as separate processes.
The file <span class='latex-texttt'>proxy.conf.json</span> in the Angular project forwards
API requests to the Quarkus backend:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:proxy-config'></a>                     <pre><code>// proxy.conf.json (Angular CLI)
{
  "/api": {
    "target": "http://localhost:8080",
    "secure": false,
    "changeOrigin": true
  }
}</code></pre>
                </div>
For the production environment the Angular project is compiled as part of the Quarkus build.
The static files are served by Quarkus as Vert.x static resources
— without a separate web server.
<div class="tip"><b>Tip: </b>The project structure for Quinoa expects
the Angular project as a subdirectory
(<span class='latex-texttt'>src/main/webui/</span>) in the Quarkus Maven project.
Quinoa runs <span class='latex-texttt'>npm install</span> and <span class='latex-texttt'>npm run build</span>
automatically as part of the Maven build.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<b>Deployment and containerization:</b> For production, the Angular application is compiled with <span class='latex-texttt'>ng build --configuration production</span>.
The result is a folder with static HTML, CSS, and JavaScript files.
These can be served directly by Quarkus &mdash; either via the <span class='latex-texttt'>quarkus-quinoa</span> extension (which automatically integrates the Angular build into the Quarkus artifact) or via a separate Nginx container.
<div class="tip"><b>Tip: </b><b>One artifact for everything:</b> With Quarkus + Quinoa, a single JAR (or native image) is created that serves both the REST API and the Angular SPA. For <span class='latex-textit'>IdeaFork</span> this means: a single <span class='latex-texttt'>docker build</span> command produces a container image with the complete stack &mdash; backend, frontend, and database migration.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.10'><span class='entry-number'>11.10</span> Sources</a> </h2>
<b>Sources:</b><br />
- angular.dev<br />
- quarkus.io<br />
- quarkus.io/guides/quinoa<br />
- microprofile.io<br />
- jakarta.ee<br />
- deltaspike.apache.org<br />
</section>
<section class="chapter-section" id="chapter-12">
<h1> <a class='latex-index-anchor' name='!idx:/testing.html:12'><span class='entry-number'>12</span> Testing Across the Stack</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> This chapter was written by Claude (Anthropic) based on the previous chapters. It describes the migration of the IdeaFork test strategy &mdash; from DeltaSpike Test-Control through Weld-JUnit5 and @QuarkusTest to Angular unit tests and Playwright E2E tests.
</div>
<a name = '!idx:/testing.html:chap:testing-across-stack'> </a><h2><a class='latex-index-anchor' name='!idx:/testing.html:12.1'><span class='entry-number'>12.1</span> A New Test Foundation</a> </h2>
 In the previous chapters, we progressively modernized <span class='latex-textit'>IdeaFork</span>:
Chapter 9 guided the migration to Jakarta EE, Chapter 10 completed the switch to Quarkus,
and Chapter 11 migrated the frontend from JSF to Angular.
Each of these migration steps requires a corresponding adaptation of the test strategy.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The testing landscape has fundamentally changed in the process.
In the original Java EE world of <span class='latex-textit'>IdeaFork</span>, the test strategy was based
on DeltaSpike Test-Control (Chapter 5) and Arquillian for integration tests.
With the switch to Quarkus, <span class='latex-texttt'>@QuarkusTest</span> and Dev Services take their place.
On the frontend side, Angular brings its own test framework with TestBed,
and for end-to-end tests across the entire stack, Playwright is the tool of choice.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The following overview shows the test migration in the context of the IdeaFork architecture:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-evolution-overview'></a>                     <pre><code>Test-Migrations-Uebersicht
======================================

Schicht          Alt                          Neu
----------------------------------------------------------------------
CDI-Unit         DeltaSpike Test-Control      Weld-JUnit5 (@EnableAutoWeld)
                 (CdiTestRunner, JUnit 4)     (JUnit 5, CDI SE)

Integration      Arquillian                   @QuarkusTest + Dev Services
                 (@Deployment, ShrinkWrap)    (Testcontainers, Zero-Config)

REST-API         Meecrowave/MonoMeecrowave    REST Assured + @QuarkusTest
                 (MonoMeecrowave.Rule)        (@TestHTTPResource)

Frontend-Unit    ---                          Angular TestBed
                                              (ComponentFixture, HttpTestingController)

E2E              Selenium (manuell)           Playwright
                                              (Auto-Wait, Multi-Browser, Tracing)</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-dependencies-overview'></a>                     <pre><code>&lt;!-- Test-Abhaengigkeiten (Ueberblick) --&gt;
&lt;dependencies&gt;
    &lt;!-- CDI-Unit-Tests --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt;
        &lt;artifactId&gt;weld-junit5&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- Quarkus-Integrationstests --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- REST-API-Tests --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
        &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The test migration mirrors the production migration:
Each layer of the application &mdash; CDI beans, REST endpoints, frontend components &mdash;
has its own test framework tailored to the respective runtime environment.
The key is to migrate the tests incrementally while
maintaining the test pyramid (many unit tests, few E2E tests).</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.2'><span class='entry-number'>12.2</span> Testing CDI Beans (Weld-JUnit5)</a> </h2>
Weld-JUnit5 is the lightweight successor to DeltaSpike Test-Control for
CDI unit tests. Instead of starting a full application server or container,
Weld-JUnit5 uses Weld's CDI SE implementation &mdash; the same CDI container
that is also used in Quarkus (as ArC).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The Maven dependency is minimal:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:weld-junit5-dependency'></a>                     <pre><code>&lt;!-- pom.xml: Weld-JUnit5 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt;
    &lt;artifactId&gt;weld-junit5&lt;/artifactId&gt;
    &lt;version&gt;4.0.3.Final&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
                </div>
A simple test for the <span class='latex-texttt'>IdeaManager</span> using
<span class='latex-texttt'>@EnableAutoWeld</span> looks like this:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:weld-junit5-basic-test'></a>                     <pre><code>// IdeaManagerTest.java (Weld-JUnit5)
@EnableAutoWeld
class IdeaManagerTest {

    @Inject
    IdeaManager ideaManager;

    @Test
    void shouldCreateIdea() {
        Idea idea = new Idea();
        idea.setTitle("Test-Idee");

        Idea created = ideaManager.createIdea(idea);

        assertNotNull(created.getId());
        assertEquals("Test-Idee", created.getTitle());
    }

    @Test
    void shouldFindAllIdeas() {
        List&lt;Idea&gt; ideas = ideaManager.findAll();
        assertNotNull(ideas);
    }
}</code></pre>
                </div>
The <span class='latex-texttt'>@EnableAutoWeld</span> annotation automatically starts a
Weld SE container, scans the classes on the classpath, and injects all
<span class='latex-texttt'>@Inject</span> fields of the test class. The bean discovery rules
of CDI are respected &mdash; beans with <span class='latex-texttt'>@ApplicationScoped</span>,
<span class='latex-texttt'>@RequestScoped</span>, and other standard scopes are automatically discovered.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
For mocking, Weld-JUnit5 provides the <span class='latex-texttt'>@ExcludeBean</span> annotation,
which replaces a production bean implementation with a test double:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:weld-junit5-mock'></a>                     <pre><code>// IdeaManagerMockTest.java (Weld-JUnit5 + Mock)
@EnableAutoWeld
class IdeaManagerMockTest {

    @Inject
    IdeaManager ideaManager;

    @Produces
    @ExcludeBean
    IdeaRepository mockRepository = mock(IdeaRepository.class);

    @Test
    void shouldUseMockRepository() {
        Idea testIdea = new Idea();
        testIdea.setId(1L);
        testIdea.setTitle("Mock-Idee");

        when(mockRepository.findAll()).thenReturn(List.of(testIdea));

        List&lt;Idea&gt; result = ideaManager.findAll();

        assertEquals(1, result.size());
        assertEquals("Mock-Idee", result.get(0).getTitle());
        verify(mockRepository).findAll();
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b><span class='latex-texttt'>@EnableAutoWeld</span> fully replaces the previous
<span class='latex-texttt'>CdiTestRunner</span> from DeltaSpike.
The advantage: Weld-JUnit5 is based on JUnit 5, supports nested test classes
(<span class='latex-texttt'>@Nested</span>), parameterized tests, and parallel test execution &mdash;
features that were not available with the JUnit 4-based CdiTestRunner.</div>
<div class="tip"><b>Tip: </b><span class='latex-texttt'>@ExcludeBean</span> marks a
<span class='latex-texttt'>@Produces</span> method or field as a replacement for the
production CDI bean of the same type. This is the CDI-native equivalent of
Mockito annotations like <span class='latex-texttt'>@Mock</span> with <span class='latex-texttt'>@InjectMocks</span> &mdash;
with the difference that the CDI container handles the wiring and
thus interceptors, decorators, and event observers are correctly resolved.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.3'><span class='entry-number'>12.3</span> DeltaSpike Test-Control Revisited</a> </h2>
Before we turn to the modern test frameworks, it is worth looking back at DeltaSpike Test-Control.
In Chapter 5, we introduced the <span class='latex-texttt'>CdiTestRunner</span> as the central test infrastructure
for CDI unit tests. Its principle was simple: the runner starts a
CDI container via the CDI-Control abstraction and injects the test class as a CDI bean.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
A typical DeltaSpike test looked as follows:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:deltaspike-test-control-recap'></a>                     <pre><code>// IdeaManagerTest.java (DeltaSpike Test-Control)
@RunWith(CdiTestRunner.class)
public class IdeaManagerTest {

    @Inject
    private IdeaManager ideaManager;

    @Test
    public void shouldCreateIdea() {
        Idea idea = new Idea();
        idea.setTitle("Test-Idee");

        Idea created = ideaManager.createIdea(idea);

        assertNotNull(created.getId());
    }
}</code></pre>
                </div>
The corresponding Maven dependencies:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:deltaspike-test-control-deps'></a>                     <pre><code>&lt;!-- pom.xml: DeltaSpike Test-Control --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-test-control-module-api&lt;/artifactId&gt;
    &lt;version&gt;${deltaspike.version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-test-control-module-impl&lt;/artifactId&gt;
    &lt;version&gt;${deltaspike.version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-cdictrl-weld&lt;/artifactId&gt;
    &lt;version&gt;${deltaspike.version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
                </div>
The key disadvantage: DeltaSpike Test-Control is based on JUnit 4 and the
<span class='latex-texttt'>@RunWith</span> mechanism, which was replaced by Extensions in JUnit 5.
Additionally, Test-Control requires three separate artifacts (API, Impl, CDI-Control implementation),
while Weld-JUnit5 is a single dependency.
<div class="tip"><b>Tip: </b>DeltaSpike Test-Control internally uses the CDI-Control abstraction
to support different CDI implementations (Weld, OpenWebBeans).
Weld-JUnit5 binds directly to Weld and eliminates this indirection &mdash;
resulting in faster startup times and simpler configuration.
The migration essentially consists of: removing <span class='latex-texttt'>@RunWith(CdiTestRunner.class)</span>,
adding <span class='latex-texttt'>@EnableAutoWeld</span>, and swapping the dependencies.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.4'><span class='entry-number'>12.4</span> Arquillian: Integration Testing</a> </h2>
For integration tests that required a full application server,
Arquillian was the standard tool in the Java EE world.
Arquillian creates a micro-deployment &mdash; a minimal archive containing only the
classes and resources needed for the test &mdash; and deploys it
into a real or embedded container.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
A typical Arquillian test with the <span class='latex-texttt'>@Deployment</span> pattern:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:arquillian-test'></a>                     <pre><code>// IdeaServiceIT.java (Arquillian)
@RunWith(Arquillian.class)
public class IdeaServiceIT {

    @Deployment
    public static Archive&lt;?&gt; createDeployment() {
        return ShrinkWrap.create(WebArchive.class, "test.war")
            .addClasses(IdeaService.class, IdeaRepository.class,
                        Idea.class, EntityManagerProducer.class)
            .addAsResource("META-INF/persistence.xml")
            .addAsWebInfResource("beans.xml");
    }

    @Inject
    private IdeaService ideaService;

    @Test
    public void shouldPersistIdea() {
        Idea idea = new Idea();
        idea.setTitle("Arquillian-Test");

        ideaService.save(idea);

        assertNotNull(idea.getId());
    }
}</code></pre>
                </div>
The corresponding dependencies and container adapter:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:arquillian-deps'></a>                     <pre><code>&lt;!-- pom.xml: Arquillian --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.junit&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-junit-container&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.wildfly.arquillian&lt;/groupId&gt;
    &lt;artifactId&gt;wildfly-arquillian-container-managed&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
                </div>
The comparison with <span class='latex-texttt'>@QuarkusTest</span> shows the evolution:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:arquillian-vs-quarkustest'></a>                     <pre><code>Vergleich: Arquillian vs. @QuarkusTest
======================================

Aspekt               Arquillian                    @QuarkusTest
----------------------------------------------------------------------
Setup                @Deployment + ShrinkWrap      Keine Deployment-Methode
Container            Externer App-Server           Quarkus-integriert
Bean-Discovery       Nur explizit gepackte Beans   Gesamte Anwendung
Startup-Zeit         30-60 Sekunden                2-5 Sekunden
Dev Services         Nicht verfuegbar              Automatische DB/MQ/...
Mocking              Eigene Producer               @InjectMock (nativ)
Continuous Testing   Nicht unterstuetzt            quarkus.test.continuous-testing
JUnit-Version        JUnit 4 (Standard)            JUnit 5 (nativ)</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b>Arquillian tests and <span class='latex-texttt'>@QuarkusTest</span>
differ fundamentally in bean isolation: Arquillian tests only the
classes explicitly packaged in the <span class='latex-texttt'>@Deployment</span> archive, while
<span class='latex-texttt'>@QuarkusTest</span> starts the entire application.
This means that side effects between beans that were not visible in Arquillian
may suddenly appear in <span class='latex-texttt'>@QuarkusTest</span>.</div>
<div class="tip"><b>Tip: </b>Arquillian remains a valid tool for projects
that still run on a classic application server (WildFly, Payara, TomEE).
For Quarkus-based projects like <span class='latex-textit'>IdeaForkMicro</span>,
<span class='latex-texttt'>@QuarkusTest</span> offers a significantly simpler and faster alternative.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.5'><span class='entry-number'>12.5</span> @QuarkusTest and Dev Services</a> </h2>
<span class='latex-texttt'>@QuarkusTest</span> starts the entire Quarkus application in a
test mode that provides the full CDI, REST, and persistence infrastructure.
The key advantage over Arquillian: there is no <span class='latex-texttt'>@Deployment</span> method,
no ShrinkWrap archives, and no external application server.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
A simple <span class='latex-texttt'>@QuarkusTest</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:quarkustest-basic'></a>                     <pre><code>// IdeaServiceTest.java (@QuarkusTest)
@QuarkusTest
class IdeaServiceTest {

    @Inject
    IdeaService ideaService;

    @Test
    void shouldCreateAndFindIdea() {
        Idea idea = new Idea();
        idea.setTitle("Quarkus-Test");

        ideaService.save(idea);

        List&lt;Idea&gt; all = ideaService.findAll();
        assertTrue(all.stream()
            .anyMatch(i -&gt; "Quarkus-Test".equals(i.getTitle())));
    }
}</code></pre>
                </div>
For mocking, Quarkus provides the <span class='latex-texttt'>@InjectMock</span> annotation,
which replaces a CDI bean at runtime with a Mockito mock:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:quarkustest-injectmock'></a>                     <pre><code>// IdeaServiceMockTest.java (@QuarkusTest + @InjectMock)
@QuarkusTest
class IdeaServiceMockTest {

    @InjectMock
    IdeaRepository ideaRepository;

    @Inject
    IdeaService ideaService;

    @Test
    void shouldUseMockedRepository() {
        Idea testIdea = new Idea();
        testIdea.setId(1L);
        testIdea.setTitle("Mock-Idee");

        when(ideaRepository.findAll()).thenReturn(List.of(testIdea));

        List&lt;Idea&gt; result = ideaService.findAll();

        assertEquals(1, result.size());
        verify(ideaRepository).findAll();
    }
}</code></pre>
                </div>
A particularly powerful feature of Quarkus is Dev Services:
They automatically start Testcontainers for databases, message brokers, and other
infrastructure services &mdash; without manual configuration:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:devservices-config'></a>                     <pre><code># application.properties (Dev Services)
# Keine DB-URL noetig im Test-Profil!
# Quarkus startet automatisch einen PostgreSQL-Testcontainer.

%test.quarkus.datasource.devservices.enabled=true
%test.quarkus.datasource.devservices.image-name=postgres:16-alpine

# Hibernate: Schema automatisch erzeugen
%test.quarkus.hibernate-orm.database.generation=drop-and-create

# Optional: Dev Services auch fuer Kafka
%test.quarkus.kafka.devservices.enabled=true</code></pre>
                </div>
For different test configurations, Quarkus offers test profiles:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:quarkustest-profile'></a>                     <pre><code>// IntegrationTestProfile.java (QuarkusTestProfile)
public class IntegrationTestProfile implements QuarkusTestProfile {

    @Override
    public String getConfigProfile() {
        return "integration";
    }

    @Override
    public Map&lt;String, String&gt; getConfigOverrides() {
        return Map.of(
            "quarkus.datasource.devservices.image-name", "postgres:16-alpine",
            "quarkus.log.level", "DEBUG"
        );
    }
}

// Verwendung im Test:
@QuarkusTest
@TestProfile(IntegrationTestProfile.class)
class IdeaServiceIntegrationTest {
    // ... Tests mit Integration-Profil
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Dev Services completely eliminate manual database configuration
in tests. Instead of maintaining a <span class='latex-texttt'>persistence.xml</span> with an
H2 in-memory database, Quarkus automatically starts a real
PostgreSQL container via Testcontainers. This means: the tests run against
the same database as production &mdash; a common source of errors with
H2-based tests is thereby eliminated.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b><span class='latex-texttt'>@QuarkusTest</span> starts the entire application
and is therefore significantly slower than a pure CDI unit test with Weld-JUnit5.
For tests that only verify CDI beans without database access or REST endpoints,
Weld-JUnit5 is the more efficient choice. Reserve
<span class='latex-texttt'>@QuarkusTest</span> for integration tests that require the full
Quarkus infrastructure.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.6'><span class='entry-number'>12.6</span> Testing REST Endpoints</a> </h2>
In Chapter 8, we tested the REST endpoints of <span class='latex-textit'>IdeaForkMicro</span>
with Apache Meecrowave and <span class='latex-texttt'>MonoMeecrowave.Rule</span>.
With the migration to Quarkus, REST Assured becomes the standard tool for HTTP-based tests.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
As a reminder: the Meecrowave-based approach from Chapter 8:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:meecrowave-recap'></a>                     <pre><code>// IdeaResourceTest.java (Meecrowave)
public class IdeaResourceTest {

    @ClassRule
    public static final MonoMeecrowave.Rule RULE =
        new MonoMeecrowave.Rule();

    @Test
    public void shouldReturnIdeas() {
        String response = ClientBuilder.newClient()
            .target("http://localhost:" + RULE.getConfiguration().getHttpPort())
            .path("/api/ideas")
            .request(MediaType.APPLICATION_JSON)
            .get(String.class);

        assertNotNull(response);
    }
}</code></pre>
                </div>
The same test with REST Assured and <span class='latex-texttt'>@QuarkusTest</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:rest-assured-basic'></a>                     <pre><code>// IdeaResourceTest.java (REST Assured + @QuarkusTest)
@QuarkusTest
class IdeaResourceTest {

    @Test
    void shouldReturnIdeas() {
        given()
            .when().get("/api/ideas/v1")
            .then()
            .statusCode(200)
            .contentType(ContentType.JSON);
    }

    @Test
    void shouldCreateIdea() {
        given()
            .contentType(ContentType.JSON)
            .body("""
                {"title": "REST-Test", "category": "MISC"}
                """)
            .when().post("/api/ideas/v1")
            .then()
            .statusCode(201)
            .body("title", equalTo("REST-Test"));
    }
}</code></pre>
                </div>
For secured endpoints, Quarkus provides the <span class='latex-texttt'>@TestSecurity</span> annotation,
which simulates an authenticated identity:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:rest-assured-testsecurity'></a>                     <pre><code>// SecuredIdeaResourceTest.java (@TestSecurity)
@QuarkusTest
class SecuredIdeaResourceTest {

    @Test
    @TestSecurity(user = "testuser", roles = {"user"})
    void shouldAllowAuthenticatedUser() {
        given()
            .when().get("/api/ideas/v1")
            .then()
            .statusCode(200);
    }

    @Test
    void shouldRejectUnauthenticatedUser() {
        given()
            .when().get("/api/ideas/v1")
            .then()
            .statusCode(401);
    }

    @Test
    @TestSecurity(user = "admin", roles = {"admin"})
    void shouldAllowAdminToDelete() {
        given()
            .when().delete("/api/ideas/v1/1")
            .then()
            .statusCode(204);
    }
}</code></pre>
                </div>
For testing the native Quarkus artifact, <span class='latex-texttt'>@QuarkusIntegrationTest</span>
provides the ability to run tests against the actually built artifact (JAR or native image):
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:quarkus-integration-test'></a>                     <pre><code>// IdeaResourceIT.java (@QuarkusIntegrationTest)
@QuarkusIntegrationTest
class IdeaResourceIT {

    @Test
    void shouldReturnIdeasFromNativeImage() {
        given()
            .when().get("/api/ideas/v1")
            .then()
            .statusCode(200)
            .contentType(ContentType.JSON);
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b><span class='latex-texttt'>@TestSecurity</span> completely replaces manual
JWT creation in tests. Instead of generating a token and sending it in the
<span class='latex-texttt'>Authorization</span> header, the annotation declares
the user and their roles directly on the test case &mdash; this is more readable and less error-prone.</div>
<div class="tip"><b>Tip: </b><span class='latex-texttt'>@QuarkusIntegrationTest</span> tests the
actually built artifact &mdash; that is, the JAR or the native image.
Unlike <span class='latex-texttt'>@QuarkusTest</span>, which starts the application in JVM mode,
<span class='latex-texttt'>@QuarkusIntegrationTest</span> starts the real process.
This is particularly important for native images, as GraalVM compilation
can reveal reflection issues that are not visible in JVM mode.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.7'><span class='entry-number'>12.7</span> Angular Unit Tests (TestBed)</a> </h2>
On the frontend side, Angular provides its own test framework with <span class='latex-texttt'>TestBed</span>,
which conceptually corresponds to the CDI container for tests.
TestBed configures an isolated Angular module for the test case,
resolves dependencies, and creates component instances &mdash;
analogous to <span class='latex-texttt'>@EnableAutoWeld</span> for CDI beans.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
A component test for the <span class='latex-texttt'>IdeaListComponent</span> from Chapter 11:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:angular-component-test'></a>                     <pre><code>// idea-list.component.spec.ts
describe('IdeaListComponent', () =&gt; {
  let component: IdeaListComponent;
  let fixture: ComponentFixture&lt;IdeaListComponent&gt;;
  let ideaService: jasmine.SpyObj&lt;IdeaService&gt;;

  beforeEach(async () =&gt; {
    const spy = jasmine.createSpyObj('IdeaService', ['getAll', 'create']);

    await TestBed.configureTestingModule({
      imports: [IdeaListComponent],
      providers: [
        { provide: IdeaService, useValue: spy }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(IdeaListComponent);
    component = fixture.componentInstance;
    ideaService = TestBed.inject(IdeaService) as jasmine.SpyObj&lt;IdeaService&gt;;
  });

  it('should load ideas on init', () =&gt; {
    const testIdeas: Idea[] = [
      { id: 1, title: 'Test-Idee', category: 'MISC' }
    ];
    ideaService.getAll.and.returnValue(of(testIdeas));

    fixture.detectChanges();

    expect(component.ideas().length).toBe(1);
    expect(component.ideas()[0].title).toBe('Test-Idee');
  });

  it('should display ideas in template', () =&gt; {
    ideaService.getAll.and.returnValue(of([
      { id: 1, title: 'Angezeigt', category: 'MISC' }
    ]));

    fixture.detectChanges();

    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('.idea-card h3')?.textContent)
      .toContain('Angezeigt');
  });
});</code></pre>
                </div>
For service tests that mock HTTP calls, Angular provides the
<span class='latex-texttt'>HttpClientTestingModule</span> (or since Angular 18,
<span class='latex-texttt'>provideHttpClientTesting()</span>):
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:angular-service-test'></a>                     <pre><code>// idea.service.spec.ts
describe('IdeaService', () =&gt; {
  let service: IdeaService;
  let httpTesting: HttpTestingController;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      providers: [
        IdeaService,
        provideHttpClient(),
        provideHttpClientTesting()
      ]
    });
    service = TestBed.inject(IdeaService);
    httpTesting = TestBed.inject(HttpTestingController);
  });

  afterEach(() =&gt; {
    httpTesting.verify();
  });

  it('should fetch all ideas', () =&gt; {
    const testIdeas: Idea[] = [
      { id: 1, title: 'HTTP-Test', category: 'MISC' }
    ];

    service.getAll().subscribe(ideas =&gt; {
      expect(ideas.length).toBe(1);
      expect(ideas[0].title).toBe('HTTP-Test');
    });

    const req = httpTesting.expectOne('/api/ideas/v1');
    expect(req.request.method).toBe('GET');
    req.flush(testIdeas);
  });
});</code></pre>
                </div>
A test for the auth guard that verifies JWT-based authentication:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:angular-guard-test'></a>                     <pre><code>// auth.guard.spec.ts
describe('AuthGuard', () =&gt; {
  let authService: jasmine.SpyObj&lt;AuthService&gt;;
  let router: jasmine.SpyObj&lt;Router&gt;;

  beforeEach(() =&gt; {
    const authSpy = jasmine.createSpyObj('AuthService', ['isAuthenticated']);
    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);

    TestBed.configureTestingModule({
      providers: [
        { provide: AuthService, useValue: authSpy },
        { provide: Router, useValue: routerSpy }
      ]
    });

    authService = TestBed.inject(AuthService) as jasmine.SpyObj&lt;AuthService&gt;;
    router = TestBed.inject(Router) as jasmine.SpyObj&lt;Router&gt;;
  });

  it('should allow authenticated users', () =&gt; {
    authService.isAuthenticated.and.returnValue(true);

    const result = TestBed.runInInjectionContext(() =&gt;
      authGuard({} as ActivatedRouteSnapshot, {} as RouterStateSnapshot)
    );

    expect(result).toBeTrue();
  });

  it('should redirect unauthenticated users to login', () =&gt; {
    authService.isAuthenticated.and.returnValue(false);

    TestBed.runInInjectionContext(() =&gt;
      authGuard({} as ActivatedRouteSnapshot, {} as RouterStateSnapshot)
    );

    expect(router.navigate).toHaveBeenCalledWith(['/login']);
  });
});</code></pre>
                </div>
The test configuration in <span class='latex-texttt'>angular.json</span> defines the Karma runner
and code coverage thresholds:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:angular-test-config'></a>                     <pre><code>// angular.json (Test-Konfiguration, Auszug)
{
  "projects": {
    "ideafork-frontend": {
      "architect": {
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "tsConfig": "tsconfig.spec.json",
            "assets": ["src/assets"],
            "styles": ["src/styles.scss"],
            "codeCoverage": true,
            "codeCoverageExclude": [
              "src/test-setup.ts",
              "**/*.spec.ts"
            ]
          }
        }
      }
    }
  }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The <span class='latex-texttt'>TestBed</span> is the Angular equivalent
of the CDI container in the test context: it configures dependencies, resolves injections,
and provides isolated component instances.
The method <span class='latex-texttt'>TestBed.inject()</span> corresponds to
<span class='latex-texttt'>CDI.current().select()</span> &mdash;
both return an instance from their respective dependency injection container.</div>
<div class="tip"><b>Tip: </b>Standalone Components (since Angular 15) significantly simplify test configuration:
instead of building a <span class='latex-texttt'>TestModule</span> with declarations,
imports, and providers, the component is passed directly in
<span class='latex-texttt'>imports</span>. This reduces boilerplate code in tests
and follows the trend away from NgModules toward individual, self-describing components.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.8'><span class='entry-number'>12.8</span> E2E Testing with Playwright</a> </h2>
End-to-end tests verify the entire application from the user's perspective &mdash;
from the Angular frontend through the REST API to the database.
Playwright is the modern successor to Selenium and offers auto-wait,
multi-browser support, and integrated tracing.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The Playwright configuration for <span class='latex-textit'>IdeaFork</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:playwright-config'></a>                     <pre><code>// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  retries: process.env.CI ? 2 : 0,
  reporter: process.env.CI ? 'html' : 'list',

  use: {
    baseURL: 'http://localhost:8080',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },

  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
  ],

  webServer: {
    command: 'mvn quarkus:dev -Dquarkus.http.port=8080',
    port: 8080,
    timeout: 120_000,
    reuseExistingServer: !process.env.CI,
  },
});</code></pre>
                </div>
An E2E test for the login flow:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:playwright-login-test'></a>                     <pre><code>// e2e/login.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Login', () =&gt; {
  test('should login with valid credentials', async ({ page }) =&gt; {
    await page.goto('/login');

    await page.getByLabel('Username').fill('testuser');
    await page.getByLabel('Password').fill('testpass');
    await page.getByRole('button', { name: 'Login' }).click();

    await expect(page).toHaveURL('/ideas');
    await expect(page.getByText('Meine Ideen')).toBeVisible();
  });

  test('should show error for invalid credentials', async ({ page }) =&gt; {
    await page.goto('/login');

    await page.getByLabel('Username').fill('invalid');
    await page.getByLabel('Password').fill('wrong');
    await page.getByRole('button', { name: 'Login' }).click();

    await expect(page.getByText('Anmeldung fehlgeschlagen'))
      .toBeVisible();
  });
});</code></pre>
                </div>
A more comprehensive E2E test for the idea workflow:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:playwright-idea-flow'></a>                     <pre><code>// e2e/idea-flow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Idea Flow', () =&gt; {
  test.beforeEach(async ({ page }) =&gt; {
    // Login
    await page.goto('/login');
    await page.getByLabel('Username').fill('testuser');
    await page.getByLabel('Password').fill('testpass');
    await page.getByRole('button', { name: 'Login' }).click();
    await expect(page).toHaveURL('/ideas');
  });

  test('should create and display a new idea', async ({ page }) =&gt; {
    await page.getByRole('button', { name: 'Neue Idee' }).click();

    await page.getByLabel('Titel').fill('E2E-Testidee');
    await page.getByLabel('Kategorie').selectOption('MISC');
    await page.getByLabel('Beschreibung').fill('Erstellt via Playwright');
    await page.getByRole('button', { name: 'Speichern' }).click();

    await expect(page.getByText('E2E-Testidee')).toBeVisible();
  });

  test('should promote an idea', async ({ page }) =&gt; {
    await page.getByText('E2E-Testidee').click();
    await page.getByRole('button', { name: 'Promote' }).click();

    await expect(page.getByText('Status: PROMOTED')).toBeVisible();
  });
});</code></pre>
                </div>
For integration into a CI/CD pipeline:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:ci-workflow'></a>                     <pre><code># .github/workflows/e2e.yml
name: E2E Tests
on: [push, pull_request]

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps chromium
      - name: Run E2E Tests
        run: npx playwright test --project=chromium
      - uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The <span class='latex-texttt'>webServer</span> configuration in Playwright
automatically starts the Quarkus dev server before the tests and shuts it down afterward.
With <span class='latex-texttt'>reuseExistingServer: !process.env.CI</span>, an already running
server is reused in local development &mdash; this significantly speeds up
the feedback loop.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b>E2E tests are the slowest and most fragile test level.
Keep the number of E2E tests low and focus on
the critical user workflows (login, create idea, promotion).
The test pyramid applies here as well: many unit tests (Weld-JUnit5, TestBed),
few integration tests (<span class='latex-texttt'>@QuarkusTest</span>),
minimal E2E tests (Playwright).</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.9'><span class='entry-number'>12.9</span> IdeaFork Test Migration Checklist</a> </h2>
The test migration for <span class='latex-textit'>IdeaFork</span> follows the same principles
as the production migration: incremental, layer by layer, and with clear equivalences.
The following checklist summarizes the concrete migration steps:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-migration-checklist'></a>                     <pre><code>IdeaFork Test-Migrations-Checkliste
======================================

1. Test-Abhaengigkeiten umstellen
   - DeltaSpike Test-Control   -> org.jboss.weld:weld-junit5
   - Arquillian                -> io.quarkus:quarkus-junit5
   - Meecrowave Test           -> io.rest-assured:rest-assured
   - Selenium                  -> @playwright/test
   - JUnit 4                   -> JUnit 5 (org.junit.jupiter)

2. CDI-Unit-Tests migrieren
   - @RunWith(CdiTestRunner.class) entfernen
   - @EnableAutoWeld hinzufuegen
   - public-Modifier von Testklassen/Methoden entfernen (JUnit 5)
   - DeltaSpike @Exclude in Tests -> @ExcludeBean fuer Mocks

3. Integrationstests migrieren
   - @RunWith(Arquillian.class) entfernen
   - @Deployment-Methoden entfernen
   - @QuarkusTest hinzufuegen
   - ShrinkWrap-Archive durch Dev Services ersetzen
   - @InjectMock statt manueller CDI-Producer

4. REST-Tests migrieren
   - MonoMeecrowave.Rule entfernen
   - REST Assured DSL verwenden (given/when/then)
   - @TestSecurity fuer gesicherte Endpunkte
   - @QuarkusIntegrationTest fuer Native-Image-Tests

5. Frontend-Tests einrichten
   - Angular TestBed fuer Komponenten- und Service-Tests
   - HttpTestingController fuer HTTP-Mocking
   - Karma-Runner konfigurieren (angular.json)
   - Code-Coverage aktivieren

6. E2E-Tests einrichten
   - Playwright installieren und konfigurieren
   - webServer-Config fuer Quarkus-Dev-Server
   - Kritische Workflows als E2E-Tests abbilden
   - CI-Workflow mit Playwright einrichten</code></pre>
                </div>
The test pyramid for the migrated <span class='latex-textit'>IdeaFork</span> shows
the recommended distribution of test levels:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-pyramid'></a>                     <pre><code>IdeaFork Testpyramide
======================================

          /\
         /  \           E2E (Playwright)
        / 5% \          ~5 Tests: Login, Idee-CRUD, Promotion
       /------\
      /        \        Integration (@QuarkusTest)
     /   20%    \       ~20 Tests: REST-Endpunkte, DB-Zugriff
    /------------\
   /              \     Unit (Weld-JUnit5 + TestBed)
  /     75%        \    ~80 Tests: CDI-Beans, Services, Komponenten
 /------------------\

 Schnell, isoliert             Langsam, realistisch
 &lt;---------------------------------------------&gt;</code></pre>
                </div>
The concrete commands for running tests:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-run-commands'></a>                     <pre><code># Test-Ausfuehrung
# ======================================

# Alle Backend-Tests (Unit + Integration)
mvn test

# Nur CDI-Unit-Tests (schnell, kein Container)
mvn test -Dtest="*Test" -DfailIfNoTests=false

# Nur Integrationstests
mvn verify -Dskip.unit.tests=true

# Native-Image-Tests
mvn verify -Pnative -Dquarkus.test.native-image-wait-time=300

# Angular Unit-Tests
cd src/main/webui &amp;&amp; ng test --watch=false --code-coverage

# Angular Unit-Tests (CI, headless)
cd src/main/webui &amp;&amp; ng test --watch=false --browsers=ChromeHeadless

# Playwright E2E-Tests
npx playwright test

# Playwright E2E-Tests (nur Chromium, mit UI)
npx playwright test --project=chromium --ui</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The test migration can be done incrementally:
start with the CDI unit tests (Weld-JUnit5), as these require the least
infrastructure. Then migrate the integration tests to
<span class='latex-texttt'>@QuarkusTest</span> and finally set up the frontend
and E2E tests. Old and new tests can coexist during the migration
&mdash; JUnit 4 and JUnit 5 can be combined in the same
project via the <span class='latex-texttt'>junit-vintage-engine</span>.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.10'><span class='entry-number'>12.10</span> Sources</a> </h2>
<b>Sources:</b><br />
- weld.cdi-spec.org (Weld-JUnit5)<br />
- quarkus.io/guides/getting-started-testing<br />
- quarkus.io/guides/dev-services<br />
- rest-assured.io<br />
- arquillian.org<br />
- angular.dev/guide/testing<br />
- playwright.dev<br />
- junit.org/junit5<br />
</section>

<section class="chapter-section" id="chapter-13">
<h1> <a class='latex-index-anchor' name='!idx:/security.html:13'><span class='entry-number'>13</span> Security Across the Stack</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> This chapter was written by Claude (Anthropic) based on the preceding chapters. It describes the migration of IdeaFork's security architecture &mdash; from DeltaSpike @Secured through Quarkus Security and MicroProfile JWT to OIDC with Keycloak and Angular Auth Guards.
</div>
<div style="background:#f8d7da; border:1px solid #f5c2c7; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#842029;">
<strong>Warning:</strong> This chapter has not been reviewed by a security expert. Since it is 100% AI-generated content, errors in the text or code examples could do more harm than good in a security context. Always consult official documentation and seek expert review before applying any of this to production systems.
</div>
<a name = '!idx:/security.html:chap:security-across-stack'> </a><h2><a class='latex-index-anchor' name='!idx:/security.html:13.1'><span class='entry-number'>13.1</span> DeltaSpike Security — A Retrospective</a> </h2>
 In Chapter 5, <span class='latex-textit'>IdeaFork</span>'s security integration was introduced based on
DeltaSpike Security. The concept relied on the <span class='latex-texttt'>@Secured</span> annotation
in combination with the <span class='latex-texttt'>AccessDecisionVoter</span> pattern. Methods could be
annotated with <span class='latex-texttt'>@Secured</span>, and a CDI interceptor delegated the
authorization check to one or more voters.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The following example shows the DeltaSpike security pattern in overview &mdash; a service
that secures access via an <span class='latex-texttt'>AccessDecisionVoter</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:deltaspike-secured-recap'></a>                     <pre><code>@ApplicationScoped
public class IdeaServiceSecured {

    @Inject
    private IdeaManager ideaManager;

    @Secured(IdeaAccessDecisionVoter.class)
    public List&lt;Idea&gt; findAllSecured() {
        return ideaManager.findAll();
    }
}</code></pre>
                </div>
The corresponding <span class='latex-texttt'>AccessDecisionVoter</span> implements the actual
authorization logic:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:deltaspike-voter-impl'></a>                     <pre><code>@ApplicationScoped
public class IdeaAccessDecisionVoter
        implements AccessDecisionVoter {

    @Override
    public Set&lt;SecurityViolation&gt; checkPermission(
            AccessDecisionVoterContext context) {
        // Custom security logic
        return Collections.emptySet();
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>DeltaSpike Security was a purely annotation-driven approach
that integrated seamlessly into the CDI world. The voter pattern enabled flexible,
reusable authorization checks. With the migration to Quarkus,
standardized alternatives are now available.</div>
The following overview shows the mapping of DeltaSpike security concepts
to their Quarkus equivalents:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:voter-to-identity-mapping'></a>                     <pre><code>DeltaSpike Security  --&gt;  Quarkus Security
======================================
@Secured              --&gt;  @RolesAllowed
AccessDecisionVoter   --&gt;  SecurityIdentity
SecurityViolation     --&gt;  ForbiddenException
Interceptor-basiert   --&gt;  Annotation-basiert
Custom Voter-Logik    --&gt;  hasRole() / hasPermission()</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.2'><span class='entry-number'>13.2</span> Quarkus Security — Architecture</a> </h2>
Quarkus comes with its own standards-based security framework.
At its center is <span class='latex-texttt'>SecurityIdentity</span> &mdash; the central object
representing the authenticated user. It replaces both DeltaSpike's
<span class='latex-texttt'>AccessDecisionVoter</span> and the manual
<span class='latex-texttt'>IdentityHolder</span> from the IdeaForkMicro example (Chapter 8).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The Quarkus security architecture consists of three core components:
<span class='latex-texttt'>HttpAuthenticationMechanism</span> (how to authenticate),
<span class='latex-texttt'>IdentityProvider</span> (where user data comes from), and
<span class='latex-texttt'>SecurityIdentity</span> (who is the current user).
For most use cases, it suffices to include an extension like
<span class='latex-texttt'>quarkus-oidc</span> &mdash; the three components are then
automatically configured.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The following example shows a REST endpoint that combines
<span class='latex-texttt'>SecurityIdentity</span> and <span class='latex-texttt'>@RolesAllowed</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:security-identity-resource'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class SecuredIdeaResource {

    @Inject
    SecurityIdentity identity;

    @Inject
    IdeaService ideaService;

    @GET
    @RolesAllowed("user")
    public List&lt;Idea&gt; getAll() {
        return ideaService.findAll();
    }

    @DELETE
    @Path("/{id}")
    @RolesAllowed("admin")
    public void delete(@PathParam("id") Long id) {
        String user = identity.getPrincipal().getName();
        // Protokollierung: user hat Idea id geloescht
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b><span class='latex-texttt'>SecurityIdentity</span> is the central abstraction
in Quarkus Security. It provides methods like <span class='latex-texttt'>getPrincipal()</span>,
<span class='latex-texttt'>getRoles()</span>, and <span class='latex-texttt'>hasRole()</span> &mdash;
comparable to the DeltaSpike voter pattern, but built on a standard API.</div>
In addition to <span class='latex-texttt'>@RolesAllowed</span>, Quarkus offers the
<span class='latex-texttt'>@Authenticated</span> annotation, which only requires valid
authentication without checking for specific roles:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:authenticated-resource'></a>                     <pre><code>@Path("/api/profile")
@Authenticated
@RequestScoped
public class ProfileResource {

    @Inject
    SecurityIdentity identity;

    @GET
    public String getProfile() {
        return identity.getPrincipal().getName();
    }
}</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b><span class='latex-texttt'>@RolesAllowed</span> and
<span class='latex-texttt'>@Authenticated</span> only work when an
authentication mechanism is configured (e.g., via
<span class='latex-texttt'>quarkus-oidc</span> or
<span class='latex-texttt'>quarkus-smallrye-jwt</span>). Without such an extension,
the annotations are ignored and all endpoints remain unprotected.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.3'><span class='entry-number'>13.3</span> MicroProfile JWT in Depth</a> </h2>
In Chapter 8, the IdeaForkMicro example implemented manual JWT handling &mdash;
token creation, validation, and propagation between services were all done by hand.
MicroProfile JWT standardizes this process and makes the manual implementation unnecessary.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
MicroProfile JWT defines the <span class='latex-texttt'>JsonWebToken</span> interface,
which can be injected via <span class='latex-texttt'>@Inject</span> into any CDI bean.
It provides type-safe access to token claims like name, groups, and expiration time:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:jwt-token-resource'></a>                     <pre><code>@Path("/api/ideas")
@RequestScoped
public class JwtIdeaResource {

    @Inject
    JsonWebToken jwt;

    @Inject
    IdeaService ideaService;

    @GET
    @Path("/my")
    @RolesAllowed("user")
    public List&lt;Idea&gt; getMyIdeas() {
        String username = jwt.getName();
        Set&lt;String&gt; groups = jwt.getGroups();
        return ideaService.findAll();
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>MicroProfile JWT is a standardized specification &mdash;
the code works unchanged with any conforming implementation
(Quarkus SmallRye JWT, Open Liberty, Payara). The manual JWT handling
from Chapter 8 was educational, but in production applications
the standardized variant should always be preferred.</div>
For accessing individual claims, MicroProfile JWT provides the
<span class='latex-texttt'>@Claim</span> annotation, which exposes claims directly as CDI injection points:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:jwt-claim-resource'></a>                     <pre><code>@Path("/api/userinfo")
@RequestScoped
public class UserInfoResource {

    @Inject
    @Claim(standard = Claims.preferred_username)
    String username;

    @Inject
    @Claim(standard = Claims.email)
    String email;

    @GET
    @RolesAllowed("user")
    public String getUserInfo() {
        return username + " (" + email + ")";
    }
}</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b><span class='latex-texttt'>@Claim</span> injection
only works in <span class='latex-texttt'>@RequestScoped</span> beans, since claims
are bound to the current HTTP request. In
<span class='latex-texttt'>@ApplicationScoped</span> beans, the claim from
the first request would always be injected.</div>
The configuration of MicroProfile JWT is done via standard properties
in <span class='latex-texttt'>application.properties</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:mp-jwt-config'></a>                     <pre><code># MicroProfile JWT Konfiguration
mp.jwt.verify.publickey.location=publicKey.pem
mp.jwt.verify.issuer=https://idp.ideafork.dev

smallrye.jwt.sign.key.location=privateKey.pem</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.4'><span class='entry-number'>13.4</span> OIDC / OAuth2 with Keycloak</a> </h2>
While MicroProfile JWT standardizes token validation, OIDC (OpenID Connect)
addresses the entire authentication flow &mdash; from login through token issuance to
session management. Quarkus supports OIDC natively via the
<span class='latex-texttt'>quarkus-oidc</span> extension.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Keycloak is the most widely used OIDC provider in the Java ecosystem
and integrates seamlessly with Quarkus. The configuration requires
just a few properties:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:oidc-keycloak-config'></a>                     <pre><code># OIDC/Keycloak Konfiguration
quarkus.oidc.auth-server-url=\
    http://localhost:8180/realms/ideafork
quarkus.oidc.client-id=ideafork-backend
quarkus.oidc.credentials.secret=geheim
quarkus.oidc.application-type=service
quarkus.oidc.token.issuer=any</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The <span class='latex-texttt'>application-type=service</span> setting
configures the backend endpoint as a pure bearer token receiver &mdash;
it accepts and validates tokens but does not provide a login page.
For web applications with server-side rendering,
<span class='latex-texttt'>application-type=web-app</span> would be the correct choice.</div>
A particular advantage of Quarkus is the integrated Keycloak Dev Service.
During development and testing, Quarkus automatically starts a
Keycloak instance as a container &mdash; without manual configuration:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:keycloak-devservice-config'></a>                     <pre><code># Keycloak Dev Service (nur dev/test)
quarkus.keycloak.devservices.enabled=true
quarkus.keycloak.devservices.realm-path=\
    ideafork-realm.json
quarkus.keycloak.devservices.port=8180</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The Keycloak Dev Service eliminates the need for a
manual Keycloak installation during development and testing. Quarkus automatically
starts a Keycloak container with the predefined realm configuration.
This makes the identity provider setup just as simple as
the database setup with Dev Services from Chapter 12.</div>
The REST endpoint itself requires no OIDC-specific annotations &mdash;
the existing <span class='latex-texttt'>@RolesAllowed</span> and
<span class='latex-texttt'>@Authenticated</span> annotations work automatically
with the OIDC provider:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:oidc-protected-resource'></a>                     <pre><code>@Path("/api/ideas")
@Authenticated
@ApplicationScoped
public class OidcIdeaResource {

    @Inject
    SecurityIdentity identity;

    @Inject
    IdeaService ideaService;

    @GET
    public List&lt;Idea&gt; getAll() {
        return ideaService.findAll();
    }

    @POST
    @RolesAllowed("user")
    public Idea create(Idea idea) {
        return ideaService.save(idea);
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Switching from MicroProfile JWT to OIDC requires no changes
to the application code &mdash; only the <span class='latex-texttt'>application.properties</span>
change. The annotations <span class='latex-texttt'>@RolesAllowed</span> and
<span class='latex-texttt'>@Authenticated</span> work identically with both approaches.
This is a key advantage of the standardized Quarkus security architecture.</div>
For token propagation between microservices &mdash; a topic that was
solved manually in Chapter 8 &mdash; Quarkus provides the
<span class='latex-texttt'>quarkus-rest-client-oidc-token-propagation</span> extension. It automatically
forwards the bearer token from the incoming request to REST client calls:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:token-propagation-config'></a>                     <pre><code># Token-Propagation fuer REST Client
quarkus.rest-client.downstream-api.url=\
    http://localhost:8081
quarkus.rest-client.downstream-api\
    .provider=io.quarkus.oidc.token.propagation\
    .reactive.AccessTokenRequestReactiveFilter</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.5'><span class='entry-number'>13.5</span> @RolesAllowed and Permissions</a> </h2>
The <span class='latex-texttt'>@RolesAllowed</span> annotation from
<span class='latex-texttt'>jakarta.annotation.security</span> is the standard mechanism
for declarative authorization in Quarkus. It can be applied at both the class
and method level, providing the same flexibility as the DeltaSpike voter pattern.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The following example shows fine-grained permissions at the method level,
combined with a permissive default configuration at the class level:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:roles-method-level'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
@PermitAll
public class GranularIdeaResource {

    @Inject
    IdeaService ideaService;

    @GET
    @PermitAll
    public List&lt;Idea&gt; getAll() {
        return ideaService.findAll();
    }

    @POST
    @RolesAllowed("user")
    public Idea create(Idea idea) {
        return ideaService.save(idea);
    }

    @DELETE
    @Path("/{id}")
    @RolesAllowed("admin")
    public void delete(@PathParam("id") Long id) {
        // Nur Administratoren
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Method-level annotations override class-level annotations.
In the above example, <span class='latex-texttt'>@PermitAll</span> is set at the class level
(all endpoints are open by default), but individual methods restrict
access with <span class='latex-texttt'>@RolesAllowed</span>.
The opposite &mdash; <span class='latex-texttt'>@DenyAll</span> at the class level with
<span class='latex-texttt'>@RolesAllowed</span> at the method level &mdash; is the
more restrictive and therefore recommended pattern.</div>
When role-based authorization is insufficient,
<span class='latex-texttt'>SecurityIdentity</span> provides programmatic security checks.
This enables complex authorization scenarios that go beyond
simple role membership:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:programmatic-security'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class ProgrammaticSecurityResource {

    @Inject
    SecurityIdentity identity;

    @Inject
    IdeaService ideaService;

    @PUT
    @Path("/{id}")
    @Authenticated
    public Idea update(@PathParam("id") Long id,
                       Idea idea) {
        if (!identity.hasRole("admin")
                &amp;&amp; !isOwner(id)) {
            throw new ForbiddenException(
                "Keine Berechtigung");
        }
        return ideaService.save(idea);
    }

    private boolean isOwner(Long id) {
        String user =
            identity.getPrincipal().getName();
        return user != null;
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Programmatic security checks with
<span class='latex-texttt'>SecurityIdentity</span> are the direct equivalent
of the <span class='latex-texttt'>AccessDecisionVoter</span> logic from DeltaSpike.
The advantage: no separate voter is needed &mdash; the logic
can be implemented directly in the resource endpoint.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.6'><span class='entry-number'>13.6</span> Angular Auth Guards in Depth</a> </h2>
In Chapter 11, the basic integration of Angular route guards was introduced.
For a production-ready OIDC integration, the
<span class='latex-texttt'>angular-auth-oidc-client</span> library replaces the manual token handling
via <span class='latex-texttt'>localStorage</span> that was shown as a simple solution in Chapter 11.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
The OIDC configuration is done centrally in the Angular application:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:angular-oidc-config'></a>                     <pre><code>// app.config.ts
export const authConfig = {
  config: {
    authority:
      'http://localhost:8180/realms/ideafork',
    redirectUrl: window.location.origin,
    postLogoutRedirectUri: window.location.origin,
    clientId: 'ideafork-frontend',
    scope: 'openid profile email',
    responseType: 'code',
  }
};</code></pre>
                </div>
The auth guard checks on each route change whether the user is authenticated
and redirects to the Keycloak login page if not:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:angular-auth-guard'></a>                     <pre><code>// auth.guard.ts
@Injectable({ providedIn: 'root' })
export class AuthGuard {
  private oidc = inject(OidcSecurityService);

  canActivate(): Observable&lt;boolean&gt; {
    return this.oidc.isAuthenticated$.pipe(
      map(({ isAuthenticated }) =&gt; {
        if (!isAuthenticated) {
          this.oidc.authorize();
          return false;
        }
        return true;
      })
    );
  }
}</code></pre>
                </div>
To automatically include the bearer token with every HTTP request,
an HTTP interceptor is registered:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:angular-auth-interceptor'></a>                     <pre><code>// auth.interceptor.ts
export const authInterceptor: HttpInterceptorFn =
  (req, next) =&gt; {
    const oidc = inject(OidcSecurityService);
    return oidc.getAccessToken().pipe(
      switchMap(token =&gt; {
        if (token) {
          req = req.clone({
            setHeaders: {
              Authorization: `Bearer ${token}`
            }
          });
        }
        return next(req);
      })
    );
  };</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The <span class='latex-texttt'>angular-auth-oidc-client</span> library
stores tokens securely in session storage (not localStorage)
and supports automatic token renewal (silent renew).
This completely replaces the manual token management from Chapter 11.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.7'><span class='entry-number'>13.7</span> CSRF, CORS, and CSP</a> </h2>
Beyond authentication and authorization, a production-ready application
requires additional HTTP security mechanisms. The three most important are
CORS (Cross-Origin Resource Sharing), CSRF (Cross-Site Request Forgery),
and CSP (Content Security Policy).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
CORS controls which domains are allowed to access the REST API.
Since the Angular frontend and the Quarkus backend typically run on different
ports, CORS must be explicitly configured:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:cors-config'></a>                     <pre><code># CORS Konfiguration
quarkus.http.cors=true
quarkus.http.cors.origins=http://localhost:4200
quarkus.http.cors.methods=\
    GET,POST,PUT,DELETE,OPTIONS
quarkus.http.cors.headers=\
    Authorization,Content-Type
quarkus.http.cors.exposed-headers=Location
quarkus.http.cors.access-control-max-age=24H</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b>Avoid
<span class='latex-texttt'>quarkus.http.cors.origins=*</span> in production environments.
A wildcard allows every origin to access the API &mdash;
this opens the door for cross-site attacks. Instead, explicitly
list the allowed domains.</div>
CSRF protection prevents malicious websites from performing actions
on behalf of the logged-in user. Quarkus provides the
<span class='latex-texttt'>quarkus-rest-csrf</span> extension for this:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:csrf-config'></a>                     <pre><code># CSRF-Schutz Konfiguration
quarkus.rest-csrf.cookie-name=csrf-token
quarkus.rest-csrf.form-field-name=csrf-token
quarkus.rest-csrf.token-header-name=\
    X-CSRF-TOKEN</code></pre>
                </div>
Content Security Policy (CSP) controls which resources the browser is allowed to load.
A JAX-RS filter can set these headers for every response:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:csp-response-filter'></a>                     <pre><code>@Provider
public class SecurityHeadersFilter
        implements ContainerResponseFilter {

    @Override
    public void filter(
            ContainerRequestContext request,
            ContainerResponseContext response) {
        response.getHeaders().add(
            "Content-Security-Policy",
            "default-src 'self'; script-src 'self'");
        response.getHeaders().add(
            "X-Content-Type-Options", "nosniff");
        response.getHeaders().add(
            "X-Frame-Options", "DENY");
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>CORS, CSRF, and CSP complement each other:
CORS protects the API from unauthorized cross-origin calls,
CSRF prevents forged requests on behalf of the user,
and CSP controls which resources the browser may load.
For complete protection, all three mechanisms should be
enabled together.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.8'><span class='entry-number'>13.8</span> Securing IdeaFork — Checklist</a> </h2>
Security tests are an essential part of the migration strategy.
Quarkus provides <span class='latex-texttt'>@TestSecurity</span> as an elegant way to test
security aspects in isolation &mdash; without requiring a running identity provider:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:security-test-roles'></a>                     <pre><code>@QuarkusTest
class IdeaResourceSecurityTest {

    @Test
    @TestSecurity(user = "testuser", roles = "user")
    void testGetIdeasAsUser() {
        given()
            .when().get("/api/ideas")
            .then()
            .statusCode(200);
    }

    @Test
    @TestSecurity(user = "admin", roles = "admin")
    void testDeleteAsAdmin() {
        given()
            .when().delete("/api/ideas/1")
            .then()
            .statusCode(204);
    }

    @Test
    void testUnauthorizedAccess() {
        given()
            .when().get("/api/ideas")
            .then()
            .statusCode(401);
    }
}</code></pre>
                </div>
<div class="tip"><b>Tip: </b><span class='latex-texttt'>@TestSecurity</span> simulates an
authenticated user directly in the test &mdash; without token generation or
Keycloak connectivity. For integration tests that need to test the full
OIDC flow with Keycloak, the Keycloak Dev Service can be used
in combination with <span class='latex-texttt'>@QuarkusTest</span>.</div>
The following overview summarizes the security stack migration:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:security-stack-overview'></a>                     <pre><code>Sicherheits-Stack-Uebersicht
======================================

Schicht          Alt                    Neu
----------------------------------------------
Backend-Auth     DeltaSpike @Secured    @RolesAllowed
Token            manuell (Kap. 8)      MicroProfile JWT
Identity         IdentityHolder         SecurityIdentity
IdP              ---                    Keycloak + OIDC
Frontend-Auth    localStorage           angular-auth-oidc
HTTP-Security    ---                    CORS / CSRF / CSP
Test             ---                    @TestSecurity</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The security migration can be done incrementally:
First introduce <span class='latex-texttt'>@RolesAllowed</span> on the REST endpoints (works even
without OIDC with <span class='latex-texttt'>@TestSecurity</span> in tests), then connect Keycloak as
the identity provider, and finally switch the Angular frontend to
the OIDC client.</div>
The concrete migration checklist for <span class='latex-textit'>IdeaFork</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:security-migration-checklist'></a>                     <pre><code>IdeaFork Security-Haertung -- Checkliste
=========================================
[ ] DeltaSpike @Secured  --&gt;  @RolesAllowed
[ ] IdentityHolder  --&gt;  SecurityIdentity
[ ] Manueller JWT (Kap. 8) --&gt; MicroProfile JWT
[ ] Keycloak als Identity Provider
[ ] OIDC-Integration (Backend + Frontend)
[ ] Angular: localStorage  --&gt;  OIDC-Client
[ ] CORS auf Produktions-Domains einschraenken
[ ] CSP-Headers aktivieren
[ ] @TestSecurity fuer Security-Tests
[ ] Keycloak Dev Service fuer Integration</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.9'><span class='entry-number'>13.9</span> Sources</a> </h2>
- quarkus.io/guides/security-overview<br />
- quarkus.io/guides/security-oidc-bearer-token-authentication<br />
- quarkus.io/guides/security-keycloak-admin-client<br />
- download.eclipse.org/microprofile/microprofile-jwt-auth-2.1<br />
- keycloak.org/documentation<br />
- github.com/damienbod/angular-auth-oidc-client<br />
- developer.mozilla.org/en-US/docs/Web/HTTP/CORS<br />
- developer.mozilla.org/en-US/docs/Web/HTTP/CSP<br />
- owasp.org/www-community/attacks/csrf<br />
</section>

<section class="chapter-section" id="chapter-14">
<h1> <a class='latex-index-anchor' name='!idx:/cloud.html:14'><span class='entry-number'>14</span> From JAR to Cloud</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Disclaimer:</strong> This chapter was written by Claude (Anthropic) based on the preceding chapters. It describes the path from local IdeaFork development to a production-ready, containerized cloud environment &mdash; from packaging through observability to Kubernetes deployment.
</div>
<a name = '!idx:/cloud.html:chap:from-jar-to-cloud'> </a><h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.1'><span class='entry-number'>14.1</span> Quarkus Packaging Options</a> </h2>
 The migration path for <span class='latex-textit'>IdeaFork</span> completed the switch to Quarkus in Chapter 10,
modernized the frontend in Chapter 11, and established testing and security in Chapters 12-13.
The final step: the path from a locally running JAR to a production-ready cloud environment.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Quarkus offers three packaging modes, each serving different requirements:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:packaging-overview'></a>                     <pre><code>Quarkus Packaging-Optionen
======================================

Modus           Artefakt              Einsatz
----------------------------------------------
Fast JAR        quarkus-app/          Standard, schneller
                                      Classpath-Start
Uber-JAR        *-runner.jar          Einzelne JAR-Datei,
                                      einfaches Deployment
Native Image    *-runner               GraalVM-Binary,
                                      minimaler Speicher,
                                      schnellster Start</code></pre>
                </div>
The configuration is done via a single property in
<span class='latex-texttt'>application.properties</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:packaging-config'></a>                     <pre><code># Packaging-Modus waehlen
# Optionen: fast-jar (Standard), uber-jar, native
quarkus.package.type=fast-jar

# Uber-JAR aktivieren:
# quarkus.package.type=uber-jar

# Native Image aktivieren:
# quarkus.package.type=native</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The <span class='latex-texttt'>fast-jar</span> mode is the recommended default
for containerization. It offers faster classpath scanning than uber-jar
and produces a structured directory that is ideal for
Docker layer caching.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.2'><span class='entry-number'>14.2</span> Docker Multi-Stage Builds</a> </h2>
A multi-stage Dockerfile separates the build process from the runtime environment.
The first stage compiles the application with Maven, the second creates
a lean runtime image:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:dockerfile-jvm'></a>                     <pre><code># Stage 1: Build
FROM maven:3.9-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -B package -DskipTests

# Stage 2: Runtime
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build \
    /app/target/quarkus-app /app
EXPOSE 8080
CMD ["java", "-jar", "quarkus-run.jar"]</code></pre>
                </div>
For native images, the build stage changes to a GraalVM-based image,
and the runtime environment is reduced to a minimal operating system:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:dockerfile-native'></a>                     <pre><code># Stage 1: Native Build
FROM quay.io/quarkus/ubi-quarkus-graalvmce-builder-image:jdk-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -B package -Dnative -DskipTests

# Stage 2: Native Runtime
FROM quay.io/quarkus/quarkus-micro-image:2.0
WORKDIR /app
COPY --from=build \
    /app/target/*-runner /app/application
EXPOSE 8080
CMD ["./application"]</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Multi-stage builds keep the final image lean:
The JVM image is based on Alpine (~200 MB), the native image on
<span class='latex-texttt'>quarkus-micro-image</span> (~30 MB). Build tools like Maven
and GraalVM are only included in the build stage and not in
the final production image.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.3'><span class='entry-number'>14.3</span> Quarkus + Angular in a Single Image</a> </h2>
With the Quarkus extension <span class='latex-texttt'>quarkus-quinoa</span> (Chapter 11), backend
and frontend can be combined into a single artifact.
Quinoa builds the Angular frontend automatically during the Quarkus build
and integrates the static files into the Quarkus artifact:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:quinoa-config'></a>                     <pre><code># Quinoa-Konfiguration
quarkus.quinoa.enable=true
quarkus.quinoa.build-dir=dist/ideafork-frontend
quarkus.quinoa.package-manager-install=true
quarkus.quinoa.package-manager-install\
    .node-version=20.11.0</code></pre>
                </div>
The Dockerfile for the full-stack application uses a single build stage,
since Quinoa combines both frontend and backend in one Maven build:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:dockerfile-fullstack'></a>                     <pre><code># Full-Stack Build (Quarkus + Angular)
FROM maven:3.9-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -B package -DskipTests \
    -Dquarkus.quinoa.enable=true

# Runtime
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build \
    /app/target/quarkus-app /app
EXPOSE 8080
CMD ["java", "-jar", "quarkus-run.jar"]</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Quinoa handles the entire frontend build pipeline &mdash;
<span class='latex-texttt'>npm install</span>, <span class='latex-texttt'>ng build</span>, and the
integration of static files into the Quarkus artifact.
The result is a single Docker image that serves both the REST API
and the Angular frontend.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b>Quinoa expects the Angular project
in a specific subdirectory (by default <span class='latex-texttt'>src/main/webui</span>).
Make sure the directory structure is correctly configured
before starting the build. The property
<span class='latex-texttt'>quarkus.quinoa.ui-dir</span> allows customization
of the directory path.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.4'><span class='entry-number'>14.4</span> MicroProfile Health Checks</a> </h2>
Kubernetes requires health checks to monitor the state of the application.
MicroProfile Health defines two types of checks:
<span class='latex-texttt'>@Liveness</span> (is the application fundamentally alive?)
and <span class='latex-texttt'>@Readiness</span> (is the application ready to process requests?).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
A simple liveness check confirms that the application is running:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:health-check-custom'></a>                     <pre><code>@Liveness
@ApplicationScoped
public class IdeaForkLivenessCheck
        implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse
            .named("ideafork-alive")
            .up()
            .build();
    }
}</code></pre>
                </div>
A readiness check verifies external dependencies like the database connection:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:health-check-database'></a>                     <pre><code>@Readiness
@ApplicationScoped
public class DatabaseReadinessCheck
        implements HealthCheck {

    @Inject
    IdeaRepository ideaRepository;

    @Override
    public HealthCheckResponse call() {
        try {
            ideaRepository.findAll();
            return HealthCheckResponse
                .named("database")
                .up()
                .build();
        } catch (Exception e) {
            return HealthCheckResponse
                .named("database")
                .down()
                .build();
        }
    }
}</code></pre>
                </div>
The health endpoints are automatically available at
<span class='latex-texttt'>/q/health/live</span> and
<span class='latex-texttt'>/q/health/ready</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:health-config'></a>                     <pre><code># Health Check Konfiguration
quarkus.smallrye-health.root-path=/q/health
# Automatische Health-Endpunkte:
# /q/health/live   -- Liveness
# /q/health/ready  -- Readiness
# /q/health        -- Alle Checks</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Quarkus automatically provides basic health checks
(e.g., for datasource connections). Custom checks supplement
these default probes. In Kubernetes, the endpoints are referenced directly
as <span class='latex-texttt'>livenessProbe</span> and
<span class='latex-texttt'>readinessProbe</span> in the pod manifest.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.5'><span class='entry-number'>14.5</span> MicroProfile Metrics / Micrometer</a> </h2>
Quarkus uses Micrometer as the standard metrics framework.
Through annotations like <span class='latex-texttt'>@Timed</span> and
<span class='latex-texttt'>@Counted</span>, endpoints can be instrumented
without modifying business code:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:micrometer-timed'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class MeteredIdeaResource {

    @Inject
    IdeaService ideaService;

    @GET
    @Timed(value = "ideas.list",
           description = "Time to list ideas")
    @Counted(value = "ideas.list.count",
             description = "List request count")
    public List&lt;Idea&gt; getAll() {
        return ideaService.findAll();
    }
}</code></pre>
                </div>
The metrics are provided in Prometheus format at
<span class='latex-texttt'>/q/metrics</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:metrics-config'></a>                     <pre><code># Micrometer Konfiguration
quarkus.micrometer.enabled=true
quarkus.micrometer.export.prometheus.enabled=true
# Endpunkt: /q/metrics</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Micrometer is the standard metrics framework in Quarkus
and replaces the older MicroProfile Metrics API.
It supports various monitoring systems
(Prometheus, Grafana, Datadog) through interchangeable registries &mdash;
the application code remains unchanged.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.6'><span class='entry-number'>14.6</span> Distributed Tracing (OpenTelemetry)</a> </h2>
OpenTelemetry enables tracing a request across all layers of the application &mdash;
from the Angular frontend through the Quarkus REST endpoint to the database query.
Quarkus instruments JAX-RS endpoints automatically; for finer control,
custom spans can be created:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:otel-custom-span'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class TracedIdeaResource {

    @Inject
    Tracer tracer;

    @Inject
    IdeaService ideaService;

    @GET
    @Path("/{id}")
    public Idea getById(@PathParam("id") Long id) {
        Span span = tracer.spanBuilder("findIdea")
            .startSpan();
        try {
            span.setAttribute("idea.id",
                String.valueOf(id));
            return ideaService.findAll().stream()
                .findFirst()
                .orElse(null);
        } finally {
            span.end();
        }
    }
}</code></pre>
                </div>
The OpenTelemetry configuration connects the application with a
tracing backend like Jaeger:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:otel-config'></a>                     <pre><code># OpenTelemetry Konfiguration
quarkus.otel.enabled=true
quarkus.otel.exporter.otlp.endpoint=\
    http://localhost:4317
quarkus.otel.service.name=ideafork
quarkus.otel.resource.attributes=\
    deployment.environment=production</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Quarkus instruments JAX-RS endpoints, REST clients,
and JDBC calls automatically &mdash; without code changes.
Custom spans are only needed for business-logic-specific measurement points.
The traces can be visualized in Jaeger and make
the service communication of <span class='latex-textit'>IdeaFork</span> visible.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.7'><span class='entry-number'>14.7</span> Structured Logging</a> </h2>
In a containerized environment, logs are typically collected by
a log aggregator (ELK Stack, Loki).
Structured JSON logs enable efficient filtering and searching:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:structured-log-resource'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class LoggedIdeaResource {

    private static final Logger LOG =
        Logger.getLogger(LoggedIdeaResource.class);

    @Inject
    IdeaService ideaService;

    @GET
    public List&lt;Idea&gt; getAll() {
        LOG.info("Listing all ideas");
        List&lt;Idea&gt; ideas = ideaService.findAll();
        LOG.infof("Found %d ideas", ideas.size());
        return ideas;
    }
}</code></pre>
                </div>
Switching to JSON format requires only a single property:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:logging-config'></a>                     <pre><code># Structured JSON Logging
quarkus.log.console.json=true
quarkus.log.console.json.pretty-print=false
# Ergebnis:
# {"timestamp":"...","level":"INFO",
#  "message":"Found 42 ideas",
#  "loggerName":"...LoggedIdeaResource",
#  "traceId":"abc123..."}</code></pre>
                </div>
<div class="tip"><b>Tip: </b>JSON logs automatically include the OpenTelemetry trace ID
when <span class='latex-texttt'>quarkus-opentelemetry</span> is active.
This allows log entries to be directly correlated with their corresponding traces
&mdash; a significant advantage for debugging
in distributed systems.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.8'><span class='entry-number'>14.8</span> Kubernetes Deployment</a> </h2>
The Quarkus extension <span class='latex-texttt'>quarkus-kubernetes</span> automatically generates
Kubernetes manifests from the application properties.
Configuration is done via standard properties:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:k8s-config'></a>                     <pre><code># Kubernetes Extension Konfiguration
quarkus.kubernetes.deploy=false
quarkus.kubernetes.name=ideafork
quarkus.kubernetes.namespace=ideafork-prod
quarkus.kubernetes.replicas=2
quarkus.kubernetes.image-pull-policy=always
quarkus.kubernetes.service-type=cluster-ip
quarkus.kubernetes.env.configmaps=ideafork-config
quarkus.kubernetes.ports.http.host-port=8080</code></pre>
                </div>
The resulting deployment manifest automatically includes the health check probes
and environment configuration:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:k8s-deployment'></a>                     <pre><code># Generiertes Kubernetes Deployment (Auszug)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ideafork
  namespace: ideafork-prod
spec:
  replicas: 2
  template:
    spec:
      containers:
      - name: ideafork
        image: ideafork:latest
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /q/health/live
            port: 8080
        readinessProbe:
          httpGet:
            path: /q/health/ready
            port: 8080
        envFrom:
        - configMapRef:
            name: ideafork-config</code></pre>
                </div>
Environment-specific configuration is separated from the application code
via Kubernetes ConfigMaps:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:k8s-configmap'></a>                     <pre><code># ConfigMap fuer IdeaFork
apiVersion: v1
kind: ConfigMap
metadata:
  name: ideafork-config
  namespace: ideafork-prod
data:
  QUARKUS_DATASOURCE_JDBC_URL: \
    jdbc:postgresql://db:5432/ideafork
  QUARKUS_OIDC_AUTH_SERVER_URL: \
    https://keycloak.example.com/realms/ideafork
  IDEAFORK_GREETING: "Willkommen"
  IDEAFORK_MAX_RESULTS: "500"</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Quarkus automatically generates Kubernetes manifests
under <span class='latex-texttt'>target/kubernetes/</span>. The health check probes
from Section 14.4 are directly integrated into the deployment.
Environment-specific values (database URL, OIDC configuration)
are injected via ConfigMaps &mdash; the application code reads
them automatically through MicroProfile Config.</div>
To make the ConfigMap values available in the application,
the standard <span class='latex-texttt'>@ConfigProperty</span> annotation is sufficient:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:config-resource'></a>                     <pre><code>@Path("/api/config")
@ApplicationScoped
public class ConfigResource {

    @ConfigProperty(name = "ideafork.greeting",
                    defaultValue = "Hello")
    String greeting;

    @ConfigProperty(name = "ideafork.max-results",
                    defaultValue = "100")
    int maxResults;

    @GET
    public String getConfig() {
        return greeting
            + " (max: " + maxResults + ")";
    }
}</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.9'><span class='entry-number'>14.9</span> Native Image in Production</a> </h2>
Chapter 10 covered the fundamentals of native image compilation.
In the production environment, the concrete benefits become apparent &mdash;
particularly in terms of startup time and memory consumption:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:native-build-config'></a>                     <pre><code># Native Image Build-Konfiguration
quarkus.package.type=native
quarkus.native.container-build=true
quarkus.native.builder-image=\
    quay.io/quarkus/ubi-quarkus-graalvmce-builder-image:jdk-21
quarkus.native.additional-build-args=\
    -H:+ReportExceptionStackTraces</code></pre>
                </div>
The comparison between JVM and native mode shows significant differences:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:native-benchmark'></a>                     <pre><code>IdeaFork Benchmark: JVM vs. Native
======================================

Metrik              JVM-Modus     Native
----------------------------------------------
Startzeit           ~2.5 s        ~0.05 s
Speicher (RSS)      ~250 MB       ~50 MB
Docker-Image        ~350 MB       ~80 MB
Build-Zeit          ~30 s         ~5 min
Durchsatz (Req/s)   ~12.000       ~10.000
Erster Request      ~50 ms        ~5 ms</code></pre>
                </div>
<div class="tip"><b>Tip: </b>Native images are ideal for serverless scenarios (AWS Lambda,
Azure Functions) and Kubernetes environments with frequent scaling,
where fast startup times are critical. For long-lived services
with high throughput, JVM mode can offer slight advantages
in steady-state throughput through JIT optimization.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warning: </b>Not all libraries are
fully compatible with native image. Reflection, dynamic proxies,
and certain serialization frameworks require explicit
GraalVM configuration. Quarkus extensions are generally
native-compatible; for third-party libraries, compatibility
should be tested before production deployment.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.10'><span class='entry-number'>14.10</span> IdeaFork Production Checklist</a> </h2>
The following overview summarizes the entire production stack
built in this chapter:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:production-stack-overview'></a>                     <pre><code>IdeaFork Produktions-Stack
======================================

Schicht          Technologie
----------------------------------------------
Packaging        Quarkus Fast JAR / Native
Container        Docker Multi-Stage Build
Frontend         Angular via Quinoa
Health           MicroProfile Health
Metriken         Micrometer + Prometheus
Tracing          OpenTelemetry + Jaeger
Logging          JSON Structured Logging
Deployment       Kubernetes + ConfigMaps
Sicherheit       OIDC + CORS + CSP (Kap. 13)</code></pre>
                </div>
<div class="tip"><b>Tip: </b>The path to production can be taken step by step:
First containerize the application (Dockerfile),
then add health checks and metrics (observability),
and finally deploy to Kubernetes.
Each step provides standalone value.</div>
The complete migration checklist for <span class='latex-textit'>IdeaFork</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:production-checklist'></a>                     <pre><code>IdeaFork Produktions-Checkliste
=========================================
[ ] Docker Multi-Stage Build konfiguriert
[ ] Quinoa fuer Angular-Integration aktiviert
[ ] Liveness- und Readiness-Checks implementiert
[ ] Micrometer-Metriken aktiviert
[ ] OpenTelemetry-Tracing konfiguriert
[ ] JSON Structured Logging aktiviert
[ ] Kubernetes-Manifeste generiert
[ ] ConfigMaps fuer Umgebungskonfiguration
[ ] TLS/HTTPS aktiviert
[ ] CORS auf Produktions-Domains (Kap. 13)
[ ] Rate-Limiting konfiguriert
[ ] Graceful Shutdown aktiviert
[ ] Native Image getestet (optional)
[ ] Monitoring-Dashboard eingerichtet</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.11'><span class='entry-number'>14.11</span> Sources</a> </h2>
- quarkus.io/guides/building-native-image<br />
- quarkus.io/guides/container-image<br />
- quarkus.io/guides/quinoa<br />
- quarkus.io/guides/smallrye-health<br />
- quarkus.io/guides/micrometer<br />
- quarkus.io/guides/opentelemetry<br />
- quarkus.io/guides/logging<br />
- quarkus.io/guides/deploying-to-kubernetes<br />
- graalvm.org/latest/reference-manual/native-image<br />
- kubernetes.io/docs/concepts/configuration/configmap<br />
</section>

    </div>
  </main>

  <script>
    (function() {
      'use strict';

      // --- Scroll Spy ---
      var tocLinks = document.querySelectorAll('#toc a');
      var headingElements = [];

      tocLinks.forEach(function(link) {
        var id = decodeURIComponent(link.getAttribute('href').slice(1));
        // Anchors use name attributes, not id
        var target = document.querySelector('a[name="' + CSS.escape(id) + '"]');
        if (target) {
          headingElements.push({ el: target, link: link });
        }
      });

      var activeLink = null;

      function updateScrollSpy() {
        var scrollTop = window.scrollY + 120;
        var current = null;

        for (var i = 0; i < headingElements.length; i++) {
          if (headingElements[i].el.offsetTop <= scrollTop) {
            current = headingElements[i];
          }
        }

        if (current && current.link !== activeLink) {
          if (activeLink) {
            activeLink.classList.remove('active');
          }
          current.link.classList.add('active');
          activeLink = current.link;

          // Expand parent chapter in TOC
          document.querySelectorAll('.toc-chapter').forEach(function(ch) {
            ch.classList.remove('expanded');
          });
          var parentChapter = current.link.closest('.toc-chapter');
          if (parentChapter) {
            parentChapter.classList.add('expanded');
            // Scroll TOC to keep active link visible
            var toc = document.getElementById('toc');
            var linkRect = current.link.getBoundingClientRect();
            var tocRect = toc.getBoundingClientRect();
            if (linkRect.top < tocRect.top || linkRect.bottom > tocRect.bottom) {
              current.link.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
          }
        }
      }

      var scrollTimer;
      window.addEventListener('scroll', function() {
        if (scrollTimer) cancelAnimationFrame(scrollTimer);
        scrollTimer = requestAnimationFrame(updateScrollSpy);
      });
      updateScrollSpy();

      // --- Smooth scroll on TOC click ---
      tocLinks.forEach(function(link) {
        link.addEventListener('click', function(e) {
          var id = decodeURIComponent(this.getAttribute('href').slice(1));
          var target = document.querySelector('a[name="' + CSS.escape(id) + '"]');
          if (target) {
            e.preventDefault();
            var top = target.offsetTop - 30;
            window.scrollTo({ top: top, behavior: 'smooth' });
            // Close mobile sidebar
            document.querySelector('.sidebar').classList.remove('open');
            document.querySelector('.overlay').classList.remove('active');
          }
        });
      });

      // --- Chapter heading click to expand/collapse in TOC ---
      document.querySelectorAll('.toc-chapter > a.toc-h1').forEach(function(link) {
        link.addEventListener('click', function() {
          var parent = this.parentElement;
          // Toggle only if already expanded (navigation still happens via smooth scroll)
          document.querySelectorAll('.toc-chapter').forEach(function(ch) {
            if (ch !== parent) ch.classList.remove('expanded');
          });
          parent.classList.add('expanded');
        });
      });

      // --- Mobile toggle ---
      var hamburger = document.querySelector('.hamburger');
      var sidebar = document.querySelector('.sidebar');
      var overlay = document.querySelector('.overlay');

      if (hamburger) {
        hamburger.addEventListener('click', function() {
          sidebar.classList.toggle('open');
          overlay.classList.toggle('active');
        });
      }

      if (overlay) {
        overlay.addEventListener('click', function() {
          sidebar.classList.remove('open');
          overlay.classList.remove('active');
        });
      }
    })();

  </script>
</body>
