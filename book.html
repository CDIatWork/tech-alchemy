<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>[CDI@Work]:AI &ndash; CDI und Apache DeltaSpike</title>
  <meta name="description" content="[CDI@Work]:AI, Author: Gerhard Petracek">
  <meta name="author" content="Gerhard Petracek">
  <style>
    /* ===== Reset & Base ===== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    html {
      scroll-behavior: smooth;
      font-size: 17px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.7;
      color: #2c3e50;
      background: #f8f9fa;
    }

    /* ===== Sidebar ===== */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 300px;
      height: 100vh;
      background: #1a1f36;
      color: #c8ccd4;
      overflow-y: auto;
      z-index: 100;
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .sidebar-brand {
      padding: 1.5rem 1.25rem 1rem;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      flex-shrink: 0;
    }

    .sidebar-brand h1 {
      font-size: 1.25rem;
      font-weight: 700;
      color: #fff;
      letter-spacing: -0.02em;
    }

    .sidebar-brand .subtitle {
      font-size: 0.75rem;
      color: #8892a4;
      margin-top: 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .sidebar-brand .lang-switch {
      display: inline-block;
      font-size: 0.7rem;
      color: #8892a4;
      text-decoration: none;
      margin-top: 0.5rem;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 0.2rem 0.6rem;
      border-radius: 4px;
      transition: color 0.2s, border-color 0.2s;
    }

    .sidebar-brand .lang-switch:hover {
      color: #fff;
      border-color: rgba(255,255,255,0.4);
    }

    #toc {
      flex: 1;
      overflow-y: auto;
      padding: 0.75rem 0;
    }

    .toc-header { display: none; }

    .toc-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .toc-chapter {
      margin-bottom: 0.15rem;
    }

    .toc-chapter > a.toc-h1 {
      display: block;
      padding: 0.5rem 1.25rem;
      font-size: 0.82rem;
      font-weight: 600;
      color: #e2e6ed;
      text-decoration: none;
      transition: background 0.15s, color 0.15s;
      border-left: 3px solid transparent;
    }

    .toc-chapter > a.toc-h1:hover {
      background: rgba(255,255,255,0.05);
      color: #fff;
    }

    .toc-chapter > a.toc-h1.active {
      background: rgba(99, 128, 255, 0.12);
      color: #8fa4ff;
      border-left-color: #6380ff;
    }

    .toc-sections {
      list-style: none;
      padding: 0;
      margin: 0;
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.35s ease;
    }

    .toc-chapter.expanded .toc-sections {
      max-height: 2000px;
    }

    .toc-section a.toc-h2,
    .toc-subsection a.toc-h3 {
      display: block;
      padding: 0.3rem 1.25rem 0.3rem 2rem;
      font-size: 0.76rem;
      color: #8892a4;
      text-decoration: none;
      transition: color 0.15s, background 0.15s;
    }

    .toc-subsection a.toc-h3 {
      padding-left: 2.75rem;
      font-size: 0.72rem;
    }

    .toc-section a.toc-h2:hover,
    .toc-subsection a.toc-h3:hover {
      color: #c8ccd4;
      background: rgba(255,255,255,0.03);
    }

    .toc-section a.toc-h2.active,
    .toc-subsection a.toc-h3.active {
      color: #8fa4ff;
    }

    /* ===== Main Content ===== */
    .main-content {
      margin-left: 300px;
      min-height: 100vh;
    }

    .content-wrapper {
      max-width: 800px;
      margin: 0 auto;
      padding: 2.5rem 2rem 4rem;
    }

    .sticky-disclaimer {
      position: sticky;
      top: 0;
      z-index: 90;
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 0 0 8px 8px;
      padding: 0.75em 1.5em;
      margin: -2.5rem -2rem 2em -2rem;
      font-size: 0.9em;
      color: #856404;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      opacity: 0.85;
    }

    /* ===== Mobile Hamburger ===== */
    .hamburger {
      display: none;
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 200;
      background: #1a1f36;
      color: #fff;
      border: none;
      border-radius: 8px;
      width: 44px;
      height: 44px;
      cursor: pointer;
      font-size: 1.4rem;
      line-height: 1;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      align-items: center;
      justify-content: center;
    }

    .overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 90;
    }

    /* ===== Typography ===== */
    h1 {
      font-size: 1.9rem;
      font-weight: 800;
      color: #1a1f36;
      margin: 3rem 0 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 3px solid #6380ff;
      letter-spacing: -0.02em;
      line-height: 1.3;
    }

    section:first-child h1:first-of-type {
      margin-top: 0;
    }

    h2 {
      font-size: 1.4rem;
      font-weight: 700;
      color: #2c3550;
      margin: 2.5rem 0 0.75rem;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #e0e4ea;
      line-height: 1.35;
    }

    h3 {
      font-size: 1.15rem;
      font-weight: 600;
      color: #3a4260;
      margin: 2rem 0 0.6rem;
    }

    h4 {
      font-size: 1rem;
      font-weight: 600;
      color: #4a5270;
      margin: 1.5rem 0 0.5rem;
    }

    p, .content-wrapper > br {
      margin-bottom: 0.5rem;
    }

    a {
      color: #4361ee;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
      color: #3a56d4;
    }

    .entry-number {
      color: #6380ff;
      font-weight: 700;
      margin-right: 0.4em;
    }

    /* ===== LaTeX Content Classes ===== */
    .latex-texttt {
      font-family: 'SFMono-Regular', 'Consolas', 'Liberation Mono', 'Menlo', monospace;
      font-size: 0.88em;
      background: #eef0f5;
      padding: 0.15em 0.4em;
      border-radius: 4px;
      color: #c7254e;
      word-break: break-word;
    }

    .latex-textit {
      font-style: italic;
    }

    .latex-textbf {
      font-weight: 700;
    }

    .latex-unknwown-link {
      font-style: italic;
      color: #888;
    }

    .latex-footnote-marker {
      font-weight: 700;
      color: #4361ee;
      border-bottom: 2px solid #4361ee;
      padding-bottom: 1px;
      margin-right: 0.3em;
    }

    .latex-index-anchor {
      text-decoration: none;
      color: inherit;
    }

    .latex-index-anchor:hover {
      text-decoration: none;
      color: inherit;
    }

    /* ===== Code Blocks ===== */
    .latex-begin-block {
      margin: 1.25rem 0;
    }

    .latex-begin-block pre {
      background: #1e1e2e;
      color: #cdd6f4;
      padding: 1.1rem 1.25rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.82rem;
      line-height: 1.6;
      border: 1px solid #313244;
    }

    .latex-begin-block pre code {
      font-family: 'SFMono-Regular', 'Consolas', 'Liberation Mono', 'Menlo', monospace;
      background: none;
      padding: 0;
      color: inherit;
    }

    /* ===== Tip Boxes ===== */
    .tip {
      background: #f0f4ff;
      border-left: 4px solid #4361ee;
      padding: 1rem 1.25rem;
      margin: 1.25rem 0;
      border-radius: 0 8px 8px 0;
      font-size: 0.93rem;
    }

    .tip b {
      color: #4361ee;
    }

    /* ===== Tables ===== */
    .latex-table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      font-size: 0.88rem;
    }

    .latex-table-header-cell {
      background: #2c3550;
      color: #fff;
      font-weight: 600;
      padding: 0.6rem 0.8rem;
      text-align: left;
      border: 1px solid #3a4568;
    }

    .latex-table-body-cell {
      padding: 0.5rem 0.8rem;
      border: 1px solid #e0e4ea;
    }

    .latex-table-body-row:nth-child(even) .latex-table-body-cell {
      background: #f4f6fa;
    }

    .latex-table-body-row:hover .latex-table-body-cell {
      background: #e8ecf4;
    }

    /* Hide empty header rows (LaTeX artifacts) */
    .latex-table-header-row:first-child:empty,
    .latex-table-header-row:last-child:empty {
      display: none;
    }
    .latex-table-header-row:not(:has(td)) {
      display: none;
    }

    /* ===== Spacing helpers ===== */
    /* Remove excessive blank spacers from LaTeX output */
    p[style*="margin:0"] {
      margin: 0.6rem 0 !important;
      line-height: normal !important;
    }

    /* ===== Chapter sections ===== */
    .chapter-section {
      padding-bottom: 2rem;
    }

    .chapter-section + .chapter-section {
      border-top: 1px solid #e0e4ea;
      padding-top: 1rem;
    }

    /* ===== Responsive ===== */
    @media (max-width: 900px) {
      .sidebar {
        transform: translateX(-100%);
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .hamburger {
        display: flex;
      }

      .overlay.active {
        display: block;
      }

      .main-content {
        margin-left: 0;
      }

      .content-wrapper {
        padding: 1.5rem 1rem 3rem;
        padding-top: 4rem;
      }

      .sticky-disclaimer {
        margin: -4rem -1rem 2em -1rem;
        border-radius: 0;
      }
    }

    @media (max-width: 600px) {
      html { font-size: 15px; }

      h1 { font-size: 1.5rem; }
      h2 { font-size: 1.2rem; }

      .latex-begin-block pre {
        font-size: 0.75rem;
        padding: 0.8rem;
      }

      .latex-table {
        font-size: 0.8rem;
      }
    }

    /* ===== Print Styles ===== */
    @media print {
      body {
        font-family: 'Georgia', 'Times New Roman', serif;
        font-size: 11pt;
        line-height: 1.5;
        color: #000;
        background: #fff;
      }

      .sidebar, .hamburger, .overlay, .sticky-disclaimer {
        display: none !important;
      }

      .main-content {
        margin-left: 0;
      }

      .content-wrapper {
        max-width: 100%;
        padding: 0;
      }

      h1 {
        font-size: 18pt;
        border-bottom: 2px solid #000;
        color: #000;
        page-break-after: avoid;
      }

      h2 {
        font-size: 14pt;
        border-bottom: 1px solid #666;
        color: #000;
        page-break-after: avoid;
      }

      h3 {
        font-size: 12pt;
        color: #000;
        page-break-after: avoid;
      }

      .chapter-section {
        page-break-before: always;
      }

      .chapter-section:first-child {
        page-break-before: avoid;
      }

      .entry-number { color: #000; }

      .latex-texttt {
        background: none;
        border: 1px solid #ccc;
        padding: 0 0.2em;
        color: #000;
      }

      .latex-begin-block pre {
        background: #f5f5f5;
        color: #000;
        border: 1px solid #ccc;
        border-radius: 0;
        font-size: 9pt;
        page-break-inside: avoid;
      }

      .tip {
        background: none;
        border: 1px solid #999;
        border-left: 4px solid #999;
        border-radius: 0;
        page-break-inside: avoid;
      }

      .tip b { color: #000; }

      .latex-table-header-cell {
        background: #eee;
        color: #000;
        border-color: #666;
      }

      .latex-table-body-cell {
        border-color: #999;
      }

      .latex-table-body-row:nth-child(even) .latex-table-body-cell {
        background: #f5f5f5;
      }

      .latex-footnote-marker {
        color: #000;
        border-bottom-color: #000;
      }

      a {
        color: #000;
        text-decoration: underline;
      }

      a[href^="#"]::after {
        content: "";
      }

      a[href^="http"]::after {
        content: " (" attr(href) ")";
        font-size: 0.85em;
        color: #555;
      }
    }
    
  </style>
</head>
<body>

  <button class="hamburger" aria-label="Menu">&#9776;</button>
  <div class="overlay"></div>

  <aside class="sidebar">
    <div class="sidebar-brand">
      <h1>[CDI@Work]:AI</h1>
      <div class="subtitle">CDI und Apache DeltaSpike</div>
      <a href="book_en.html" class="lang-switch">English Edition</a>
    </div>
    <nav id="toc" aria-label="Table of Contents">
  <div class="toc-header">
    <h2>Inhalt</h2>
  </div>
  <ul class="toc-list">
    <li class="toc-chapter">
      <a href="#!idx:/introduction.html:1" class="toc-h1">1 Einführung in CDI</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.1" class="toc-h2">1.1 Context- und Dependency-Management</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.2" class="toc-h2">1.2 Annotationen als zentraler Bestandteil</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.3" class="toc-h2">1.3 Hello CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.4" class="toc-h2">1.4 Die Applikation zu diesem Buch</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/introduction.html:1.5" class="toc-h2">1.5 Wichtige Begriffe der Spezifikation</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/cdi_basics.html:2" class="toc-h1">2 CDI Grundkonzepte</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.1" class="toc-h2">2.1 Typsichere Dependency-Injection</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.2" class="toc-h2">2.2 Normal- und Pseudo-Scopes</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.3" class="toc-h2">2.3 CDI Standard-Scopes</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.4" class="toc-h2">2.4 Qualifiers</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.5" class="toc-h2">2.5 Dynamische Verwendung von CDI-Beans</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.6" class="toc-h2">2.6 Producer-/Disposer- Methoden</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.7" class="toc-h2">2.7 Events</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.8" class="toc-h2">2.8 Beans ersetzen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.9" class="toc-h2">2.9 Interceptoren</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.10" class="toc-h2">2.10 Decoratoren</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.11" class="toc-h2">2.11 Stereotypes</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_basics.html:2.12" class="toc-h2">2.12 Explizite Typisierung</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/java_ee.html:3" class="toc-h1">3 CDI und Java EE</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.1" class="toc-h2">3.1 Die ersten Schritte in Richtung Java EE</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.2" class="toc-h2">3.2 Web-Applikationen mit CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.3" class="toc-h2">3.3 JSF mit CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.4" class="toc-h2">3.4 Servlets mit CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.5" class="toc-h2">3.5 JAX-RS mit CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.6" class="toc-h2">3.6 EJB mit CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.7" class="toc-h2">3.7 JPA mit CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.8" class="toc-h2">3.8 Bean-Validation mit CDI</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/java_ee.html:3.9" class="toc-h2">3.9 Bean-Deployment Archive mit Java EE</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/extensions.html:4" class="toc-h1">4 Portable CDI-Erweiterungen</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/extensions.html:4.1" class="toc-h2">4.1 Der Container-Lifecycle von CDI</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.1" class="toc-h3">4.1.1 BeforeBeanDiscovery</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.2" class="toc-h3">4.1.2 ProcessAnnotatedType</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.3" class="toc-h3">4.1.3 AfterTypeDiscovery</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.4" class="toc-h3">4.1.4 ProcessInjectionPoint</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.5" class="toc-h3">4.1.5 ProcessInjectionTarget</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.6" class="toc-h3">4.1.6 ProcessBeanAttributes</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.7" class="toc-h3">4.1.7 ProcessProducer</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.8" class="toc-h3">4.1.8 ProcessBean</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.9" class="toc-h3">4.1.9 ProcessObserverMethod</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.10" class="toc-h3">4.1.10 AfterBeanDiscovery</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.11" class="toc-h3">4.1.11 AfterDeploymentValidation</a>
        </li>
        <li class="toc-subsection">
          <a href="#!idx:/extensions.html:4.1.12" class="toc-h3">4.1.12 BeforeShutdown</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/extensions.html:4.2" class="toc-h2">4.2 Eigene CDI Erweiterungen entwickeln</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/deltaspike.html:5" class="toc-h1">5 Apache DeltaSpike</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.1" class="toc-h2">5.1 Alle für einen Kern</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.2" class="toc-h2">5.2 Flexible Spielregeln</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.3" class="toc-h2">5.3 Alles unter Kontrolle</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.4" class="toc-h2">5.4 Helfende Hände</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.5" class="toc-h2">5.5 Sicher ist sicher</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.6" class="toc-h2">5.6 Bestehendes verbessern</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.7" class="toc-h2">5.7 Flexibilität mit Alternativen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.8" class="toc-h2">5.8 Eigene Konzepte</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.9" class="toc-h2">5.9 Flexibilität weiter erhöhen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.10" class="toc-h2">5.10 Besser früher als Später</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/deltaspike.html:5.11" class="toc-h2">5.11 Sichere Wege</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/cdi_lite.html:6" class="toc-h1">6 CDI Lite</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.1" class="toc-h2">6.1 Weniger Alternativen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.2" class="toc-h2">6.2 Von Decoratoren zu Interceptoren</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.3" class="toc-h2">6.3 Weniger ist mehr</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.4" class="toc-h2">6.4 Konventionen einhalten</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_lite.html:6.5" class="toc-h2">6.5 Ebenen einsparen</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/integration.html:7" class="toc-h1">7 CDI oder nicht CDI</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/integration.html:7.1" class="toc-h2">7.1 CDI-Integration durch Producer</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/integration.html:7.2" class="toc-h2">7.2 Beans aus anderen Welten</a>
        </li>
    </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/cdi_micro.html:8" class="toc-h1">8 CDI Micro</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.1" class="toc-h2">8.1 EE oder nicht EE</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.2" class="toc-h2">8.2 IdeaForkMicro</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.3" class="toc-h2">8.3 Module über Module</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.4" class="toc-h2">8.4 Am Puls der Zeit</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.5" class="toc-h2">8.5 Projektaufteilung</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.6" class="toc-h2">8.6 Jeder Start ist einfach</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.7" class="toc-h2">8.7 Von Lite zu Micro</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.8" class="toc-h2">8.8 Asynchrone CDI-Events</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.9" class="toc-h2">8.9 Entfernt und doch so nahe</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.10" class="toc-h2">8.10 Diversität je Modul</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.11" class="toc-h2">8.11 Alles zu seiner Zeit</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.12" class="toc-h2">8.12 Zusammenführung</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.13" class="toc-h2">8.13 Kein Vorteil ohne Nachteil</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cdi_micro.html:8.14" class="toc-h2">8.14 Der Weg ist das Ziel</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/upgrade.html:9" class="toc-h1">9 Von Java EE zu Jakarta EE</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.1" class="toc-h2">9.1 Ein neues Kapitel</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.2" class="toc-h2">9.2 Von javax zu jakarta</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.3" class="toc-h2">9.3 CDI Lite und CDI Full</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.4" class="toc-h2">9.4 Build Compatible Extensions</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.5" class="toc-h2">9.5 Neue Spielregeln</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.6" class="toc-h2">9.6 DeltaSpike 2.0</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.7" class="toc-h2">9.7 Die CDI-Implementierungen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/upgrade.html:9.8" class="toc-h2">9.8 IdeaFork aktualisieren</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/quarkus.html:10" class="toc-h1">10 Migration zu Quarkus</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.1" class="toc-h2">10.1 Ein neues Ziel</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.2" class="toc-h2">10.2 Von CDI Full zu ArC</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.3" class="toc-h2">10.3 Scopes in Quarkus</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.4" class="toc-h2">10.4 Konfiguration mit MicroProfile Config</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.5" class="toc-h2">10.5 Erweiterungen zur Build-Zeit</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.6" class="toc-h2">10.6 DeltaSpike-Module ersetzen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.7" class="toc-h2">10.7 Interceptoren und Decoratoren</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.8" class="toc-h2">10.8 Native Images mit GraalVM</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.9" class="toc-h2">10.9 IdeaFork auf Quarkus migrieren</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/quarkus.html:10.10" class="toc-h2">10.10 Quellen</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/angular.html:11" class="toc-h1">11 Von JSF zu Angular</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.1" class="toc-h2">11.1 Ein neues Frontend</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.2" class="toc-h2">11.2 Von JSF-Seiten zu Angular-Komponenten</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.3" class="toc-h2">11.3 Navigation: ViewConfig zu Angular Router</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.4" class="toc-h2">11.4 Scopes und Lebenszyklus</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.5" class="toc-h2">11.5 Formulare und Validierung</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.6" class="toc-h2">11.6 Sicherheit im Frontend</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.7" class="toc-h2">11.7 REST-Kommunikation</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.8" class="toc-h2">11.8 Der Promotion-Wizard</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.9" class="toc-h2">11.9 IdeaFork-Frontend migrieren</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/angular.html:11.10" class="toc-h2">11.10 Quellen</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/testing.html:12" class="toc-h1">12 Testing Across the Stack</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.1" class="toc-h2">12.1 Ein neues Testfundament</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.2" class="toc-h2">12.2 CDI-Beans testen (Weld-JUnit5)</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.3" class="toc-h2">12.3 DeltaSpike Test-Control im Rückblick</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.4" class="toc-h2">12.4 Arquillian: Integrationstests</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.5" class="toc-h2">12.5 @QuarkusTest und Dev Services</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.6" class="toc-h2">12.6 REST-Endpunkte testen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.7" class="toc-h2">12.7 Angular Unit-Tests (TestBed)</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.8" class="toc-h2">12.8 E2E-Tests mit Playwright</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.9" class="toc-h2">12.9 IdeaFork Test-Migrations-Checkliste</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/testing.html:12.10" class="toc-h2">12.10 Quellen</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/security.html:13" class="toc-h1">13 Sicherheit über alle Schichten</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/security.html:13.1" class="toc-h2">13.1 DeltaSpike Security — Ein Rückblick</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.2" class="toc-h2">13.2 Quarkus Security — Architektur</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.3" class="toc-h2">13.3 MicroProfile JWT im Detail</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.4" class="toc-h2">13.4 OIDC / OAuth2 mit Keycloak</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.5" class="toc-h2">13.5 @RolesAllowed und Berechtigungen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.6" class="toc-h2">13.6 Angular Auth Guards im Detail</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.7" class="toc-h2">13.7 CSRF, CORS und CSP</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.8" class="toc-h2">13.8 IdeaFork absichern — Checkliste</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/security.html:13.9" class="toc-h2">13.9 Quellen</a>
        </li>
      </ul>
    </li>
    <li class="toc-chapter">
      <a href="#!idx:/cloud.html:14" class="toc-h1">14 Vom JAR in die Cloud</a>
      <ul class="toc-sections">
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.1" class="toc-h2">14.1 Quarkus Packaging-Optionen</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.2" class="toc-h2">14.2 Docker Multi-Stage Builds</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.3" class="toc-h2">14.3 Quarkus + Angular in einem Image</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.4" class="toc-h2">14.4 MicroProfile Health Checks</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.5" class="toc-h2">14.5 MicroProfile Metrics / Micrometer</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.6" class="toc-h2">14.6 Distributed Tracing (OpenTelemetry)</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.7" class="toc-h2">14.7 Structured Logging</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.8" class="toc-h2">14.8 Kubernetes Deployment</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.9" class="toc-h2">14.9 Native Image in der Produktion</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.10" class="toc-h2">14.10 IdeaFork Produktions-Checkliste</a>
        </li>
        <li class="toc-section">
          <a href="#!idx:/cloud.html:14.11" class="toc-h2">14.11 Quellen</a>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>

  <main class="main-content">
    <div class="content-wrapper">
      <div class="sticky-disclaimer">
        <strong>Hinweis:</strong> Diese Website wurde automatisch von Claude (AI built by Anthropic) auf Basis des ursprünglichen Online-Buches generiert. Der Originalinhalt stammt vom Autor Gerhard Petracek. Einige Kapitel wurden vollständig von der KI verfasst — ohne Review durch den Originalautor. Details hierzu finden Sie im jeweiligen Kapitel-Hinweis.
      </div>
      <section class="chapter-section" id="chapter-1">
<h1> <a class='latex-index-anchor' name='!idx:/introduction.html:1' ><span class='entry-number'>1</span> Einführung in CDI</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
        <strong>Hinweis:</strong> Der Text dieses Kapitels wurde von Claude (AI built by Anthropic) als Co-Autor überarbeitet. Die Überarbeitung erfolgte ohne Post-Review des Originalautors. Die Nutzung der Inhalte erfolgt auf eigene Verantwortung.
      </div>
<a name = '!idx:/introduction.html:chap:cdi-introduction'> </a><span id='_footnote_marker_1' class='latex-footnote-marker'>IoC:</span>
                 Am 10. Dezember 2009 wurde "Contexts and Dependency Injection for the Java EE platform" –
kurz CDI – in der finalen Version veröffentlicht.
Diese neue Spezifikation sollte das Java-EE-Ökosystem schon bald nachhaltig verändern.
Inspiriert von erfolgreichen Open-Source-Frameworks wie Spring, Seam und Guice und
der damit verbundenen langjährigen Erfahrung wurde ein neues typsicheres Komponentenmodell spezifiziert,
das die tägliche Arbeit erheblich erleichtert. Doch auch komplexere Anforderungen kommen dank der
Flexibilität von CDI nicht zu kurz. Genau diese Flexibilität ermöglichte portable CDI-Erweiterungen,
die entscheidend zum Erfolg von CDI beigetragen haben.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.0.0.1' ><span class='entry-number'>1.0.0.1</span> Ziel dieses Buchs</a></h4>
 In diesem Buch lernen Sie Schritt für Schritt die Grundkonzepte von CDI und
wie Sie sowohl Java-SE- als auch Java-EE-Projekte erfolgreich mit diesem Komponentenmodell umsetzen können.
Wie bei jeder Technologie gibt es auch bei CDI den einen oder anderen Fallstrick.
Mit gezielten Tipps und Tricks lernen Sie, diese zu erkennen, und erfahren Details zu den Lösungsmöglichkeiten.
Neben der Integration mit anderen Technologien widmen wir uns auch bewährten CDI-Erweiterungen und
zeigen Ihnen auf, wie Sie von diesen profitieren können.<br />
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Dieses Kapitel beschreibt CDI in seiner ursprünglichen Form unter Java EE. Seit der Erstveröffentlichung hat sich CDI erheblich weiterentwickelt – von der Migration zu Jakarta EE über die Aufteilung in CDI Lite und CDI Full bis hin zu CDI 4.1. Die Details zu diesen Änderungen finden Sie in Kapitel <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div>
<div class="tip"><b>Tipp: </b>Dieses Buch setzt grundlegende Kenntnisse in Java SE (ab Version 8), Apache Maven und idealerweise erste Erfahrung mit Java EE / Jakarta EE voraus. JPA-Grundwissen ist hilfreich, aber nicht zwingend erforderlich.</div>
<div class="tip"><b>Tipp: </b>Seit der Erstveröffentlichung dieses Buchs wurde der Inhalt erheblich erweitert: Kapitel 9 behandelt die Migration von Java EE zu Jakarta EE, Kapitel 10 die Migration zu Quarkus und Kapitel 11 den Wechsel von JSF zu Angular. Zusammen bilden die Kapitel 1&ndash;11 einen vollständigen Migrationspfad von CDI 1.0 bis zur modernen Quarkus + Angular-Architektur.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.1' ><span class='entry-number'>1.1</span> Context- und Dependency-Management</a> </h2>
<span id='_footnote_marker_2' class='latex-footnote-marker'>Context-Management:</span>
                 Um zu verstehen, warum mit der Arbeit an CDI begonnen wurde,
machen wir einen kurzen Ausflug in die Anfänge der Softwareentwicklung mit Java.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ohne ein zusätzliches Framework steht Ihnen zunächst nur der grundlegende Sprachumfang von Java zur Verfügung.
Geht es um die Erzeugung neuer Instanzen einer Klasse, können Sie das Schlüsselwort  <span class='latex-texttt'>new</span>  verwenden.
Allerdings müssen Sie eine solche Instanz auch verwalten, um sie zu einem späteren Zeitpunkt wiederverwenden zu können (= Context-Management).
Ähnlich wie in anderen Programmiersprachen haben sich auch in Java hierfür verschiedene Entwurfsmuster etabliert.
Doch selbst diese Entwurfsmuster führten in großen Applikationen oft zu unnötig komplexen Umsetzungen.
Um Instanzen effizienter zu verwalten und mit zusätzlicher Funktionalität anzureichern, wurden Komponentenmodelle eingeführt,
die einen Großteil der Komplexität in Konfigurationsdateien auslagerten. Mangels einer besseren Alternative
wurde hierfür häufig XML als Konfigurationsformat herangezogen. Dies führte jedoch zu neuen Herausforderungen:
Ein zentraler Teil einer Applikation ist nicht mehr typsicher, und die Konfiguration mancher Komponentenmodelle wurde so umfangreich,
dass sie oft mit Generatoren erzeugt werden musste. Im Laufe der Zeit wurden die Komponentenmodelle besser und
der Konfigurationsaufwand erheblich gesenkt. Jedoch basiert das Format der Konfigurationsdateien weiterhin auf Strings,
wodurch viele Vorteile einer typsicheren Sprache wie Java verloren gehen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span id='_footnote_marker_3' class='latex-footnote-marker'>Dependency-Management:</span>
                 Eine zweite Herausforderung bei der Entwicklung von Applikationen
sind die Referenzen zu anderen Instanzen (= Dependency-Management). Hierbei erhöht sich die Komplexität,
sobald Beans mit unterschiedlicher Lebensdauer (Scopes) beteiligt sind. Sorgt der Container dafür,
dass die erforderlichen Referenzen zu anderen Instanzen automatisch gesetzt (= injiziert) werden, spricht man von Dependency-Injection.
Für dieses Dependency-Management nutzen viele Komponentenmodelle Konfigurationseinträge, die ebenfalls zum Verlust der Typsicherheit führen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ein Container stellt ein Komponentenmodell zur Verfügung, das vom Applikationscode verwendet werden kann,
um Teile der Applikation einfacher umzusetzen.
Container bilden somit das Bindeglied zwischen der darunterliegenden Laufzeitumgebung und dem Applikationscode.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Sowohl beim Context- als auch beim Dependency-Management gab es bis JDK 5 keine Alternative,
um diese Grundproblematik effizienter und vor allem typsicher zu lösen. 2004 wurden die anfänglich stark unterschätzten Annotationen
mit Java 5 eingeführt. Doch erst 2006 kamen Annotationen mit Java EE 5 erstmals offiziell für Dependency-Injection zum Einsatz.
Im darauffolgenden Jahr verfeinerte ein Projekt namens Guice diesen Ansatz bezüglich der Typsicherheit.
Durch die zunehmende Beliebtheit typsicherer Komponentenmodelle war eine Spezifikation solcher Konzepte naheliegend.
Ursprünglich wurde CDI (JSR-299) unter dem Namen "Web Beans" geführt,
denn das primäre Ziel war es, ein Bindeglied zwischen der JSF- und EJB-Spezifikation zu schaffen.
Drei Jahre später feierte CDI sein Debüt. Bis zur finalen Version
hatte sich nicht nur der Name geändert, sondern es wurden mehrere größere Überarbeitungen vorgenommen.
So wurde beispielsweise ein Teil der Spezifikation ausgelagert (zu JSR-330) und bildet seither nicht nur die Basis für CDI,
sondern auch für andere Komponentenmodelle. Außerdem ist CDI nicht mehr an Java EE gebunden,
sondern kann problemlos auch in Java-SE-Applikationen eingesetzt werden.<br /> <div class="tip"><b>Tipp: </b> JSR-330 besteht aus 5 Annotationen und einem Interface und spezifiziert einen minimalen Funktionsumfang,
der für Dependency-Injection und die Definition eigener Scopes erforderlich ist.
Neben CDI-Implementierungen wird JSR-330 auch von anderen Projekten als Basis verwendet. </div><h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.2' ><span class='entry-number'>1.2</span> Annotationen als zentraler Bestandteil</a> </h2>
 Annotationen sind zusätzliche Metadaten und wurden in Java 5 als Erweiterung des Typsystems eingeführt.
Da CDI hauptsächlich auf Annotationen basiert und die Erstellung eigener Annotationen zum täglichen Handwerkszeug
für die Arbeit mit CDI gehört, sehen wir uns ein paar Details etwas näher an.
Bei Annotationen muss grundsätzlich unterschieden werden, ob sie zur Laufzeit der Applikation abgefragt werden können oder nicht.
Ein bekannter Vertreter für Annotationen, die nicht zur Laufzeit abgefragt werden können, ist  <span class='latex-texttt'>@Override</span> ,
da hier  <span class='latex-texttt'>@Retention(RetentionPolicy.SOURCE)</span>  definiert ist. Für ein Komponentenmodell wie CDI sind natürlich nur Informationen sinnvoll,
die zur Laufzeit zur Verfügung stehen. Daher müssen alle Annotationen, die Sie im Zusammenhang mit CDI erstellen, immer
 <span class='latex-texttt'>@Retention(RetentionPolicy.RUNTIME)</span>  definieren. Andernfalls sieht der CDI-Container die Annotation zur Laufzeit nicht.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Darüber hinaus muss noch angegeben werden, an welchen Stellen die Annotation verwendet werden kann.
Dies wird mithilfe von  <span class='latex-texttt'>@Target</span>  ausgedrückt. Somit können wir bereits die gebräuchlichste Annotation
für die tägliche Arbeit mit CDI – nämlich  <span class='latex-texttt'>@Inject</span> , dargestellt in Listing  <a href='#!idx:/introduction.html:fig:implementation-adinject'> Spezifizierter Aufbau von @Inject </a>  dargestellt ist, analysieren.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/introduction.html:fig:implementation-adinject'></a>                     <pre><code>@Target({ElementType.CONSTRUCTOR,
    ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Inject {}
</code></pre>
                </div> 
Im Falle von  <span class='latex-texttt'>@Inject</span>  sind die möglichen Verwendungsziele Konstruktoren, Methoden und Felder.
Neben den eben erwähnten Elementtypen sind im Kontext von CDI noch  <span class='latex-texttt'>ElementType.TYPE</span>  für Annotationen auf Klassenebene,
 <span class='latex-texttt'>ElementType.PARAMETER</span>  für Annotationen auf Methodenparametern und  <span class='latex-texttt'>ElementType.ANNOTATION_TYPE</span>  für Annotationen auf Annotationen wichtig. Eine Annotation zu annotieren mag sich anfangs etwas ungewohnt anhören.
Im Laufe des Buches werden wir jedoch sehr sinnvolle Verwendungsmöglichkeiten für diesen Elementtyp kennenlernen.<br /> <h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.3' ><span class='entry-number'>1.3</span> Hello CDI</a> </h2>
 CDI folgt in seiner minimalen Ausprägung einigen wenigen Regeln.
In den nachfolgenden Kapiteln werden wir zusätzlich spezielle Konstellationen betrachten.
Behalten Sie bitte im Hinterkopf, dass viele der vorgestellten Konzepte optional sind und
somit zwar zur Verfügung stehen, aber selbstverständlich nicht ständig verwendet werden müssen.
Eine durchschnittliche CDI-basierte Applikation kommt sogar mit erstaunlich wenigen CDI-Funktionalitäten aus.
Dennoch ist es sinnvoll, einen Überblick über den gesamten Funktionsumfang zu haben, falls Sie auf komplexere Anwendungsfälle stoßen und
auch diese mit den eleganten CDI-Konzepten lösen möchten.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/introduction.html:fig:minimal_cdi-bean'> Minimales CDI-Bean </a>  zeigt ein POJO (Plain Old Java Object), das bereits ein vollwertiges CDI-Bean darstellt.
Wie unschwer zu erkennen ist, wird hier weder eine CDI-Klasse noch eine spezielle Annotation verwendet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/introduction.html:fig:minimal_cdi-bean'></a>                     <pre><code>public class HelloWorldBean {
  public String hello() {
    return "Hello CDI";
  }
}
</code></pre>
                </div> 
Nur anhand der Klasse kann in diesem Fall nicht festgestellt werden, ob es sich um ein CDI-Bean handelt oder nicht.
Damit der CDI-Container von dieser Klasse überhaupt erfährt, muss eine Marker-Datei namens  <span class='latex-texttt'>beans.xml</span>  je Modul
(in  <span class='latex-texttt'>META-INF</span>  bei JAR-Dateien bzw.  <span class='latex-texttt'>WEB-INF</span>  bei WAR-Dateien) angelegt werden.
Wie der Begriff Marker-Datei bereits vermuten lässt, kann diese Datei leer (= 0 Byte) sein,
da sie im einfachsten Fall lediglich zur Kennzeichnung sogenannter Bean-Archive (bzw. Bean Deployment Archive) dient.
Somit muss nicht der gesamte Klassenpfad gescannt werden, sondern nur die entsprechend markierten Archive.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Ab CDI 4.0 ist der Standard-Discovery-Modus <span class='latex-texttt'>annotated</span> statt <span class='latex-texttt'>all</span>. Das bedeutet, dass nur noch Klassen mit einer Bean-definierenden Annotation (wie <span class='latex-texttt'>@ApplicationScoped</span>) erkannt werden – eine leere <span class='latex-texttt'>beans.xml</span> allein reicht dann nicht mehr aus, um alle Klassen als Beans zu registrieren. Details hierzu finden Sie in Kapitel <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div><br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Selbst wenn der CDI-Container die Klasse aus Listing  <a href='#!idx:/introduction.html:fig:minimal_cdi-bean'> Minimales CDI-Bean </a>  gefunden hat,
muss dieses Bean vom Container implizit via Dependency-Injection oder explizit via manuellem Bean-Lookup vom Container bezogen werden.
Würden Sie manuell eine Instanz dieser Klasse erzeugen, dann wird diese nicht vom Container verwaltet und die Instanz ist auch kein CDI-Bean.<br /> <div class="tip"><b>Tipp: </b> Ab CDI 1.1 ist die Datei beans.xml optional. Um mit CDI 1.0 Bean-Module ohne beans.xml zu integrieren, kann
beispielsweise auf die SPI von CDI zurückgegriffen werden. Die entsprechenden Mechanismen werden im Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  vorgestellt. </div> Die erste Instanz, die den Einstiegspunkt einer Verarbeitung darstellt, muss immer vom CDI-Container initialisiert werden.
In einem Java-EE-Applikationsserver wird dies im Regelfall automatisch durchgeführt.
Java-SE-Applikationen müssen hingegen mindestens ein Bean manuell vom CDI-Container abfragen oder
eine manuelle Injizierung durchführen, damit der Objektgraph vom CDI-Container korrekt aufgebaut wird.
Vor CDI 1.1 ist dies in einer Java-SE-Applikation nicht mithilfe einer standardisierten API möglich.
Um dennoch unser Bean beispielsweise mit einem einfachen Unit-Test zu überprüfen, müssen wir an dieser Stelle etwas vorgreifen und
verwenden einen JUnit-Test-Runner einer portablen CDI-Erweiterung namens Apache DeltaSpike.
Sowohl der Test-Runner als auch viele weitere Bestandteile von DeltaSpike werden später im Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  im Detail beschrieben.
Dieser Test-Runner sorgt im Hintergrund vor allem dafür, dass der CDI-Container gestartet wird und
CDI-Beans in die JUnit-Testklasse injiziert werden können.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/introduction.html:fig:direct_bean_injection'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class HelloWorldBeanTest {
  @Inject
  private HelloWorldBean bean;

  @Test
  public void testInjectedBean() {
    Assert.assertEquals("Hello CDI", bean.hello());
  }
}
</code></pre>
                </div> 
Erst durch  <span class='latex-texttt'>@Inject</span>  wird veranlasst, dass der CDI-Container eine Instanz der Klasse  <span class='latex-texttt'>HelloWorldBean</span>  erzeugt und
eine Referenz auf diese zur Verfügung stellt. Somit kann über das mit  <span class='latex-texttt'>@Inject</span>  annotierte Feld auf diese Instanz zugegriffen werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/introduction.html:fig:minimal_cdi-bean'> Minimales CDI-Bean </a>  und  <a href='#!idx:/introduction.html:fig:direct_bean_injection'> Injection eines CDI-Beans </a>  zeigen wie einfach CDI sein kann.
Natürlich gibt es viele weitere Mechanismen, die in den nachfolgenden Kapiteln im Detail beschrieben werden.
Dennoch sei an dieser Stelle nochmals erwähnt, dass eine durchschnittliche CDI-Applikation nicht den vollen Funktionsumfang
von CDI ausschöpfen muss. In vielen Fällen lautet die Devise: "Je geringer die Komplexität gehalten wird,
desto einfacher kann eine Applikation gewartet werden." Das gilt nicht nur für die Geschäftslogik einer Applikation,
sondern auch für die Auswahl der genutzten Funktionalitäten von Komponentenmodellen wie CDI.<br /> <h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.4' ><span class='entry-number'>1.4</span> Die Applikation zu diesem Buch</a> </h2>
<a name = '!idx:/introduction.html:sec:ideafork_intro'> </a> Der Name der Beispielapplikation ist  <span class='latex-textit'>IdeaFork</span> . Im Laufe des Buches wird eine kleine Plattform entwickelt, mit der sich beispielsweise
Rezept-, Reise- oder Geschenk-Ideen einfach verwalten lassen. Darüber hinaus können Ideen gesucht und kopiert (geforked) werden.
Das ermöglicht die Abwandlung und Weiterentwicklung bestehender Ideen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bitte beachten Sie, dass die Beispielapplikation kein Referenzdesign einer typischen CDI-Applikation darstellen soll.
Stattdessen werden alle Grundkonzepte von CDI sowie Funktionalitäten von CDI-Erweiterungen anhand konkreter Anwendungsfälle
illustriert. Selbstverständlich können einige dieser Anwendungsfälle auch ohne CDI umgesetzt werden.
Auch mit CDI bedeutet die Verfügbarkeit einer Funktionalität nicht, dass sie um jeden Preis verwendet werden muss.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im ersten Teil des Buches konzentrieren wir uns auf das Backend der Applikation.
Anfänglich wird der Backend-Code keine Abhängigkeiten zu anderen Java-EE-Spezifikationen wie beispielsweise JPA haben.
Dadurch können wir uns voll und ganz auf die CDI-Konzepte konzentrieren.
Erst danach beschäftigen wir uns mit der Integration anderer Java-EE-Spezifikationen sowie weiterer Technologien.
Die Struktur des Backend-Moduls ist bewusst einfach gehalten, da die illustrierten CDI-Funktionalitäten im Mittelpunkt stehen
und nicht die Erstellung eines bestimmten Applikationsdesigns.
Für eine einfachere Verwendung des Moduls gibt es lediglich eine Trennung zwischen API- und Impl-Package.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Da CDI selbst nur eine schriftliche Spezifikation ist, benötigen wir eine Implementierung davon.
Hier haben wir eine beachtliche Auswahl. Neben der Referenzimplementierung namens Weld (von JBoss/Red Hat) gibt es noch
OpenWebBeans (von Apache) und CanDI (von Resin). Weit verbreitet sind Weld und OpenWebBeans (aka OWB).
Daher werden wir uns auf diese beiden Implementierungen beschränken. In Java-SE-Anwendungen sowie bei Webapplikationen,
die in einen Servlet-Container deployt werden, können Sie selbst wählen, welche Implementierung Sie verwenden möchten.
Bei Java-EE-6+-Applikationsservern wird Ihnen diese Entscheidung vom Hersteller des Servers abgenommen,
und Sie müssen sich nicht manuell um das Setup kümmern.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Die in diesem Kapitel genannten Versionen (OWB 1.2.x, Weld 1.1.x) entsprechen dem Stand zur Erstveröffentlichung des Buches. Aktuelle Versionen sind deutlich weiter: Weld 6.x und OpenWebBeans 4.x implementieren CDI 4.1 unter dem <span class='latex-texttt'>jakarta</span>-Namespace. CanDI (Resin) wird nicht mehr aktiv weiterentwickelt. Details zu den aktuellen Versionen finden Sie in Kapitel <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div><br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.4.0.1' ><span class='entry-number'>1.4.0.1</span> Das Setup</a></h4>
 In Kombination mit einem Java-EE-6+-Applikationsserver ist das Setup minimal, da nur das Java-EE-API-JAR während der Entwicklung erforderlich ist.
Für das Deployment wird es dann nicht mehr benötigt, und es müssen nur die Klassen des Projekts selbst bereitgestellt werden.
Da wir jedoch mit Java SE (bzw. JUnit-Tests) und CDI anfangen, sehen wir uns das erforderliche Setup für OpenWebBeans und
Weld etwas genauer an.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Sowohl Weld als auch OpenWebBeans sind mit jeder standardkonformen API verwendbar. Hier gibt es mehrere Möglichkeiten.<br /> <div class='latex-begin-block'><table border=0 class='latex-table'><thead class='latex-table-header'><tr class='latex-table-header-row'></tr><tr class='latex-table-header-row'><td class='latex-table-header-cell'>[groupId:artifactId]</td><td class='latex-table-header-cell'>Version</td><td class='latex-table-header-cell'>Beschreibung</td></tr><tr class='latex-table-header-row'></tr></thead><tbody class='latex-table-body'><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>javax:javaee-web-api</span>   </td><td class='latex-table-body-cell'>    6.0    </td><td class='latex-table-body-cell'>    Offizielle     Java     EE     6     API </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>javax:javaee-web-api</span>   </td><td class='latex-table-body-cell'>    7.0    </td><td class='latex-table-body-cell'>    Offizielle     Java     EE     7     API </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.openejb:javaee-api</span>   </td><td class='latex-table-body-cell'>    6.0-5    </td><td class='latex-table-body-cell'>    Alternatives     Java     EE     6     API </td></tbody></table><div class='latex-begin-block'> <br /> </div></div> 
Tabelle  <span class='latex-unknwown-link'> tab:ee-api </span>  zeigt unterschiedliche EE API-Bundles, welche aktuell zur Verfügung stehen.
Da jedes Bundle die komplette API enthält ist nur eines dieser Bundles erforderlich.
Sind Sie jedoch nur an der CDI-API selbst interessiert, so können Sie alternativ
 <span class='latex-texttt'>javax.inject:javax.inject:1</span>  und  <span class='latex-texttt'>javax.enterprise:cdi-api:1.0-SP4</span>  einbinden.
Als weitere Alternative können die einzelnen API-Module von Apache verwendet werden, welche in Tabelle  <span class='latex-unknwown-link'> tab:spec-apis </span>  aufgelistet sind.
Bei Apache werden diese API Module gesammelt im Projekt Apache Geronimo gehostet,
jedoch gibt es keine Abhängigkeit zu der gleichnamigen Serverimplementierung.<br /> <div class='latex-begin-block'><table border=0 class='latex-table'><thead class='latex-table-header'><tr class='latex-table-header-row'></tr><tr class='latex-table-header-row'><td class='latex-table-header-cell'>[groupId:artifactId]</td><td class='latex-table-header-cell'>Version</td><td class='latex-table-header-cell'>Beschreibung</td></tr><tr class='latex-table-header-row'></tr></thead><tbody class='latex-table-body'><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.geronimo.specs: geronimo-atinject_1.0_spec</span>   </td><td class='latex-table-body-cell'>    1.0    </td><td class='latex-table-body-cell'>    JSR-330 </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.geronimo.specs: geronimo-jcdi_1.0_spec</span>   </td><td class='latex-table-body-cell'>    1.0    </td><td class='latex-table-body-cell'>    JSR-299 </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.geronimo.specs: geronimo-interceptor_1.1_spec</span>   </td><td class='latex-table-body-cell'>    1.0    </td><td class='latex-table-body-cell'>    Bestandteil     von     JSR-318 </td></tbody></table><div class='latex-begin-block'> <br /> </div></div> 
Zusätzlich zu den API Modulen sind die entsprechenden Implementierungsmodule erforderlich:<br /> <div class='latex-begin-block'><table border=0 class='latex-table'><thead class='latex-table-header'><tr class='latex-table-header-row'></tr><tr class='latex-table-header-row'><td class='latex-table-header-cell'>[groupId:artifactId]</td><td class='latex-table-header-cell'>Version</td><td class='latex-table-header-cell'>Beschreibung</td></tr><tr class='latex-table-header-row'></tr></thead><tbody class='latex-table-body'><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.openwebbeans: openwebbeans-impl</span>   </td><td class='latex-table-body-cell'>    1.2.2    </td><td class='latex-table-body-cell'>    Implementierung     von     JSR-299 </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.apache.openwebbeans: openwebbeans-spi</span>   </td><td class='latex-table-body-cell'>    1.2.2    </td><td class='latex-table-body-cell'>    Separates     SPI     Modul     für     eine     einfachere     Erweiterbarkeit     von     OWB </td></tbody></table><div class='latex-begin-block'> <br /> </div></div><div class='latex-begin-block'><table border=0 class='latex-table'><thead class='latex-table-header'><tr class='latex-table-header-row'></tr><tr class='latex-table-header-row'><td class='latex-table-header-cell'>[groupId:artifactId]</td><td class='latex-table-header-cell'>Version</td><td class='latex-table-header-cell'>Beschreibung</td></tr><tr class='latex-table-header-row'></tr></thead><tbody class='latex-table-body'><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.jboss.weld: weld-core-bom</span>   </td><td class='latex-table-body-cell'>    1.1.18    </td><td class='latex-table-body-cell'>    BOM     für     Weld </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.jboss.weld: weld-api</span>   </td><td class='latex-table-body-cell'>    Durch     BOM     definiert    </td><td class='latex-table-body-cell'>    Proprietäre     API     von     Weld </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.jboss.weld: weld-core</span>   </td><td class='latex-table-body-cell'>    Durch     BOM     definiert    </td><td class='latex-table-body-cell'>    Implementierung     von     JSR-299 </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.jboss.weld.se: weld-se</span>   </td><td class='latex-table-body-cell'>    Durch     BOM     definiert    </td><td class='latex-table-body-cell'>    Spezielles     Module     für     Java     SE </td></tr><tr class='latex-table-body-row'><td class='latex-table-body-cell'><span class='latex-texttt'>org.slf4j: slf4j-simple</span>   </td><td class='latex-table-body-cell'>    1.7.2    </td><td class='latex-table-body-cell'>    Logging     Framework,     welches     von     Weld     verwendet     wird </td></tbody></table><div class='latex-begin-block'> <br /> </div></div> 
Im  <span class='latex-texttt'>pom.xml</span>  von  <span class='latex-textit'>IdeaFork</span>  werden sowohl die Dependencies von OpenWebBeans (Tabelle  <span class='latex-unknwown-link'> tab:owb_java-se </span> ) als auch
Weld (Tabelle  <span class='latex-unknwown-link'> tab:weld_java-se </span> ) verwendet. Zur Laufzeit darf immer nur eine Implementierung aktiv sein.
Diese Trennung wird in  <span class='latex-textit'>IdeaFork</span>  mit Maven-Profilen umgesetzt,
um die Portabilität der Applikation sicherzustellen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Damit CDI einfach in JUnit-Tests gestartet und verwendet werden kann,
finden Sie in der Demo-Applikation zusätzlich Test-Dependencies für das Test-Control-Modul von Apache DeltaSpike,
das im Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  detailliert beschrieben wird.<br /> <h2><a class='latex-index-anchor' name='!idx:/introduction.html:1.5' ><span class='entry-number'>1.5</span> Wichtige Begriffe der Spezifikation</a> </h2>
<a name = '!idx:/introduction.html:sec:cdi_terms'> </a> Bevor wir mit den einzelnen Grundkonzepten loslegen, betrachten wir noch die wichtigsten Begriffe der CDI-Spezifikation.
Auf diese Begriffe werden Sie nicht nur in den nachfolgenden Kapiteln vermehrt stoßen,
sondern auch im JavaDoc von CDI und möglicherweise bei der einen oder anderen eigenen Recherche zu einem CDI-spezifischen Thema.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.1' ><span class='entry-number'>1.5.0.1</span> Injection-Point</a></h4>
 Injection-Points sind Referenzvariablen, die vom CDI-Container automatisch gesetzt werden.
Im Laufe des Buchs werden wir verschiedene Möglichkeiten für explizite und implizite Injection-Points kennenlernen.
Eine mit  <span class='latex-texttt'>@Inject</span>  annotierte Instanzvariable ist beispielsweise ein expliziter Injection-Point.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Das SPI von CDI enthält ebenfalls ein Interface mit diesem Namen.
Über dieses Interface können die Metadaten eines Injection-Points während des Containerstarts angepasst werden.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.2' ><span class='entry-number'>1.5.0.2</span> Scope und Kontext</a></h4>
 Der Scope definiert die Lebensdauer einer Instanz. Mit  <span class='latex-texttt'>@NormalScope</span>  definiert CDI selbst nur eine Scope-Art.
Da CDI auf JSR-330 basiert und dort durch  <span class='latex-texttt'>@Scope</span>  ein einfacherer Scope-Typ spezifiziert wird,
muss man effektiv zwischen den Normal-Scopes von CDI (JSR-299) und den sogenannten Pseudo-Scopes von JSR-330 unterscheiden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Für CDI-basierte Applikationen sind primär Normal-Scoped Beans relevant. Hier definiert CDI  <span class='latex-texttt'>@ApplicationScoped</span>  (Instanzen werden beim Shutdown der Applikation zerstört),  <span class='latex-texttt'>@SessionScoped</span>  (die Lebensdauer ist von der HTTP-Session abhängig),
 <span class='latex-texttt'>@RequestScoped</span>  (die Lebensdauer ist auf einen HTTP-Request beschränkt) und  <span class='latex-texttt'>@ConversationScoped</span>  (halbautomatisch gesteuert).
Der einzige durch CDI spezifizierte Pseudo-Scope ist  <span class='latex-texttt'>@Dependent</span> , der aus CDI-Sicht in vielen Fällen eine Ausnahme darstellt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ein Scope ist mit einer Instanz einer Implementierung von  <span class='latex-texttt'>javax.enterprise.context.spi.Context</span>  verbunden,
die den Lebenszyklus von Instanzen (Contextual-Instances) verwaltet. Ob ein Kontext aktiv ist oder nicht,
hängt von der Art des Scopes ab und kann dynamisch ausgewertet werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Von CDI spezifizierte Standard-Kontexte werden komplett beendet. Wird beispielsweise der Request-Scope für den aktuellen Thread zerstört,
werden alle request-scoped Beans gesammelt vernichtet. Die manuelle Verwaltung einzelner Beans ist bei den Standard-Kontexten nicht vorgesehen.
Dabei handelt es sich jedoch nicht um eine technische Einschränkung von CDI.
Eine feingranulare Verwaltung einzelner Beans ist bei eigenen Kontext-Implementierungen durchaus möglich.<br /> <div class="tip"><b>Tipp: </b> In der Praxis können  <span class='latex-texttt'>@SessionScoped</span>  und  <span class='latex-texttt'>@RequestScoped</span>  sogar in Java-SE-Applikationen verwendet werden.
Sie müssen dort jedoch manuell gesteuert werden. Weitere Details hierzu und zu den einzelnen Scopes
sowie die Definition eigener Scopes folgen in den Kapiteln  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  und  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a> . </div><h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.3' ><span class='entry-number'>1.5.0.3</span> Managed-Bean</a></h4>
 Managed-Beans sind nach der Definition von CDI nicht mit Java-Beans zu verwechseln.
Allerdings sind selbst in der CDI-Spezifikation mehrere Verwendungen des Begriffs für unterschiedliche Konzepte zu finden.
In diesem Buch verwenden wir aus Sicht von CDI folgende Hauptdefinition:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ein Managed-Bean wird durch  <span class='latex-texttt'>javax.enterprise.inject.spi.Bean&lt;T&gt;</span>  repräsentiert und
setzt sich aus der Java-Klasse und den zusätzlichen Metadaten zusammen.
Wie wir später noch sehen werden, können diese Metadaten während dem Containerstart beinahe beliebig angepasst werden.
In jedem Fall werden sie im Zuge des Startprozesses der Applikation überprüft.
Werden CDI-Regeln nicht eingehalten, so wird der Containerstart abgebrochen und eine entsprechende Fehlerbeschreibung angezeigt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Auf Basis der Java-Klasse und der Metadaten kann der Container zur Laufzeit die sog. Contextual-Instance erzeugen.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.4' ><span class='entry-number'>1.5.0.4</span> Contextual-Instance</a></h4>
 Umgangssprachlich wird statt Contextual-Instance oft der Begriff (CDI-)Bean verwendet.
Da der Begriff "Bean" jedoch mehrdeutig ist, werden wir in den nachfolgenden Kapiteln größtenteils den Begriff Contextual-Instance verwenden.
Wie zuvor erwähnt, handelt es sich bei der Contextual-Instance um die tatsächliche Instanz, die vom CDI-Container auf Basis des Managed-Beans
(= Java-Klasse und zusätzliche Metadaten) erzeugt wird.
Allerdings gibt der Container in vielen Fällen nicht die physische Referenz auf die Instanz nach außen, sondern eine sogenannte Contextual-Reference.<br /> <h4><a class='latex-index-anchor' name='!idx:/introduction.html:1.5.0.5' ><span class='entry-number'>1.5.0.5</span> Contextual-Reference</a></h4>
 Statt der physischen Referenz auf eine (Contextual-)Instance gibt der CDI-Container in vielen Fällen eine Proxy-Instanz nach außen.
Ob ein Proxy verwendet wird oder nicht, hängt vom definierten Scope des Managed-Beans ab. Für Normal-Scoped Beans werden immer Proxys erzeugt.
Für Pseudo-Scoped Beans ist dies nur dann vorgeschrieben, wenn Interceptoren oder Decoratoren um eine Contextual-Instance gelegt werden müssen,
da solche Funktionalitäten ohne angepassten Bytecode nicht umsetzbar sind.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Durch die Verwendung von Proxys wird außerdem die sogenannte Cross-Scope-Injection-Thematik gelöst.
Ohne Proxys würde beispielsweise ein Session-Scoped Bean mit einer injizierten Referenz auf ein Request-Scoped Bean
nach dem ersten Request noch eine Referenz auf die alte Instanz (aus dem ersten Request) halten.
Stattdessen soll das Session-Scoped Bean immer das aktuelle Request-Scoped Bean ansprechen können.
Dafür sorgt die Contextual-Reference (der Proxy), da für jeden Methodenaufruf die richtige Instanz ermittelt und
der Aufruf erst dann an diese weitergeleitet wird.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Da Proxys laut CDI-Spezifikation unabhängig von der Contextual-Instance immer serialisierbar sind,
ist die Passivierung (= Serialisierung und Speicherung einer Contextual-Instance außerhalb der Laufzeitumgebung)
einer Contextual-Instance unabhängig von den injizierten Referenzen.<br /> <div class="tip"><b>Tipp: </b> Der Proxy-Overhead ist bei aktuellen Implementierungen bereits minimal.
Beispielsweise erzeugt OpenWebBeans 1.2+ hoch optimierte Proxys via Subclassing auf Bytecode-Ebene.
Unabhängig von der konkreten Umsetzung gibt es jedoch Einschränkungen, die zu beachten sind:
Klassen und deren Methoden dürfen nicht final sein. Außerdem ist bei der täglichen Verwendung von CDI zu beachten,
dass im Debugger ("leere") Proxy-Instanzen angezeigt werden.
Um den State der Contextual-Instance im Debugger zu sehen, muss man sich innerhalb dieser Instanz befinden. </div>
<div class="tip"><b>Tipp: </b><b>Leseempfehlung je nach Vorkenntnissen:</b><br />
&bull; <b>CDI-Einsteiger:</b> Beginnen Sie mit den Kapiteln 1&ndash;4 für die Grundkonzepte (Injection, Scopes, Events, Interceptoren, Extensions).<br />
&bull; <b>DeltaSpike-Anwender:</b> Die Kapitel 5&ndash;8 vertiefen die DeltaSpike-Module und zeigen die IdeaFork-Fallstudie mit Microservices.<br />
&bull; <b>Migrationsprojekte:</b> Die Kapitel 9&ndash;11 führen von Java EE über Jakarta EE und Quarkus bis hin zu Angular &mdash; der vollständige Modernisierungspfad.</div>
</section>
<section class="chapter-section" id="chapter-2">
<h1> <a class='latex-index-anchor' name='!idx:/cdi_basics.html:2' ><span class='entry-number'>2</span> CDI Grundkonzepte</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Der Text dieses Kapitels wurde von Claude (AI built by Anthropic) als Co-Autor überarbeitet. Die Überarbeitung erfolgte ohne Post-Review des Originalautors. Die Nutzung der Inhalte erfolgt auf eigene Verantwortung.
</div>
<a name = '!idx:/cdi_basics.html:chap:cdi-basics'> </a> In diesem Kapitel betrachten wir die grundlegenden Konzepte von CDI. Am Ende des Kapitels kennen Sie die wichtigsten Basisfunktionalitäten,
die zur Entwicklung von CDI-basierten Applikationen verwendet werden können. CDI bietet darüber hinaus einige Erweiterungsmöglichkeiten,
die einen zentralen Aspekt dieses Komponentenmodells darstellen. Daher widmen wir diesem Thema ein eigenes Kapitel.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.1' ><span class='entry-number'>2.1</span> Typsichere Dependency-Injection</a> </h2>
 Der wohl bekannteste Bestandteil von CDI ist die typsichere Dependency-Injection.
Ein einfaches Beispiel haben wir bereits im Kapitel  <a href='#!idx:/introduction.html:chap:cdi-introduction'>  Einführung in CDI </a>  kennengelernt. Dieses Beispiel ist bewusst einfach gehalten,
repräsentiert jedoch einen der Hauptanwendungsfälle und verbirgt interessante Vorteile.
In diesem Kapitel werden wir darüber hinaus weitere Injection-Varianten und deren Eigenschaften kennenlernen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Es gibt mehrere Möglichkeiten, wie Sie dem CDI-Container mitteilen, dass eine Contextual-Reference gesetzt werden soll.
Die einfachste Variante ist die "direkte" Injection. Hierbei werden Felder, Methoden oder auch ein Konstruktor mit  <span class='latex-texttt'>@Inject</span>  annotiert.
Dieser Ansatz ist nicht nur einfach anzuwenden, sondern bietet außerdem den Vorteil,
dass der CDI-Container während des Startprozesses die Injection-Points validiert. Alle drei Möglichkeiten können beliebig kombiniert werden.
Dennoch gibt es eine definierte Reihenfolge, in der die Injizierung durchgeführt wird.
Zuerst wird immer die sogenannte Constructor-Injection ausgeführt.
Danach werden alle mit  <span class='latex-texttt'>@Inject</span>  annotierten Felder befüllt. Dies wird Field-Injection genannt.
In einem letzten Schritt wird Method-Injection durchgeführt.
Hierbei kann es sich um Initialisierungsmethoden mit beliebig vielen Parametern handeln.
Wie bei der Constructor-Injection stellt jeder Parameter einen eigenen Injection-Point dar,
der durch den CDI-Container befüllt wird.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Sollte kein gültiges Managed-Bean für einen Injection-Point gefunden werden, dann wird eine  <span class='latex-texttt'>UnsatisfiedResolutionException</span>  geworfen.
Sollten hingegen mehrere gültige Kandidaten gefunden werden, so wird eine  <span class='latex-texttt'>AmbiguousResolutionException</span>  geworfen.
Die  <span class='latex-texttt'>AmbiguousResolutionException</span>  werden wir uns später in Verbindung mit Qualifiern noch genauer ansehen.
In beiden Fällen wird der Containerstart abgebrochen, und somit erkennen Sie frühzeitig,
ob es ein grundlegendes Problem in Ihrer Applikation gibt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die im Kapitel  <a href='#!idx:/introduction.html:sec:ideafork_intro'>  Die Applikation zu diesem Buch </a>  beschriebene Beispielapplikation namens  <span class='latex-textit'>IdeaFork</span>  benötigt eine zentrale Entität,
der wir den naheliegenden Namen  <span class='latex-texttt'>Idea</span>  vergeben.
Äquivalent zu Listing 1.2 könnten wir eine Instanz der Klasse einfach in unsere Beans injizieren,
sofern alle CDI-Regeln erfüllt sind. Dies wird weitläufig als fachliche Injizierung (auch Business-Injection genannt) bezeichnet.<br /> <div class="tip"><b>Tipp: </b> Bei fachlicher Injizierung muss mit großer Sorgfalt vorgegangen werden. Fügen wir später beispielsweise JPA hinzu, ist es wichtig,
dass eine Instanz nur von einem Container verwaltet wird. In diesem Bereich gibt es viele Empfehlungen für die Strukturierung einer Applikation.
Wir folgen der Empfehlung, dass Entitäten nicht von CDI verwaltet werden.
Da wir dennoch die Erzeugung von  <span class='latex-texttt'>Idea</span> -Instanzen an einer zentralen Stelle durchführen wollen,
führen wir einen  <span class='latex-texttt'>IdeaManager</span>  ein, der später zusätzliche Aufgaben erfüllen wird. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.1.0.1' ><span class='entry-number'>2.1.0.1</span> Field-Injection</a></h4>
 Listing  <a href='#!idx:/cdi_basics.html:fig:minimal_idea-entity'> Idea Entität </a>  zeigt Details der Entität  <span class='latex-texttt'>Idea</span> . Vorerst handelt es sich um ein einfaches POJO mit 3 Properties,
von denen 2 für die Erzeugung einer Instanz erforderlich sind.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:minimal_idea-entity'></a>                     <pre><code>public class Idea {
  private String topic;
  private String category;
  private String description;

  Idea(String topic, String category) {
    this.topic = topic;
    this.category = category;
  }
  //+ Getter- und Setter-Methoden
}
</code></pre>
                </div> 
Da wir hier durch den Konstruktor die Erzeugung nur innerhalb des gleichen Pakets zulassen,
legen wir die Klasse  <span class='latex-texttt'>IdeaManager</span>  im gleichen Paket an.
Listing  <a href='#!idx:/cdi_basics.html:fig:minimal_factory'> CDI-Bean als einfache Factory </a>  zeigt die Implementierung von  <span class='latex-texttt'>IdeaManager</span> .
Vorerst verzichten wir auf die explizite Definition eines Scopes.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:minimal_factory'></a>                     <pre><code>public class IdeaManager {
  public Idea createIdeaFor(String topic, String category) {
    return new Idea(topic, category);
  }
}
</code></pre>
                </div> 
Mit Listing  <a href='#!idx:/cdi_basics.html:fig:minimal_idea-entity'> Idea Entität </a>  und  <a href='#!idx:/cdi_basics.html:fig:minimal_factory'> CDI-Bean als einfache Factory </a>  haben wir alle Bestandteile für die Erstellung eines Unit-Tests,
um die Erzeugung einer  <span class='latex-texttt'>Idea</span> -Instanz zu testen.
In diesem Test (siehe Listing  <a href='#!idx:/cdi_basics.html:fig:test_field-injection'> Unit-Test mit Field-Injection </a> ) legen wir ein privates Feld vom Typ  <span class='latex-texttt'>IdeaManager</span>  an und
annotieren es mit  <span class='latex-texttt'>@Inject</span> , wodurch wir für CDI einen Injection-Point definieren.
Zur Laufzeit befüllt der CDI-Container das Feld (den Injection-Point) mit einer Contextual-Reference,
über welche auf die Contextual-Instance zugegriffen werden kann.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test_field-injection'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class FieldInjectionTest {
  @Inject
  private IdeaManager ideaManager;

  @Test
  public void ideaCreation() {
    String topic = "Learn CDI";
    String category = "Education";
    String description = "Hello Injection!";

    Idea newIdea = this.ideaManager.createIdeaFor(topic, category);
    newIdea.setDescription(description);

    Assert.assertEquals(topic, newIdea.getTopic());
    Assert.assertEquals(category, newIdea.getCategory());
    Assert.assertEquals(description, newIdea.getDescription());
  }
}
</code></pre>
                </div> Diesen ersten Schritt könnten wir auch ohne Dependency-Injection umsetzen.
Statt der Annotation  <span class='latex-texttt'>@Inject</span>  müssten wir das Schlüsselwort  <span class='latex-texttt'>new</span>  für eine manuelle Instanziierung verwenden.
Manuell erzeugte Instanzen sind weiterhin möglich,
jedoch werden sie nicht durch den CDI-Container verwaltet, und somit wären viele CDI-basierte Funktionalitäten nicht oder
nur über Umwege verwendbar. Im nachfolgenden Schritt werden wir den ersten Vorteil von verwalteten Instanzen kennenlernen.<br />  
 <div class="tip"><b>Tipp: </b> Der zuvor erwähnte Vorteil, dass die demonstrierte (direkte) Field-Injection beim Containerstart validiert wird,
verhindert gleichzeitig die Verwendung von optionalen Beans. Ein Beispiel hierfür ist die optionale Implementierung eines Interfaces.
Zur Lösung solcher Anwendungsfälle benötigen wir eine Indirektion, für die es mehrere Möglichkeiten gibt.
Details zu solchen programmatischen Lookups werden wir in den Kapiteln  <a href='#!idx:/cdi_basics.html:sec:lookup_via_instance'> [ Indirektion mit Instance] </a>  und  <a href='#!idx:/cdi_basics.html:sec:lookup_via_bm'> [ Beans via BeanManager finden] </a>  behandeln. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.1.0.2' ><span class='entry-number'>2.1.0.2</span> Constructor-Injection</a></h4>
 Eine Alternative zur Field-Injection ist die Constructor-Injection.
Hierbei wird ein parametrisierter Konstruktor mit  <span class='latex-texttt'>@Inject</span>  annotiert.
Sobald ein Proxy zur Referenzierung einer Contextual-Instance erforderlich ist, muss ein Default-Konstruktor angelegt werden.
Anderenfalls wird während des Containerstarts eine  <span class='latex-texttt'>UnproxyableResolutionException</span>  geworfen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In unserer Applikation können wir einen  <span class='latex-texttt'>IdeaValidator</span>  hinzufügen,
der via Constructor-Injection in  <span class='latex-texttt'>IdeaManager</span>  gesetzt wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:bean_with_constructor-injection'></a>                     <pre><code>public class IdeaManager {
  private final IdeaValidator ideaValidator;

  @Inject
  protected IdeaManager(IdeaValidator ideaValidator) {
    this.ideaValidator = ideaValidator;
  }

  public Idea createIdeaFor(String topic, String category) {
    Idea result = new Idea(topic, category);
    if (!ideaValidator.checkIdea(result)) {
      throw new IllegalArgumentException(
        "Please try it harder next time!");
    }
    return result;
  }
}
</code></pre>
                </div> 
Aus technischer Sicht gibt es in CDI keine Vorteile von Constructor-Injection im Vergleich zu den anderen Varianten,
da erst vollständig initialisierte Beans vom Container nach außen gegeben werden.
In vielen Fällen wird Constructor-Injection primär verwendet, wenn der Injection-Point nicht direkt einer Instanzvariablen zugewiesen wird.
Stattdessen wird oft nur ein Wert über den Injection-Point abgefragt und
dieser einer Instanzvariablen zugewiesen oder im Konstruktor direkt ausgewertet.<br /> <div class="tip"><b>Tipp: </b> In Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_constructor-injection'> Constructor-Injection </a>  ist kein Default-Konstruktor erforderlich.
Dies ändert sich, sobald ein Bean normal-scoped ist oder einen Interceptor/Decorator hat. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.1.0.3' ><span class='entry-number'>2.1.0.3</span> Method-Injection</a></h4>
 Ähnlich der Constructor-Injection können auch Methoden mit  <span class='latex-texttt'>@Inject</span>  annotiert werden.
Jeder Parameter stellt einen Injection-Point dar, der vom CDI-Container injiziert wird.
Da Parameter optional sind, können 0 bis n Parameter angegeben werden.
Init-Methoden ohne Parameter werden jedoch üblicherweise mit  <span class='latex-texttt'>@PostConstruct</span>  annotiert.
Für die Contextual-Instance macht es technisch gesehen keinen relevanten Unterschied,
allerdings ist  <span class='latex-texttt'>@PostConstruct</span>  aussagekräftiger und wird genauso wie  <span class='latex-texttt'>@PreDestroy</span>  von CDI unterstützt.
Wie eingangs erwähnt wird Method-Injection nach Constructor- und Field-Injection durchgeführt und
stellt den letzten Injizierungsschritt dar.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/cdi_basics.html:fig:test_method-injection'> Unit-Test mit Method-Injection </a>  wird statt Field-Injection das eben beschriebene Method-Injection Konzept angewendet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test_method-injection'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class MethodInjectionTest {
  private IdeaManager ideaManager;

  @Inject
  protected void init(IdeaManager ideaManager) {
    this.ideaManager = ideaManager;
  }

  @Test(expected = IllegalArgumentException.class)
  public void invalidIdeaCreation() {
    this.ideaManager.createIdeaFor(null, null);
  }

  //...
}
</code></pre>
                </div> 
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.2' ><span class='entry-number'>2.2</span> Normal- und Pseudo-Scopes</a> </h2>
 Wie im Kapitel  <a href='#!idx:/introduction.html:sec:cdi_terms'>  Wichtige Begriffe der Spezifikation </a>  beschrieben, werden Contextual-Instances auf Basis der zugrundeliegenden Bean-Metadaten erzeugt.
Ein Bestandteil dieser Metadaten ist der Scope des Beans, der die Lebensdauer der Contextual-Instance definiert.
Ist eine Contextual-Instance noch nicht verfügbar, so wird diese üblicherweise automatisch erzeugt, sofern der Scope aktiv ist.
Das genaue Verhalten wird durch den Scope und dessen Kontext-Implementierung definiert.
Selbst in der CDI-Spezifikation gibt es mit dem Conversation-Scope einen Spezialfall, da dieser explizit gestartet werden muss.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Dies ist nicht die einzige Ausnahme in der CDI-Spezifikation.
Es wird grundsätzlich zwischen "Pseudo-Scopes" und "Normal-Scopes" unterschieden, wobei Pseudo-Scopes eher selten vorkommen.
Wie dieses Kapitel zeigt, folgen beide Scope-Arten unterschiedlichen Regeln. Die Verwendung ist hingegen durchgängig.
Sie wählen den passenden Scope für ein Managed-Bean aus und annotieren die Bean-Klasse (oder Producer) mit der entsprechenden Scope-Annotation.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.2.0.1' ><span class='entry-number'>2.2.0.1</span> Pseudo-Scopes</a></h4>
 Bereits JSR-330 enthält eine Annotation ( <span class='latex-texttt'>@Scope</span> ), mit der eigene Scope-Annotationen erstellt werden können.
In der CDI-Spezifikation werden entsprechende Scopes unter dem Namen "Pseudo-Scope" geführt, da  <span class='latex-texttt'>@Scope</span>  praktisch undefiniert ist.
Dies ist der Grund, warum es zwei ähnliche Scopes ( <span class='latex-texttt'>@javax.inject.Singleton</span>  von JSR-330 und
 <span class='latex-texttt'>@javax.enterprise.context.ApplicationScoped</span>  von CDI) gibt.
Selbst bei dem wesentlich konkreter definierten  <span class='latex-texttt'>@ApplicationScoped</span>  gibt es noch Feinheiten,
die zu unterschiedlichen Interpretationen führten.<br />
<div class="tip"><b>Tipp: </b>Die in diesem Kapitel verwendeten Paketnamen <span class='latex-texttt'>javax.inject</span> und <span class='latex-texttt'>javax.enterprise</span> wurden mit Jakarta EE 10 zu <span class='latex-texttt'>jakarta.inject</span> und <span class='latex-texttt'>jakarta.enterprise</span> umbenannt. Die Konzepte und APIs bleiben identisch &mdash; nur der Namespace ändert sich. Details zur Migration finden Sie in Kapitel <a href='#!idx:/upgrade.html:9'>9</a>.</div> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.2.0.2' ><span class='entry-number'>2.2.0.2</span> Normal-Scopes</a></h4>
 Mit Passivierung und den damit verbundenen Regeln definiert die CDI-Spezifikation einen sehr praktischen Mechanismus.
 <span class='latex-texttt'>@Scope</span>  von JSR-330 ist allerdings zu simpel gehalten und somit fehlt eine Möglichkeit die Passivierung anzugeben.
Eine zusätzliche Annotation hätte diese Einschränkung überwunden.
Die CDI Expert-Group hat sich hingegen dazu entschlossen eine besser definierte Scope-Art einzuführen,
die es ermöglicht, die Passivierbarkeit des Scopes anzugeben. Diese Scope-Art wird "Normal-Scope" genannt.
Dementsprechend werden Scope-Annotationen mit  <span class='latex-texttt'>@NormalScope</span>  annotiert.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ein zentraler Unterschied zwischen beiden Scope-Arten ist,
dass die Contextual-Reference auf eine normal-scoped Contextual-Instance immer ein Proxy ist.
Hingegen ist dies bei pseudo-scoped Beans nur erforderlich, sobald ein Interceptor/Decorator für das entsprechende Bean definiert ist,
da dies technisch nur mit angepasstem Bytecode möglich ist. Wie bereits im Kapitel  <a href='#!idx:/introduction.html:chap:cdi-introduction'>  Einführung in CDI </a>  erwähnt,
sind normal-scoped Beans wesentlich komfortabler, da wir uns über viele technischen Details,
wie beispielsweise Cross-Scope-Injection, keine Gedanken machen müssen.<br />
<div class="tip"><b>Tipp: </b><b>Häufiger Fehler &mdash; Proxy vs. direkte Referenz:</b> Bei Normal-Scoped Beans (<span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@RequestScoped</span>, etc.) injiziert CDI einen Proxy, nicht die eigentliche Instanz. Direkter Zugriff über <span class='latex-texttt'>new</span> oder statische Methoden umgeht den Proxy und damit den Scope-Mechanismus. Verwenden Sie immer <span class='latex-texttt'>@Inject</span>, um korrekt verwaltete Referenzen zu erhalten.</div> <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3' ><span class='entry-number'>2.3</span> CDI Standard-Scopes</a> </h2>
 Da das ursprüngliche Ziel von CDI die Verbindung zwischen JSF und EJBs war,
wurden in der CDI-Spezifikation sämtliche JSF-Scopes als CDI Normal-Scopes nochmals definiert.
Somit stehen mit CDI standardmäßig  <span class='latex-texttt'>@ApplicationScoped</span> ,  <span class='latex-texttt'>@SessionScoped</span>  und  <span class='latex-texttt'>@RequestScoped</span>  zur Verfügung.
Zusätzlich wurde ein neuer Conversation-Scope eingeführt. In diesem Kapitel beschränken wir uns auf eine Zusammenfassung der Standard-Scopes.
Konkrete Beispiele zu Web-Scopes werden wir in den Kapiteln  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  (JSF) und
 <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  (DS Test-Control) analysieren.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.1' ><span class='entry-number'>2.3.0.1</span> @ApplicationScoped</a></h4>
 Wie der Name bereits vermuten lässt, existieren application-scoped Contextual-Instances nach dem ersten Zugriff bis zum Ende der Applikation.
Somit handelt es sich um einen applikationsweiten Singleton.<br /> <div class="tip"><b>Tipp: </b> Der Begriff "Applikation" wird nicht genau definiert.
Selbst nach über 100 Kommentaren beim Spezifikationsticket CDI-129 zeichnet sich keine vollständig akzeptierte Definition ab.
Zu diesem Zeitpunkt ist lediglich klar, dass Weld und OpenWebBeans den Applikationsbegriff anders definieren,
sobald die Applikation in einer EAR-Datei verpackt wird. OpenWebBeans hält sich an das referenzierte Verhalten der Servlet-Spezifikation,
wohingegen sich Weld an der EJB-Welt orientiert.
Daher ist mit Weld eine application-scoped Contextual-Instance in allen Web-Applikationen eines EARs gültig,
sofern darauf zugegriffen werden kann. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In unserer Applikation können wir, wie in Listing  <a href='#!idx:/cdi_basics.html:fig:application-scoped_bean'> Verwendung von Scopes </a> ,
beispielsweise  <span class='latex-texttt'>IdeaManager</span>  mit  <span class='latex-texttt'>@ApplicationScoped</span>  annotieren.
Der Rest der Applikation bleibt unverändert. Die Veränderung zur Laufzeit ist in diesem Fall nur im Debugger ersichtlich.
Da diese Klasse zustandslos implementiert ist, gibt es keine unmittelbar merkbare Auswirkung in der Applikation und
die Unit-Tests müssen nicht angepasst werden. Im Debugger können Sie jedoch feststellen, dass die Referenzvariablen,
welche vom CDI-Container mit einer Contextual-Reference auf  <span class='latex-texttt'>IdeaManager</span>  befüllt werden,
zur Laufzeit nicht wie bisher direkt auf die Contextual-Instance verweisen, sondern auf einen entsprechenden Proxy.
Wie zu erwarten war, wird außerdem nur noch eine Contexual-Instance (je Container-Start) erzeugt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:application-scoped_bean'></a>                     <pre><code>@ApplicationScoped
public class IdeaManager {
  private IdeaValidator ideaValidator;

  protected IdeaManager() {
    //needed by proxy-libs
  }

  @Inject
  protected IdeaManager(IdeaValidator ideaValidator) {
    this.ideaValidator = ideaValidator;
  }
  //...
}
</code></pre>
                </div> 
 <div class="tip"><b>Tipp: </b> In Listing  <a href='#!idx:/cdi_basics.html:fig:application-scoped_bean'> Verwendung von Scopes </a>  wird Constructor-Injection verwendet.
Da die Contextual-Reference für normal-scoped Beans zur Laufzeit ein Proxy ist,
muss es möglich sein für diese Klasse eine Proxy-Instanz zu erzeugen. Dies ist in Java nur mit dem Default-Konstruktor machbar.
Der parametrisierte Konstruktor wird erst später für die Erzeugung der Contextual-Instance verwendet.
Wie oft der Default-Konstruktor aufgerufen werden darf ist nicht spezifiziert.
Initialisierungslogik sollte daher in eine mit  <span class='latex-texttt'>@PostConstruct</span> annotierte Methode verschoben werden. Dies bietet zusätzlich den Vorteil,
dass sämtliche Injection-Points bereits befüllt und somit verwendbar sind. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.2' ><span class='entry-number'>2.3.0.2</span> @SessionScoped</a></h4>
 In Hinsicht auf die Lebensdauer ist der CDI Session-Scope äquivalent zur Gültigkeit der aktuellen HTTP-Session.
Folglich ist eine session-scoped Contextual-Instance ein sogenannter Session-Singleton.
Über mehrere User-Sessions hinweg kann es mehrere Contextual-Instances eines Managed-Beans geben.
Innerhalb einer User-Session ist per Definition nur eine Contextual-Instance je Managed-Bean möglich.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Um Mechanismen wie beispielsweise Session-Replication zu ermöglichen, ist dieser Scope als passivierbar definiert.
In Scope-Annotationen wie beispielsweise  <span class='latex-texttt'>javax.enterprise.context.SessionScoped</span> wird dies durch  <span class='latex-texttt'>@NormalScope(passivating = true)</span>  angegeben.
Daher müssen die Bean-Klassen (in/)direkt das Interface  <span class='latex-texttt'>java.io.Serializable</span>  implementieren.
Referenzierte CDI-Beans müssen selbst nicht serialisierbar sein, wenn es normal-scoped Beans sind.
Zur Laufzeit sorgt der CDI-Container dafür, dass die Proxys serialisierbar sind.
Denn nur diese Proxys (Contextual-References), und nicht die referenzierten Contextual-Instances selbst,
werden mit einem passivierbaren Bean gespeichert. CDI-Proxys arbeiten unabhängig von der Passivierung immer gleich.
Mit einer eindeutigen (internen) Bean-ID wird die aktuell gültige Instanz gesucht bzw. bei Bedarf erzeugt und
anschließend wird die gewünschte Methode von der Contextual-Instance aufgerufen.<br /> <div class="tip"><b>Tipp: </b> Damit es zu keinen unerwarteten Problemen zur Laufzeit kommt,
schreibt CDI die Implementierung von  <span class='latex-texttt'>java.io.Serializable</span>  bei Beans mit einem passivierbaren Scope vor.
Diese Regel gilt immer, selbst wenn es effektiv nie in einer Applikation zu einer Passivierung von Beans kommt.
Somit muss diese Regel immer beim Applikationsstart vom CDI-Container überprüft werden.
In einem Fehlerfall wird der Startprozess abgebrochen und eine entsprechende Fehlermeldung ausgegeben. </div>
<div class="tip"><b>Tipp: </b><b>Häufiger Fehler &mdash; Serialisierung:</b> Normal-Scoped Beans in passivierbaren Scopes (z.B. <span class='latex-texttt'>@SessionScoped</span>) müssen <span class='latex-texttt'>Serializable</span> implementieren. Vergisst man dies, meldet der Container beim Start oder zur Laufzeit einen Fehler. Dies gilt auch für alle nicht-transienten Felder der Bean-Klasse.</div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.3' ><span class='entry-number'>2.3.0.3</span> @RequestScoped</a></h4>
 Äquivalent zu den bisher beschriebenen Scope-Definitionen sind request-scoped Beans Singletons je (HTTP-)Request und
somit nur für den aktuellen Request gültig. Request-Scoped Beans sind nicht passivierbar,
da ein HTTP-Request selbst nicht auf einem externen Speichermedium abgelegt und zu einem späteren Zeitpunkt reaktiviert werden kann.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.4' ><span class='entry-number'>2.3.0.4</span> @ConversationScoped</a></h4>
 Der Conversation-Scope wurde primär für JSF-basierte Applikationen spezifiziert.
Er ist mit einer Session je Browser-Fenster/Tab vergleichbar (inklusive Passivierbarkeit).
Allerdings muss die aktuelle Conversation manuell gestartet und beendet werden.
Wird eine Conversation nicht gestartet, dann handelt es sich um eine transiente Conversation,
die am Ende des Requests vom CDI-Container zerstört werden muss.
Um dies zu vermeiden kann  <span class='latex-texttt'>javax.enterprise.context.Conversation</span>  injiziert und die Methode  <span class='latex-texttt'>begin</span>  aufgerufen werden.
Dadurch stehen sämtliche conversation-scoped CDI-Beans so lange zur Verfügung,
bis explizit  <span class='latex-texttt'>end</span>  auf die injizierte Conversation aufgerufen wird.
Hier kommt die spezielle Integration mit JSF zu tragen. Eine Conversation wird nämlich nicht sofort beendet,
sondern erst nach dem nächsten Rendering-Prozess.
Durch diese Regel ist das Ende der Conversation unabhängig von der gewählten Art der JSF Navigation (Forward vs. Redirect).<br /> <div class="tip"><b>Tipp: </b> Leider sind CDI Standard-Conversations sehr stark limitiert und für viele Anwendungsfälle fachlich und technisch nicht geeignet.
Aus diesem Grund empfehlen wir stattdessen die Verwendung von (Grouped-)Conversations,
die mit CODI eingeführt und in DeltaSpike übernommen wurden (siehe Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a> ).
Hier wurden gezielt die Einschränkungen und Schwachstellen der CDI Standard-Conversations behoben.
Auf weitere Details zu (Grouped-)Conversations werden wir im Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  eingehen. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.5' ><span class='entry-number'>2.3.0.5</span> @Dependent</a></h4>
<span class='latex-texttt'>@Dependent</span>  ist derzeit der einzige Pseudo-Scope in der CDI Spezifikation und zugleich der Default-Scope für CDI-Beans.
In  <span class='latex-textit'>IdeaFork</span>  wird beispielsweise für  <span class='latex-texttt'>IdeaValidator</span>  kein Scope explizit angegeben.
Intern behandelt der CDI-Container solche Beans als wären sie explizit mit  <span class='latex-texttt'>@Dependent</span>  annotiert.
In unserer Applikation wird  <span class='latex-texttt'>IdeaValidator</span>  in  <span class='latex-texttt'>IdeaManager</span>  injiziert.
Die in  <span class='latex-texttt'>IdeaManager</span>  injizierte Instanz existiert daher so lange wie die Contextual-Instance von  <span class='latex-texttt'>IdeaManager</span> .
Im konkreten Fall existiert die Instanz von  <span class='latex-texttt'>IdeaManager</span>  bis zum Stopp der Applikation.
Im Zuge der Zerstörung der  <span class='latex-texttt'>IdeaManager</span> -Instanz wird die injizierte  <span class='latex-texttt'>IdeaValidator</span> -Instanz ebenfalls vom CDI-Container zerstört,
da  <span class='latex-texttt'>IdeaValidator</span>  implizit dependent-scoped ist.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Daraus folgt, dass die Lebensdauer einer dependent-scoped Contextual-Instance an die Lebensdauer der Contextual-Instance,
in die sie injiziert wird, gebunden ist. Somit entspricht die Lebensdauer von dependent-scoped Beans normalen Objekten,
die mit dem Schlüsselwort  <span class='latex-texttt'>new</span>  erzeugt und einer Instanzvariablen zugewiesen werden.
Bei dependent-scoped Beans übernimmt allerdings der CDI-Container die Erzeugung (inkl. eventueller Interceptoren,...) und
bei direkter Injizierung auch die Zerstörung der dependent-scoped Contextual-Instance.<br /> <div class="tip"><b>Tipp: </b> Bei der Verwendung der CDI Scope-Annotationen  <span class='latex-texttt'>@ApplicationScoped</span> ,  <span class='latex-texttt'>@SessionScoped</span>  und  <span class='latex-texttt'>@RequestScoped</span> ist es wichtig auf die Pakete zu achten. Importieren Sie irrtümlich  <span class='latex-texttt'>javax.faces.bean</span>  statt  <span class='latex-texttt'>javax.enterprise.context</span> ,
so verwenden Sie aus Sicht des CDI-Containers keine gültige Scope-Annotation und folglich wird der  <span class='latex-texttt'>Dependent</span> -Scope verwendet.
Portable Erweiterungen wie beispielsweise DeltaSpike übersetzen JSF-Annotationen für den CDI-Container,
wodurch diese häufige Fehlerquelle auf einfache Art und Weise beseitigt wird. </div>
<div class="tip"><b>Tipp: </b><b>Häufiger Fehler &mdash; Scope-Mismatch:</b> Wenn ein <span class='latex-texttt'>@Dependent</span>-Bean in ein <span class='latex-texttt'>@ApplicationScoped</span>-Bean injiziert wird, lebt die <span class='latex-texttt'>@Dependent</span>-Instanz so lange wie das Ziel-Bean &mdash; also die gesamte Applikationslaufzeit. Dies kann zu unerwartetem Zustandsverhalten führen. Prüfen Sie bei unerwarteten Nebeneffekten immer, ob die Scope-Kombination der beteiligten Beans korrekt ist.</div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.3.0.6' ><span class='entry-number'>2.3.0.6</span> Manuelle Scope-Steuerung</a></h4>
 In einer Java SE Applikation sind Web-Scopes nur beschränkt sinnvoll.
Dennoch kann es erforderlich sein eine portable CDI Erweiterung zu verwenden,
die einen oder mehrere dieser Scopes verwendet, um beispielsweise Werte für den aktuellen Request zu cachen.
Verwenden Sie CDI in einer Java SE Applikation, so können Sie trotzdem Beans mit Web-Scopes verwenden.
Allerdings müssen die Scopes explizit gestartet und wieder gestoppt werden.
In Web-Applikationen wird dies automatisch durch den Container durchgeführt, sofern es einen aktuellen HTTP-Request bzw. eine aktive HTTP-Session gibt.
Implementieren Sie beispielsweise einen Batch-Job, der als Bestandteil einer Web-Applikation deployed wird,
so müssen Sie die Scope-Steuerung manuell übernehmen.
Somit kann der Batch-Job im Hintergrund beispielsweise ohne einen realen HTTP-Request ausgeführt werden und auf Beans mit Web-Scopes zugreifen.
Auf technische Details zur manuellen Steuerung von Standard-Scopes werden wir im Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  eingehen.<br /> <div class="tip"><b>Tipp: </b> Ein Scope ist mit einer  <span class='latex-texttt'>Context</span> -Instanz verbunden,
die sämtliche Contextual-Instances des Scopes verwaltet und entscheidet, ob der Scope zu einem bestimmten Zeitpunkt aktiv ist.
Da es je Applikation (in einer JVM) nur eine  <span class='latex-texttt'>Context</span> -Instanz je Scope gibt,
ist diese dafür verantwortlich, für den aktuellen Thread die korrekte Contextual-Instance des jeweiligen Beans zur Verfügung zu stellen.
Im Umkehrschluss bedeutet dies, dass in einem Thread für ein Bean nur eine Contextual-Instance verfügbar ist.
Eine einfache Analogie hierzu ist eine Map. Für jeden Key (Managed-Bean) kann ein Wert (Contextual-Instance) abgelegt werden.
Abhängig von der Definition des Scopes kann es eine oder mehrere solcher Maps geben.
Im Falle des Application-Scopes gibt es beispielsweise eine Map für die gesamte Applikation.
Hingegen gibt es beispielsweise beim Request-Scope eine Map je (HTTP-)Request.
Ist der Kontext nicht aktiv, so wird eine  <span class='latex-texttt'>ContextNotActiveException</span>  geworfen,
wenn auf eine Contextual-Instance in diesem Kontext zugegriffen wird. </div><h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.4' ><span class='entry-number'>2.4</span> Qualifiers</a> </h2>
 Bisher hatten wir simple Konstellationen, bei denen wir genau ein Bean für eine Aufgabe hatten.
In solchen Fällen ist die direkte typsichere Injizierung kein Problem, da beim Injection-Point der gewünschte Typ angegeben wird.
In realen Applikationen treffen wir in der Regel auf umfangreichere Anforderungen.
Als konkretes Beispiel führen wir ein  <span class='latex-texttt'>ObjectConverter</span> -Interface in  <span class='latex-textit'>IdeaFork</span>  ein.
Implementierungen des Interfaces können Objekte in ein externes Text-Format konvertieren und umgekehrt.
Um beispielsweise verschiedene Exportformate zu unterstützen, sind unterschiedliche Implementierungen des Interfaces erforderlich.
In der Applikation soll jedoch nur gegen das Interface implementiert werden.
Folglich brauchen wir einen Mechanismus, um die konkreten Implementierungen beim Injection-Point zu identifizieren,
ohne die Implementierungsklasse selbst anzugeben. In CDI ist dies durch Qualifier-Annotationen abgedeckt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  wollen wir XML und JSON als externe Formate unterstützen.
Für XML verwenden wir vorerst JAXB und für JSON eine Bibliothek namens Gson (http://code.google.com/p/google-gson/).
Wir beginnen mit einfachen "Marker-Qualifiern". Ähnlich wie Marker-Interfaces dienen sie als zusätzliche Markierung.
Für die Erstellung der Qualifier-Annotationen  <span class='latex-texttt'>@XML</span>  und  <span class='latex-texttt'>@JSON</span> müssen wir uns überlegen, an welchen Stellen diese Annotationen verwendet werden sollen.
In einem ersten Schritt wollen wir die Implementierungsklassen annotieren ( <span class='latex-texttt'>ElementType.TYPE</span> ).
Später werden wir Producer-Methoden kennenlernen, für welche  <span class='latex-texttt'>ElementType.METHOD</span>  erforderlich wäre.
Bei möglichen Injection-Points können wir Felder ( <span class='latex-texttt'>ElementType.FIELD</span> )
sowie Methoden-(/Konstruktor-)Parameter ( <span class='latex-texttt'>ElementType.PARAMETER</span> ) unterstützen.
Damit der CDI-Container selbst erstellte Annotationen als Qualifier erkennt,
müssen wir unsere Annotationen mit  <span class='latex-texttt'>javax.inject.Qualifier</span>  annotieren.
Listing  <a href='#!idx:/cdi_basics.html:fig:marker-qualifier-annotation'> Einfache Qualifier-Annotation als Marker </a>  zeigt die vollständige Implementierung von  <span class='latex-texttt'>@JSON</span> .
 <span class='latex-texttt'>@XML</span>  unterscheidet sich nur durch den Namen der Annotation.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:marker-qualifier-annotation'></a>                     <pre><code>@Target({TYPE, FIELD})
@Retention(RUNTIME)
@Qualifier
public @interface JSON {}
</code></pre>
                </div> 
Mit den Qualifier-Annotationen  <span class='latex-texttt'>@JSON</span>  und  <span class='latex-texttt'>@XML</span>  können wir beide Implementierungen identifizieren.
Wie Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_qualifier'> Bean-Klasse mit Qualifier </a>  zeigt, annotieren wir hierfür die Implementierungsklassen mit dem entsprechenden Qualifier.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:bean_with_qualifier'></a>                     <pre><code>@JSON
@ApplicationScoped
public class JSONConverter implements ObjectConverter {
  @Override
  public &lt;T&gt; T toObject(String value, Class&lt;T&gt; type) {
    return new Gson().fromJson(value, type);
  }

  @Override
  public String toString(Object entity) {
    return new Gson().toJson(entity);
  }
}
</code></pre>
                </div> 
Da die Implementierung in Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_qualifier'> Bean-Klasse mit Qualifier </a>  zustandslos ist,
könnten wir ebenso auf den  <span class='latex-texttt'>Dependent</span> -Scope zurückgreifen,
wodurch nicht mehr benötigte Instanzen laufend durch den Garbage-Collector entsorgt werden müssen.
Der Proxy-Overhead ist mittlerweile minimal und daher gibt es hier keine "richtige" und keine "falsche" Wahl.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Um beispielsweise die Exportlogik unseres JSON-Konverters zu testen, können wir diesen in einem Unit-Test verwenden.
In Listing  <a href='#!idx:/cdi_basics.html:fig:injection-point_with_qualifier'> Injection-Point mit Qualifier </a>  injizieren wir den Konverter mit unserem allgemeinen  <span class='latex-texttt'>ObjectConverter</span> -Interface
in Verbindung mit  <span class='latex-texttt'>@JSON</span>  als Qualifier.
Ohne Qualifier-Annotationen könnten wir nie ein Interface mit mehreren Implementierungen injizieren und
müssten direkt die Implementierungsklasse beim Injection-Point angeben.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Wird kein Qualifier beim Injection-Point angegeben,
so verwendet der CDI-Container  <span class='latex-texttt'>javax.enterprise.inject.Default</span>  als Standard-Qualifier.
Geben wir in unserem Beispiel  <span class='latex-texttt'>@JSON</span>  nicht an, dann kann kein passendes CDI-Bean gefunden werden,
da wir bisher keine Implementierung explizit oder implizit mit dem  <span class='latex-texttt'>Default</span> -Qualifier annotiert haben.
In solchen Fällen wird der Containerstart mit einer  <span class='latex-texttt'>UnsatisfiedResolutionException</span>  abgebrochen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Würden wir komplett auf Qualifier verzichten und trotzdem den Interface-Typ beim Injection-Point verwenden,
dann wäre eine  <span class='latex-texttt'>AmbiguousResolutionException</span>  der Grund für den Abbruch des Containerstarts,
da mehrere Implementierungen mit dem impliziten  <span class='latex-texttt'>Default</span> -Qualifier verfügbar wären.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:injection-point_with_qualifier'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class QualifierTest {
  private String topic = "Learn CDI-Qualifiers";
  private String category = "Education";

  @Inject
  @JSON
  private ObjectConverter objectConverterJSON;

  @Inject
  private IdeaManager ideaManager;

  @Test
  public void jsonConversion() {
    Idea exportedIdea = ideaManager.createIdeaFor(topic, category);

    String jsonString =
      objectConverterJSON.toString(exportedIdea);

    Idea importedIdea =
      objectConverterJSON.toObject(jsonString, Idea.class);

    Assert.assertTrue(exportedIdea.equals(importedIdea));
  }
}
</code></pre>
                </div> 
In großen Projekten würden wir nach kurzer Zeit eine Vielzahl an Qualifier-Annotationen bekommen,
wenn wir zu jeder Implementierung eine Annotation benötigen würden.
Aus diesem Grund ist es möglich beliebige Zusatzinformationen in einer Qualifier-Annotation aufzunehmen.
In unserem Fall können wir statt  <span class='latex-texttt'>@XML</span>  und  <span class='latex-texttt'>@JSON</span>  einen Qualifier mit dem Namen  <span class='latex-texttt'>@ExternalFormat</span>  verwenden.
Um weiterhin zwischen XML und JSON unterscheiden zu können, fügen wir ein  <span class='latex-texttt'>enum</span>  hinzu.
Listing  <a href='#!idx:/cdi_basics.html:fig:qualifier-annotation_with_member'> Qualifier mit Annotation-Attribut </a>  zeigt die Implementierung von  <span class='latex-texttt'>@ExternalFormat</span>  und
Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_qualifier_with_member'> Verwendung von Qualifiern mit Annotation-Attribut </a>  die geänderte Verwendung bei der Implementierung und einem Injection-Point.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:qualifier-annotation_with_member'></a>                     <pre><code>@Target({TYPE, METHOD, FIELD, PARAMETER})
@Retention(RUNTIME)
@Qualifier
public @interface ExternalFormat {
  TargetFormat value();

  enum TargetFormat {
    XML, JSON
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:bean_with_qualifier_with_member'></a>                     <pre><code>@ExternalFormat(ExternalFormat.TargetFormat.JSON)
@ApplicationScoped
public class JSONConverter implements ObjectConverter {
    //...
}

@RunWith(CdiTestRunner.class)
public class QualifierTest {

  @Inject
  @ExternalFormat(JSON)
  private ObjectConverter objectConverterJSON;

  //...
}
</code></pre>
                </div> 
Bei verschiedenen Anwendungsfällen kann es erforderlich sein Informationen zur Verfügung zu stellen,
die von CDI ignoriert werden sollen. Für solche Fälle können Annotation-Attribute mit  <span class='latex-texttt'>@Nonbinding</span>  annotiert werden.
In Listing  <a href='#!idx:/cdi_basics.html:fig:qualifier_with_nonbinding'> Exkludiertes Annotation-Attribut </a>  wird  <span class='latex-texttt'>@ExternalFormat</span>  um eine optionale Beschreibung erweitert,
die vom CDI-Container nicht für die Qualifier-Logik verwendet wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:qualifier_with_nonbinding'></a>                     <pre><code>@Target({TYPE, FIELD})
@Retention(RUNTIME)
@Qualifier
public @interface ExternalFormat {
  TargetFormat value();

  @Nonbinding
  String description() default "";

  enum TargetFormat {
    XML, JSON
  }
}
</code></pre>
                </div> 
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5' ><span class='entry-number'>2.5</span> Dynamische Verwendung von CDI-Beans</a> </h2>
 Bisher haben wir "direkte" Injizierung verwendet. Es gab immer einen expliziten Injection-Point,
der vom CDI-Container zur Laufzeit mit einer Contextual-Reference automatisch befüllt wird.
Diese Injection-Points werden während des Containerstarts auf ihre Gültigkeit überprüft,
da es für solche Injection-Points jeweils genau ein Managed-Bean geben muss.
Es gibt jedoch Fälle in denen wir optionale oder sogar mehrere Managed-Beans benötigen.
Für solche Anwendungsfälle müssen Beans dynamisch gesucht werden.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.1' ><span class='entry-number'>2.5.0.1</span> Indirektion mit Instance</a></h4>
<a name = '!idx:/cdi_basics.html:sec:lookup_via_instance'> </a> Im vorherigen Kapitel haben wir den  <span class='latex-texttt'>ObjectConverter</span>  in Kombination mit dem Qualifier für JSON bzw. XML direkt injiziert.
Listing  <a href='#!idx:/cdi_basics.html:fig:injection_with_instance'> Dynamische Injizierung mit Instance </a>  zeigt das direkte Äquivalent über dynamische Injection
mit Hilfe von  <span class='latex-texttt'>javax.enterprise.inject.Instance</span> .
Dieses Interface erweitert  <span class='latex-texttt'>javax.inject.Provider</span> , welches die Methode  <span class='latex-texttt'>get</span>  definiert.
Erst durch den Aufruf dieser Methode wird der Lookup durchgeführt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:injection_with_instance'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  //...

  @Inject
  @ExternalFormat(JSON)
  private Instance&lt;ObjectConverter&gt; objectConverterJSONInstance;

  @Test
  public void jsonConversion() {
    //...
    String jsonString =
      objectConverterJSONInstance.get().toString(exportedIdea);
    //...
  }
}
</code></pre>
                </div> 
Vor dem Aufruf von  <span class='latex-texttt'>get</span>  kann mithilfe der Methode  <span class='latex-texttt'>isUnsatisfied</span>  überprüft werden,
ob der Lookup überhaupt ein Ergebnis liefern würde oder zu einer  <span class='latex-texttt'>UnsatisfiedResolutionException</span>  führt.
Über diesen Mechanismus sind optionale Beans möglich.
So können wir beispielsweise unseren  <span class='latex-texttt'>ExternalFormat</span> -Qualifier um ein zusätzliches Format (CSV) erweitern.
Wir stellen jedoch keine Implementierung zur Verfügung und erhalten dadurch ein optionales Bean.
Ein Plug-in für die Applikation könnte nachträglich eine solche Implementierung hinzufügen.
Oftmals wird dieses Konzept für simple Interfaces (ohne Qualifier-Annotationen) mit nur einer optionalen Implementierung verwendet.
Listing  <a href='#!idx:/cdi_basics.html:fig:dynamic_injection_with_optional_beans'> Dynamische Injizierung für optionale Beans </a>  zeigt einen entsprechenden Unit-Test.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:dynamic_injection_with_optional_beans'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  @ExternalFormat(CSV)
  private Instance&lt;ObjectConverter&gt; objectConverterCSVInstance;

  @Test(expected = UnsatisfiedResolutionException.class)
  public void optionalConverter() {
    Assert.assertTrue(objectConverterCSVInstance.isUnsatisfied());
    objectConverterCSVInstance.get();
  }
}
</code></pre>
                </div> 
Eine weitere Möglichkeit ist die Verwendung mehrerer Beans vom gleichen Typ.
Vor dem Aufruf von  <span class='latex-texttt'>get</span>  kann mit  <span class='latex-texttt'>isAmbiguous</span>  überprüft werden,
ob das Ergebnis des Methodenaufrufs zu mehreren Beans und somit zu einer  <span class='latex-texttt'>AmbiguousResolutionException</span>  führen würde.
Hierfür können wir beispielsweise einen Lookup auf alle Implementierungen vom Type  <span class='latex-texttt'>ObjectConverter</span>  machen.
CDI stellt für einen solchen Lookup einen "virtuellen" Qualifier namens  <span class='latex-texttt'>javax.enterprise.inject.Any</span>  zur Verfügung.
Listing  <a href='#!idx:/cdi_basics.html:fig:dynamic_injection_with_multiple_beans_and_get'> Dynamische Injizierung mit mehreren Beans </a>  zeigt einen entsprechenden Unit-Test.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:dynamic_injection_with_multiple_beans_and_get'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  @Any
  private Instance&lt;ObjectConverter&gt; converterInstance;

  @Test(expected = AmbiguousResolutionException.class)
  public void ambiguousConverter() {
    Assert.assertTrue(converterInstance.isAmbiguous());
    converterInstance.get();
  }
}
</code></pre>
                </div> 
Es gibt jedoch auch Anwendungsfälle, bei denen mehrere Beans vom gleichen Typ benötigt werden.
Ein Beispiel hierfür sind Plug-ins. In solchen Fällen kann nicht die Methode  <span class='latex-texttt'>get</span>  verwendet werden.
Allerdings erweitert  <span class='latex-texttt'>Instance</span>  ebenfalls das Interface  <span class='latex-texttt'>Iterable</span>  und
daher kann die injizierte  <span class='latex-texttt'>Instance</span>  beispielsweise in einer Schleife verwendet werden.
Listing  <a href='#!idx:/cdi_basics.html:fig:dynamic_injection_with_multiple_beans_and_iterator'> Dynamische Injizierung mit mehreren Beans </a>  illustriert dies
anhand eines automatischen Tests aller  <span class='latex-texttt'>ObjectConverter</span> -Beans.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:dynamic_injection_with_multiple_beans_and_iterator'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  @Any
  private Instance&lt;ObjectConverter&gt; converterInstance;

  @Inject
  private IdeaManager ideaManager;

  @Test
  public void allConverters() {
    Assert.assertTrue(converterInstance.isAmbiguous());
    Assert.assertFalse(converterInstance.isUnsatisfied());

    for (ObjectConverter converter : converterInstance) {
      Idea idea = ideaManager.createIdeaFor(...);
      String exported = converter.toString(idea);
      Assert.assertTrue(
        converter.toObject(exported, Idea.class).equals(idea));
    }
  }
}
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.2' ><span class='entry-number'>2.5.0.2</span> Beans via BeanManager finden</a></h4>
<a name = '!idx:/cdi_basics.html:sec:lookup_via_bm'> </a> Der  <span class='latex-texttt'>BeanManager</span>  dient zur Interaktion mit dem CDI-Container.
Über ihn können Sie beispielsweise überprüfen, ob eine Annotation ein Qualifier ist, Events feuern, Beans manuell suchen und vieles mehr.
Eine Referenz auf den  <span class='latex-texttt'>BeanManager</span>  kann injiziert oder beispielsweise via JNDI abgerufen werden.
Normalerweise ist es nicht erforderlich Contextual-References mit dem  <span class='latex-texttt'>BeanManager</span>  zu holen.
In vielen Fällen wird ein solcher manueller Lookup in Klassen verwendet, die nicht durch den CDI-Container verwaltet werden.
Ohne  <span class='latex-texttt'>CdiTestRunner</span>  wäre dies eine der Möglichkeiten Unit-Tests ohne spezielle CDI-Unterstützung zu implementieren.
Listing  <a href='#!idx:/cdi_basics.html:fig:manual_bean-lookup'> Manueller Lookup via BeanManager </a>  zeigt die Schritte, um eine Contextual-Reference auf  <span class='latex-texttt'>IdeaManager</span>  zu bekommen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:manual_bean-lookup'></a>                     <pre><code>Set&lt;Bean&lt;?&gt;&gt; beans = this.beanManager.getBeans(IdeaManager.class);
Bean&lt;?&gt; bean = beanManager.resolve(beans);
CreationalContext&lt;?&gt; creationalContext =
  beanManager.createCreationalContext(bean);
this.ideaManager = (IdeaManager)this.beanManager.getReference(
  bean, IdeaManager.class, creationalContext);
</code></pre>
                </div> 
Im ersten Schritt ist das Ergebnis ein Set von Beans, da hier beispielsweise alternative Beans,
die wir noch kennenlernen werden, enthalten sein können.
Erst durch den Aufruf von  <span class='latex-texttt'>resolve</span>  im zweiten Schritt wird ein gültiges Ergebnis geliefert.
Selbst wenn in vielen Fällen das Set nur einen Eintrag enthält, dürfen Sie den zweiten Schritt nicht auslassen und
immer das erste Bean im Set verwenden, da dies später zu unerwarteten Seiteneffekten führen kann.
Auf Basis der Managed-Bean-Definition kann der sogenannte  <span class='latex-texttt'>CreationalContext</span>  erzeugt werden.
Zusammen mit dem Bean und dem erwarteten Zieltyp muss dieser an  <span class='latex-texttt'>getReference</span>  übergeben werden,
um schließlich eine Contextual-Reference zu erhalten.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.3' ><span class='entry-number'>2.5.0.3</span> Dependent-Scoped Beans</a></h4>
 Auch bei dynamischer Injizierung bzw. einem manuellem Lookup nehmen dependent-scoped Beans eine Sonderstellung ein.
Denn das Bean wird für jeden dieser dynamischen Aufrufe vom CDI-Container erzeugt und nach außen gegeben.
Daraus folgt, dass der Container die Contextual-Instance danach nicht mehr verwaltet und
somit auch nicht mehr für die Zerstörung dieser zuständig ist.
Selbst wenn in einem weiteren Schritt eine manuelle Zuweisung an eine Instanzvariable eines normal-scoped Beans durchgeführt wird,
handelt es sich weiterhin um eine manuell verwaltete Instanz, da diese Instanzvariable kein regulärer Injection-Point ist.
In solchen speziellen Fällen muss die Zerstörung manuell durchgeführt werden.
Hierfür müssen Sie sich die  <span class='latex-texttt'>CreationalContext</span> -Instanz und die Managed-Bean-Definition speichern,
um später via  <span class='latex-texttt'>bean.destroy(contextualInstance, creationalContext)</span>  das dependent-scoped Bean korrekt zerstören zu können.
Manuelle Bean-Lookups sollten daher immer die Ausnahme bleiben und mit Sorgfalt umgesetzt werden.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.4' ><span class='entry-number'>2.5.0.4</span> Literals</a></h4>
 Annotationen sind in Java statische Metadaten, die nicht manuell instanziiert werden können.
Im vorherigen Kapitel haben wir gesehen, dass es Qualifier-Annotationen mit Attributen gibt.
In Kombination mit direkter Injizierung stoßen wir auf keine Einschränkungen.
Für das dynamische Auffinden eines Beans mit Qualifier benötigen wir allerdings Instanzen einer Annotation,
damit wir die gewünschten Werte zur Verfügung stellen können.
Um, trotz der Einschränkung von Java, Instanzen von Annotationen zu erzeugen, bedient sich CDI einem Trick.
Durch die Erstellung einer  <span class='latex-texttt'>Annotation-Literal</span> -Klasse
kann der JVM eine manuell erstellte Instanz der dazugehörigen Annotation zur Verfügung gestellt werden.
Listing  <a href='#!idx:/cdi_basics.html:fig:annotation-literal'> Annotation Literal für ExternalFormat </a>  zeigt ein Literal für  <span class='latex-texttt'>ExternalFormat</span> .
Hierfür muss von  <span class='latex-texttt'>javax.enterprise.util.AnnotationLiteral</span>  abgeleitet und der Annotation-Typ implementiert werden.
Wie bei einem Interface müssen sämtliche Annotation-Methoden implementiert werden.
Üblicherweise ändern sich Werte von Literals nicht und
somit können die gewünschten Werte direkt über einen parametrisierten Konstruktor übergeben werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:annotation-literal'></a>                     <pre><code>public class ExternalFormatLiteral
  extends AnnotationLiteral&lt;ExternalFormat&gt;
  implements ExternalFormat {
    private final TargetFormat value;

    public ExternalFormatLiteral(TargetFormat value) {
      this.value = value;
    }

    @Override
    public TargetFormat value() {
      return this.value;
    }

    @Override
    public String description() {
      return "";
    }
}
</code></pre>
                </div> Ausgerüstet mit der Literal-Klasse können wir die  <span class='latex-texttt'>select</span> -Methode von Instance verwenden,
um die Suche mit einem Qualifier einzuschränken.
Beim Injection-Point von  <span class='latex-texttt'>Instance</span>  wird in solchen Fällen normalerweise  <span class='latex-texttt'>@Any</span>  verwendet,
da der effektive Qualifier später dynamisch definiert wird.
Listing  <a href='#!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_instance'> Verwendung von Annotation Literal mit Instance </a>  illustriert die Verwendung unseres Annotation-Literals
in Kombination mit  <span class='latex-texttt'>Instance</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_instance'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  @Any
  private Instance&lt;ObjectConverter&gt; converterInstance;

  @Inject
  private IdeaManager ideaManager;

  @Test
  public void xmlConversion() {
    Idea exportedIdea = ideaManager.createIdeaFor(...);

    Assert.assertTrue(converterInstance.isAmbiguous());
    Assert.assertFalse(converterInstance.isUnsatisfied());

    String xmlString = converterInstance.select(
      new ExternalFormatLiteral(XML)).get()
      .toString(exportedIdea);

    //...
  }
}
</code></pre>
                </div> 
Unser Annotation-Literal können wir natürlich ebenso für den Lookup via  <span class='latex-texttt'>BeanManager</span>  verwenden.
Listing  <a href='#!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_bean-manager'> Verwendung von Annotation Literal mit BeanManager </a>  erweitert Listing  <a href='#!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_instance'> Verwendung von Annotation Literal mit Instance </a> um einen zweiten Bean-Lookup via  <span class='latex-texttt'>BeanManager</span>  statt via  <span class='latex-texttt'>Instance</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:lookup_with_annotation-literal_with_bean-manager'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class LookupTest {
  @Inject
  private BeanManager beanManager;

  @Inject
  @Any
  private Instance&lt;ObjectConverter&gt; converterInstance;

  @Inject
  private IdeaManager ideaManager;

  @Test
  public void xmlConversion() {
    Idea exportedIdea = ideaManager.createIdeaFor(...);

    Assert.assertTrue(converterInstance.isAmbiguous());
    Assert.assertFalse(converterInstance.isUnsatisfied());

    String xmlString = converterInstance.select(
      new ExternalFormatLiteral(XML)).get()
      .toString(exportedIdea);

    Set&lt;Bean&lt;?&gt;&gt; beans = beanManager.getBeans(
      ObjectConverter.class, new ExternalFormatLiteral(XML));
    Bean&lt;?&gt; bean = beanManager.resolve(beans);
    CreationalContext&lt;?&gt; creationalContext =
      beanManager.createCreationalContext(bean);

    ObjectConverter xmlConverter =
      (ObjectConverter)this.beanManager.getReference(
        bean, ObjectConverter.class, creationalContext);

    Idea importedIdea =
      xmlConverter.toObject(xmlString, Idea.class);
    Assert.assertTrue(exportedIdea.equals(importedIdea));
  }
}
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.5.0.5' ><span class='entry-number'>2.5.0.5</span> Type-Literal</a></h4>
 Einen vergleichbaren Helper gibt es für parametrisierte Klassen und wird Type-Literal genannt.
Die Anwendungsfälle hierfür sind jedoch eher rar. Sollten Sie auf einen solchen stoßen,
dann können Sie  <span class='latex-texttt'>TypeLiteral</span>  ähnlich zu Annotation-Literals verwenden.
Ein Beispiel hierfür ist:  <span class='latex-texttt'>new TypeLiteral&lt;MyBean&lt;MyType&gt;&gt;(){}</span> .<br />  
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6' ><span class='entry-number'>2.6</span> Producer-/Disposer- Methoden</a> </h2>
 In den meisten Fällen ist es ausreichend eine einfache Java-Klasse als CDI-Bean zu verwenden.
Der CDI-Container instanziiert die Klasse und führt verschiedene Zusatzfunktionalitäten wie beispielsweise Dependency-Injection aus.
Spezielle Initialisierungslogik kann in einer mit  <span class='latex-texttt'>@javax.annotation.PostConstruct</span>  annotierten Methode implementiert werden und
vor der Zerstörung der Instanz kann mithilfe einer  <span class='latex-texttt'>@javax.annotation.PreDestroy</span>  annotierten Methode dafür gesorgt werden,
dass die erforderlichen Aufräumarbeiten durchgeführt werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Es gibt allerdings Anwendungsfälle, in denen komplexere Anforderungen gegeben sind oder Klassen verwendet werden müssen,
für die spezielle Initialisierungslogik bzw. Aufräumarbeiten erfolgen müssen.
Einer dieser Anwendungsfälle ist die typsichere Konfiguration von Applikationen.
Viele Applikationen sind über konfigurierte Werte anpassbar.
Diese Werte werden entweder in Konfigurationsdateien mitgeliefert oder aus einer zentralen Quelle wie beispielsweise einer Datenbank geladen.
Hierbei können beispielsweise Tippfehler zu Abbrüchen bzw. schwerwiegenden Fehlern in der Applikation führen.
In manchen Fällen werden solche Fehler erst spät entdeckt, vor allem wenn konfigurierte Werte erst bei Bedarf eingelesen und konvertiert werden.
Um derartigen Fehlern entgegenzuwirken, erstellen wir im nächsten Schritt eine typsichere Applikationskonfiguration und
eine Producer-Methode für die manuelle Initialisierung des Konfigurationsobjekts.<br /> <div class="tip"><b>Tipp: </b> Typsichere Konfigurationen können einfache POJOs sein, die als CDI-Beans verwendbar sind.
CDI-Erweiterungen wie beispielsweise CODI und DeltaSpike stellen über dieses simple Konzept typsichere Konfigurationen zur Verfügung.
Die Default-Werte der Konfiguration sind oftmals hartcodiert.
Durch alternative Implementierungen, die wir im Kapitel  <a href='#!idx:/cdi_basics.html:sec:cdi-alternatives'> [ Beans ersetzen] </a>  näher betrachten werden,
können die vorgegebenen Werte auf einfache Weise angepasst werden. </div> In  <span class='latex-textit'>IdeaFork</span>  wollen wir vorerst eine simple Konfigurationsdatei anbinden und
deren Werte typsicher in der Applikation zur Verfügung stellen.
Die konfigurierten Werte hinterlegen wir in einer Property-Datei als Key/Value-Paare.
Einlesen können wir sie mit Hilfe von  <span class='latex-texttt'>java.util.ResourceBundle</span> .
In unserer Konfigurationsklasse namens  <span class='latex-texttt'>ApplicationConfig</span>  übergeben wir im Konstruktor nur eine  <span class='latex-texttt'>ResourceBundle</span> -Instanz und
laden Informationen wie beispielsweise den Applikationsnamen.
Die Logik für die Erzeugung der  <span class='latex-texttt'>ResourceBundle</span> -Instanz wollen wir in einen Producer auslagern.
Um die Typsicherheit besser zu veranschaulichen, fügen wir zusätzlich einen eigenen  <span class='latex-texttt'>ApplicationVersion</span> -Typ hinzu.
In Listing  <a href='#!idx:/cdi_basics.html:fig:producer-method'> Producer-Methode </a>  erzeugt die Producer-Methode ein application-scoped Bean vom Typ  <span class='latex-texttt'>ApplicationConfig</span> .
Diese Implementierung ist sehr einfach gehalten.
Zusätzlich könnte beispielsweise Bean-Validation verwendet werden, um die geladenen und konvertierten Werte auch zu validieren.
Darüber hinaus unterstützen auch Producer optional Qualifier-Annotationen.
Diesen Vorteil werden wir etwas später für die dynamische Selektierung einer Default-Implementierung nutzen.<br />die in einfachen Anwendungsfällen wie diesem nicht erforderlich sind.<br /> <div class="tip"><b>Tipp: </b> Würde nur die Annotation  <span class='latex-texttt'>@Produces</span>  verwendet,
so würden wir einen Producer für ein implizit dependent-scoped Bean mit  <span class='latex-texttt'>Default</span> -Qualifier erstellen. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ohne die Verwendung eines Qualifiers stehen wir jedoch wieder vor dem Problem, dass wir zwei Managed-Beans mit dem gleichen Typ haben.
Da wir das Ergebnis der Producer-Methode als Managed-Bean für  <span class='latex-texttt'>ApplicationConfig</span>  verwenden wollen und
nicht die  <span class='latex-texttt'>ApplicationConfig</span> -Klasse selbst, müssen wir dem CDI-Container signalisieren,
dass die  <span class='latex-texttt'>ApplicationConfig</span> -Klasse nicht verwendet werden soll.
Wie wir später noch kennenlernen werden, ist dies über ein Veto des Beans möglich.
Hierfür müssen wir entweder eine CDI-Erweiterung erstellen oder eine bestehende verwenden.
Erst ab CDI 1.1 kann ein solches Veto über die  <span class='latex-texttt'>@Vetoed</span>  Annotation ohne Zusätze verwendet werden.
Mit CDI 1.0 gibt es dennoch einen simplen Trick ohne die zuvor erwähnten Erweiterungen.
Die Annotation  <span class='latex-texttt'>@Typed</span>  ermöglicht die explizite Typisierung.
Implementiert beispielsweise eine Klasse eines CDI-Beans zwei Interfaces, so kann mit  <span class='latex-texttt'>@Typed</span>  festgelegt werden,
dass diese Bean-Klasse für den Injection-Prozess nur einen der beiden Typen bekommt.
Diese Annotation kann auch ohne Angabe eines Typs verwendet werden, wodurch das Managed-Bean für typsichere Injizierung unsichtbar wird.
Annotieren wir daher die  <span class='latex-texttt'>ApplicationConfig</span> -Klasse mit  <span class='latex-texttt'>@Typed()</span> , nehmen wir eines der beiden Beans aus dem Spiel und
somit existiert nur noch die Producer-Methode mit dem Typ  <span class='latex-texttt'>ApplicationConfig</span> .
Listing  <a href='#!idx:/cdi_basics.html:fig:custom_type-safe_config'> Klasse für eine typsichere Konfiguration </a>  zeigt einen Ausschnitt der Klasse  <span class='latex-texttt'>ApplicationConfig</span>  und
Listing  <a href='#!idx:/cdi_basics.html:fig:producer-method'> Producer-Methode </a>  die Producer-Methode.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:custom_type-safe_config'></a>                     <pre><code>@Typed()
public class ApplicationConfig {
  private String applicationName;
  private ApplicationVersion applicationVersion;

  protected ApplicationConfig() {
    //needed for creating a proxy
  }

  public ApplicationConfig(ResourceBundle config) {
    applicationName = config.getString("name");
    applicationVersion =
      new ApplicationVersion(config.getString("version"));
  }
  //+ Getter-Methods

  public static class ApplicationVersion {
    //...
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:producer-method'></a>                     <pre><code>@Produces
@ApplicationScoped
public ApplicationConfig exposeConfig() {
  ResourceBundle config = ResourceBundle.getBundle("app-config");
  return new ApplicationConfig(config);
}
</code></pre>
                </div> 
Wie wir bereits wissen, wird für normal-scoped Beans ein Proxy erzeugt.
Da die Producer-Methode in Listing  <a href='#!idx:/cdi_basics.html:fig:producer-method'> Producer-Methode </a>  ein normal-scoped Bean definiert,
muss es folglich in der  <span class='latex-texttt'>ApplicationConfig</span> -Klasse einen Default-Konstruktor geben.<br /> <div class="tip"><b>Tipp: </b> Um Klassen außerhalb von CDI-Archiven als CDI-Beans zu verwenden,
gibt es neben der Verwendung von Producer-Methoden (oder -Feldern) verschiedene Möglichkeiten,
die im Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  vorgestellt werden.
Komplexere Initialisierungslogik kann hingegen nur mit einer Producer-Methode umgesetzt werden. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6.0.1' ><span class='entry-number'>2.6.0.1</span> Manuelle Injection</a></h4>
 CDI-Beans, die über einen Producer erzeugt werden, haben ein paar Einschränkungen.
Der CDI-Container führt keine Dependency-Injection auf das erzeugte Objekt aus und es werden auch keine Interceptoren hinzugefügt,
da die Erzeugung und Initialisierung der Contextual-Instance manuell im Producer vorgenommen wird und
Interceptoren die Producer-Methode intercepten und nicht auf das Ergebnis des Producers angewandt werden.
Mit dem Trick aus Listing  <a href='#!idx:/cdi_basics.html:fig:manual_injection'> Manueller Field- und Method-Injection Trick </a>  können Sie Field- und Method-Injection manuell anstoßen.
In dem Quelltextausschnitt steht  <span class='latex-texttt'>unmanagedBean</span>  für die manuell erzeugte Instanz.
Beachten Sie jedoch, dass Sie dependent-scoped Beans zwar injecten können,
aber durch den fehlenden  <span class='latex-texttt'>CreationalContext</span>  der injizierten Beans diese nicht korrekt zerstören können.
Allerdings ist die primäre Auswirkung, dass dependent-scoped Beans in Kombination mit einer solchen manuellen Injection
keine  <span class='latex-texttt'>@PreDestroy</span>  annotierten Methoden verwenden können. Mit dem entsprechenden Detailwissen über diese Beans
können bei Bedarf die Callback-Methoden manuell in der (optionalen) Disposer-Methode aufgerufen werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:manual_injection'></a>                     <pre><code>CreationalContext creationalContext =
  this.beanManager.createCreationalContext(null);
AnnotatedType annotatedType = this.beanManager
  .createAnnotatedType(unmanagedBean.getClass());
InjectionTarget injectionTarget = this.beanManager
  .createInjectionTarget(annotatedType);
injectionTarget.inject(unmanagedBean, creationalContext);
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6.0.2' ><span class='entry-number'>2.6.0.2</span> Disposer-Methoden</a></h4>
 Das optionale Gegenstück zur Producer-Methode ist die Disposer-Methode.
Wie bereits erwähnt, unterstützen Beans, die mit einem Producer erzeugt werden, keine Lifecycle-Callbacks.
Die Aufgabe von  <span class='latex-texttt'>@PostConstruct</span>  übernimmt der Producer selbst und
statt  <span class='latex-texttt'>@PreDestroy</span>  kann eine sogenannte Disposer-Methode verwendet werden.
Wie Listing  <a href='#!idx:/cdi_basics.html:fig:disposer-method'> Disposer-Methode </a>  zeigt, handelt es sich hierbei um eine Methode mit mindestens einem Parameter.
Der Typ und die Qualifier müssen mit jenen der Producer-Methode übereinstimmen.
Zusätzlich muss der erste verpflichtende Parameter mit  <span class='latex-texttt'>@Disposes</span>  annotiert werden.
Erst durch diese Annotation erkennt der CDI-Container die Methode als Disposer.
Da  <span class='latex-texttt'>ApplicationConfig</span>  application-scoped ist, wird die Disposer-Methode vor jedem Applikationsstopp ausgeführt.
In unserem einfachen Beispiel loggen wir die Version der Applikation, die heruntergefahren wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:disposer-method'></a>                     <pre><code>public void onDispose(@Disposes
  ApplicationConfig applicationConfig) {
    LOGGER.info("shutting down v"
      + applicationConfig.getApplicationVersion());
}
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6.0.3' ><span class='entry-number'>2.6.0.3</span> Mit Producer-Methoden Beans selektieren</a></h4>
 Producer-Methoden können beispielsweise ebenfalls zur Selektion einer Default-Implementierung verwendet werden.
Beginnen wir vorerst mit einer möglichst einfachen Producer-Methode.
Den  <span class='latex-texttt'>Default</span> -Qualifier haben wir bei den  <span class='latex-texttt'>ObjectConverter</span> -Implementierungen weder explizit noch implizit in Verwendung.
Somit müssen wir keinen neuen Qualifier definieren, sondern können auf den  <span class='latex-texttt'>Default</span> -Qualifier zurückgreifen.
In Listing  <a href='#!idx:/cdi_basics.html:fig:simple_selection_via_producer-method'> Einfache Selektion via Producer </a>  ist die minimale Variante dargestellt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:simple_selection_via_producer-method'></a>                     <pre><code>public class CurrentObjectConverterProducer {
  @Produces
  protected ObjectConverter defaultConverter (
    @ExternalFormat(JSON) ObjectConverter objectConverter) {
      return objectConverter;
  }
}
</code></pre>
                </div> 
Der  <span class='latex-texttt'>Default</span> -Qualifier sowie der  <span class='latex-texttt'>Dependent</span> -Scope müssen nicht explizit angegeben werden.
Wir könnten natürlich die entsprechende Implementierung manuell instanziieren, statt einen Injection-Point zu verwenden.
Wie bereits zuvor erwähnt würden wir dabei auf einige CDI-Funktionalitäten verzichten.
Listing  <a href='#!idx:/cdi_basics.html:fig:simple_selection_via_producer-method'> Einfache Selektion via Producer </a>  veranschaulicht zusätzlich, dass Producer-Methoden optional Parameter verwenden können.
Jeder Parameter stellt dabei einen eigenen (impliziten) Injection-Point dar, der durch den CDI-Container wie gewohnt automatisch injiziert wird.
In diesem einfachen Producer wählen wir durch den Injection-Point die gewünschte Implementierung aus und
stellen sie unverändert mit einem anderen Qualifier, in unserem Beispiel dem impliziten  <span class='latex-texttt'>Default</span> -Qualifier, zur Verfügung.
Soll in der Applikation die Default-Implementierung verwendet werden, so kann diese dadurch wie erwartet injiziert werden.
Eine spätere Umstellung der Default-Implementierung ist jetzt einfach möglich,
da nur der Injection-Point der Producer-Methode angepasst werden muss.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Natürlich können wir den Producer etwas flexibler gestalten.
Hierfür können wir beispielsweise  <span class='latex-texttt'>ApplicationConfig</span>  um einen Eintrag für das Default-Format erweitern.
Anschließend werten wir diesen neuen Konfigurationseintrag im zuvor erstellten Producer aus.
Mit diesem Ansatz muss die Implementierung des Producers nicht umgestellt werden,
wenn das Default-Format auf ein bereits unterstütztes Format geändert werden soll.
Listing  <a href='#!idx:/cdi_basics.html:fig:extended_custom_type-safe_config'> Erweiterte ApplicationConfig </a>  zeigt die erweiterte Implementierung von  <span class='latex-texttt'>ApplicationConfig</span>  und
Listing  <a href='#!idx:/cdi_basics.html:fig:configurable_default_config'> Konfigurierbare Default-Implementierung </a>  die Verwendung in der Producer-Methode.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:extended_custom_type-safe_config'></a>                     <pre><code>@Typed()
public class ApplicationConfig {
  //...
  private ExternalFormat.TargetFormat defaultExternalFormat;

  protected ApplicationConfig() {
    //needed for creating a proxy
  }

  public ApplicationConfig(ResourceBundle config) {
    //...
    this.defaultExternalFormat =
      ExternalFormat.TargetFormat.valueOf(
      config.getString("defaultExternalFormat"));
  }

  public ExternalFormat.TargetFormat getDefaultExternalFormat() {
    return defaultExternalFormat;
  }
  //...
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:configurable_default_config'></a>                     <pre><code>@ApplicationScoped
public class CurrentObjectConverterProducer {
  @Produces
  @Default
  @Dependent
  protected ObjectConverter defaultConverter(
    @ExternalFormat(XML) ObjectConverter objectConverterXml,
    @ExternalFormat(JSON) ObjectConverter objectConverterJson,
    ApplicationConfig applicationConfig) {

      switch (applicationConfig.getDefaultExternalFormat()) {
        case JSON:
          return objectConverterJson;
        default:
          return objectConverterXml;
      }
  }
}
</code></pre>
                </div> 
Die Verwendung von  <span class='latex-texttt'>@ApplicationScoped</span>  in Listing  <a href='#!idx:/cdi_basics.html:fig:configurable_default_config'> Konfigurierbare Default-Implementierung </a>  ist in unserem Fall optional und sorgt dafür,
dass der CDI-Container nicht für jeden Aufruf der Producer-Methode eine neue  <span class='latex-texttt'>CurrentObjectConverterProducer</span> -Instanz erzeugen muss.
Da der Producer zustandslos implementiert ist,
ändert sich das Ergebnis im Vergleich zu Listing  <a href='#!idx:/cdi_basics.html:fig:simple_selection_via_producer-method'> Einfache Selektion via Producer </a>  nicht.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der  <span class='latex-texttt'>Default</span> -Qualifier ist bei Injection-Points ebenfalls optional. Daraus folgt, dass wir ihn bisher immer implizit verwendet haben.
Sie müssen sich nur überlegen, ob Sie solche impliziten Verwendungen in einer Applikation zulassen wollen,
wenn Sie jede konkrete Implementierung mit einem Qualifier versehen.
In manchen Projekten wird versucht, über explizite Qualifier die Fehlerwahrscheinlichkeit zu reduzieren und
dies würde durch den zuvor vorgestellten Ansatz ausgehebelt werden.
Möchten Sie die explizite Angabe eines Qualifiers erzwingen,
dann können Sie statt des  <span class='latex-texttt'>Default</span> -Qualifiers einen eigenen Qualifier definieren.
Beliebte Namen für solche Qualifier sind  <span class='latex-texttt'>@Current</span>  und  <span class='latex-texttt'>@Active</span> .<br /> <div class="tip"><b>Tipp: </b> CDI 1.0 spezifiziert für Injection-Points den zusätzlichen Qualifier  <span class='latex-texttt'>@New</span> ,
der seit CDI 1.1 als Deprecated markiert ist.
Durch diesen Qualifier injiziert der CDI-Container immer eine dependent-scoped Contextual-Instance eines Beans
unabhängig vom explizit angegebenen Scope des entsprechenden Managed-Beans.
Dies wurde anfangs öfters für verschiedene Tricks in Kombination mit Producer-Methoden verwendet,
ist jedoch aufgrund der höheren Komplexität im Normalfall nicht empfehlenswert. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.6.0.4' ><span class='entry-number'>2.6.0.4</span> Producer-Felder</a></h4>
 Abgesehen von Producer-Methoden können auch Producer-Felder verwendet werden.
Wie wir später sehen werden, können Producer-Felder in Kombination mit Ressource-Injection in einem EE-Server ein paar Codezeilen einsparen.
Äquivalent zu Producer-Methoden werden Producer-Felder mit  <span class='latex-texttt'>@Produces</span>  annotiert.
Für die meisten Producer sind Producer-Felder nicht empfehlenswert.
Der Unterschied zwischen einer simplen Methode und einem Feld ist in der Praxis minimal.
Jedoch ist das Debugging in Kombination mit Producer-Feldern bedeutend komplexer und
darüber hinaus erhalten wir durch Producer-Felder eine zustandsbehaftete Producer-Klasse,
wodurch der gewählte Scope dieser zu unterschiedlichen Ergebnissen führen kann.
Ein solcher Effekt ist möglich, wenn beispielsweise bei einem application-scoped CDI-Bean eine Instanzvariable nur einmal initialisiert wird,
diese jedoch als Producer für ein weiteres Bean mit einem kürzeren Scope verwendet wird.
Normalerweise möchte man hier immer eine neue Instanz erhalten, die im angegebenen Scope abgelegt werden soll.
Durch den beschriebenen Effekt wird die Instanzvariable im application-scoped Bean nur einmal erzeugt und
kann daher zu unerwateten Ergebnissen führen. Ob dies tatsächlich Seiteneffekte verursacht, hängt von der konkreten Konstellation ab.
In Kombination mit Resource-Injection von Java EE ist dies beispielsweise kein Problem, da hier ebenfalls mit Proxy-Instanzen gearbeitet wird.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.7' ><span class='entry-number'>2.7</span> Events</a> </h2>
 In einer Spezifikation zum Thema Dependency-Injection und Context-Management ist die Definition eines Event-Systems für viele unerwartet.
Allerdings sind die durch CDI spezifizierten Events nur durch die Kombination von einigen der bisher vorgestellten CDI-Konzepte möglich.
Zusammengefasst sind CDI-Events eine entkoppelte Implementierung des Observer-Entwurfsmusters.
Entsprechend werden CDI-Events derzeit nur synchron verarbeitet, wodurch es sequentiellen Methodenaufrufen gleichkommt.
Der Vorteil dabei ist die Entkoppelung von Event-Erzeuger und Event-Verbraucher.
Durch die überaus elegante Umsetzung ist es erfreulich, dass CDI-Events zusätzlich für den Containerlebenszyklus verwendet werden.
Solche Container-Events werden wir uns im Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  näher ansehen.<br /> <div class="tip"><b>Tipp: </b> Eine asynchrone Verteilung wird derzeit nicht durch die Spezifikation unterstützt und ist somit implementierungsabhängig.
So ist es beispielsweise für OpenWebBeans möglich ein entsprechendes Add-on zu implementieren.
Unabhängig ob es sich um proprietäre asynchrone CDI-Events oder eine manuell angestoßene asynchrone Verarbeitung handelt,
müssen alle statusrelevanten Informationen direkt mit der Event-Instanz übergeben werden.
Denn für eine asynchrone Verarbeitung wird ein neuer Thread gestartet, der beispielsweise einen neuen Request-, Session-,... Scope bekommt.
Wie dies genau funktioniert und was Sie hierfür beachten müssen, werden wir später im Detail analysieren. </div><div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Seit CDI 2.0 (Java EE 8) unterstützt die Spezifikation asynchrone Events nativ. Mit <span class='latex-texttt' style='color:#2e7d32;'>@ObservesAsync</span> und der Methode <span class='latex-texttt' style='color:#2e7d32;'>fireAsync()</span> können Events in separaten Threads verarbeitet werden, ohne auf proprietäre Lösungen zurückgreifen zu müssen. Die Details zur Evolution von CDI finden Sie in Kapitel <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div><div class="tip"><b>Tipp: </b>Die praktische Anwendung asynchroner Events mit <span class='latex-texttt'>@ObservesAsync</span> wird in Kapitel <a href='#!idx:/cdi_usecases.html:8'>8</a> im Rahmen von <span class='latex-textit'>IdeaForkMicro</span> demonstriert. Dort werden Events zur losen Kopplung zwischen Microservice-Modulen eingesetzt.</div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bevor wir in  <span class='latex-textit'>IdeaFork</span>  CDI-Events sinnvoll verwenden können, müssen wir zusätzliche Applikationslogik hinzufügen.
Wir erstellen eine einfache In-Memory Repository-Implementierung, mit der wir Ideen speichern, laden und löschen können.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im Hintergrund wird eine einfache Map verwendet, um  <span class='latex-texttt'>Idea</span> -Instanzen zu speichern.
Die einzige Besonderheit ist die Simulierung von detached Entitäten, die wir in einem späteren Schritt mit JPA automatisch bekommen.
Für unsere simple In-Memory Implementierung können wir diesen Effekt mit Hilfe einer einfachen Clone-Methode nachstellen,
die verwendet wird, bevor eine Entität zurückgegeben oder abgelegt wird.
Somit werden unerwartete Effekte vermieden,
die auftreten können, wenn die Referenz auf die Entität nach dem Repository-Aufruf für weitere Änderungen verwendet wird.
Als Key verwenden wir eine generierte ID, die wir vorerst in der  <span class='latex-texttt'>Idea</span> -Klasse selbst hinzufügen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Mit dieser neuen Funktionalität in  <span class='latex-textit'>IdeaFork</span>  können wir ein sinnvolles CDI-Event hinzufügen.
Beispielsweise können wir ein Event erzeugen, sobald eine  <span class='latex-texttt'>Idea</span> -Instanz gespeichert wurde.
Um dies zu erreichen, injizieren wir  <span class='latex-texttt'>javax.enterprise.event.Event</span>  in unsere soeben angelegte  <span class='latex-texttt'>IdeaRepository</span> -Klasse und
typisieren das Event auf unseren eigenen Event-Typ. Als Event-Typ kann jede beliebige Klasse verwendet werden.
Für einfache Anwendungsfälle kann die Klasse der Entität selbst verwendet werden.
Listing  <a href='#!idx:/cdi_basics.html:fig:fire_cdi-event'> CDI-Events feuern </a>  illustriert eine solche einfache Verwendung.
Später werden wir eine eigene Event-Klasse einführen, da dies in realen Applikationen aussagekräftiger ist und
zusätzliche Informationen mitgegeben werden können.
Im zweiten Teil von Listing  <a href='#!idx:/cdi_basics.html:fig:fire_cdi-event'> CDI-Events feuern </a>  wird die injizierte Event-Instanz verwendet, um ein Event zu feuern.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:fire_cdi-event'></a>                     <pre><code>public class IdeaRepository {
  @Inject
  private Event&lt;Idea&gt; ideaSavedEvent;

  private Map&lt;String, Idea&gt; entityMap =
    new ConcurrentHashMap&lt;String, Idea&gt;();

  public void save(Idea entity) {
    entityMap.put(entity.getId(), clone(entity));
    ideaSavedEvent.fire(entity);
  }
  //...
}
</code></pre>
                </div> 
Auch CDI-Qualifier sind in Kombination mit CDI-Events möglich. Sie können beim Injection-Point des Events angegeben werden.
Als Alternative ist es möglich Qualifier dynamisch mit Hilfe von Literals anzugeben.
Dies ist auch hier wieder mit den entsprechenden  <span class='latex-texttt'>select</span> -Methoden möglich.
Die Verwendung ist äquivalent zu den Konzepten,
die wir bei  <span class='latex-texttt'>javax.enterprise.inject.Instance</span>  im vorherigen Kapitel kennengelernt haben.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In CDI-basierten Frameworks gibt es Events, auf die im Framework selbst nicht reagiert wird.
Solche Events werden wir später in  <span class='latex-textit'>IdeaFork</span>  überwachen.
Applikationsspezifische Events sind per Definition nur sinnvoll, wenn diese in der Applikation verarbeitet werden.
Hierfür müssen wir in einem beliebigen CDI-Bean eine Methode mit mindestens einem Parameter hinzufügen.
Der Parametertyp und explizite/implizite Qualifier müssen jenen der Event-Quelle entsprechen.
In unserem Fall ist die  <span class='latex-texttt'>Idea</span> -Klasse der Parametertyp. Listing  <a href='#!idx:/cdi_basics.html:fig:observe_cdi-event'> CDI-Events überwachen </a>  zeigt,
dass wir keinen expliziten Qualifier angeben müssen, da wir beim Feuern des Events den impliziten  <span class='latex-texttt'>Default</span> -Qualifier verwendet haben.
Damit der CDI-Container die Methode als Observer-Methode registriert, muss dieser Parameter mit  <span class='latex-texttt'>@Observes</span>  annotiert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:observe_cdi-event'></a>                     <pre><code>@ApplicationScoped
public class IdeaSavedObserver {
  private static final Logger LOGGER =
    Logger.getLogger(IdeaSavedObserver.class.getName());

  private boolean isIdeaLoggingEnabled;

  @PostConstruct
  protected void init() {
    isIdeaLoggingEnabled = LOGGER.isLoggable(Level.FINE);
  }

  public void onIdeaSavedEvent(@Observes Idea savedIdea) {
    if (isIdeaLoggingEnabled) {
      LOGGER.fine("saved idea: " + savedIdea.getId());
    }
  }
}
</code></pre>
                </div> 
Observer sind in vielen Fällen zustandslos und führen vor der Ausführung der eigentlichen Logik die erforderlichen Auswertungen durch.
Dennoch ist es sinnvoll und vor allem möglich unveränderbare Informationen bei der Initialisierung abzulegen,
damit die Ausführungszeit der Observer-Methode minimiert werden kann.
In unserem einfachen Beispiel könnten diese Informationen statisch abgelegt werden.
Normalerweise handelt es sich nicht ausschließlich um statische Informationen,
wodurch eine mit  <span class='latex-texttt'>@PostConstruct</span>  annotierte Methode zur Initialisierung sinnvoll ist.
In application-scoped Beans, wie es  <span class='latex-texttt'>IdeaSavedObserver</span>  ist,
werden solche Auswertungen daher nur einmal und nicht bei jedem Aufruf der Observer-Methode/n durchgeführt.
Denn die Observer-Methode wird auf der effektiven Contextual-Instance aufgerufen, als wäre es ein manueller Methoden-Aufruf auf das CDI-Bean.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Events sind primär sinnvoll, wenn wir potentiell mehrere unabhängige Aktionen im System anstoßen möchten.
Zustandslose Observer werden oft dependent-scoped definiert.
Bei jedem Event wird per Definition eine Contextual-Instance der Observer-Klasse erzeugt und die Observer-Methode aufgerufen.
Abhängig von der effektiven Logik der Observer-Methode sind solche Methoden etwas schwerer testbar,
da das dependent-scoped Bean nach dem Aufruf der Observer-Methode wieder zerstört wird.
Im Hinblick auf die Zustellung von Events müssen Sie sich in solchen Fällen auf den CDI-Container verlassen.
Ob ein Event effektiv gefeuert wird, kann bei Bedarf mit einem eigenen Test-Observer überprüft werden.
Solche Test-Observer werden im Testverzeichnis abgelegt und dürfen nicht dependent-scoped sein.
Die Parameter der Observer-Test-Methoden sollten jenen der echten Observer-Methode entsprechen,
um eine sinnvolle Aussage zu ermöglichen. Die Implementierung ist hingegen in jedem Fall trivial, da Sie sich nur merken müssen,
ob die Observer-Methode nach einem bestimmten Punkt aufgerufen wurde.
Listing  <a href='#!idx:/cdi_basics.html:fig:test_event_delivery'> Zustellung von CDI-Events testen </a>  zeigt einen einfachen Testfall und Listing  <a href='#!idx:/cdi_basics.html:fig:test-observer'> Test-Observer </a>  den dazugehörigen Test-Observer.
Vor dem Speichern der neu erzeugten  <span class='latex-texttt'>Idea</span> -Instanz wird der injizierte  <span class='latex-texttt'>TestIdeaSavedObserver</span>  überprüft.
Bis zu diesem Zeitpunkt darf unser Event noch nicht aufgetreten sein.
Nach der Speicherung wird der Zustand von  <span class='latex-texttt'>TestIdeaSavedObserver</span>  erneut überprüft,
weil das Event bereits erzeugt und vom CDI-Container zugestellt wurde.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Um zu vermeiden, dass das Event durch einen anderen Test bereits angestoßen und vom  <span class='latex-texttt'>TestIdeaSavedObserver</span>  aufgezeichnet wurde,
definieren wir  <span class='latex-texttt'>TestIdeaSavedObserver</span>  als request-scoped Bean.<br /> <div class="tip"><b>Tipp: </b> Wie im Kapitel  <a href='#!idx:/introduction.html:chap:cdi-introduction'>  Einführung in CDI </a>  erwähnt, ist der CDI-Request-Scope unabhängig von einem physischen HTTP-Request,
sofern der Scope für den aktuellen Thread manuell gestartet und gestoppt wird.
In Unit-Tests ohne CDI-Support müssten wir dies manuell durchführen.
In unserem Fall übernimmt dies  <span class='latex-texttt'>CdiTestRunner</span>  für jede Test-Methode. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test_event_delivery'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class EventTest {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private IdeaRepository ideaRepository;

  @Inject
  private TestIdeaSavedObserver ideaSavedObserver;

  @Test
  public void eventDelivery() {
    Idea newIdea = ideaManager.createIdeaFor(...);

    Assert.assertFalse(ideaSavedObserver.isEventObserved());
    ideaRepository.save(newIdea);
    Assert.assertTrue(ideaSavedObserver.isEventObserved());
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test-observer'></a>                     <pre><code>@RequestScoped
public class TestIdeaSavedObserver {
  private boolean isEventObserved;

  protected void onIdeaSavedEvent(@Observes Idea savedIdea) {
    isEventObserved = true;
  }

  public boolean isEventObserved() {
    return isEventObserved;
  }
}
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.7.0.1' ><span class='entry-number'>2.7.0.1</span> Ausführungsreihenfolge</a></h4>
 Zusammen mit dem Test-Observer haben wir mittlerweile mehrere Observer-Methoden für unser  <span class='latex-texttt'>Idea</span> -Event.
Die Ausführungsreihenfolge dieser Methoden ist weder beeinflussbar, noch durch eine Regel definiert.
Wirft eine der Observer-Methoden eine Exception, so werden die nachfolgenden Observer-Methoden nicht mehr ausgeführt.
Eine mehrstufige Ausführung eines Events und
eine damit verbundene definierte Reihenfolge kann nur manuell mithilfe von verschiedenen Qualifiern erreicht werden.
In den meisten Fällen ist dies nicht erforderlich und würde hauptsächlich zu einer komplexeren Implementierung führen und
das Ergebnis kommt manuellen Methodenaufrufen nahe.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.7.0.2' ><span class='entry-number'>2.7.0.2</span> Bedingte Überwachung von Events</a></h4>
 Existiert noch keine Contextual-Instances eines Managed-Beans mit Observer-Methode,
dann wird diese erzeugt sobald das Event gefeuert wird. Somit sind reine Observer-Beans möglich.
Für manche Anwendungsfälle ist es hingegen erforderlich, dass eine Observer-Methode nur aufgerufen wird,
wenn es bereits eine Contextual-Instance des Managed-Beans gibt. Ein Beispiel hierfür sind UI-Controller,
die ein bestimmtes UI-Event überwachen. Wird das gleiche Event für verschiedene Oberflächen verwendet,
so ist es normalerweise nicht sinnvoll sämtliche UI-Controller der gesamten Applikation,
die eine Observer-Methode für dieses Event haben, zu erzeugen und die entsprechende Observer-Methode aufzurufen.
In  <span class='latex-textit'>IdeaFork</span>  sind wir von solchen spezielleren Anwendungsfällen noch entfernt und
somit veranschaulicht Listing  <a href='#!idx:/cdi_basics.html:fig:observe_if_exists'> Bedingter Test-Observer </a>  das grundlegende Konzept anhand eines einfachen Beispiels.
Die neu hinzugefügte Klasse  <span class='latex-texttt'>TestIdeaSavedConditionalObserver</span>  ist fast ident zur Implementierung von  <span class='latex-texttt'>TestIdeaSavedObserver</span> .
Der einzige Unterschied ist die Angabe von  <span class='latex-texttt'>Reception.IF_EXISTS</span> .
Da in Listing  <a href='#!idx:/cdi_basics.html:fig:test_delivery_if_exists'> Zustellung von bedingten CDI-Events testen </a>  vor dem Speichern der Idee  <span class='latex-texttt'>TestIdeaSavedConditionalObserver</span>  nicht verwendet wird,
kommt es zu keiner Ausführung der bedingten Observer-Methode.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:observe_if_exists'></a>                     <pre><code>@RequestScoped
public class TestIdeaSavedObserver {
  private boolean isEventObserved;

  protected void onIdeaSavedEvent(
    @Observes(notifyObserver = Reception.IF_EXISTS)
    Idea savedIdea) {
      isEventObserved = true;
  }

  public boolean isEventObserved() {
    return isEventObserved;
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:test_delivery_if_exists'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class EventTest {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private IdeaRepository ideaRepository;

  @Inject
  private TestIdeaSavedObserver ideaSavedObserver;

  @Inject
  private TestIdeaSavedConditionalObserver conditionalObserver;

  @Test
  public void conditionalEventDelivery() {
    Idea newIdea = ideaManager.createIdeaFor(...);

    Assert.assertFalse(ideaSavedObserver.isEventObserved());

    ideaRepository.save(newIdea);

    Assert.assertTrue(ideaSavedObserver.isEventObserved());
    Assert.assertFalse(conditionalObserver.isEventObserved());

    ideaRepository.save(newIdea);
    Assert.assertTrue(conditionalObserver.isEventObserved());
  }
}
</code></pre>
                </div> 
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8' ><span class='entry-number'>2.8</span> Beans ersetzen</a> </h2>
<a name = '!idx:/cdi_basics.html:sec:cdi-alternatives'> </a> In einigen Fällen kann es sinnvoll sein, bestehende Implementierungen anzupassen.
Verwenden Sie ein externes CDI-basiertes Framework oder teilen sich mehrere Ihrer Applikationen CDI-basierte Module,
dann kann es zu Situationen kommen, in denen eine bestehende Implementierung erweitert oder ausgetauscht werden soll.
Darüber hinaus kann es sein, dass Unit-Tests zusätzliche Anforderungen an einzelne Beans stellen.
Für diese und einige andere Anwendungsfälle stellt CDI mit  <span class='latex-texttt'>@Alternative</span>  und  <span class='latex-texttt'>@Specializes</span>  gleich zwei Ansätze zur Verfügung.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8.0.1' ><span class='entry-number'>2.8.0.1</span> Nichts ist perfekt</a></h4>
 CDI ist eine überwiegend gute und durchdachte Spezifikation. Leider gibt es wie bei jeder Spezifikation bzw. Technologie Fallstricke.
Im Falle von CDI verbergen sich die auffälligsten Probleme bei den BDAs (= Bean Deployment Archives),
auf die wir später noch eingehen werden. Die Auswirkungen werden vor allem bei alternativen Implementierungen,
mit denen wir uns in diesem Kapitel beschäftigen, sichtbar. Bereits bei der Definition der beiden Annotationen gibt es konträre Ansichten.
Beispielsweise funktioniert  <span class='latex-texttt'>javax.enterprise.inject.Instance</span>  in Verbindung mit
 <span class='latex-texttt'>@Alternative</span>  mit OpenWebBeans anders als mit Weld.
In Weld liefert der Iterator das ursprüngliche und das alternative Bean als Ergebnis.
Folglich gibt  <span class='latex-texttt'>isAmbiguous</span>   <span class='latex-texttt'>"true"</span>  zurück.
Allerdings führt die  <span class='latex-texttt'>get</span> -Methode hier nicht wie erwartet zu einer  <span class='latex-texttt'>AmbiguousResolutionException</span> ,
da nur das alternative Bean zurückgeliefert wird. OpenWebBeans implementiert dies konsistent und
verwendet in beiden Fällen nur das alternative Bean und somit gibt  <span class='latex-texttt'>isAmbiguous</span>  wie erwartet  <span class='latex-texttt'>"false"</span>  zurück.
In Kombination mit fehlerhaften Integrationen von CDI in manchen Applikationsservern,
sind beide Annotationen nur sehr beschränkt einsetzbar.
Statt auf sämtliche Regeln der Spezifikation und die vorhandenen Implementierungsfehler bzw. Inkonsistenzen in den einzelnen Versionen der CDI-Implementierungen einzugehen, beschränken wir uns auf die wichtigsten Anwendungsfälle, die in den meisten Fällen portabel sind und funktionieren.<br /> <div class="tip"><b>Tipp: </b> Wenn Sie Ihre Nerven schonen möchten, dann können Ihnen folgende Empfehlungen das Leben mit CDI 1.0 erleichtern.
Beschränken Sie die Verwendung von  <span class='latex-texttt'>@Alternative</span>  und  <span class='latex-texttt'>@Specializes</span>  auf das absolute Minimum.
Bevorzugen Sie  <span class='latex-texttt'>@Specializes</span>  und erst wenn diese Annotation nicht funktioniert oder für Ihren Anwendungsfall nicht möglich ist,
versuchen Sie  <span class='latex-texttt'>@Alternative</span> . Testen Sie die alternativen Implementierungen überdurchschnittlich gut.
Wenn weder  <span class='latex-texttt'>@Alternative</span>  noch  <span class='latex-texttt'>@Specializes</span>  funktionieren,
dann können Sie in vielen Fällen auf eine Funktionalität von Apache DeltaSpike namens "global alternatives" ausweichen. </div>
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Seit CDI 1.1 können <span class='latex-texttt' style='color:#2e7d32;'>@Alternative</span>-Beans auch via <span class='latex-texttt' style='color:#2e7d32;'>@Priority</span>-Annotation global aktiviert werden, ohne einen Eintrag in <span class='latex-texttt' style='color:#2e7d32;'>beans.xml</span> zu benötigen. Dies vereinfacht den Umgang mit Alternativen erheblich. Weitere Details finden Sie in Kapitel <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div>
<h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8.0.2' ><span class='entry-number'>2.8.0.2</span> Implementierungen ersetzen mit @Specializes</a></h4>
 Wir beginnen mit  <span class='latex-texttt'>@Specializes</span> , weil es die einfachste Variante ist um eine Default-Implementierung auszutauschen.
Die spezialisierte Implementierung leitet wie erwartet von der ursprünglichen Bean-Klasse ab und
wird mit  <span class='latex-texttt'>@Specializes</span>  annotiert. Falls die ursprüngliche Klasse ein Interface implementiert,
so genügt es nicht nur das gleiche Interface zu implementieren, sondern es muss immer von der ursprünglichen Klasse abgeleitet werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  haben wir  <span class='latex-texttt'>TestIdeaSavedObserver</span>  angelegt,
um zu testen ob das  <span class='latex-texttt'>Idea</span> -Event zum richtigen Zeitpunkt gefeuert wird und
wir die ursprüngliche Implementierung diesbezüglich nicht anpassen wollten.
Die Anpassung für den Unit-Test war in unserem simplen Beispiel sehr einfach möglich.
In komplexeren Fällen kann es jedoch sein, dass dies nicht so einfach möglich ist.
Hier können Sie  <span class='latex-texttt'>@Specializes</span>  zur Hilfe nehmen.
Statt ein zusätzliches Bean zu verwenden, können wir  <span class='latex-texttt'>TestIdeaSavedObserver</span>  von  <span class='latex-texttt'>IdeaSavedObserver</span>  ableiten und
entsprechend anpassen. Da wir  <span class='latex-texttt'>TestIdeaSavedObserver</span>  im Testverzeichnis haben,
wird diese Implementierung nur in unseren Unit-Tests aktiv.
In der effektiven Applikation kann der Testcode von  <span class='latex-texttt'>TestIdeaSavedObserver</span>  nie aktiv werden,
weil die endgültige Applikation diese Testklasse nicht enthalten wird und daher automatisch  <span class='latex-texttt'>IdeaSavedObserver</span>  verwendet wird.
Listing  <a href='#!idx:/cdi_basics.html:fig:specialized_bean'> Spezialisierte Implementierungen </a>  zeigt, dass wir in unserem einfachen Fall die Observer-Methode überschreiben.
Die neue Implementierung delegiert im ersten Schritt an die ursprüngliche Implementierung der Superklasse und
fügt danach den erforderlichen Testcode ein.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:specialized_bean'></a>                     <pre><code>@Specializes
@RequestScoped
public class TestIdeaSavedObserver extends IdeaSavedObserver {
  private boolean isEventObserved;

  @Override
  protected void onIdeaSavedEvent(@Observes Idea savedIdea) {
    super.onIdeaSavedEvent(savedIdea);
    this.isEventObserved = true;
  }

  public boolean isEventObserved() {
    return isEventObserved;
  }
}
</code></pre>
                </div> 
In unserem Fall ist  <span class='latex-texttt'>IdeaSavedObserver</span>  als application-scoped Bean definiert.
Durch die Spezialisierung haben wir nicht nur die Implementierung erweitert, sondern auch den Scope des Beans verändert.
Für eine spezialisierte Implementierung ist die Angabe eines Scopes nur erforderlich, wenn der Scope des Beans,
wie bei  <span class='latex-texttt'>TestIdeaSavedObserver</span> , geändert werden soll.
Wird kein Scope bei der spezialisierten Klasse angegeben, so wird die Scope-Annotation vererbt,
sofern diese mit  <span class='latex-texttt'>@java.lang.annotation.Inherited</span>  annotiert ist.
Da dies eine Empfehlung der CDI-Spezifikation ist, sind alle Scope-Annotationen der Spezifikation mit  <span class='latex-texttt'>@Inherited</span>  annotiert und
werden automatisch vererbt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In vielen Fällen ist es nicht erforderlich den Scope zu ändern.
Wenn wir uns zurück erinnern haben wir  <span class='latex-texttt'>TestIdeaSavedObserver</span>  mit  <span class='latex-texttt'>@RequestScoped</span>  annotiert,
weil wir je Test-Methode eine neue Instanz verwenden wollen.
Bevor Sie den Scope der ursprünglichen Implementierung verändern, stellen Sie sicher,
dass Sie die Auswirkungen verstehen und Sie nicht wichtige Aspekte bzw. Annahmen der ursprünglichen Implementierung verletzen und
dadurch unerwartete Effekte auslösen.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8.0.3' ><span class='entry-number'>2.8.0.3</span> Alternative Implementierungen mit @Alternative</a></h4>
 Im Vergleich zu den zuvor vorgestellten spezialisierten Implementierungen mit  <span class='latex-texttt'>@Specializes</span>  sind
alternative Implementierungen mit  <span class='latex-texttt'>@Alternative</span>  etwas komplexer. Die Annotation selbst ist nur der erste Schritt.
Wie bei  <span class='latex-texttt'>@Specializes</span>  können Sie von der ursprünglichen Implementierung ableiten und diese mit  <span class='latex-texttt'>@Alternative</span>  annotieren.
In vielen Anwendungsfällen haben Sie allerdings nur ein Interface, das Sie für das alternative Bean implementieren können/wollen.
Dies stellt den Hauptanwendungsfall von  <span class='latex-texttt'>@Alternative</span>  dar,
weil mit  <span class='latex-texttt'>@Specializes</span>  die alleinige Implementierung eines Interfaces nicht möglich ist.
Ein weiterer Unterschied ist, dass Implementierungen, die mit  <span class='latex-texttt'>@Alternative</span>  annotiert sind, nicht automatisch aktiv sind,
da sie via  <span class='latex-texttt'>beans.xml</span>  konfiguriert werden müssen. Hier lauert einer der Fallstricke der Spezifikation.
Laut dieser müssen alternative Implementierungen im gleichen (Bean-Deployment-)Archiv konfiguriert sein.
Die Definition eines (Bean-Deployment-)Archivs und dessen Grenzen sind sehr umstritten.
Im restriktivsten Fall müssen Sie davon ausgehen, dass die kleinste Moduleinheit, wie beispielsweise eine JAR-Datei, gemeint ist.
Dieses Konzept und die damit verbundenen Limitierungen werden wir im Kapitel  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  genauer analysieren.
Da wir nicht mehrere Applikationen haben, die sich CDI-basierte Module teilen und
die Anpassung eines CDI-basierten Frameworks erst später besprechen, werden wir zu diesem Zeitpunkt keine Einschränkungen bemerken.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span class='latex-texttt'>@Alternative</span>  bietet Ihnen die Möglichkeit mehrere Implementierungen parallel auszuprobieren.
Wird keine der alternativen Implementierungen via  <span class='latex-texttt'>beans.xml</span>  aktiviert, so bleibt das ursprüngliche Bean aktiv.
Sie können beliebig viele alternative Implementierungen mit  <span class='latex-texttt'>@Alternative</span>  annotieren.
Erst wenn Sie eine davon via  <span class='latex-texttt'>beans.xml</span>  aktivieren, wird diese zur Laufzeit verwendet.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  bietet es sich an alternative Beans für das  <span class='latex-texttt'>ObjectConverter</span>  Interface zu implementieren.
Als Alternative zu JAXB und Gson können wir Jackson (http://fasterxml.com) in das Projekt einbinden und
entsprechende Implementierungen für die JSON- und XML-Converter testen.
Listing  <a href='#!idx:/cdi_basics.html:fig:alternative_bean_implementation'> Alternative Implementierung </a>  zeigt dies am Beispiel eines Jackson-Converters für JSON.
Listing  <a href='#!idx:/cdi_basics.html:fig:alternative_bean_configuration'> Aktivierung einer alternativen Implementierung </a>  veranschaulicht die entsprechende Konfiguration in der Datei  <span class='latex-texttt'>beans.xml</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:alternative_bean_implementation'></a>                     <pre><code>@Alternative
@ExternalFormat(ExternalFormat.TargetFormat.JSON)
@ApplicationScoped
public class JSONConverterJackson implements ObjectConverter {
  @Override
  public &lt;T&gt; T toObject(String value, Class&lt;T&gt; targetType) {
    try {
      return new ObjectMapper().readValue(value, targetType);
    } catch (Exception e) {
      throw new IllegalArgumentException(e);
    }
  }

  @Override
  public String toString(Object entity) {
    try {
      return new ObjectMapper().writeValueAsString(entity);
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(e);
    }
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:alternative_bean_configuration'></a>                     <pre><code>&lt;beans&gt;
  &lt;alternatives&gt;
    &lt;class&gt;[package-name].JSONConverterJackson&lt;/class&gt;
  &lt;/alternatives&gt;
&lt;/beans&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.8.0.4' ><span class='entry-number'>2.8.0.4</span> Alternative Producer/Disposer</a></h4>
 Producer und Disposer haben eine Art Sonderstellung in Hinsicht auf alternative Implementierungen.
Die höchste Portabilität Ihrer Beans erreichen Sie, wenn Sie wie in Listing  <a href='#!idx:/cdi_basics.html:fig:specialized_bean_with_producer'> Spezialisiertes Bean mit Producer und Disposer </a> in der abgeleiteten Klasse sowohl den Producer als auch den Disposer inklusive aller Metadaten überschreiben,
selbst wenn Sie an diesen Stellen keine Anpassungen vornehmen und nur an die ursprüngliche Implementierung delegieren.
In unserem Beispiel passen wir den Producer für  <span class='latex-texttt'>ApplicationConfig</span>  an,
da wir im nächsten Kapitel für Unit-Tests andere Werte konfigurieren werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:specialized_bean_with_producer'></a>                     <pre><code>@Specializes
public class TestConfigProducer extends ConfigProducer {
  @Override
  @Produces
  @ApplicationScoped
  public ApplicationConfig exposeConfig() {
    return super.exposeConfig();
  }

  @Override
  public void onDispose(@Disposes ApplicationConfig config) {
    super.onDispose(config);
  }

  @Override
  protected String getConfigBaseName() {
    return "test-" + super.getConfigBaseName();
  }
}
</code></pre>
                </div> 
Darüber hinaus gibt es Unterschiede bei den CDI-Implementierungen.
Mit OpenWebBeans können Sie sowohl  <span class='latex-texttt'>@Specializes</span>  als auch  <span class='latex-texttt'>@Alternative</span>  verwenden.
Bei Weld sind Sie hingegen auf  <span class='latex-texttt'>@Specializes</span>  beschränkt, um alternative Producer zur Verfügung zu stellen.<br />  
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.9' ><span class='entry-number'>2.9</span> Interceptoren</a> </h2>
 Interceptoren ermöglichen die Implementierung von Querschnittsbelangen, wie beispielsweise Logging, Security, Monitoring und vieles mehr.
unabhängig von der konkreten Arbeitsweise der Beans, für die sie verwendet werden.
Im Vergleich zu anderen Interceptor-Lösungen bzw. AOP sind CDI-Interceptoren einfach und elegant gehalten.
Vergleichbar mit Servlet-Filtern wird eine verschachtelte Kette aus 2-n Instanzen erzeugt.
Die kleinste Kette besteht aus einem Interceptor und der eigentlichen Contextual-Instance.
Der Interceptor kann an beliebigen Stellen seiner Logik an die nächste Instanz in der Kette delegieren.
Als letztes Glied in der Kette wird die Methode der Contextual-Instance aufgerufen.
Danach wird wie bei verschachtelten Methodenaufrufen die Kette in die umgekehrte Richtung zurückgeschritten.
Sie können auf einfache Weise entscheiden, welche Interceptor-Logik vor und
nach dem Aufruf der effektiven Methode der Contextual-Instance ablaufen soll.
Für Exceptions benötigen Sie keinen zusätzlichen Interceptortyp, da Sie den klassischen  <span class='latex-texttt'>try/catch/finally-Block</span>  verwenden können.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  führen wir einen Interceptor ein, mit dem wir langsame Methodenaufrufe aufzeichnen können.
Wir können diesen Interceptor für beliebige Beans verwenden.
Fürs Erste werden wir  <span class='latex-texttt'>IdeaManager</span> ,  <span class='latex-texttt'>IdeaRepository</span>  und alle  <span class='latex-texttt'>ObjectConverter</span> -Implementierungen
mit diesem Interceptor überwachen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Für die Implementierung eines Interceptors müssen wir eine eigene Annotation definieren.
Ähnlich wie bei Qualifiern müssen wir überlegen, an welchen Stellen wir den Interceptor verwenden wollen bzw. dürfen.
Die CDI-Spezifikation erlaubt die Verwendung bei einzelnen Methoden sowie auf Klassenebene,
wodurch sämtliche (Business-)Methoden der Klasse den Interceptor erhalten.
Somit wird in Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-annotation'> Interceptor-Annotation </a>   <span class='latex-texttt'>ElementType.METHOD</span>  und  <span class='latex-texttt'>ElementType.TYPE</span>  verwendet.
Erst durch die Annotation  <span class='latex-texttt'>@javax.interceptor.InterceptorBinding</span>  markieren wir unsere neue Annotation als sogenanntes Interceptor-Binding.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-annotation'></a>                     <pre><code>@InterceptorBinding

@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface Monitored {}
</code></pre>
                </div> Mit dieser Annotation können wir unsere Managed-Bean-Klassen oder einzelne Methoden annotieren.
Listing  <a href='#!idx:/cdi_basics.html:fig:intercepted_bean'> Verwendung der Interceptor-Annotation </a>  veranschaulicht dies stellvertretend mit der Klasse  <span class='latex-texttt'>IdeaRepository</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:intercepted_bean'></a>                     <pre><code>@Monitored
public class IdeaRepository {
  //...
}
</code></pre>
                </div> 
Da Annotationen nur Metadaten sind, benötigen wir einen zweiten Teil des Interceptor-Bindings, die Interceptor-Implementierung selbst.
Hierfür legen wir die Klasse  <span class='latex-texttt'>MonitoredInterceptor</span>  an und annotieren sie mit  <span class='latex-texttt'>@javax.interceptor.Interceptor</span> ,
um die Klasse als Interceptor-Implementierung zu markieren.
Der Name  <span class='latex-texttt'>MonitoredInterceptor</span>  setzt sich aus dem Namen der Interceptor-Binding Annotation und
dem Wort Interceptor zusammen und folgt einer optionalen, aber weit verbreiteten, Namenskonvention.
Allerdings müssen wir noch die Verbindung zwischen unserem Interceptor-Binding und der Interceptor-Implementierung definieren.
Aus diesem Grund annotieren wir die Interceptor-Implementierung mit unserer Interceptor-Binding Annotation.
Bisher haben wir nur eine leere Klasse, die mit Metadaten annotiert wurde.
In Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-implementation'> Interceptor-Implementierung </a>  ist ersichtlich, dass wir eine Interceptor-Methode benötigen,
die mit  <span class='latex-texttt'>@javax.interceptor.AroundInvoke</span>  annotiert ist.
Diese Methode kann einen beliebigen Namen haben, muss jedoch einen Parameter vom Typ  <span class='latex-texttt'>InvocationContext</span>  verwenden,
als Rückgabetyp  <span class='latex-texttt'>Object</span>  definieren und die Möglichkeit bieten, Exceptions zu werfen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-implementation'></a>                     <pre><code>@Monitored
@Interceptor
public class MonitoredInterceptor implements Serializable {

  @Inject
  private ApplicationConfig applicationConfig;

  @AroundInvoke
  public Object intercept(InvocationContext ic) throws Exception {
    long start = System.currentTimeMillis();

    try {
      return ic.proceed();
    } finally {
      if (isSlowInvocation(start)) {
        //...
      }
    }
  }

  private boolean isSlowInvocation(long start) {
    return System.currentTimeMillis() - start &gt;
      applicationConfig.getMethodInvocationThreshold();
  }
}
</code></pre>
                </div> 
Eine Interceptor-Instanz übernimmt den Scope der entsprechenden Contextual-Instance.
Somit gelten für Interceptor-Instanzen die gleichen Regeln wie für ein dependent-scoped Bean.
Da Sie im Normalfall nicht wissen, auf welches Bean der Interceptor angewandt wird,
sollten Interceptoren immer  <span class='latex-texttt'>Serializable</span>  implementieren.
Die Minimalanforderungen an eine Interceptor-Implementierung schreiben die Implementierung des  <span class='latex-texttt'>Serializable</span> -Interfaces nicht vor,
dennoch müssen Sie davon ausgehen, dass zur Laufzeit eine Interceptor-Instanz zusammen mit der Contextual-Instance serialisiert werden könnte.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In einem letzten Schritt müssen wir den Interceptor via  <span class='latex-texttt'>beans.xml</span>  aktivieren,
wie es in Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor_configuration'> Aktivierung einer Interceptor-Implementierung </a>  gemacht wird.
Die Reihenfolge bei der Verschachtelung von mehreren Interceptoren wird nicht durch die Reihenfolge der Interceptor-Annotationen definiert,
sondern durch die Auflistungsreihenfolge in der Konfigurationsdatei.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor_configuration'></a>                     <pre><code>&lt;beans&gt;
  &lt;interceptors&gt;
    &lt;class&gt;[package-name].MonitoredInterceptor&lt;/class&gt;
  &lt;/interceptors&gt;
&lt;/beans&gt;
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Seit CDI 1.1 (Java EE 7) bietet die Annotation <span class='latex-texttt'>@Priority</span> eine portable Alternative zur Interceptor-Konfiguration in <span class='latex-texttt'>beans.xml</span>. Interceptoren mit <span class='latex-texttt'>@Priority</span> werden global aktiviert &mdash; ohne Eintrag in der Konfigurationsdatei. Die Reihenfolge der Ausführung ergibt sich aus dem numerischen Wert: niedrigere Werte werden zuerst ausgeführt. Beispiel: <span class='latex-texttt'>@Priority(Interceptor.Priority.APPLICATION + 100)</span>.</div>
<div class="tip"><b>Tipp: </b>In Quarkus (Kapitel <a href='#!idx:/quarkus.html:10'>10</a>) werden Interceptoren von ArC vollständig unterstützt &mdash; die Aktivierung über <span class='latex-texttt'>@Priority</span> ist dort sogar die einzig mögliche Methode, da ArC <span class='latex-texttt'>beans.xml</span>-basierte Konfiguration nicht unterstützt. Decoratoren werden von ArC jedoch nicht unterstützt &mdash; ein wichtiger Unterschied bei der Migration.</div>
Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-implementation'> Interceptor-Implementierung </a>  hat außerdem gezeigt, dass eine Interceptor-Implementierung Injection-Points definieren kann.
Durch diese Möglichkeit können wir eine Einschränkung von Interceptoren umgehen.
Es ist nämlich nicht möglich, Interceptor-Implementierungen auszutauschen,
wie es bei CDI-Beans durch  <span class='latex-texttt'>@Alternative</span>  bzw.  <span class='latex-texttt'>@Specializes</span>  machbar ist.
Wir können zwar hartcodiert eine andere Implementierung konfigurieren,
aber wir werden in diesem Kapitel sowie im Kapitel zu portablen CDI-Erweiterungen sehen,
dass ein flexiblerer Ansatz vergleichsweise viele Vorteile mit sich bringt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der Trick besteht darin, dass wir über einen Injection-Point eine Implementierung injizieren können,
die wie gewohnt mit  <span class='latex-texttt'>@Alternative</span>  bzw.  <span class='latex-texttt'>@Specializes</span>  anpassbar ist.
Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-strategy'> Interceptor-Strategy </a>  veranschaulicht die Umsetzung.
Das separierte Bean implementiert äquivalent zur Interceptor-Implementierung das Interface  <span class='latex-texttt'>Serializable</span> .
Da die ausgelagerte Implementierung dependent-scoped ist,
wird kein Proxy erzeugt und der Overhead besteht primär aus der initialen Injizierung in die Interceptor-Instanz und
ist somit minimal.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  können wir diesen Trick verwenden, um einen vorkonfigurierten Interceptor für Unit-Tests auszutauschen.
Die alternative Implementierung der Interceptor-Strategy kann zusätzlichen Code für eine bessere Testbarkeit enthalten und
in das Testmodul ausgelagert werden. Wir wollen eine produktive Implementierung natürlich nicht mit Test-Code belasten.
In unserem Fall könnten wir ein Test-Bean mit diesem Interceptor versehen und eine entsprechend langsame Testmethode erstellen.
Eine spezielle Interceptor-Implementierung, die entsprechend gesteuert werden kann, ist in vielen Fällen einfacher.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Beginnen wir mit der Auslagerung der Interceptor-Logik selbst. Hierzu führen wir ein Interface namens  <span class='latex-texttt'>MonitoredInterceptorStrategy</span>  ein.
Bei der Definition der Methodensignatur folgen wir den Regeln für Interceptor-Methoden.
Nur auf die  <span class='latex-texttt'>@AroundInvoke</span> -Annotation können wir an dieser Stelle verzichten.
Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-strategy'> Interceptor-Strategy </a>  zeigt das neue Interface und die Default-Implementierung mit unserer bisherigen Interceptor-Logik.
In Listing  <a href='#!idx:/cdi_basics.html:fig:injected_interceptor-strategy'> Verwendung der Interceptor-Strategy </a>  sehen wir die angepasste Interceptor-Implementierung,
die an die aktive  <span class='latex-texttt'>MonitoredInterceptorStrategy</span>  delegiert.<br /> <div class="tip"><b>Tipp: </b> Wir übernehmen die Bezeichnung  <span class='latex-texttt'>InterceptorStrategy</span>  von populären CDI-Erweiterungen,
die wir in nachfolgenden Kapiteln kennenlernen werden. Es handelt sich um eine Namenskonvention,
die nicht von der CDI-Spezifikation vorgegeben wird. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-strategy'></a>                     <pre><code>public interface MonitoredInterceptorStrategy
  extends Serializable {
    Object intercept(InvocationContext ic) throws Exception;
}

@Dependent
public class DefaultMonitoredInterceptorStrategy
  implements MonitoredInterceptorStrategy {
    @Inject
    private ApplicationConfig applicationConfig;

    public Object intercept(InvocationContext ic)
      throws Exception {
        long start = System.currentTimeMillis();

        try {
          return ic.proceed();
        } finally {
          if (isSlowInvocation(start)) {
            //...
          }
        }
    }

    protected boolean isSlowInvocation(long s) {
      return System.currentTimeMillis() - s &gt;
        applicationConfig.getMethodInvocationThreshold();
    }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:injected_interceptor-strategy'></a>                     <pre><code>@Monitored
@Interceptor
public class MonitoredInterceptor implements Serializable {

  @Inject
  private MonitoredInterceptorStrategy interceptorStrategy;

  @AroundInvoke
  public Object intercept(InvocationContext ic) throws Exception {
    return this.interceptorStrategy.intercept(ic);
  }
}
</code></pre>
                </div> 
Im Zuge des Refactorings haben wir die Methode  <span class='latex-texttt'>isSlowInvocation</span>  als  <span class='latex-texttt'>protected</span>  definiert.
Im nächsten Schritt können wir, wie in Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-test-strategy'> Interceptor-Test-Strategy </a>  zu sehen ist,
eine spezialisierte Implementierung für einen entsprechenden Unit-Test einführen.
Listing  <a href='#!idx:/cdi_basics.html:fig:control_interceptor-test-strategy'> Kontrolle der Interceptor-Test-Strategy </a>  zeigt,
dass in einem Unit-Test das Ergebnis der überschriebenen Methode einfach gesteuert werden kann.
Für unseren einfachen Test ist eine simple statische Variable in  <span class='latex-texttt'>TestMonitoredInterceptorStrategy</span>  ausreichend.
Für komplexere Fälle kann es erforderlich sein, mit einem  <span class='latex-texttt'>ThreadLocal</span>  zu arbeiten.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-test-strategy'></a>                     <pre><code>@Specializes
@Dependent
public class TestMonitoredInterceptorStrategy
  extends DefaultMonitoredInterceptorStrategy {
    private static boolean slowInvocationSimulationModeActive;

    @Override
    protected boolean isSlowInvocation(long start) {
      return slowInvocationSimulationModeActive;
    }

    static void activateTestMode(boolean newValue) {
      ControllableMonitoredInterceptorStrategy
        .slowInvocationSimulationModeActive = newValue;
    }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:control_interceptor-test-strategy'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class InterceptorTest {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private MonitoredStorage monitoredStorage;

  @After
  public void resetInvocationMode() {
    TestMonitoredInterceptorStrategy.activateTestMode(false);
  }

  @Test
  public void normalMethodInvocation() {
    ideaManager.createIdeaFor("", "");
    Assert.assertTrue(monitoredStorage.getSlowMethods().isEmpty());
  }

  @Test
  public void slowMethodInvocation() {
    TestMonitoredInterceptorStrategy.activateTestMode(true);
    Assert.assertTrue(monitoredStorage.getSlowMethods().isEmpty());
    ideaManager.createIdeaFor("", "");
    Assert.assertFalse(monitoredStorage.getSlowMethods().isEmpty());
  }
}
</code></pre>
                </div> 
 <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.9.0.1' ><span class='entry-number'>2.9.0.1</span> Interceptoren mit Zusatzinformationen</a></h4>
 Äquivalent zu Qualifiern können auch Interceptor-Annotationen mit Annotation-Attributen versehen werden.
Ohne  <span class='latex-texttt'>@Nonbinding</span>  werden Annotation-Attribute, genau wie bei Qualifiern,
zum Auffinden der passenden Interceptor-Implementierung verwendet.
Zusätzlich ist es möglich eine Interceptor-Implementierung mit mehreren Interceptor-Binding Annotationen zu versehen.
Über diesen Mechanismus können Sie eine Interceptor-Implementierung an eine bestimmte Interceptor-Kombination binden.
In der Praxis sind die Anwendungsfälle für beide Konzepte sehr dünn gesät.
Für Interceptoren wesentlich interessanter sind die Verwendungsmöglichkeiten der  <span class='latex-texttt'>@Nonbinding</span> -Annotation.
Sie ermöglicht beispielsweise globale Konfigurationen mit Inline-Konfigurationen zu übersteuern.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  injizieren wir  <span class='latex-texttt'>ApplicationConfig</span>  in  <span class='latex-texttt'>DefaultMonitoredInterceptorStrategy</span> ,
um einen konfigurierten Wert auszulesen.
Im konkreten Fall legen wir über die Konfiguration die maximal erwartete Ausführungszeit einer durchschnittlichen Methode fest.
Überschreitet ein Methodenaufruf diesen Wert, wird dies mit Hilfe von  <span class='latex-texttt'>MonitoredStorage</span>  aufgezeichnet.
Es kann natürlich Ausnahmen geben, von denen wir wissen,
dass dieser Durchschnittswert immer überschritten wird oder die maximale Dauer niedriger bemessen werden soll.
Für Fälle wie diesen können wir ein mit  <span class='latex-texttt'>@Nonbinding</span>  annotiertes Annotation-Attribut hinzufügen,
um einen anderen Wert für solche Ausnahmefälle festzulegen.
Listing  <a href='#!idx:/cdi_basics.html:fig:interceptor-annotation_with_metadata'> Interceptor mit Zusatzinformation </a>  zeigt die Erweiterung der Interceptor-Binding Annotation und
 <a href='#!idx:/cdi_basics.html:fig:extract_interceptor_metadata'> Einfache Auswertung von Interceptor-Informationen </a>  die Auswertung dieser zusätzlichen Information.
Die hier gezeigte einfache Auswertung setzt voraus, dass die Interceptor-Annotation physisch entweder auf der intercepteten Methode oder
deren Klasse verfügbar ist. Wie wir im Kapitel  <a href='#!idx:/extensions.html:chap:cdi-extensions'>  Portable CDI-Erweiterungen </a>  sehen werden,
können Metadaten wie Interceptoren bei Bedarf dynamisch während des Containerstarts hinzugefügt werden.
Hierfür müssten wir uns die Managed-Bean Definition über den  <span class='latex-texttt'>BeanManager</span>  suchen,
da diese die effektive Bean-Definition zur Laufzeit enthält.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:interceptor-annotation_with_metadata'></a>                     <pre><code>@InterceptorBinding

@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface Monitored {
  @Nonbinding
  int maxThreshold() default -1;
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:extract_interceptor_metadata'></a>                     <pre><code>public class DefaultMonitoredInterceptorStrategy
  implements MonitoredInterceptorStrategy {
    //...
    @Inject
    private ApplicationConfig applicationConfig;

    @Override
    public Object intercept(InvocationContext ic) throws Exception {
      long start = System.currentTimeMillis();

      try {
        return ic.proceed();
      } finally {
        Monitored monitored = extractMonitoredAnnotation(ic);
        int maxThreshold = monitored.maxThreshold();

        if (maxThreshold &lt; 1) {
          maxThreshold = applicationConfig.getMethodInvocationThreshold();
        }
        if (isSlowInvocation(start, maxThreshold)) {
          //...
        }
      }
    }
  }
  private Monitored extractMonitoredAnnotation(InvocationContext ic) {
    Monitored result = ic.getMethod().getAnnotation(Monitored.class);

    if (result == null) {
      result = ic.getTarget().getClass()
        .getAnnotation(Monitored.class);
    }
    if (result == null) {
      result = ic.getTarget().getClass().getSuperclass()
        .getAnnotation(Monitored.class);
    }
    return result;
  }
  protected boolean isSlowInvocation(long start, int maxThreshold) {
    return System.currentTimeMillis() - start &gt; maxThreshold;
  }
}
</code></pre>
                </div> 
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.10' ><span class='entry-number'>2.10</span> Decoratoren</a> </h2>
 Abgesehen von generischen Querschnittsbelangen, die mit Interceptoren im vorherigen Kapitel erklärt wurden,
ist es mit CDI möglich, maßgeschneiderte fachliche Interceptoren zu erstellen.
In Applikationen sind die sogenannten Decoratoren, im Vergleich zu Interceptoren, eher selten zu finden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Um den möglichen Vorteil von Decoratoren etwas klarer darzustellen,
erweitern wir  <span class='latex-textit'>IdeaFork</span>  bevor wir unseren ersten Decorator implementieren.
Bis auf die Typisierung auf  <span class='latex-texttt'>Idea</span>  ist die Implementierung von  <span class='latex-texttt'>IdeaRepository</span>  generisch.
Eine tatsächlich generische Variante könnten wir für andere Entitäten wiederverwenden.
Bisher haben wir in  <span class='latex-textit'>IdeaFork</span>  keine Entität, die einen User repräsentiert und fügen daher eine gleichnamige Entität hinzu.
Mit Generics und entsprechenden Interfaces und abstrakten Klassen
können wir redundante Implementierungen verringern (siehe  <a href='#!idx:/cdi_basics.html:fig:refactoring_02'> Repository Refactoring in IdeaFork </a> ).
Somit führen wir unter anderem die abstrakte Klasse  <span class='latex-texttt'>BaseEntity</span>  und das Interface  <span class='latex-texttt'>GenericRepository</span>  ein.
Listing  <a href='#!idx:/cdi_basics.html:fig:refactoring_01'> Basis-Entität in IdeaFork </a>  veranschaulicht,
dass wir in der Klasse  <span class='latex-texttt'>BaseEntity</span>  außerdem ein neues Feld für die Version der Entität hinzufügen,
da wir diese im nächsten Schritt verwenden werden.
Die Entitäten  <span class='latex-texttt'>Idea</span>  und  <span class='latex-texttt'>User</span>  leiten von dieser neuen Basisklasse ab und erweitern sie um die entsprechenden Properties.
In  <span class='latex-textit'>IdeaFork</span>  wollen wir einen Autor vom Typ  <span class='latex-texttt'>User</span>  referenzieren.
Aus diesem Grund müssen wir JAXB Annotationen hinzufügen, damit unsere bestehenden  <span class='latex-texttt'>ObjectConverter</span> -Tests weiterhin funktionieren.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:refactoring_01'></a>                     <pre><code>public abstract class BaseEntity implements Serializable {
  protected String id;
  protected Long version;

  public BaseEntity() {
    this.id = UUID.randomUUID().toString();
  }

  public void increaseVersion() {
    if (version == null) {
      version = 0L;
    } else {
      version++;
    }
  }
  //...
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:refactoring_02'></a>                     <pre><code>public interface GenericRepository&lt;T extends BaseEntity&gt;
  extends Serializable {
    void save(T entity);
    void remove(T entity);
    T loadById(String id);
}

public interface IdeaRepository extends GenericRepository&lt;Idea&gt; {}

public abstract class GenericInMemoryRepository&lt;T extends BaseEntity&gt;
  implements GenericRepository&lt;T&gt; {
    protected Map&lt;String, T&gt; entityMap =
      new ConcurrentHashMap&lt;String, T&gt;();

    public void save(T entity) {
      entity.increaseVersion();
      this.entityMap.put(entity.getId(), clone(entity));
    }
    public void remove(T entity) {
      this.entityMap.remove(entity.getId());
    }
    public T loadById(String id) {
      T originalEntity = this.entityMap.get(id);
      T detachedEntity = null;

      if (originalEntity != null) {
        detachedEntity = clone(originalEntity);
      }
      return detachedEntity;
  }
  public static &lt;T&gt; T clone(T source) { /*...*/ }
}

@Monitored
public class IdeaInMemoryRepository extends GenericInMemoryRepository&lt;Idea&gt;
  implements IdeaRepository {}
</code></pre>
                </div> 
Da wir  <span class='latex-texttt'>Idea</span>  nur vorübergehend als Event-Typ verwendet haben und dies spätestens jetzt nicht mehr sinnvoll ist,
erstellen wir die Klasse  <span class='latex-texttt'>EntityChangedEvent</span> , die in Listing  <a href='#!idx:/cdi_basics.html:fig:custom_event-class'> Explizite Event-Klasse </a>  zu sehen ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:custom_event-class'></a>                     <pre><code>public abstract class EntityChangedEvent &lt;T extends BaseEntity&gt; {
  private final T entity;
  private final long creationTimestamp;

  public EntityChangedEvent(T entity) {
    this.entity = entity;
    this.creationTimestamp = System.currentTimeMillis();
  }

  public T getEntity() {
    return entity;
  }

  public long getCreationTimestamp() {
    return creationTimestamp;
  }
}

public class UserChangedEvent extends EntityChangedEvent&lt;User&gt; {
  public UserChangedEvent(User createdEntity) {
    super(createdEntity);
  }
}
</code></pre>
                </div> 
Mit diesem Stand sind wir bereit, einen sinnvollen Decorator zu erstellen.
 <span class='latex-texttt'>GenericInMemoryRepository</span>  enthält nur noch die effektive Logik für die Verwaltung von Entitäten und
nicht mehr die Erzeugung von Events.
Dies ist der Grund, warum zu diesem Punkt unseres Refactorings die Tests in  <span class='latex-texttt'>EventTest</span>  fehlschlagen.
Die Event-Behandlung werden wir im nächsten Schritt in einen Decorator auslagern.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Durch das neue Interface  <span class='latex-texttt'>GenericRepository</span>  können wir eine abstrakte Klasse  <span class='latex-texttt'>GenericRepositoryDecorator</span>  erstellen,
da wir ein Interface als Basis benötigen.
Die abstrakte Klasse kann für alle  <span class='latex-texttt'>GenericRepository</span> -Decoratoren als Basis-Klasse verwendet werden.
Hierfür implementieren wir das zu dekorierende Interface selbst und fügen an den entsprechenden Stellen die benötigte Decorator-Logik hinzu.
In unserem Fall implementieren wir mit der Methode  <span class='latex-texttt'>checkEntity</span>  eine grundlegende Überprüfung,
die wir ausführen, bevor an die dekorierte Instanz delegiert wird.
Somit können wir rudimentäre technische Überprüfungen von der Repository-Implementierung trennen.
Außerdem rufen wir nach einer erfolgreichen Speicherung die abstrakte Methode  <span class='latex-texttt'>fireEntityChangedEvent</span>  auf.
Konkrete Decorator-Implementierungen stellen diese zur Verfügung und können somit das jeweils benötigte Event feuern.
Mit Hilfe der abstrakten Methode  <span class='latex-texttt'>getDelegate</span>  können wir in der generischen Implementierung auf die dekorierte Instanz zugreifen,
die von einem konkreten Decorator zur Verfügung gestellt werden muss.
Die wichtigsten Bestandteile von  <span class='latex-texttt'>GenericRepositoryDecorator</span>  sind in Listing  <a href='#!idx:/cdi_basics.html:fig:generic_repository-decorator'> Generische Decorator Logik </a>  ersichtlich.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:generic_repository-decorator'></a>                     <pre><code>public abstract class GenericRepositoryDecorator
  &lt;T extends BaseEntity&gt; implements GenericRepository&lt;T&gt; {

    protected abstract GenericRepository&lt;T&gt; getDelegate();

    protected abstract void fireEntityChangedEvent(T entity);

    @Override
    public void save(T entity) {
      checkEntity(entity);
      getDelegate().save(entity);
      fireEntityChangedEvent(entity);
    }

    @Override
    public void remove(T entity) {
      checkEntity(entity);
      getDelegate().remove(entity);
    }

    @Override
    public T loadById(String id) {
      if (id == null) {
        throw new IllegalArgumentException("...");
      }
      return getDelegate().loadById(id);
    }

    private void checkEntity(T entity) {
      //...
    }
}
</code></pre>
                </div> 
Listing  <a href='#!idx:/cdi_basics.html:fig:repository-decorator_implementation'> Decorator Implementierung </a>  zeigt ein Beispiel für eine konkrete Decorator Implementierung.
Äquivalent zu Interceptoren gibt es eine Marker-Annotation namens  <span class='latex-texttt'>@Decorator</span> ,
die dem CDI-Container signalisiert, dass es sich bei dieser Klasse um eine Decorator-Implementierung handelt.
Durch  <span class='latex-texttt'>@Delegate</span>  in Kombination mit  <span class='latex-texttt'>@Inject</span>  können wir uns die nächste Instanz in der Kette injizieren.
Normalerweise muss der Typ des injizierten Delegates mit dem Decorator-Typ übereinstimmen.
Wollen wir beispielsweise  <span class='latex-texttt'>IdeaRepository</span>  dekorieren, so muss der Decorator  <span class='latex-texttt'>IdeaRepository</span>  implementieren.
Da  <span class='latex-texttt'>GenericRepositoryDecorator</span>  und unsere Repositories in diesem Fall  <span class='latex-texttt'>GenericRepository</span>  implementieren,
ist dies aus technischer Sicht bereits ausreichend, da der korrekte Decorator über Generics identifiziert wird.
Obwohl in diesem Fall die Implementierung des konkreten Repository-Interfaces technisch gesehen nicht erforderlich ist,
sollte dies gemacht werden, da wir nur über diesen Weg Methoden dekorieren können,
die durch ein konkretes  <span class='latex-texttt'>Repository</span> -Interface und nicht durch das  <span class='latex-texttt'>GenericRepository</span> -Interface definiert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:repository-decorator_implementation'></a>                     <pre><code>@Decorator
public class IdeaRepositoryDecorator
  extends GenericRepositoryDecorator&lt;Idea&gt;
  implements IdeaRepository /*optional here*/ {

    @Inject
    @Delegate
    private IdeaRepository delegate;

    @Inject
    private Event&lt;IdeaChangedEvent&gt; changedEvent;

    protected IdeaRepository getDelegate() {
      return delegate;
    }

    @Override
    protected void fireEntityChangedEvent(Idea entity) {
        changedEvent.fire(new IdeaChangedEvent(entity));
    }
}
</code></pre>
                </div> 
Listing  <a href='#!idx:/cdi_basics.html:fig:decorator_configuration'> Aktivierung einer Decorator-Implementierung </a>  stellt den letzten Schritt bei der Implementierung eines Decorators dar.
Äquivalent zu Interceptoren müssen Decoratoren in der Datei  <span class='latex-texttt'>beans.xml</span>  aktiviert werden.
Sollte es für ein Bean mehrere Decoratoren geben,
so kann die Verschachtelungsreihenfolge durch die Reihenfolge bei der Auflistung definiert werden.
Damit die Tests in  <span class='latex-texttt'>EventTest</span>  wieder funktionieren,
müssen wir natürlich unsere Observer-Methoden noch von  <span class='latex-texttt'>Idea</span>  auf  <span class='latex-texttt'>IdeaChangedEvent</span>  umstellen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:decorator_configuration'></a>                     <pre><code>&lt;decorators&gt;
  &lt;class&gt;[package-name].IdeaRepositoryDecorator&lt;/class&gt;
&lt;/decorators&gt;
</code></pre>
                </div> 
Einen weiteren Vorteil, den wir durch die Auftrennung der Repository-Logik erhalten,
werden wir sehen, sobald wir im Kapitel  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  alternative JPA-Repository-Implementierungen erstellen werden.
Diese werden nämlich ebenfalls unsere eben erstellten Decorator-Implementierungen verwenden und
müssen die grundlegenden Überprüfungen sowie die Event-Logik nicht redundant implementieren.
Dies ist selbstverständlich nur als Beispiel gedacht, da in der Praxis oft nur eine Repository-Implementierung erstellt wird.
Somit sollten Sie in Ihren Projekten genau evaluieren, ab wann sich die zusätzliche Komplexität durch die Einführung von Decoratoren lohnt.<br /> <h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.10.0.1' ><span class='entry-number'>2.10.0.1</span> Abstrakte Decoratoren</a></h4>
 In vielen Fällen gibt es nicht für jede Methode Decorator-Logik.
Decorator-Methoden ohne zusätzliche Logik würden einfach den Aufruf manuell weiterdelegieren.
Daher erlaubt CDI die Verwendung von abstrakten Decorator-Klassen.
Methoden, die nicht durch einen abstrakten Decorator implementiert sind, werden automatisch an die nächste Instanz in der Kette weitergeleitet.
In  <span class='latex-textit'>IdeaFork</span>  können wir  <span class='latex-texttt'>EntityChangeRepository</span>  hinzufügen, um Änderungen an Entitäten zu archivieren.
Listing  <a href='#!idx:/cdi_basics.html:fig:abstract-decorator'> Abstrakter Decorator </a>  veranschaulicht,
dass nur eine Methode im dazugehörigen abstrakten Decorator implementiert und mit Decorator-Logik ausgestattet ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:abstract-decorator'></a>                     <pre><code>@Decorator
public abstract class EntityChangeRepositoryDecorator
  implements EntityChangeRepository {
    @Inject
    @Delegate
    private EntityChangeRepository delegate;

    @Override
    public void save(EntityChange entity) {
      checkEntity(entity);
      this.delegate.save(entity);
    }

    private void checkEntity(EntityChange ec) {
      //...
    }
}
</code></pre>
                </div> 
 <span class='latex-texttt'>EntityChangeRepository</span>  definiert außerdem die Methode  <span class='latex-texttt'>findRevision</span> ,
die mit der ID einer Entität und der Versionsnummer den dazugehörigen archivierten Stand der Entität sucht.
Die einzelnen Zustände der Entität können wir mit einem Observer automatisch speichern.
Listing  <a href='#!idx:/cdi_basics.html:fig:rev-history_observer'> Observer zur Speicherung von Revisionen </a>  zeigt die Observer- Implementierung in der Klasse  <span class='latex-texttt'>IdeaHistoryProcessor</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:rev-history_observer'></a>                     <pre><code>@ApplicationScoped
public class IdeaHistoryProcessor {
  @Inject
  private ObjectConverter currentObjectConverter;

  @Inject
  private EntityChangeRepository entityChangeRepository;

  public void onIdeaCreated(
    @Observes IdeaChangedEvent changedEvent) {
      Idea entity = changedEvent.getEntity();
      String ideaSnapshot = currentObjectConverter.toString(entity);
      EntityChange entityChange =
        new EntityChange(
            entity.getId(),
            entity.getVersion(),
            ideaSnapshot,
            changedEvent.getCreationTimestamp());
      entityChangeRepository.save(entityChange);
  }
}
</code></pre>
                </div> 
Bisher haben wir unseren Repository-Implementierungen keinen Scope vergeben.
Da wir die Contextual-Instance immer nur in unseren Unit-Tests injiziert und angesprochen haben,
sind die damit verbundenen Einschränkungen bisher nicht aufgefallen.
 <span class='latex-texttt'>EntityChangeRepository</span>  verwenden wir hingegen in der Klasse  <span class='latex-texttt'>IdeaHistoryProcessor</span> und Listing  <a href='#!idx:/cdi_basics.html:fig:check_observer-logic'> Ergebnis der Observer-Logik überprüfen </a>  veranschaulicht einen Ausschnitt aus einem Unit-Test,
der die zweite Verwendung darstellt. Aus diesem Grund muss  <span class='latex-texttt'>EntityChangeInMemoryRepository</span>  einen expliziten Scope erhalten.
In unserem Fall entscheiden wir uns für den Application-Scope.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:check_observer-logic'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class DecoratorTest {
  //...

  @Test
  public void passingGenericDecoratorCheck() {
    //...
    Idea newIdea = ideaManager.createIdeaFor(...);
    ideaRepository.save(newIdea);

    Idea savedIdea = ideaRepository.loadById(newIdea.getId());

    EntityChange revision = entityChangeRepository.findRevision(
      savedIdea.getId(), savedIdea.getVersion());

    Assert.assertNotNull(revision);

    Idea archivedIdea = objectConverter.toObject(
      revision.getEntityState(), Idea.class);
    Assert.assertEquals(savedIdea, archivedIdea);
  }
}
</code></pre>
                </div> 
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.11' ><span class='entry-number'>2.11</span> Stereotypes</a> </h2>
 Im vorherigen Kapitel haben wir herausgefunden, dass unsere Repository-Implementierungen einen Scope haben sollten.
Im aktuellen Stand von  <span class='latex-textit'>IdeaFork</span>  haben wir jedoch eine Inkonsistenz.
 <span class='latex-texttt'>EntityChangeRepository</span>  ist application-scoped und
die anderen Repository-Implementierungen sind nur mit  <span class='latex-texttt'>@Monitored</span>  annotiert und somit implizit dependent-scoped.
Mit CDI-Stereotypen ist es möglich, solche Inkonsistenzen zentral zu lösen und Annotationen ausdrucksstärker und effizienter zu nutzen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Vergleichbar mit UML-Stereotypen können mit CDI-Stereotypen Rollen eines Managed-Beans zum Ausdruck gebracht werden.
Zusätzlich ermöglichen Stereotypen Informationen zu kapseln.
Statt gleichartige Managed-Beans mit mehreren und vor allem immer gleichen Annotationen zu versehen,
können wir eine Stereotyp-Annotation definieren, die diese Annotationen kapselt.
Die Annotation sollte nach dem Artefakt-Typ benannt werden.
In unserem Fall legen wir eine Stereotyp-Annotation namens  <span class='latex-texttt'>@Repository</span>  an und annotieren diese,
wie in Listing  <a href='#!idx:/cdi_basics.html:fig:stereotype-annotation'> Eigene Stereotyp-Annotation </a> , mit  <span class='latex-texttt'>@ApplicationScoped</span>  und  <span class='latex-texttt'>@Monitored</span> .
Damit der CDI-Container unsere Stereotyp-Annotation als solche erkennt, muss diese mit  <span class='latex-texttt'>@Stereotype</span>  annotiert werden.
Wir verwenden in  <span class='latex-textit'>IdeaFork</span>  keine Producer für Repository-Implementierungen und daher genügt  <span class='latex-texttt'>ElementType.TYPE</span>  für  <span class='latex-texttt'>@Target</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:stereotype-annotation'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Stereotype
@ApplicationScoped
@Monitored
public @interface Repository {}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_basics.html:fig:bean_with_stereotype'> Verwendung einer eigenen Stereotyp-Annotation </a>  zeigt die vereinfachte Implementierung von  <span class='latex-texttt'>EntityChangeInMemoryRepository</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:bean_with_stereotype'></a>                     <pre><code>@Repository
public class EntityChangeInMemoryRepository
  extends GenericInMemoryRepository&lt;EntityChange&gt;
  implements EntityChangeRepository {

    @Override
    public EntityChange findRevision(
      String entityId, long entityVersionToFind) {
        for (EntityChange current : entityMap.values()) {
          if (current.getEntityId().equals(entityId) &&
              current.getEntityVersion() == entityVersionToFind) {
                return current;
          }
        }
        return null;
    }
}
</code></pre>
                </div> 
Natürlich annotieren wir die anderen Repository-Implementierungen ebenfalls mit unserer neuen Stereotyp-Annotation.
Zukünftige Änderungen, wie beispielsweise die Änderung des Scopes,
können durch die Stereotyp-Annotation zentral für alle Implementierungen vorgenommen werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Stereotypen können, wie in Listing  <a href='#!idx:/cdi_basics.html:fig:stereotype-annotation'> Eigene Stereotyp-Annotation </a> , den Default-Scope eines Managed-Beans vorgeben.
Dieser kann bei konkreten Implementierungen für spezielle Fälle überschrieben werden,
indem der Scope bei der Implementierung explizit angegeben wird.
Ähnliches gilt für den Namen eines Beans.  <span class='latex-texttt'>@javax.enterprise.inject.Model</span>  ist ein Stereotyp,
der in der CDI-Spezifikation definiert ist. Diese Stereotyp-Annotation ist mit  <span class='latex-texttt'>@RequestScoped</span>  und  <span class='latex-texttt'>@Named</span>  annotiert.
Beans, die mit  <span class='latex-texttt'>@Model</span>  annotiert werden, bekommen automatisch einen Namen auf Basis der Default-Namenskonvention.
Soll ein mit  <span class='latex-texttt'>@Model</span>  annotiertes Bean einen anderen Namen erhalten,
so kann der Default-Name durch die explizite Verwendung von  <span class='latex-texttt'>@Named</span>  übersteuert werden.
Mehr Details zur Benennung von Managed-Beans werden wir im Kapitel  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  betrachten.<br /> <div class="tip"><b>Tipp: </b> Im vorherigen Kapitel haben wir manuell die Interceptor-Annotation gesucht.
Da wir  <span class='latex-texttt'>@Monitored</span>  in  <span class='latex-texttt'>@Repository</span>  verschoben haben,
müssen wir die Logik zum Auffinden der Annotation entsprechend erweitern und alle Annotationen analysieren.
In  <span class='latex-textit'>IdeaFork</span>  wird eine einfache Umsetzung illustriert.
Wollen Sie umfangreichere Konstellationen, wie beispielsweise Stereotyp-Annotationen annotierte mit einer oder mehreren anderen Stereotyp-Annotation/en,
unterstützen, so muss die Suchlogik aufwändiger umgesetzt werden. </div><h4><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.11.0.1' ><span class='entry-number'>2.11.0.1</span> Alternative-Stereotypen</a></h4>
 Bei der Verwendung von alternativen Implementierungen haben wir bisher jede Klasse separat in der Datei  <span class='latex-texttt'>beans.xml</span>  aktiviert.
In großen Applikationen mit vielen alternativen Beans kann dies sehr aufwändig und fehleranfällig werden.
Aus diesem Grund stellt CDI einen einfachen und ausdrucksstarken Mechanismus auf Basis von Stereotypen zur Verfügung.
Eine eigene Annotation, die mindestens mit  <span class='latex-texttt'>@Stereotype</span>  und  <span class='latex-texttt'>@Alternative</span>  annotiert ist,
ermöglicht die Aktivierung aller Alternativen, die mit dieser Stereotyp-Annotation versehen sind.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ein häufig anzutreffender Anwendungsfall ist die Aktivierung von Mock- bzw. Test-Klassen für Unit-Tests.
Zur Abwechslung beginnen wir mit einem anderen Anwendungsfall.
In  <span class='latex-textit'>IdeaFork</span>  möchten wir alle Jackson-Converter mit einem Konfigurationseintrag de-/aktivieren können.
Die Annotation  <span class='latex-texttt'>@JacksonConverter</span> , die in Listing  <a href='#!idx:/cdi_basics.html:fig:alternative-stereotype-annotation'> Alternative Stereotyp-Annotation </a>  zu sehen ist,
erhält außerdem die  <span class='latex-texttt'>@Monitored</span>  Interceptor-Binding Annotation, sowie  <span class='latex-texttt'>@ApplicationScoped</span>  als Default-Scope.
Listing  <a href='#!idx:/cdi_basics.html:fig:alternative-stereotype_configuration'> Aktivierung alternativer Beans via Stereotyp </a>  veranschaulicht die Aktivierung aller Jackson-Converter Implementierungen
mit nur einem Eintrag in der Datei  <span class='latex-texttt'>beans.xml</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:alternative-stereotype-annotation'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Alternative
@Stereotype
@ApplicationScoped
@Monitored
public @interface JacksonConverter {}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:alternative-stereotype_configuration'></a>                     <pre><code>&lt;beans&gt;
  &lt;alternatives&gt;
    &lt;stereotype&gt;[package-name].JacksonConverter&lt;/stereotype&gt;
  &lt;/alternatives&gt;
&lt;/beans&gt;
</code></pre>
                </div> 
 <h2><a class='latex-index-anchor' name='!idx:/cdi_basics.html:2.12' ><span class='entry-number'>2.12</span> Explizite Typisierung</a> </h2>
 Direkte typsichere Dependency-Injection bedeutet, dass es nur ein Managed-Bean je Typ geben kann.
Wir haben bereits Qualifier als Erweiterung des Typsystems und die Möglichkeit von dynamischen Lookups kennengelernt.
Mit diesen Konzepten ist es möglich, die Einschränkungen von typsicherer Dependency-Injection etwas auszudehnen.
Es gibt allerdings Fälle, in denen ein Bean aus Sicht von Java mehrere Typen haben kann und
für den CDI Injection-Prozess nur eine Teilmenge davon erhalten soll, um beispielsweise Typ-Überschneidungen mit anderen Beans zu verhindern.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  können wir beispielsweise die Anzahl der erforderlichen Injection-Points reduzieren,
wenn wir aus  <span class='latex-texttt'>IdeaManager</span>  und  <span class='latex-texttt'>UserManager</span>  eine Facade machen.
Beide Klassen können die dazugehörigen Repository-Interfaces implementieren und
die entsprechenden Methoden an das jeweilige Repository delegieren.
Implementiert beispielsweise  <span class='latex-texttt'>IdeaManager</span>  das Interface  <span class='latex-texttt'>IdeaRepository</span> ,
so haben wir in der Applikation zwei Managed-Beans vom Typ  <span class='latex-texttt'>IdeaRepository</span> .
Doppeldeutigkeiten wie diese führen zu einem Fehlstart der Applikation und eine  <span class='latex-texttt'>AmbiguousResolutionException</span>  ist das Ergebnis.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bei einem Injection-Point vom Typ  <span class='latex-texttt'>IdeaRepository</span>  weiß der CDI-Container durch unsere gewünschte Änderung nicht,
ob  <span class='latex-texttt'>IdeaManager</span>  oder  <span class='latex-texttt'>IdeaInMemoryRepository</span>  injiziert werden soll.
In unserem Fall möchten wir  <span class='latex-texttt'>IdeaInMemoryRepository</span>  injizieren,
da  <span class='latex-texttt'>IdeaManager</span>  dieses ebenfalls für die Delegierung der Methodenaufrufe verwendet.
Solche Mehrdeutigkeiten können mit der Annotation  <span class='latex-texttt'>@Typed</span>  elegant aufgelöst werden.
Sie ermöglicht die Angabe von beliebigen Typen eines Managed-Beans,
die für den CDI-Container für den Injection-Prozess verwendet werden sollen.
Mit  <span class='latex-texttt'>@Typed()</span>  kann eine Klasse sogar für das Typsystem von CDI unsichtbar gemacht werden.
Das Managed-Bean selbst existiert weiterhin im Hintergrund,
doch es hat aus Sicht des CDI-Containers keinen Typ und kann deshalb nicht gefunden werden.
Nur  <span class='latex-texttt'>@Named</span>  könnte noch dafür sorgen, dass ein solches Managed-Bean über dessen Namen gefunden werden kann.
Diesen Trick haben wir bereits bei  <span class='latex-texttt'>ApplicationConfig</span>  genutzt,
damit wir für die Producer-Methode keinen zusätzlichen Qualifier benötigen.
Abgesehen von der kompletten Entfernung der Typinformation ist es auch möglich, 1-n Typen explizit zu definieren.
Nur diese Typen werden für das Managed-Bean vom CDI-Container verwendet.
Für unsere Manager-Facade können wir, wie in Listing  <a href='#!idx:/cdi_basics.html:fig:explicit_typing'> Explizite Typisierung </a> , die Manager-Klasse selbst angeben.
Unsere typsicheren Injection-Points werden somit wieder eindeutig.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_basics.html:fig:explicit_typing'></a>                     <pre><code>@ApplicationScoped
@Typed(IdeaManager.class)
public class IdeaManager implements IdeaRepository {
  //...
}
</code></pre>
                </div> 
 <span class='latex-texttt'>@Typed</span>  kann daher für komplexere Konstellationen mit mehreren Interfaces bzw. einer Basisklasse verwendet werden und
ermöglicht bei Bedarf die Verwendung komplexer Typhierarchien.
<div class="tip"><b>Tipp: </b><b>CDI damals und heute &mdash; Die wichtigsten Änderungen:</b><br />
&bull; <b>Bean Discovery:</b> CDI 1.0 verwendet <span class='latex-texttt'>bean-discovery-mode="all"</span> als Standard. Ab CDI 4.0 ist <span class='latex-texttt'>"annotated"</span> der Standard &mdash; nur explizit annotierte Klassen werden erkannt.<br />
&bull; <b>Namespace:</b> <span class='latex-texttt'>javax.enterprise</span> wird zu <span class='latex-texttt'>jakarta.enterprise</span> (ab Jakarta EE 10).<br />
&bull; <b>Leere beans.xml:</b> CDI 1.0 erfordert eine <span class='latex-texttt'>beans.xml</span>. Ab CDI 1.1 ist sie optional, ab CDI 4.0 wird <span class='latex-texttt'>bean-discovery-mode="annotated"</span> der Standardmodus auch ohne Datei.<br />
&bull; <b>@Priority:</b> Ab CDI 1.1 können Alternativen und Interceptoren per <span class='latex-texttt'>@Priority</span> aktiviert werden &mdash; die Konfiguration in <span class='latex-texttt'>beans.xml</span> ist nicht mehr zwingend nötig.<br />
&bull; <b>Asynchrone Events:</b> Ab CDI 2.0 werden <span class='latex-texttt'>@ObservesAsync</span> und <span class='latex-texttt'>fireAsync()</span> nativ unterstützt.</div>
</section>
<section class="chapter-section" id="chapter-3">
<h1> <a class='latex-index-anchor' name='!idx:/java_ee.html:3' ><span class='entry-number'>3</span> CDI und Java EE</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Der Text dieses Kapitels wurde von Claude (AI built by Anthropic) als Co-Autor überarbeitet. Die Überarbeitung erfolgte ohne Post-Review des Originalautors. Die Nutzung der Inhalte erfolgt auf eigene Verantwortung.
</div>
<a name = '!idx:/java_ee.html:chap:cdi-java_ee'> </a> CDI wurde erstmals mit Java EE6 als fixer Bestandteil der Java EE Plattform veröffentlicht.
Anfangs war CDI primär als Bindeglied zwischen JSF und EJB gedacht.
Darauf ist auch der ursprüngliche Name der Spezifikation (Web-Beans) zurückzuführen.
Doch CDI wurde sehr schnell zu einem vollwertigen Komponentenmodell, das weit mehr als nur ein Bindeglied ist.
Obwohl dies in der ersten Revision der Spezifikation nicht vorgesehen war,
kann sowohl Apache OpenWebBeans als auch JBoss Weld, mit Hilfe von proprietären APIs,
in Java SE Applikationen verwendet werden.
Seit CDI 1.1 wird dies durch die Spezifikation selbst unterstützt.
Im Kapitel  <a href='#!idx:/deltaspike.html:chap:deltaspike'>  Apache DeltaSpike </a>  werden wir die Kompatibilität mit Java SE genauer betrachten.
In diesem Kapitel konzentrieren wir uns auf die Standardintegration in Java EE6 und EE7.<br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.1' ><span class='entry-number'>3.1</span> Die ersten Schritte in Richtung Java EE</a> </h2>
 In Java EE6 wurden einige grundlegende Integrationspunkte direkt in der CDI- und Plattform-Spezifikation definiert.
Als Grundregel kann in jeder gemanagten Instanz einer Klasse, bei der Ressourcen-Injizierung bereits mit Java EE5 möglich war,
auch CDI basierte Injizierung via  <span class='latex-texttt'>@Inject</span>  verwendet werden. Durch diese Regel kann CDI Injizierung in Artefakten unterstützt werden,
die nicht explizit in der Plattform-Spezifikation aufgelistet werden.
Darüber hinaus unterstützen EE Server Injection-Points für vordefinierte EE Artefakte. Hierzu zählen  <span class='latex-texttt'>UserTransaction</span> ,
 <span class='latex-texttt'>javax.validation.ValidationFactory</span> ,  <span class='latex-texttt'>javax.validation.Validator</span>  und  <span class='latex-texttt'>javax.security.Principal</span> .<br />Durch die enge Integration von CDI, EJB und JSF stößt man in vielen Fällen erst spät an die Grenzen der Integrationspunkte.
In den nachfolgenden Revisionen von Java EE werden diese Grenzen weiter verschoben.
Dank der stark zunehmenden Verbreitung von CDI wird seit EE7 die Integration mit CDI auch in anderen EE Spezifikationen ausgeweitet.
Doch bereits EE6 selbst bietet viele Integrationspunkte.
Einige davon werden wir in den nachfolgenden Teilen dieses Kapitels genauer betrachten.
Bevor wir eine Web-Oberfläche für  <span class='latex-textit'>IdeaFork</span>  erstellen und dessen Funktionalität erweitern,
werfen wir einen Blick auf die Umstrukturierungsmöglichkeiten in CDI basierten Applikationen.
In  <span class='latex-textit'>IdeaFork</span>  können wir beispielsweise sämtliche Klassen in ein anderes Package verschieben.
Jede moderne Java IDE unterstützt solche Änderungen in wenigen Schritten.
Durch die Typsicherheit von Java wird das Ergebnis spätestens durch den Compiler überprüft.
In vielen Projekten wird die Konfigurationsdatei  <span class='latex-texttt'>beans.xml</span>  als einfacher Marker verwendet,
wodurch für CDI keine weiteren Änderungen erforderlich sind. In  <span class='latex-textit'>IdeaFork</span>  nutzen wir allerdings einige Konfigurationsmöglichkeiten.
Manche IDEs stellen einen erstklassigen CDI-Support zur Verfügung, wodurch selbst diese Konfigurationseinträge automatisch aktualisiert werden.
Sollte dies nicht der Fall sein und ein oder mehrere Einträge sind nach der Umstrukturierung nicht mehr aktuell,
so wird dies spätestens beim nächsten Applikationsstart vom CDI-Container überprüft und als Fehler erkannt.
Der Startvorgang wird in einem solchen Fall mit einer entsprechenden Fehlermeldung abgebrochen.
Technische Fehler, die erst nach dem Deployment der Applikation auftreten, werden dadurch auf ein absolutes Minimum reduziert.
Hier müssen primär dynamische Bean-Lookups, die nur im Ausnahmefall oder in Verbindung mit der EL (Expression Language) empfehlenswert sind,
berücksichtigt werden.<br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.2' ><span class='entry-number'>3.2</span> Web-Applikationen mit CDI</a> </h2>
 Sowohl JSF als auch JAX-RS basieren auf Servlets.
Für Servlet basierte Technologien gelten die gleichen Regeln in Hinblick auf die Konfiguration von CDI.
Die Datei  <span class='latex-texttt'>beans.xml</span>  könnten wir wie bisher im Verzeichnis  <span class='latex-texttt'>META-INF</span>  hinterlegen.
In Web-Applikationen wird zusätzlich  <span class='latex-texttt'>WEB-INF</span>  als Konfigurationsverzeichnis unterstützt.
Manche EE Server unterstützen  <span class='latex-texttt'>META-INF/beans.xml</span>  in Web-Applikationen allerdings nicht korrekt.
Aus diesem Grund verwenden wir das Verzeichnis  <span class='latex-texttt'>WEB-INF</span> .
Nachdem wir  <span class='latex-texttt'>WEB-INF/beans.xml</span>  als leere Markerdatei angelegt haben, ist CDI im Web-Modul unserer Applikation aktiviert und
wir können die ersten Funktionalitäten umsetzen.<br /> <div class="tip"><b>Tipp: </b> Unsere primäre Laufzeitumgebung ist Apache TomEE 1.7+.
Darüber hinaus ist  <span class='latex-textit'>IdeaFork</span>  auch mit anderen EE6 Servern wie beispielsweise JBoss AS7 und Oracle Glassfish 3 getestet.
Eine grundsätzliche Kompatibilität besteht jedoch mit jedem Server, der Java EE6 spezifikationskonform unterstützt. </div> Das zentrale Thema bei zustandsbehafteten Web-Applikationen im Java EE Umfeld im Zusammenhang mit CDI
ist die Behandlung der serverseitigen Scopes.
Der Request- sowie der Session-Scope sind für alle Servlet basierten Technologien relevant.
Die korrekte Behandlung beider Scopes wird durch den CDI-Container sichergestellt.
Somit sind hier keine zusätzlichen Integrationen in den anderen Spezifikationen erforderlich.
Applikationsentwickler können CDI-Beans mit den entsprechenden Scope-Annotationen versehen und
der CDI-Container sorgt wie gewohnt für die korrekte Verwaltung der Beans.
Damit wir unsere bisherige Implementierung unabhängig wiederverwenden können,
erstellen wir ein neues Java EE6 spezifisches Web-Modul.
In diesem definieren wir die Java EE6 API und unser bisheriges Modul als Abhängigkeit.<br /> <div class="tip"><b>Tipp: </b> Seit EE6 bietet die Verwendung von Enterprise-Archiven (EARs) im Vergleich zu einfachen Web-Archiven (WARs) nur wenige Vorteile,
aber in vielen Applikationsservern ergeben sich durch die unterschiedliche Interpretation der Bean Deployment Archive (BDA) Regeln
unnötige Nachteile. In  <span class='latex-textit'>IdeaFork</span>  gibt es keinen Bedarf für EARs und daher können wir durch die Verwendung eines Web-Archivs die Portabilität erhöhen. </div><h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.3' ><span class='entry-number'>3.3</span> JSF mit CDI</a> </h2>
 In Java EE6 wird die CDI-Integration mit JSF primär durch die CDI-Spezifikation definiert.
Da JSF-Beans laut der EE6 Plattform-Spezifikation Komponenten sind, die Injizierung unterstützen müssen,
können in einem EE-Server CDI-Beans problemlos in JSF-Beans injiziert werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Injizierung in anderen JSF Artefakten, wie beispielsweise in Phase-Listenern, wird in EE6 allerdings noch nicht unterstützt.
Neben Java-Klassen spielen in JSF auch die sogenannten View Declaration Languages (VDL) eine zentrale Rolle.
Sowohl JSP als auch die modernere Alternative namens Facelets verwenden die Expression-Language (EL), um auf Beans zuzugreifen.
Durch  <span class='latex-texttt'>@Named</span>  (aus JSR-330) können CDI-Beans in einer EL-Expression mit ihrem Namen angesprochen werden.
Wie in JSF üblich wird dies intern mit einem eigenen EL-Resolver umgesetzt.
CDI-Implementierungen registrieren diesen EL-Resolver automatisch, wodurch die Integration ohne manuelle Konfigurationsschritte aktiviert ist.
Dieser Resolver ist dafür verantwortlich, die entsprechende Contextual-Reference zu finden oder  <span class='latex-texttt'>null</span>  zurückzuliefern.
Dependent-scoped Beans nehmen allerdings erneut eine Sonderstellung ein.
Sie existieren in diesem Zusammenhang für die Auswertungszeit einer vollständigen EL-Expression,
selbst wenn sie in der Expression mehrmals angesprochen werden.
Erst nach der vollständigen Auswertung der EL-Expression werden dependent-scoped Beans wieder zerstört.
Neben dependent-scoped Beans können Beans mit beliebigen CDI-Scopes direkt via EL-Expression angesprochen werden,
sofern der entsprechende Scope zum Zeitpunkt der Auswertung aktiv ist.
In diesem Zusammenhang nimmt der CDI Conversation-Scope eine Sonderstellung ein,
da für diesen eine spezielle Regel in Verbindung mit JSF definiert wurde.
Details zum Conversation-Scope werden wir im Kapitel  <a href='#!idx:/deltaspike.html:chap:deltaspike'>  Apache DeltaSpike </a>  genauer betrachten,
da wir hier auch alternative Conversation -Konzepte kennenlernen werden.
Somit haben wir die wichtigsten Integrationspunkte zwischen CDI und JSF bereits theoretisch kennengelernt und
es ist Zeit,  <span class='latex-textit'>IdeaFork</span>  mit einer simplen Weboberfläche zu erweitern.
In unserer Web-Applikation legen wir neben einer einfachen XHTML-Datei für JSF noch die Konfigurationsdatei  <span class='latex-texttt'>WEB-INF/web.xml</span>  an und
konfigurieren das Faces-Servlet für JSF. In unserem Fall definieren wir zusätzlich die eben erstellte XHTML-Datei als Startpunkt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im nächsten Schritt verwenden wir Twitter-Bootstrap (http://getbootstrap.com), um unser Seitentemplate visuell ansprechender zu gestalten.
Hierfür werden primär HTML-Tags verwendet. Nur an Stellen, an denen es unerlässlich ist, verwenden wir JSF Standardkomponenten.
Somit bleiben wir in  <span class='latex-textit'>IdeaFork</span>  unabhängig von einer zusätzlichen Komponentenbibliothek für JSF.
Sie können selbstverständlich jede beliebige JSF-Komponentenbibliothek verwenden,
da die Integration mit CDI an einem unabhängigen Erweiterungspunkt ansetzt.
Dieser erste Schritt ist unabhängig von CDI und daher werden wir die Details überspringen.
Im Git-Repository von  <span class='latex-textit'>IdeaFork</span>  sind die erforderlichen Änderungen in einem Commit zusammengefasst und
können einfach nachvollzogen werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Unabhängig vom Layout sollte einer der ersten Schritte das Hinzufügen einer "Messages"-Komponente sein,
damit Nachrichten wie beispielsweise Fehlermeldungen angezeigt werden können.
In  <span class='latex-textit'>IdeaFork</span>  wollen wir den Nachrichtenbereich visuell etwas aufbessern und zeigen globale Nachrichten in einem Message-Panel an.
Hierzu betten wir die Standardkomponente  <span class='latex-texttt'>h:messages</span>  in ein Panel, das mit Hilfe von Twitter-Bootstrap formatiert ist, ein.
Damit wir kein leeres Panel anzeigen, falls es keine Meldungen gibt, können wir diesen Bereich standardmäßig ausblenden.
In Listing  <a href='#!idx:/java_ee.html:fig:access_cdi-bean_via_el'> Via EL-Expression auf ein CDI-Bean zugreifen </a>  wird deutlich, dass wir uns hier dem  <span class='latex-texttt'>rendered</span> -Attribut bedienen.
Innerhalb der Panel-Group ist folglich neben einigen Tags zur Formatierung auch die  <span class='latex-texttt'>h:messages</span> -Komponente zu finden.
Der für uns entscheidende Teil ist hier allerdings der Inhalt von  <span class='latex-texttt'>rendered</span> .
Die EL-Expression  <span class='latex-texttt'>#{messageController.globalMessageAvailable}</span>  verrät noch nicht,
dass  <span class='latex-texttt'>messageController</span>  ein CDI-Bean referenziert. Erst durch Listing  <a href='#!idx:/java_ee.html:fig:named_request_scoped_bean'> CDI-Bean mit Namen </a>  wird dies deutlich.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:access_cdi-bean_via_el'></a>                     <pre><code>&lt;h:panelGroup layout="block" class="panel"
  rendered="#{messageController.globalMessageAvailable}"&gt;
    &lt;!-- message panel content --&gt;
&lt;/h:panelGroup&gt;
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:named_request_scoped_bean'></a>                     <pre><code>@javax.enterprise.inject.Model
public class MessageController {
  public boolean isGlobalMessageAvailable() {
    return !FacesContext.getCurrentInstance()
      .getMessageList(null).isEmpty();
  }
}
</code></pre>
                </div> <br />Durch die Stereotype-Annotation  <span class='latex-texttt'>@Model</span>  definieren wir in Listing  <a href='#!idx:/java_ee.html:fig:named_request_scoped_bean'> CDI-Bean mit Namen </a> ein  <span class='latex-texttt'>@javax.inject.Named</span>  und  <span class='latex-texttt'>@javax.enterprise.context.RequestScoped</span>  CDI-Bean.
Die Namenskonvention entspricht jener von klassischen JSF-Managed Beans.
Der EL-Ausdruck  <span class='latex-texttt'>#{messageController.globalMessageAvailable}</span>  referenziert somit ein CDI-Bean,
das die Methode  <span class='latex-texttt'>isGlobalMessageAvailable </span>  zur Verfügung stellt. Über diese Methode können wir auswerten,
ob es globale Faces-Messages gibt oder nicht und folglich das dazugehörige Message-Panel ein- oder ausblenden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Als nächstes wollen wir unser Menü mit Leben füllen. Hierfür ersetzen wir die HTML-Links, die als Platzhalter dienten,
mit  <span class='latex-texttt'>h:commandLink</span> -Komponenten. Diese Menülinks verwenden ein CDI-Bean namens  <span class='latex-texttt'>menuBean</span> ,
das äquivalent zu  <span class='latex-texttt'>messageController</span>  mit  <span class='latex-texttt'>@Model</span>  annotiert ist.
In unserem Fall heißt die Java-Klasse jedoch  <span class='latex-texttt'>MenuController</span> .
Um dennoch den Namen  <span class='latex-texttt'>menuBean</span>  verwenden zu können und somit die Default-Namenskonvention anzupassen,
müssen wir den durch  <span class='latex-texttt'>@Model</span>  vorgegebenen Namen mit der expliziten Verwendung von  <span class='latex-texttt'>@Named(''menuBean'')</span>  abändern.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/java_ee.html:fig:customized_name'> CDI-Bean mit angepasstem Namen </a>  zeigt,
dass wir an einigen Stellen den eingeloggten  <span class='latex-texttt'>User</span>  überprüfen oder
zurücksetzen müssen, damit sich das Menü wie erwartet verhält.
Den eingeloggten  <span class='latex-texttt'>User</span>  speichern wir im Session-scoped  <span class='latex-texttt'>ActiveUserHolder</span> -Bean,
das wir in das  <span class='latex-texttt'>MenuController</span> -Bean injizieren und verwenden.
Die Klasse  <span class='latex-texttt'>ActiveUserHolder</span>  selbst ist mit  <span class='latex-texttt'>@Model</span>  annotiert. Zusätzlich übersteuern wir den Scope,
der durch  <span class='latex-texttt'>@Model</span>  vorgegeben ist, durch die explizite Verwendung von  <span class='latex-texttt'>@javax.enterprise.context.SessionScoped</span> .<br /> <div class="tip"><b>Tipp: </b> Anpassungen von  <span class='latex-texttt'>@Model</span>  reduzieren die Vorteile dieses Stereotypes erheblich,
da sich die Anzahl der Annotations nicht reduziert. Die gezeigten Beispiele sollen primär veranschaulichen,
dass solche Anpassungen grundsätzlich möglich sind.
Die explizite Verwendung von  <span class='latex-texttt'>@Named</span>  kann den Aufwand bei einem Refactoring reduzieren,
da der Name des Beans zumindest im ersten Schritt unverändert bleibt und sich dennoch der Namen der Klasse ändern kann.
In der Regel ist die Übersteuerung des Bean-Namens und des Scopes bei eigenen Stereotype-Annotationen sinnvoller,
da eine Stereotype-Annotation die primären Eigenschaften der jeweiligen ''Bean-Kategorie'' bzw. -Rolle definiert und
im Idealfall die Aussagekraft erhöht.
In Ausnahmefällen können diese Vorgaben für einzelne Beans übersteuert werden.
Dennoch bleibt zumindest der Vorteil der höheren Aussagekraft. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:customized_name'></a>                     <pre><code>@Named("menuBean")
@Model
public class MenuController {
  @Inject
  private ActiveUserHolder userHolder;

  public String home() {
    return "/pages/index.xhtml";
  }

  public String login() {
    return "/pages/user/login.xhtml";
  }

  public String logout() {
    userHolder.setAuthenticatedUser(null);
    return "/pages/user/login.xhtml";
  }

  public String start() {
    if (userHolder.isLoggedIn()) {
      return "/pages/idea/overview.xhtml";
    }
    return "/pages/user/login.xhtml";
  }

  public String register() {
    return "/pages/user/registration.xhtml";
  }
}
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:active_user-holder_bean'></a>                     <pre><code>@Named
@SessionScoped
public class ActiveUserHolder implements Serializable {
  private User authenticatedUser;

  public void setAuthenticatedUser(User authenticatedUser) {
    this.authenticatedUser = authenticatedUser;
  }

  public boolean isLoggedIn() {
    return authenticatedUser != null && !authenticatedUser.isTransient();
  }

  public User getAuthenticatedUser() {
    return authenticatedUser;
  }
}
</code></pre>
                </div> <br />Die Methode  <span class='latex-texttt'>isTransient</span>  ist in  <span class='latex-texttt'>BaseEntity</span>  neu hinzugekommen und wertet aus, ob die Versionsnummer bereits gesetzt ist.
Dies wird später vor allem in Kombination mit JPA relevant, da wir nur persistente  <span class='latex-texttt'>User</span> -Entitäten für das Login akzeptieren wollen.
In der Klasse  <span class='latex-texttt'>MenuController</span>  referenzieren wir bereits Seiten als Navigationsziel, die derzeit noch nicht vorhanden sind.
Daher erstellen wir im nächsten Schritt die Seiten  <span class='latex-texttt'>login.xhtml</span>  und  <span class='latex-texttt'>registration.xhtml</span> .
Je Seite verwenden wir einen eigenen Controller, der genau für diese Seite zuständig ist.
Vorerst sind die meisten unserer Controller Request-Scoped und müssen, wie zuvor erwähnt, mit  <span class='latex-texttt'>@Named</span>  annotiert werden,
damit sie in einer EL-Expression angesprochen werden können. Wir könnten auch hier statt dieser beiden Annotationen  <span class='latex-texttt'>@Model</span>  verwenden.
Allerdings ist ein eigener Stereotyp namens  <span class='latex-texttt'>@ViewController</span>  wesentlich aussagekräftiger.
Abgesehen davon ist diese Stereotyp-Annotation eine inhaltliche Kopie von  <span class='latex-texttt'>@Model</span> .
Listing  <a href='#!idx:/java_ee.html:fig:cdi-beans_as_view-controller'> CDI-Beans als View-Controller </a>  zeigt die Controller-Implementierungen  <span class='latex-texttt'>LoginViewCtrl</span>  für  <span class='latex-texttt'>login.xhtml</span> ,
sowie  <span class='latex-texttt'>RegistrationViewCtrl</span>  für  <span class='latex-texttt'>registration.xhtml</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:cdi-beans_as_view-controller'></a>                     <pre><code>@ViewController
public class LoginViewCtrl {
  @Inject
  private UserService userService;

  @Inject
  private ActiveUserHolder userHolder;

  private String email;
  private String password;

  public String login() {
    userService.login(email, password);

    final String message;
    final String navigationTarget;
    FacesMessage.Severity severity = FacesMessage.SEVERITY_INFO;
    if (userHolder.isLoggedIn()) {
      message = "Welcome " +
        userHolder.getAuthenticatedUser().getNickName() + "!";
      navigationTarget = "/pages/idea/overview.xhtml";
    } else {
      message = "Login failed!";
      severity = FacesMessage.SEVERITY_ERROR;
      navigationTarget = null;
    }

    FacesContext.getCurrentInstance()
      .addMessage(null, new FacesMessage(severity, message, message));
    return navigationTarget;
  }

  //+ getter and setter
}

@ViewController
public class RegistrationViewCtrl {
  @Inject
  private UserService userService;

  private User newUser = new User();

  public String register() {
    User registeredUser = userService.registerUser(this.newUser);

    final String message;
    final String targetPage;
    FacesMessage.Severity severity = FacesMessage.SEVERITY_INFO;
    if (registeredUser != null) {
      message = "Registration successful!";
      targetPage = "/pages/user/login.xhtml";
    } else {
      message = "Registration failed!";
      severity = FacesMessage.SEVERITY_ERROR;
      targetPage = null;
    }

    FacesContext.getCurrentInstance()
      .addMessage(null, new FacesMessage(severity, message, message));
    return targetPage;
  }

  public User getNewUser() {
    return newUser;
  }
}
</code></pre>
                </div> <br />Die hier implementierte Logik ist sehr einfach gehalten. Derzeit verwenden wir noch unsere In-Memory Repositories.
Sobald wir EJBs hinzufügen, wird sich dies ändern. Als Vorbereitung für diese Änderung erstellen wir die Klasse  <span class='latex-texttt'>UserService</span> ,
die für die Registrierung und für das Login zuständig ist und hierfür verschiedene Methoden von  <span class='latex-texttt'>UserManager</span>  kombiniert,
sowie mit Hilfe eines neu hinzugefügten  <span class='latex-texttt'>PasswordManager</span> s den Passworthash berechnet und mit dem gespeicherten Wert vergleicht.
Außerdem erweitern wir unsere bisherigen Implementierungen und Tests.
Die Entität  <span class='latex-texttt'>User</span>  wird um ein Passwortfeld und  <span class='latex-texttt'>UserRepository</span>  um die Methode  <span class='latex-texttt'>loadByEmail</span>  erweitert.
Dementsprechend muss die Methode  <span class='latex-texttt'>createUserFor</span>  von  <span class='latex-texttt'>UserManager</span>  erweitert werden.
Die dazugehörigen Implementierungen und Änderungen sind im Git-Repository übersichtlich in einem Commit zusammengefasst und
können mit dem bisher erworbenen Wissen einfach nachvollzogen werden.<br /> <div class="tip"><b>Tipp: </b> Obwohl  <span class='latex-texttt'>UserService</span>  ein injiziertes Feld verwendet, ist die Implementierung implizit zustandslos,
da nur eine Contextual-Reference als Proxy injiziert wird.
Die Proxy-Instanz selbst ist Thread-safe und kann bei Bedarf de-/serialisiert bzw.
notfalls durch manuelle Injizierung jederzeit wiederhergestellt werden.
Ist Thread-Sicherheit relevant, dann muss diese auch in allen injizierten Beans sichergestellt werden.
Würden wir an dieser Stelle ein Session-scoped Bean injizieren, so wäre nur  <span class='latex-texttt'>UserService</span>  inklusive der Contextual-Reference Thread-safe.
Ein Session-scoped Bean müsste selbst Maßnahmen ergreifen, damit dessen Methoden Thread-safe funktionieren. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:cdi-bean_as_stateless_service'></a>                     <pre><code>@ApplicationScoped
public class UserService {
  @Inject
  private UserManager userManager;

  @Inject
  private ActiveUserHolder userHolder;

  public User registerUser(User newUser) {
    if (userManager.loadByEmail(newUser.getEmail()) == null) {
      User result = userManager.createUserFor(
        newUser.getNickName(), newUser.getEmail(), newUser.getPassword());
      userManager.save(result);
      return userManager.loadById(result.getId());
    }
    return null;
  }

  public void login(String email, String password) {
    User registeredUser = userManager.loadByEmail(email);

    if (registeredUser != null) {
      if (password.equals(registeredUser.getPassword())) {
        userHolder.setAuthenticatedUser(registeredUser);
        return;
      }
    }

    userHolder.setAuthenticatedUser(null);
  }
}
</code></pre>
                </div> <br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.4' ><span class='entry-number'>3.4</span> Servlets mit CDI</a> </h2>
<span class='latex-textit'>IdeaFork</span>  besteht in der aktuellen Ausbaustufe aus einem CDI basierten Basismodul,
das unabhängig von einer konkreten UI-Technologie für verschiedene Oberflächen verwendet werden kann.
Im vorherigen Abschnitt haben wir den ersten Teil einer JSF/CDI Applikation entwickelt.
JSF basiert zwar auf Servlets, jedoch wird dies primär intern umgesetzt.
Selbst in JSF-Applikationen gibt es weiterhin Anwendungsgebiete, bei denen auf Servlets zurückgegriffen werden kann.
Ein solches Beispiel ist der Datei-Upload.
In  <span class='latex-textit'>IdeaFork</span>  wollen wir diese Funktionalität nutzen, um via Datei-Upload Ideen zu importieren.
Damit wir unser Seiten-Template auch hier wiederverwenden können, erstellen wir eine weitere JSF-Seite namens  <span class='latex-texttt'>upload.xhtml</span> .
Wie in Listing  <a href='#!idx:/java_ee.html:fig:upload_form'> HTML-Form für den Ideen-Import </a>  dargestellt, können wir in diesem Fall eine normale HTML-Form verwenden.
Als  <span class='latex-texttt'>action</span>  tragen wir den Pfad zum Upload-Servlet ein.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:upload_form'></a>                     <pre><code>&lt;form method="post" enctype="multipart/form-data"
      action="#{jsf.contextPath}/idea/import "&gt;
  &lt;!-- ... --&gt;
&lt;/form&gt;
</code></pre>
                </div> <br />Listing  <a href='#!idx:/java_ee.html:fig:servlet_with_injection-points'> Injizierung in einem Servlet </a>  veranschaulicht,
dass CDI basierte Injizierung in einem EE6+ Server auch in Servlets verwendet werden kann.
 <span class='latex-texttt'>IdeaImportServlet</span>  verwendet das bereits bekannte Session-scoped Bean  <span class='latex-texttt'>ActiveUserHolder</span> ,
sowie ein Application-scoped  <span class='latex-texttt'>FileUploadService</span> , das an  <span class='latex-texttt'>IdeaManager</span>  delegiert und
das Ergebnis (Erfolg oder Fehlschlag) des Imports in einem Request-Scoped Bean ( <span class='latex-texttt'>ImportSummary</span> ) ablegt.
Dies verdeutlicht erneut den Vorteil von Contextual-References. Da für die Injection-Points nur Proxies verwendet werden,
kann der CDI-Container immer auf die korrekte Contextual-Instance umleiten und wir müssen uns nicht um die Scopes der Beans kümmern,
wie es beispielsweise bei JSF Managed-Beans der Fall ist. Nach dem Import leiten wir auf die Seite  <span class='latex-texttt'>summary.xhtml</span>  um,
auf der wir das Ergebnis anzeigen. Hierfür können wir wie bisher eine JSF-Seite erstellen,
die auf ein CDI-Bean, in diesem Fall  <span class='latex-texttt'>ImportSummary</span> , zugreift. Sobald ein CDI-Bean verwendet werden kann,
ist es daher möglich dieses als eine Art Zwischen- bzw. Transferspeicher für Daten zu verwenden.<br /> <div class="tip"><b>Tipp: </b> Nur bei einer asynchronen Verarbeitung, wie es bei Servlets seit Version 3.0 möglich ist, muss mit etwas mehr Sorgfalt vorgegangen werden.
Wird ein neuer Thread nicht vom EE-Server verwaltet, so können nur Scopes verwendet werden,
die unabhängig von einem Thread (und somit Request) sind. Alternativ ist es möglich über proprietäre APIs der Container,
Scopes manuell zu starten und zu stoppen.
Selbst wenn der Container den neuen Thread startet und somit die korrekte Behandlung der Scopes übernimmt,
müssen alle erforderlichen Informationen per Parameter übergeben werden, da es keinen Automatismus in diesem Bereich gibt,
der beispielsweise Daten aus dem ursprünglichen Request-Context in den neuen übernimmt. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:servlet_with_injection-points'></a>                     <pre><code>@WebServlet("/idea/import ")
@MultipartConfig
public class IdeaImportServlet extends HttpServlet {
  @Inject
  private ActiveUserHolder userHolder;

  @Inject
  private FileUploadService fileUploadService;

  protected void doPost(HttpServletRequest request,
                        HttpServletResponse response)
        throws ServletException, IOException {

    fileUploadService.storeUploadedFiles(
      request.getParts(), userHolder.getAuthenticatedUser());
    request.getRequestDispatcher("/pages/import/summary.xhtml")
      .forward(request, response);
  }
}
</code></pre>
                </div> <br />CDI-Beans können auch in Servlet-Filtern injiziert werden. Wir können einen einfachen Filter ( <span class='latex-texttt'>UserAwareFilter</span> ) erstellen,
um einzelne Bereiche bzw. verschiedene Aktionen abzusichern. Listing  <a href='#!idx:/java_ee.html:fig:servlet-filter_with_injection-points'> Injizierung in einem Servlet-Filter </a>  zeigt,
dass wir mit Hilfe von   <span class='latex-texttt'>ActiveUserHolder</span> , eine einfache Überprüfung durchführen können, ob der aktuelle Benutzer bereits eingelogged ist.
Falls dies noch nicht oder nicht mehr der Fall ist, wird statt des eigentlichen Ziels auf die Login-Seite ( <span class='latex-texttt'>login.xhtml</span> ) umgeleitet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:servlet-filter_with_injection-points'></a>                     <pre><code>@WebFilter(urlPatterns = {"/pages/import/*", "/idea/import"})
public class UserAwareFilter implements Filter {
  @Inject
  private ActiveUserHolder userHolder;

  @Override
  public void doFilter(ServletRequest request,
                       ServletResponse response,
                       FilterChain chain)
      throws IOException, ServletException {
    if (userHolder.isLoggedIn()) {
      chain.doFilter(request, response);
    } else {
      request.getRequestDispatcher("/pages/user/login.xhtml")
        .forward(request, response);
    }
  }
  //...
}
</code></pre>
                </div> <br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.5' ><span class='entry-number'>3.5</span> JAX-RS mit CDI</a> </h2>
 Die EE Spezifikation zu RESTful Services (JAX-RS) wird primär für Applikationen verwendet,
die REST (Representational State Transfer) basierte Kommunikation mit der Außenwelt zur Verfügung stellen wollen.
In  <span class='latex-textit'>IdeaFork</span>  verwenden wir JAX-RS für den Export von Ideen im JSON-Format.
Durch die eingangs erwähnte Grundregel unterstützen bereits EE6-Server CDI basierte Injizierung in JAX-RS Ressourcen,
obwohl die JAX-RS Spezifikation selbst in Version 1.1 CDI nicht erwähnt.
Wie bei JAX-RS üblich beginnen wir bei Listing  <a href='#!idx:/java_ee.html:fig:jax-rs_application'> Konfiguration JAX-RS Application </a>  mit der Registrierung eines Basispfades und
der Konfiguration der Ressourcen.
Als Basispfad wählen wir  <span class='latex-texttt'>public</span> . Außerdem stellen wir eine Klasse ( <span class='latex-texttt'>IdeaExporter</span> ) zur Verfügung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jax-rs_application'></a>                     <pre><code>@ApplicationPath("/public")
public class RestApplicationConfig extends Application {
  @Override
  public Set&lt;Class&lt;?&gt;&gt; getClasses() {
    return new HashSet&lt;Class&lt;?&gt;&gt;() {{
      add(IdeaExporter.class);
    }};
  }
}
</code></pre>
                </div> <br />Listing  <a href='#!idx:/java_ee.html:fig:jax-rs_resource_with_injection-points'> JAX-RS Ressource mit CDI Injection-Points </a>  veranschaulicht,
dass wir neben der JAX-RS spezifischen Injizierung via  <span class='latex-texttt'>@Context</span>  auch CDI basierte Injizierung verwenden können.
Allerdings müssen wir unterscheiden, bei welchen Injection-Points wir  <span class='latex-texttt'>@Context</span>  und bei welchen  <span class='latex-texttt'>@Inject</span>  verwenden.
Sollten Sie für JAX-RS Artefakte wie beispielsweise  <span class='latex-texttt'>HttpServletResponse</span>  versehentlich  <span class='latex-texttt'>@Inject</span>  statt  <span class='latex-texttt'>@Context</span>  verwenden,
dann werden Sie dies spätestens beim nächsten Applikationsstart bemerken,
da dieser mit einer  <span class='latex-texttt'>UnsatisfiedResolutionException</span>  abgebrochen wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jax-rs_resource_with_injection-points'></a>                     <pre><code>@Path("/idea/")
@Produces(APPLICATION_JSON)
public class IdeaExporter {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private UserManager userManager;

  @Inject
  private ActiveUserHolder userHolder;

  @Context
  private HttpServletResponse response;

  @GET
  @Path("/export/all")
  public Response allIdeasOfCurrentUser() {
    User authenticatedUser = userHolder.getAuthenticatedUser();

    if (authenticatedUser == null) {
      try {
        return Response.temporaryRedirect(
          UriBuilder.fromPath("../pages/user/login.xhtml").build())
          .build();
      } catch (Exception e) {
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
          .build();
      }
    }
    return Response.ok(ideaManager.loadAllOfAuthor(authenticatedUser))
      .header(/*...*/)
      .build();
  }

  @GET
  @Path("/export/{nickname}")
  public List&lt;Idea&gt; allIdeasOfUser(
    @PathParam("nickname") String nickName) {
      response.setHeader(/*...*/);
      User loadedUser = userManager.loadByNickName(nickName);
      return ideaManager.loadAllOfAuthor(loadedUser);
  }
}
</code></pre>
                </div> <br /> <span class='latex-texttt'>IdeaExporter</span>  definiert zwei Endpunkte.
Via  <span class='latex-texttt'>/public/idea/export/all</span>  werden alle Ideen des aktuell eingeloggten Benutzers mit Hilfe von  <span class='latex-texttt'>IdeaManager</span>  geladen und
als Response an den JAX-RS Container weitergegeben, der für die Umwandlung nach JSON sorgt.
Wird dieser Endpunkt von einer anonymen Quelle aufgerufen, dann wird eine temporäre Umleitung zur Login-Seite ( <span class='latex-texttt'>login.xhtml</span> ) veranlasst.
Auch hier können wir wie bisher auf  <span class='latex-texttt'>ActiveUserHolder</span>  zurückgreifen. Unabhängig von einem vorgelagerten Login ist der zweite Endpunkt.
Mit diesem können alle Ideen eines bestimmten Benutzers abgefragt werden.
Hierfür muss die Adresse des Endpunkts ( <span class='latex-texttt'>/public/idea /export/{nickname}</span> ) nur mit einem gültigen Usernamen parametrisiert werden.
Dieser wird an  <span class='latex-texttt'>IdeaManager</span>  weitergeleitet, der eine entsprechende Ergebnisliste liefert.
Diese Ergebnisliste wird anschließend vom JAX-RS Container wieder in JSON umgewandelt.
Bei einem Export wollen wir jedoch nicht sämtliche internen Informationen vollständig in das Ergebnis übernehmen.
Statt einer manuellen Nachbearbeitung können wir eine Datenprojektion verwenden.
Diese wird allerdings nicht von JAX-RS selbst unterstützt. Daher müssen wir auf die proprietäre Funktionalität von Jackson zurückgreifen.
Hierfür erweitern wir den bestehenden  <span class='latex-texttt'>ObjectConverter</span>  um eine Methode.
Listing  <a href='#!idx:/java_ee.html:fig:json_conversion_with_data-view'> JSON Konvertierung mit View </a>  zeigt einen Ausschnitt des angepassten Converters.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:json_conversion_with_data-view'></a>                     <pre><code>@ExternalFormat(ExternalFormat.TargetFormat.JSON)
@JacksonConverter
public class JSONConverterJackson implements ObjectConverter {
  //...

  @Override
  public String toString(Object entity, Class typeSafeDataView) {
    try {
      ObjectMapper objectMapper = new ObjectMapper();
      if (typeSafeDataView != null) {
        objectMapper.configure(
          MapperFeature.DEFAULT_VIEW_INCLUSION, false);

        return objectMapper.writerWithView(typeSafeDataView)
          .writeValueAsString(entity);
      }
      return objectMapper.writeValueAsString(entity);
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(e);
    }
  }
}
</code></pre>
                </div> <br />Damit dieser  <span class='latex-texttt'>ObjectConverter</span>  auch von JAX-RS verwendet wird, müssen wir einen Adapter zur Verfügung stellen.
Listing  <a href='#!idx:/java_ee.html:fig:message-body_writer_with_injection-points'> Manuelle CDI Injizierung in Message-Body Writer </a>  zeigt den erforderlichen  <span class='latex-texttt'>MessageBodyWriter</span>  für JAX-RS.
Als View für die Datenprojektion übergeben wir dem  <span class='latex-texttt'>ObjectConverter</span>  die selbst erstellte Marker-Klasse  <span class='latex-texttt'>ExportView.Public.class</span> .
Um beim Export nur einen Teil der Daten zu verwenden, müssen wir in den Klassen  <span class='latex-texttt'>Idea</span>  und  <span class='latex-texttt'>User</span> die entsprechenden Getter-Methoden mit  <span class='latex-texttt'>@JsonView(ExportView.Public.class)</span>  markieren.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:message-body_writer_with_injection-points'></a>                     <pre><code>@Provider
@Produces(MediaType.APPLICATION_JSON)
public class CustomJsonWriter implements MessageBodyWriter&lt;Object&gt; {
  @Inject
  @ExternalFormat(JSON)
  private ObjectConverter objectConverter;

  @Override
  public boolean isWriteable(Class&lt;?&gt; rawType,
                             Type genericType,
                             Annotation[] annotations,
                             MediaType mediaType) {
    return true;
  }

  @Override
  public void writeTo(Object o,
                      Class&lt;?&gt; rawType,
                      Type genericType, Annotation[] annotations,
                      MediaType mediaType,
                      MultivaluedMap&lt;String, Object&gt; httpHeaders,
                      OutputStream entityStream) throws IOException {
    entityStream.write(
      objectConverter.toString(o, ExportView.Public.class).getBytes());
  }

  @Override
  public long getSize(Object o,
                      Class&lt;?&gt; rawType,
                      Type genericType,
                      Annotation[] annotations,
                      MediaType mediaType) {
    return -1;
  }
}
</code></pre>
                </div> <br /> <span class='latex-texttt'>CustomJsonWriter</span>  definiert einen Injection-Point für  <span class='latex-texttt'>ObjectConverter</span> , wie wir ihn bereits früher verwendet haben.
Da  <span class='latex-texttt'>MessageBodyWriter</span> -Implementierungen jedoch keine Injection-Points unterstützen, müssen wir dies selbst anstoßen.
Dies können wir in  <span class='latex-texttt'>RestApplicationConfig</span>  veranlassen.
Listing  <a href='#!idx:/java_ee.html:fig:extended_jax-rs_application'> Erweiterte JAX-RS Application (nicht portabel) </a>  zeigt als Ausschnitt von  <span class='latex-texttt'>RestApplicationConfig </span>  die Methode  <span class='latex-texttt'>getSingletons</span> .
In dieser Methode wird eine neue Instanz der Klasse  <span class='latex-texttt'>CustomJsonWriter</span>  manuell erstellt und
danach der Helper-Methode  <span class='latex-texttt'>injectFields</span>  übergeben,
in der die manuelle Injizierung durchgeführt wird. Abschließend wird die Instanz dem Ergebnis-Set hinzugefügt,
das später vom JAX-RS Container unverändert verwendet wird.
Die in  <a href='#!idx:/java_ee.html:fig:extended_jax-rs_application'> Erweiterte JAX-RS Application (nicht portabel) </a>  illustierte minimale Implementierung ist allerdings nicht vollständig portabel.
Im Git-Repository von  <span class='latex-textit'>IdeaFork</span>  wird daher das Ergebnis in einem  <span class='latex-texttt'>Set</span>  gecached.
Dieser Trick funktioniert für die getesteten EE-Server.
Eine vollständige Portabilität ist nicht garantiert, da JAX-RS in Version 1.1 einen solchen Anwendungsfall nicht berücksichtigt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:extended_jax-rs_application'></a>                     <pre><code>@Override
public Set&lt;Object&gt; getSingletons() {
  final CustomJsonWriter jsonWriter = new CustomJsonWriter();
  CdiUtils.injectFields(jsonWriter); //not portable at this point
  return new HashSet&lt;Object&gt;() {{
    add(jsonWriter);
  }};
}
</code></pre>
                </div> <br />Die eben erwähnte Helper-Methode  <span class='latex-texttt'>injectFields</span>  kann ebenfalls von uns in wenigen Schritten implementiert werden.
Ein EE-Container muss den  <span class='latex-texttt'>BeanManger</span>  via JNDI unter  <span class='latex-texttt'>java:comp/BeanManager</span>  zur Verfügung stellen.
Dieser Lookup ist nur dann erforderlich, wenn wir uns in einem Bereich der Applikation befinden, der nicht durch den CDI-Container verwaltet wird.
Mit Hilfe des  <span class='latex-texttt'>BeanManger</span> s erzeugen wir uns manuell eine Instanz vom Typ  <span class='latex-texttt'>InjectionTarget</span> ,
über die wir abschließend mit der Methode  <span class='latex-texttt'>inject</span>  die manuelle Injizierung an den CDI-Container delegieren können.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:manual_injection'></a>                     <pre><code>public class CdiUtils {
  public static &lt;T&gt; T injectFields(T instance) {
    if (instance == null) {
      return null;
    }

    BeanManager beanManager = resolveBeanManagerViaJndi();

    if (beanManager == null) {
      return instance;
    }

    CreationalContext creationalContext =
      beanManager.createCreationalContext(null);

    AnnotatedType annotatedType =
      beanManager.createAnnotatedType(instance.getClass());
    InjectionTarget injectionTarget =
      beanManager.createInjectionTarget(annotatedType);
    injectionTarget.inject(instance, creationalContext);
    return instance;
  }

  private static BeanManager resolveBeanManagerViaJndi() {
    try {
      return (BeanManager) new InitialContext()
        .lookup("java:comp/BeanManager");
    } catch (NamingException e) {
      return null;
    }
  }
}
</code></pre>
                </div> <br /> <div class="tip"><b>Tipp: </b> Die Implementierung von  <span class='latex-texttt'>injectFields</span>  ist portabel und vollständig.
Allerdings kann dieser Ansatz nicht an allen Punkten einer Applikation portabel verwendet werden.
Verschiedene EE-Server und teilweise auch unterschiedliche Versionen eines Servers agieren beim Aufruf innerhalb von
 <span class='latex-texttt'>getSingletons</span>  sehr unterschiedlich.
Unter anderem ist nicht garantiert, dass zu diesem Zeitpunkt ein valider CDI-Container zur Verfügung steht.
Dies liegt jedoch nicht an CDI selbst, sondern an der Integration verschiedener EE-Spezifikationen in den Servern.
Dieses Beispiel veranschaulicht,
dass selbst korrekte Implementierungen im Ausnahmefall nicht immer auf direktem Weg zum gewünschten Ergebnis führen.
In einer realen Applikation wäre es bei einer solchen Einschränkung einfacher auf  <span class='latex-texttt'>CdiUtils#getContextualReference</span>  zurückzugreifen,
da hiermit erst zum letztmöglichen Zeitpunkt auf den CDI-Container zugegriffen wird. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die Umsetzung und manuelle Initialisierung eines  <span class='latex-texttt'>MessageBodyWriter</span> s ist somit fertig gestellt.
Im nächsten Schritt können wir einen der Endpunkte direkt in einer JSF-Seiten ansprechen.
Hierfür genügt der in Listing  <a href='#!idx:/java_ee.html:fig:link_to_jax-rs_endpoint'> HTML-Link auf JAX-RS Endpoint </a>  gezeigten einfache HTML-Link.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:link_to_jax-rs_endpoint'></a>                     <pre><code>&lt;a href="#{jsf.contextPath}/public/idea/export/all" class="btn"&gt;
  &lt;span class="glyphicon glyphicon-import"/&gt; Export My Ideas
&lt;/a&gt;
</code></pre>
                </div> <br />Würden wir zu diesem Zeitpunkt den Server starten, so würde der Export bereits funktionieren.
Allerdings bekommen wir nicht bei jedem EE-Server das gleiche Ergebnis. Grund hierfür sind die sogenannten
BDA-Regeln, die wir in diesem Kapitel noch im Detail kennenlernen werden.
Einige Details dieser Regeln sind nicht eindeutig definiert bzw. stark umstritten.
Für uns bedeuten sie vorerst, dass wir einen Konfigurationseintrag duplizieren müssen, damit unsere Applikation portable bleibt.
Konkret müssen wir den alternativen Stereotyp @JacksonConverter in  <span class='latex-texttt'>WEB-INF/beans.xml</span>  erneut aktivieren,
damit die alternativen Implementierungen in der Web-Applikation ebenfalls aktiv sind.
Weitere Details zu diesem Thema werden wir in  <a href='#!idx:/java_ee.html:sec:bda-rules'> [ Bean-Deployment Archive mit Java EE] </a>  betrachten.<br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.6' ><span class='entry-number'>3.6</span> EJB mit CDI</a> </h2>
 Aus J2EE Zeiten haben EJBs bis heute noch einen angeschlagenen Ruf.
Spätestens seit Java EE6 ist dies jedoch kaum noch berechtigt.
EE6-Server selbst sind fast durchgängig sehr schnell beim Start.
Lange Wartezeiten während der Entwicklung gehören somit der Vergangenheit an.
Das Programmiermodell wurde ebenfalls wesentlich effizienter.
Mittlerweile genügt es im einfachsten Fall eine Annotation zu verwenden,
um ein POJO in ein EJB zu verwandeln.
EJBs können mit CDI-Beans mit zusätzlichen Services, wie beispielsweise Transaktionen, verglichen werden.
In  <span class='latex-textit'>IdeaFork</span>  können wir beginnen unsere Services auf EJBs umzustellen.
Bisher haben wir  <span class='latex-texttt'>FileUploadService</span>  und  <span class='latex-texttt'>UserService</span>  als Application-scoped CDI-Bean definiert.
Der äquivalente EJB-Typ ist ein Singleton EJB.
Daher können wir  <span class='latex-texttt'>@ApplicationScoped</span>  durch  <span class='latex-texttt'>@javax.ejb.Singleton</span>  ersetzen.
Wir bekommen mit dieser Änderung nicht nur per Default transaktionale Beans,
wovon wir später profitieren werden, sondern alle für  <span class='latex-texttt'>@Singleton</span>  definierten Zusatzfunktionalitäten.
Hier liegt auch ein Fallstrick vergraben.
Eine dieser Zusatzfunktionalitäten ist die Synchronisierung von Methodenaufrufen,
die zu einem ungewollten Flaschenhals in der Applikation werden kann.
Um dies zu vermeiden, müssen wir noch  <span class='latex-texttt'>@ConcurrencyManagement(ConcurrencyManagementType.BEAN)</span>  hinzufügen.
Wir können in unserem Fall auf die Synchronisierung verzichten,
weil wir keinen Zustand in den Bean-Instanzen verwalten.
Denn Contextual-References auf CDI-Beans werden nur vom CDI-Container gesetzt und
verändern sich nach der Erzeugung des Beans nicht.
Die injizierte Proxy-Instanz selbst kann selbstverständlich mit parallelen Methodenaufrufen ohne Einschränkungen umgehen.
Nur in der referenzierten Contextual-Instance muss darauf geachtet werden,
ob parallele Aufrufe speziell behandelt werden müssen.
In unserem Fall trifft dies nicht zu und daher ist keine weitere Änderung erforderlich.
Listing  <a href='#!idx:/java_ee.html:fig:ejb_with_cdi_injection-points'> EJB mit CDI Injection-Points </a>  zeigt, dass wir weiterhin CDI basierte Injizierung verwenden können.
In unseren bisherigen Application-scoped CDI-Beans konnten die Methoden ebenfalls problemlos parallel aufgerufen werden.
Dieser Aspekt ändert sich somit durch unsere Umstellung nicht.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_with_cdi_injection-points'></a>                     <pre><code>@Singleton
@ConcurrencyManagement(BEAN)
public class FileUploadService {
    private static final Charset UTF8 = Charset.forName("UTF-8");

    @Inject
    private IdeaManager ideaManager;

    @Inject
    private ImportSummary importSummary;

    public void storeUploadedFiles(Collection&lt;Part&gt; parts, User user) {
      for (Part part : parts) {
        String fileName = getFileName(part);
        try {
          BufferedReader bufferedReader = new BufferedReader(
            new InputStreamReader(part.getInputStream(), UTF8));
          String ideaToImportString = bufferedReader.readLine();

          while (ideaToImportString != null) {
            try {
              Idea importedIdea =
                ideaManager.importIdea(user, ideaToImportString);
              importSummary.addImportedIdea(importedIdea);
            } catch (Exception e) {
              importSummary.addFailedImport(ideaToImportString);
            }
            ideaToImportString = bufferedReader.readLine();
          }
        } catch (Exception e) {
          //...
        }
      }
    }
    //...
}
</code></pre>
                </div> <br />Soll ein CDI-Scope für ein EJB verwendet werden,
so ist dies mit der Annotation  <span class='latex-texttt'>@Stateful</span>  (statt  <span class='latex-texttt'>@Singleton</span> ) möglich.
Der EJB-Container erzeugt die Instanz und übergibt diese dem CDI-Container zur weiteren Verwaltung.
In  <span class='latex-textit'>IdeaFork</span>  fügen wir als nächstes die Seite  <span class='latex-texttt'>create.xhtml</span>  hinzu, um eine neue Idee zu erstellen.
Als View-Controller können wir direkt ein EJB verwenden.
Wie Listing  <a href='#!idx:/java_ee.html:fig:ejb_with_cdi-stereotype'> EJB mit CDI-Stereotype </a>  zeigt können wir hierfür zu der bisherigen  <span class='latex-texttt'>@ViewController</span>  Annotation noch
 <span class='latex-texttt'>@javax.ejb.Stateful</span>  hinzufügen.
Das resultierende EJB ist durch diese Kombination wie erwartet Request-scoped und kann in EL-Expressions,
in unserem Fall in  <span class='latex-texttt'>create.xhtml</span> , referenziert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_with_cdi-stereotype'></a>                     <pre><code>@Stateful
@ViewController
public class IdeaCreateViewCtrl implements Serializable {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private ActiveUserHolder userHolder;

  private String topic;
  private String category;
  private String description;

  public String save() {
    Idea ideaToSave = ideaManager.createIdeaFor(
      topic, category, userHolder.getAuthenticatedUser());
    ideaToSave.setDescription(description);
    ideaManager.save(ideaToSave);
    return "/pages/idea/overview.xhtml";
  }
  //+ Getter- and Setter-Methods
}
</code></pre>
                </div> <br />Die Methode  <span class='latex-texttt'>#save</span>  ist in diesem Fall eine klassische JSF Action-Methode,
die in  <span class='latex-texttt'>create.xhtml</span>  wie üblich von einer Command-Komponente verwendet wird und
an die entsprechenden Methoden vom injizierten  <span class='latex-texttt'>IdeaManager</span>  delegiert.
Da wir durch diesen Ansatz einen transaktionalen View-Controller bekommen,
läuft die gesamte Ausführung der Action-Methode(n), sowie jede Getter- und Setter- Methode, in einer Transaktion ab.
In unserem Fall ist dies unproblematisch,
bei komplexeren Konstellationen ist bereits eine transaktionale Action-Methode oftmals nicht erwünscht,
sofern mehrere unabhängige Operationen durchgeführt werden sollen.
Außerdem entsteht, ohne Eingrenzung via  <span class='latex-texttt'>@javax.ejb.TransactionAttribute</span>  und
 <span class='latex-texttt'>@javax.ejb.Lock</span> , ein unnötiger Overhead beim Zugriff auf Getter- bzw. Setter-Methoden.
Aus diesen Gründen werden normalerweise EJBs primär für Services verwendet.
Technisch gesehen ist es jedoch problemlos möglich EJB als View-Controller zu verwenden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im nächsten Schritt legen wir die Seite  <span class='latex-texttt'>list.xhtml</span>  an.
Wie der Seitenname bereits vermuten lässt werden die Ideen des eingeloggten Benutzers in einer Übersichtsliste dargestellt.
Auch für diese Seite verwenden wir ein EJB als View-Controller.
Hierzu erstellen wir die Klasse  <span class='latex-texttt'>IdeaListViewCtrl</span>  und annotieren sie zusätzlich zu  <span class='latex-texttt'>@javax.ejb.Stateful</span>  mit
unserer Stereotyp-Annotation  <span class='latex-texttt'>@ViewController</span> , die wie bisher  <span class='latex-texttt'>@javax.enterprise.context.RequestScoped</span>  als Scope vorgibt.
Allerdings passen wir diesen vorgegebenen Scope an und bekommen dadurch ein  <span class='latex-texttt'>@javax.enterprise.context.SessionScoped</span> -EJB.
Die Methode  <span class='latex-texttt'>#onPreRenderView</span>  wird in  <span class='latex-texttt'>list.xhtml</span>  als Callback für das  <span class='latex-texttt'>PreRenderView</span> -Event verwendet und
ist in Listing  <a href='#!idx:/java_ee.html:fig:ejb_as_backing-bean_with_callback'> EJB als Backing-Bean mit Callback </a>  dafür verantwortlich,
dass im nachfolgendem Rendering-Prozess von  <span class='latex-texttt'>list.xhtml</span>  immer die aktuelle Liste angezeigt wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_as_backing-bean_with_callback'></a>                     <pre><code>@Stateful
@SessionScoped
@ViewController
//can be optimized via @TransactionAttribute and @Lock
public class IdeaListViewCtrl implements Serializable {
  @Inject
  private IdeaManager ideaManager;

  @Inject
  private ActiveUserHolder userHolder;

  private List&lt;Idea&gt; ideaList;

  public void onPreRenderView() {
    ideaList = ideaManager.loadAllOfAuthor(
      userHolder.getAuthenticatedUser());
  }

  public void deleteIdea(Idea currentIdea) {
    this.ideaManager.remove(currentIdea);
  }

  public List&lt;Idea&gt; getIdeaList() {
    return ideaList;
  }
}
</code></pre>
                </div> <br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_with_cdi-stereotype_and_overrule_scope'></a>                     <pre><code>@Stateful
@SessionScoped
@ViewController
//can be optimized via @TransactionAttribute and @Lock
public class IdeaEditViewCtrl implements Serializable {
  @Inject
  private IdeaManager ideaManager;

  private Idea currentIdea;

  public String editIdea(Idea currentIdea) {
    this.currentIdea = currentIdea;
    return "/pages/idea/edit.xhtml";
  }

  public String save() {
    ideaManager.save(currentIdea);
    return "/pages/idea/list.xhtml";
  }

  public Idea getCurrentIdea() {
    return currentIdea;
  }
}
</code></pre>
                </div> <br />Gleiches gilt für  <span class='latex-texttt'>IdeaDetailsViewCtrl</span>  und  <span class='latex-texttt'>IdeaForkViewCtrl</span>  in Listing
 <a href='#!idx:/java_ee.html:fig:cdi-bean_with_stereotype_and_overrule_scope'> CDI-Bean mit Stereotype und übersteuertem Scope </a>  und  <a href='#!idx:/java_ee.html:fig:cdi-bean_as_backing-bean_with_injection-point_to_other_backing-bean'> CDI-Bean als Backing-Bean mit Injection-Point zu anderem Backing-Bean </a> ,
allerdings handelt es sich bei diesen Beans um normale CDI-Beans, die als View-Controller verwendet werden.
Dies repräsentiert auch den klassischen Fall,
bei dem primär View-Controller Logik umgesetzt wird und der Rest an injizierte Beans delegiert wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:cdi-bean_with_stereotype_and_overrule_scope'></a>                     <pre><code>@SessionScoped
@ViewController
public class IdeaDetailsViewCtrl implements Serializable {
  @Inject
  private IdeaManager ideaManager;

  private Idea currentIdea;

  private Stack&lt;Idea&gt; displayedIdeas = new Stack&lt;Idea&gt;();

  public String showIdea(Idea currentIdea) {
    this.currentIdea = currentIdea;
    return "/pages/idea/details.xhtml";
  }

  public void showOriginal() {
    displayedIdeas.push(currentIdea);
    currentIdea = ideaManager.loadById(currentIdea.getBaseIdeaId());
  }

  public String back() {
    if (displayedIdeas.empty()) {
      return "/pages/idea/list.xhtml";
    }
    currentIdea = displayedIdeas.pop();
    return null;
  }

  public Idea getCurrentIdea() {
     return currentIdea;
  }
}
</code></pre>
                </div> <br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:cdi-bean_as_backing-bean_with_injection-point_to_other_backing-bean'></a>                     <pre><code>@SessionScoped
@ViewController
public class IdeaForkViewCtrl implements Serializable {
  @Inject
  private IdeaEditViewCtrl ideaEditViewCtrl;

  @Inject
  private IdeaManager ideaManager;

  @Inject
  private ActiveUserHolder userHolder;

  public String forkIdea(Idea currentIdea) {
    Idea forkedIdea = ideaManager.forkIdea(
      currentIdea, userHolder.getAuthenticatedUser());
    ideaEditViewCtrl.editIdea(forkedIdea);
    return "/pages/idea/edit.xhtml";
  }
}
</code></pre>
                </div> <br />Abgesehen von CDI basierter Injizierung und von CDI-Scopes können EJBs auch Observer-Methoden für CDI-Events enthalten.
In Kombination mit  <span class='latex-texttt'>@javax.ejb.Asynchronous</span>  ergibt sich ein interessanter Vorteil,
da die eigentliche Logik in einer solchen Observer-Methode asynchron ausgeführt wird.
In Listing  <a href='#!idx:/java_ee.html:fig:ejb_with_asynchronous_cdi-observer_method'> EJB mit asynchroner CDI-Observer Methode </a>  verwenden wir diesen Vorteil,
um Login- und Logout-Ereignisse je User asynchron aufzuzeichnen.
Die asynchrone Observer-Methode  <span class='latex-texttt'>#onUserAction</span>  delegiert hierbei auf direktem Weg an
das synchron implementierte  <span class='latex-texttt'>UserActionRepository</span> .
Da die gesamte Methode  <span class='latex-texttt'>#onUserAction</span>  in einem separaten Thread ausgeführt wird,
erfolgt die Verarbeitung aus Sicht der Event-Quelle asynchron.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:ejb_with_asynchronous_cdi-observer_method'></a>                     <pre><code>@Stateless
public class StatisticService {
  @Inject
  private UserActionRepository userActionRepository;

  @Asynchronous
  public void onUserAction(@Observes UserActionEvent userActionEvent) {
    userActionRepository.save(userActionEvent.getUserAction());
  }

  //...
}
</code></pre>
                </div> <div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Seit CDI 2.0 (Java EE 8) unterstützt die Spezifikation asynchrone Events nativ über <span class='latex-texttt' style='color:#2e7d32;'>@ObservesAsync</span> und <span class='latex-texttt' style='color:#2e7d32;'>fireAsync()</span>. Der hier gezeigte Umweg über EJB <span class='latex-texttt' style='color:#2e7d32;'>@Asynchronous</span> ist damit nicht mehr erforderlich. Seit Quarkus und CDI Lite entfällt zudem die EJB-Abhängigkeit vollständig — Services werden als reine CDI-Beans implementiert. Details finden Sie in den Kapiteln <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a> und <a href='#!idx:/quarkus.html:10' style='color:#2e7d32;'>10</a>.</div> <br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.7' ><span class='entry-number'>3.7</span> JPA mit CDI</a> </h2>
 In Java EE6 gibt es noch keine mitgelieferte Integration von CDI in JPA.
Erst Java EE7 definiert einen rudimentären Funktionsumfang für Entity-Listener.
Entity-Listener werden zwar weiterhin nicht direkt von CDI verwaltet,
jedoch steht Injizierung von CDI-Beans sowie die Möglichkeit von Lifecycle-Callbacks ( <span class='latex-texttt'>PostConstruct</span>  und
 <span class='latex-texttt'>PreDestroy</span> ) zur Verfügung.
Eine Option, die bereits seit EE6 zur Verfügung steht, ist natürlich das manuelle Auffinden bzw.
die manuelle Injizierung. Beide Varianten haben wir bereits kennengelernt und
mit der Implementierung von  <span class='latex-texttt'>CdiUtils</span>  umgesetzt.
Dennoch können wir CDI verwenden, um Teile von JPA zu vereinfachen, und somit besteht der nächste Schritt in der
Umstellung von  <span class='latex-textit'>IdeaFork</span>  auf JPA.
Die bisherigen In-Memory Repositories können wir weiterhin für unsere Unit-Tests verwenden.
Hierfür verschieben wir sie in das Test-Verzeichnis des Modules und
annotieren sie mit dem selbst erstellten alternativen Stereotyp  <span class='latex-texttt'>MockedRepository</span> ,
den wir in der Konfigurationsdatei  <span class='latex-texttt'>beans.xml</span>  des Testmoduls aktivieren.
Dies ist äquivalent zu dem alternativen Stereotyp  <span class='latex-texttt'>JacksonConverter</span> , den wir bereits erstellt haben.
Die neuen JPA basierten Repositories annotieren wir hingegen wie gewohnt mit unserem Stereotyp  <span class='latex-texttt'>@Repository</span> .
Da wir für  <span class='latex-texttt'>MockedRepository</span>  aus Listing  <a href='#!idx:/java_ee.html:fig:alternative_stereotype_annotated_with_stereotype'> Stereotyp-Annotation annotiert mit Stereotyp </a> die gleichen Definitionen übernehmen wollen, können wir diese Stereotyp-Annotation ebenfalls mit der  <span class='latex-texttt'>@Repository</span>  Annotation versehen.
All diese Änderungen basieren auf den bisher erworbenen Erkenntnissen.
Daher gehen wir an dieser Stelle auf diese Details nicht näher ein.
Im Git-Repository von  <span class='latex-textit'>IdeaFork</span>  sind die erforderlichen Änderungen in einem Commit zusammengefasst und
können einfach nachvollzogen werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:alternative_stereotype_annotated_with_stereotype'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Alternative

@Stereotype
@Repository
public @interface MockedRepository {
}
</code></pre>
                </div> Ein zentraler Bestandteil von JPA ist der  <span class='latex-texttt'>EntityManager</span> . Seit Java EE6 vereinfacht CDI dessen Verwendung.
Mit Java EE5 musste dieser noch überall via  <span class='latex-texttt'>@PersistenceContext</span>  injiziert werden.
Somit wurde diese Annotation mit all den erforderlichen Parametern zur Injizierung über mehrere Klassen der Applikation verstreut.
Eine elegante Alternative hierzu ist die Verwendung eines CDI-Producers, wie wir ihn bereits im Kapitel  <a href='#!idx:/cdi_basics.html:chap:cdi-basics'>  CDI Grundkonzepte </a>  kennengelernt haben.
Bei der Beschreibung des Grundkonzepts haben wir erfahren,
dass Producer-Felder in Kombination mit Ressource-Injection in einem EE-Server ein paar Codezeilen einsparen können.
Listing  <a href='#!idx:/java_ee.html:fig:jpa_entity-manager_producer-field'> Entity-Manager Producer-Feld </a>  zeigt eine solche Ressource-Injection via  <span class='latex-texttt'>@PersistenceContext</span> .
Gleichzeitig ist dieser Ressource-Injection-Point durch die Verwendung von  <span class='latex-texttt'>@Produces</span>  ein CDI-Producer.
Nach der Instantiierung der Klasse injiziert der EE-Server einen  <span class='latex-texttt'>EntityManager</span> -Proxy.
Ab diesem Zeitpunkt kann der CDI-Container diesen Proxy durch den Producer als Contextual-Instance verwenden.
Da der EE-Server bereits einen Proxy erzeugt, müssen wir keinen zusätzlichen Scope für den  <span class='latex-texttt'>EntityManager</span>  definieren,
um eine sinnvolle Verwendung zu ermöglichen.
In Listing  <a href='#!idx:/java_ee.html:fig:jpa_entity-manager_producer-method'> Entity-Manager Producer-Methode </a>  ist die gleiche Funktionalität mit einer Producer-Methode zu sehen.
Auch hier wird ein dependent-scoped Bean definiert.
In beiden Fällen ist  <span class='latex-texttt'>EntityManagerProducer</span>  ein Application-scoped Bean.
Diese Definition ermöglicht, dass die Instanz nur einmal erzeugt und der  <span class='latex-texttt'>EntityManager</span> -Proxy ebenfalls nur einmal injiziert werden muss.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jpa_entity-manager_producer-field'></a>                     <pre><code>@ApplicationScoped
public class EntityManagerProducer {
  @Produces
  @PersistenceContext(name = "ideaForkPU")
  private EntityManager entityManager;
}
</code></pre>
                </div> Im Vergleich zum Producer-Feld bietet die Producer-Methode den Vorteil, dass der Debugging-Prozess vereinfacht wird.
Die hierfür zusätzliche Methode sollte nicht weiter ins Gewicht fallen, da diese nur einmal zentral implementiert werden muss.
Aus diesen Gründen verwendet auch  <span class='latex-textit'>IdeaFork</span>  die nachfolgende Variante mit der Producer-Methode.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jpa_entity-manager_producer-method'></a>                     <pre><code>@ApplicationScoped
public class EntityManagerProducer {
  @PersistenceContext(name = "ideaForkPU")
  private EntityManager entityManager;

  @Produces
  protected EntityManager exposeEntityManagerProxy() {
    return entityManager;
  }
}
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span>  injizieren wir den so erzeugten  <span class='latex-texttt'>EntityManager</span>  in die Basisklasse unserer JPA-Repositories,
die in Listing  <a href='#!idx:/java_ee.html:fig:jpa_generic-repository'> Generisches JPA-Repository </a>  auszugsweise dargestellt ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:jpa_generic-repository'></a>                     <pre><code>public abstract class GenericJpaRepository&lt;T extends BaseEntity&gt;
  implements GenericRepository&lt;T&gt; {

    //...

    @Inject
    protected EntityManager entityManager;

    @Override
    public void save(T entity) {
      if (entity.isTransient()) {
        entityManager.persist(entity);
      } else {
        entityManager.merge(entity);
      }
    }

    //...
}
</code></pre>
                </div> <br /> <div class="tip"><b>Tipp: </b> Erwähnenswert im Zusammenhang mit JPA ist die Trennung von CDI-Beans und JPA-Entitäten.
Instanzen einer Klasse sollten nur durch einen Container (JPA oder CDI) verwaltet werden,
um technische Probleme durch die beteiligten Proxy-Bibliotheken zu vermeiden.
Technisch gesehen könnten wir Einschränkungen in diesem Bereich einfach ausweichen,
indem wir nur Dependent-scoped Beans für Entitäten einsetzen,
die keine Interceptoren oder Decoratoren verwenden. Dadurch können wir Instanzen von Entitäten einfach injizieren.
Um zu vermeiden, dass dieser Aspekt in Vergessenheit gerät,
verwenden wir in  <span class='latex-textit'>IdeaFork</span>   eine solche fachliche Injizierung nicht.
Stattdessen bedienen wir uns des klassischen Schlüsselworts  <span class='latex-texttt'>new</span> . </div><h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.8' ><span class='entry-number'>3.8</span> Bean-Validation mit CDI</a> </h2>
 Die bisher behandelten EE-Spezifikationen und
deren Integration mit CDI decken bereits einen großen Teil an Anwendungsfällen in Geschäftsapplikationen ab.
Ein wichtiger Aspekt fehlt jedoch - die Validierung.
Die Spezifikation Bean-Validation (JSR 303) feierte, wie CDI selbst, in EE6 ihr Debut.
Wie bereits kurz erwähnt, können Contextual-References auf
 <span class='latex-texttt'>javax.validation.ValidationFactory</span>  und  <span class='latex-texttt'>javax.validation.Validator</span>  via  <span class='latex-texttt'>@Inject</span>  injiziert werden.
In vielen Fällen ist die manuelle Verwendung dieser Artefakte nicht erforderlich.
Beispielsweise integrieren sowohl JSF als auch JPA die damals neue Spezifikation von Anfang an.
Im Normalfall müssen somit nur die gewünschten Bean-Validation Constraints für die eigentliche Validierung verwendet werden.
Am häufigsten kann es erforderlich werden, ein CDI-Bean in einem Constraint-Validator zu verwenden,
um für die Validierung beispielsweise Werte aus der Datenbank abzufragen. Dies wird jedoch erst ab EE7 standardmäßig unterstützt.
Mit EE6 kann diese Funktionalität jedoch sehr einfach selbst umgesetzt werden. Wir könnten natürlich CDI-Beans jederzeit manuell suchen.
Dies müssten wir jedoch in jedem Constraint-Validator erneut machen.
Stattdessen wollen wir an einer zentralen Stelle die Erzeugung von Constraint-Validatoren  an den CDI-Container delegieren,
sofern dieser ein Bean mit dem entsprechenden Typ kennt.
Im Kapitel  <a href='#!idx:/cdi_basics.html:chap:cdi-basics'>  CDI Grundkonzepte </a>  haben wir das manuelle Auffinden von Beans bereits kennengelernt.
In einem ersten Schritt erweitern wir  <span class='latex-texttt'>CdiUtils</span>  um die Methode  <span class='latex-texttt'>getContextualReference</span> .
Listing  <a href='#!idx:/java_ee.html:fig:integration_of_bv_and_cdi'> Manuelle Integration von Bean-Validation und CDI </a>  veranschaulicht, dass  <span class='latex-texttt'>null</span>  zurückgegeben wird,
wenn kein entsprechendes Bean vom CDI-Container gefunden wurde.
Diese neue Methode können wir in einer eigenen Implementierung von  <span class='latex-texttt'>javax.validation.ConstraintValidatorFactory</span>  verwenden.
Die Implementierung in Listing  <a href='#!idx:/java_ee.html:fig:integration_of_bv_and_cdi'> Manuelle Integration von Bean-Validation und CDI </a>  delegiert an  <span class='latex-texttt'>defaultFactory</span> ,
wenn der CDI-Container kein entsprechendes Bean für einen Constraint-Validator findet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:integration_of_bv_and_cdi'></a>                     <pre><code>public class BeanAwareConstraintValidatorFactory
  implements ConstraintValidatorFactory {
    private final ConstraintValidatorFactory defaultFactory;

    public BeanAwareConstraintValidatorFactory() {
      defaultFactory = Validation.byDefaultProvider().configure()
        .getDefaultConstraintValidatorFactory();
    }

    @Override
    public &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T getInstance(
      Class&lt;T&gt; validatorClass) {
        T managedConstraintValidator =
          CdiUtils.getContextualReference(validatorClass);

        if (managedConstraintValidator == null) {
          managedConstraintValidator = this.defaultFactory
            .getInstance(validatorClass);
        }
        return managedConstraintValidator;
    }
}
</code></pre>
                </div> <br />Damit  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span>  aktiv wird,
müssen wir die voll qualifizierte Klasse noch in der Datei  <span class='latex-texttt'>validation.xml</span>  aktivieren.
Listing  <a href='#!idx:/java_ee.html:fig:bv_config'> Aktivierung der Validator-Factory </a>  veranschaulicht die Konfiguration, die in  <span class='latex-textit'>IdeaFork</span>  verwendet wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:bv_config'></a>                     <pre><code>&lt;validation-config&gt;
  &lt;constraint-validator-factory&gt;at.irian.cdiatwork.ideafork.infrastructure
    .BeanAwareConstraintValidatorFactory&lt;/constraint-validator-factory&gt;
&lt;/validation-config&gt;
</code></pre>
                </div> <br />In  <span class='latex-textit'>IdeaFork</span>  nutzen wir diese neue Funktionalität im Constraint-Validator  <span class='latex-texttt'>UniqueUserNameValidator</span> ,
der ein neu hinzugefügtes Constraint namens  <span class='latex-texttt'>@UserName</span>  validiert.
In unserem Fall delegiert der Constraint-Validator im Listing  <a href='#!idx:/java_ee.html:fig:constraint-validator_as_cdi-bean'> Constraint-Validator als CDI-Bean </a>  die Hauptarbeit an
das injizierte  <span class='latex-texttt'>UserRepository</span> .
Bei der Verwendung von  <span class='latex-texttt'>@UserName</span>  müssen wir nur berücksichtigen,
dass wir eine spezielle Validierungsgruppe verwenden müssen,
da sonst die Validierung ebenfalls beim Login durchgeführt wird.
Abgesehen davon entspricht der Rest den herkömmlichen Regeln,
die durch die Bean-Validation Spezifikation definiert sind.
Konkret annotieren wir die Property  <span class='latex-texttt'>nickName</span>  mit
 <span class='latex-texttt'>@UserName(groups = UniqueUserName.class)</span>  und
erweitern die Komponente  <span class='latex-texttt'>formGroup.xhtml</span>  mit einem optionalen Attribut,
um den ebenfalls neu hinzugefügten Tag  <span class='latex-texttt'>f:validateBean</span>  von außen zu parametrisieren.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/java_ee.html:fig:constraint-validator_as_cdi-bean'></a>                     <pre><code>@ApplicationScoped
public class UniqueUserNameValidator
  implements ConstraintValidator&lt;UserName, String&gt; {
    @Inject
    private UserRepository userRepository;

    public void initialize(UserName differentName) {
    }

    public boolean isValid(
      String userName,
      ConstraintValidatorContext constraintValidatorContext) {
        return this.userRepository.loadByNickName(userName) == null;
    }
}
</code></pre>
                </div> <br />Wir könnten die Validierungslogik in  <span class='latex-texttt'>UserService#loadByEmail</span>  ebenfalls per Bean-Validation Constraint lösen.
Allerdings ist es nicht immer erforderlich, sämtliche Konsistenzchecks via Bean-Validation abzubilden,
da durch die zusätzlichen Validierungsgruppen auch die Komplexität der Constraint-Logik steigt.
Ein Vorteil der Validierungslogik mit Bean-Validation Constraints ist,
dass JSF die Validierung der Constraints in der Validierungsphase anstößt und
im Falle eines Fehlers diesen direkt neben der Eingabekomponente anzeigt und
nicht wie zuvor im allgemeinen Bereich für Nachrichten.<br /> <h2><a class='latex-index-anchor' name='!idx:/java_ee.html:3.9' ><span class='entry-number'>3.9</span> Bean-Deployment Archive mit Java EE</a> </h2>
<a name = '!idx:/java_ee.html:sec:bda-rules'> </a> Eine der wenigen Schattenseiten von CDI 1.0 ist die Definition von Bean-Deployment Archiven (BDAs) und
deren Umsetzung in den verschiedenen Servern.
Selbst EE-Server mit der gleichen CDI-Implementierung haben nicht immer ein einheitliches Verhalten,
weil zentrale Aspekte in diesem Bereich vom Integrationscode des EE-Servers definiert werden können.
So kann es selbst bei der Migration von einem Weld basierten Server auf einen anderen zu feinen Unterschieden kommen,
wenn die Applikation nicht vollständig portabel implementiert ist.
Das Konzept der Bean-Deployment Archive wurde eingeführt, um Modulgrenzen für Beans und Konfigurationen zu definieren.
Im restriktivsten Fall sind CDI-Beans und Konfigurationen via  <span class='latex-texttt'>beans.xml</span>  nur für das aktuelle Archiv gültig.
Im ersten Moment hört sich dies eventuell sinnvoll an.
Sobald jedoch Module, wie beispielsweise JARs, nicht unter der eigenen Kontrolle stehen oder
zur Modularisierung der eigenen Applikation genutzt werden,
können verschiedene Anwendungsfälle nur mit zusätzlichem Aufwand oder überhaupt nicht umgesetzt werden.
Abhängig von der konkreten Konstellation kann dies in schweren Fällen auch Injizierung über Modulgrenzen hinweg betreffen,
sowie die Anpassung von Default-Implementierungen eines Moduls,
bei der eine alternative Implementierung außerhalb des Moduls zur Verfügung gestellt werden soll.
Außerdem müssen beispielsweise Interceptoren für jedes Archiv erneut konfiguriert werden.
Da die Definition der BDA-Regeln viel Interpretationsspielraum lässt und bereits für lange Diskussionen gesorgt hat,
wurden teilweise alternative Ansätze geschaffen.
Einige Applikationsserver gestehen beispielsweise der Datei  <span class='latex-texttt'>beans.xml</span>  eine Sonderstellung zu,
wenn diese im Verzeichnis  <span class='latex-texttt'>WEB-INF</span>  platziert wird.
Die genaue Umsetzung ist jedoch nicht durch die CDI-Spezifikation gedeckt und
das konkrete Verhalten kann sogar zwischen einzelnen Versionen eines Servers unterschiedlich sein.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Enterprise-Archiven (EARs) verschärft sich die Situation,
da es hier von der genauen Strukturierung der Applikation abhängen kann,
ob und wie verschiedene Konstellationen funktionieren.
Da es in manchen Serverversionen sogar zu Seiteneffekten zwischen Beans mehrerer Web-Archiven (WARs)
in Kombination mit Klassen in einem geteilten Modul eines EARs kommen kann,
ist es ratsam, zumindest in EE6 und EE7 auf EARs möglichst zu verzichten.
Seit EE6 haben EARs glücklicherweise nur noch eine untergeordnete Rolle,
wodurch sich diese Einschränkung in vielen Fällen kaum oder überhaupt nicht bemerkbar macht.
Apache OpenWebBeans im Standalone-Betrieb (= manuell für Java SE oder einen Servlet-Container konfiguriert)
deaktiviert sogar die BDA-Regeln per Default komplett,
wodurch viele Einschränkungen und Hürden nicht auftreten.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Selbst bei einer überschaubaren Applikation wie  <span class='latex-textit'>IdeaFork</span>  müssen die BDAs für GlassFish 3 anders strukturiert werden als beispielsweise für AS7,
obwohl beide Server Weld als CDI-Implementierung verwenden.
Erst durch unterschiedliche Maven-Build-Profile, die im Git-Repository im Detail ersichtlich sind,
kann zur Laufzeit das gleiche Verhalten erzielt werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Seit CDI 1.1, das Bestandteil von EE7 ist,
wurde diese Thematik teilweise durch eine neue Annotation namens  <span class='latex-texttt'>@Priority</span>  gelöst.
Artefakte werden für die gesamte Applikation aktiviert, sobald diese mit  <span class='latex-texttt'>@Priority</span>  annotiert sind.
Bei alternativen Beans entscheidet die angegebene Priorität, welches Bean effektiv aktiv wird, und
bei Decorators und Interceptors wird die Reihenfolge dieser definiert.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Zusammengefasst bedeutet dies, dass bei Modularisierungen und
bei der Wahl des Archivtyps möglichst von der einfachsten Variante ausgegangen werden soll.
Je komplexer die Strukturierung der Applikation wird, desto wahrscheinlicher sind Einschränkungen,
die durch BDA- bzw. Classloading-Regeln auftreten.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Mit CDI 4.0 (Jakarta EE 10) wurde die Bean-Discovery grundlegend vereinfacht. Der neue Standard-Modus <span class='latex-texttt' style='color:#2e7d32;'>annotated</span> erfordert keine <span class='latex-texttt' style='color:#2e7d32;'>beans.xml</span> mehr — nur explizit annotierte Klassen werden als Beans erkannt. In Quarkus entfallen die BDA-Regeln vollständig, da ArC alle Beans zur Build-Zeit auflöst. Details finden Sie in den Kapiteln <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a> und <a href='#!idx:/quarkus.html:10' style='color:#2e7d32;'>10</a>.</div>
</section>
<section class="chapter-section" id="chapter-4">
<h1> <a class='latex-index-anchor' name='!idx:/extensions.html:4' ><span class='entry-number'>4</span> Portable CDI-Erweiterungen</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Der Text dieses Kapitels wurde von Claude (AI built by Anthropic) als Co-Autor überarbeitet. Die Überarbeitung erfolgte ohne Post-Review des Originalautors. Die Nutzung der Inhalte erfolgt auf eigene Verantwortung.
</div>
<a name = '!idx:/extensions.html:chap:cdi-extensions'> </a> Im Dezember 2009 war es soweit und CDI stand in einer ersten Version als Teil von Java EE6 zur Verfügung.
Das vorherige Kapitel hat gezeigt, dass CDI sehr früh mit anderen Java EE6 Spezifikationen
wie beispielsweise JSF, EJB und vieles mehr integriert wurde.
Allerdings gibt es bei der standardmäßigen Integration teilweise Verbesserungspotential.
Dieses wurde in einigen Fällen schnell erkannt und bei der nächsten Gelegenheit, dem Release von Java EE7, nachgereicht.
Abgesehen davon können bestimmte Funktionalitäten wie beispielsweise die Integration anderer Frameworks
nur schwer oder gar nicht durch Spezifikationen abgedeckt werden.
Damit diese Einschränkungen bei der täglichen Arbeit nicht zu einem limitierenden Faktor werden,
wurde das SPI (Service Provider Interface) von CDI sehr flexibel gehalten.
Dadurch wird es möglich sogenannte portable CDI Erweiterungen zu implementieren,
um das Standard-API von CDI zu erweitern und mögliche Lücken zu schließen.
Mittlerweile gibt es viele solcher Erweiterungen.
In diesem Kapitel erhalten Sie Grundkenntnisse, mit deren Hilfe Sie CDI relativ einfach erweitern können.
Darüber hinaus ermöglichen diese Grundlagen die Analyse und eventuelle Verbesserung von bestehenden CDI-Erweiterungen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im weiteren Sinne handelt es sich bei portablen CDI-Erweiterungen um Aufsätze für CDI,
die nur auf Basis des APIs und SPIs von CDI implementiert sind.
Sofern ein paar Feinheiten der CDI-Implementierungen beachtet werden,
ist ein solcher Aufsatz mit jeder spezifikationskonformen Implementierung kompatibel.
Im Optimalfall gilt dies auch für den Einsatz in Java EE6+ Servern.
Hier kann jedoch die tiefe Integration von CDI und
die unterschiedliche Auslegung von Teilen der Spezifikation eine zusätzliche Herausforderung darstellen.
Bei den BDA-Regeln haben wir im Kapitel  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  bereits verschiedene Interpretationen kurz kennengelernt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Von einer portablen Erweiterung im engeren Sinne spricht man,
wenn das Marker-Interface  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>  implementiert wird,
um beispielsweise während des Startprozesses der Applikation das Default-Verhalten abzuändern oder zu erweitern.
Dieses Marker-Interface wird nur benötigt,
um die entsprechenden Implementierungen für den  <span class='latex-texttt'>ServiceLoader</span>  Mechanismus ( <span class='latex-texttt'>java.util.ServiceLoader</span> ) zu konfigurieren.
Implementierungen dieses Interfaces können beliebig viele CDI-Observer Methoden enthalten,
die vordefinierte Phasen des Container-Lifecycles überwachen.
Abhängig von der Lifecycle-Phase können Sie die Standardkonzepte von CDI mit eigenen Mechanismen erweitern,
um zusätzliche Anwendungsfälle möglichst komfortabel zu unterstützen.<br /> <h2><a class='latex-index-anchor' name='!idx:/extensions.html:4.1' ><span class='entry-number'>4.1</span> Der Container-Lifecycle von CDI</a> </h2>
 Bevor wir mit einer konkreten Erweiterung beginnen, sehen wir uns den Container-Lifecycle im Detail an,
da dieser die Basis für die erfolgreiche Implementierung von Extension-Klassen ist.
Der Lifecycle besteht grundsätzlich aus zwei Hauptteilen. Zu Beginn steht der Containerstart, auch Bootstrapping-Prozess genannt,
und am Ende der Containerstopp. Während des Containerstartes können Bean-Definitionen optional verändert, hinzugefügt oder entfernt werden.
Dies ermöglicht die Integration mit beinahe beliebigen Frameworks, die selbst keine explizite CDI-Unterstützung zur Verfügung stellen.
Im nachfolgenden Teil lernen wir sämtliche Events des Lifecycles kennen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Wie eingangs erwähnt notifiziert der CDI-Container aktive Implementierungen von  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>  durch CDI-Events.
Für die Konfiguration und somit die Aktivierung eigener  <span class='latex-texttt'>Extension</span> -Klassen wird das Service-Loader Konzept,
das mit JDK6 eingeführt wurde, verwendet.
Mit Hilfe der Klasse  <span class='latex-texttt'>java.util.ServiceLoader</span>  werden im Falle von CDI alle konfigurierten Implementierungen des
Markerinterfaces  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>  durch den CDI-Container abgefragt,
die in einer oder mehreren Dateien namens  <span class='latex-texttt'>/META-INF/services/javax.enterprise.inject.spi.Extension</span>  konfiguriert sind.
Je Archiv, beispielsweise einer JAR-Datei, ist eine solche Konfigurationsdatei mit beliebig vielen Einträgen möglich.
Ein Eintrag besteht aus dem vollständig qualifizierten Klassennamen einer Implementierung des zuvor erwähnten Markerinterfaces.
Für jeden dieser Einträge erzeugt der CDI-Container eine Instanz, die für die gesamte Applikation gültig ist.
Hierbei handelt es sich um eine fixe Vorgabe. Die explizite Angabe eines Scopes ist dadurch nicht vorgesehen.
Wie die Bezeichnung Markerinterface bereits vermuten lässt,
sind durch  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>  keine Methodensignaturen vorgegeben,
wodurch nicht zu jedem Lifecycle-Event eine Methode zur Verfügung gestellt werden muss.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI-Events des Container-Lifecycles können in aktiven  <span class='latex-texttt'>Extension</span> -Klassen mit Hilfe von Observer-Methoden überwacht werden.
Manche der Lifecycle-Events feuert der CDI-Container einmalig und andere für jedes gefundene Artefakt wie beispielsweise Beans.
Die meisten dieser Events stehen bereits seit CDI 1.0 zur Verfügung.
CDI 1.1 führt mit  <span class='latex-texttt'>AfterTypeDiscovery</span> ,  <span class='latex-texttt'>ProcessInjectionPoint</span>  und  <span class='latex-texttt'>ProcessBeanAttributes</span>  drei zusätzliche Events ein,
auf die ebenfalls im nachfolgenden Abschnitt eingegangen wird.<br /> <div class="tip"><b>Tipp: </b> Selbst  <span class='latex-texttt'>Extension</span> s sind später in andere CDI-Beans injizierbar.
Durch diesen Ansatz ist es möglich während des Applikationsstartes Informationen zu sammeln,
um diese zu einem späteren Zeitpunkt zu verwenden. </div> Im nachfolgenden Teil erfahren Sie mehr über die einzelnen Lifecycle-Events und deren Einsatzgebiete.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.1'><span class='entry-number'>4.1.1</span> BeforeBeanDiscovery</a> </h3>
 Bevor mit der Verarbeitung der Bean-Kandidaten begonnen wird,
feuert der CDI-Container das Event  <span class='latex-texttt'>BeforeBeanDiscovery</span> .
Über dieses Event lassen sich Qualifier-, Scope-, Stereotyp- und Interceptor- Annotationen hinzufügen,
die nicht sämtliche Vorgaben der CDI-Spezifikation erfüllen.
Darüber hinaus ist es sogar möglich für Klassen außerhalb von BDAs (Bean Deployment Archiv) einen sogenannten  <span class='latex-texttt'>AnnotatedType</span> ,
die Vorstufe von Managed-Beans, zu erzeugen und über dieses Event hinzuzufügen.
Die später daraus resultierenden Beans unterscheiden sich kaum von Beans, die regulär in einem BDA enthalten sind.
Einen kleinen Unterschied gibt es jedoch auch hier durch BDAs.
Für solche Bean-Kandidaten existiert keine  <span class='latex-texttt'>beans.xml</span> -Datei,
wodurch nur global (Interceptor-,...) Konfigurationen, die seit CDI 1.1 verfügbar sind, für die endgültigen Beans verwendbar sind.
Abgesehen von der Einschränkung in Kombination mit BDAs ermöglicht die manuelle Registrierung von  <span class='latex-texttt'>AnnotatedType</span> s
die Integration beliebiger Archive und Konfigurationsformate, um die standardmäßige Suche nach Bean-Kandidaten zu erweitern.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.2'><span class='entry-number'>4.1.2</span> ProcessAnnotatedType</a> </h3>
 Nach den manuellen Registrierungen via  <span class='latex-texttt'>BeforeBeanDiscovery</span>  führt der CDI-Container einen Scan aller BDAs durch und
erstellt für jede potentielle Bean-Klasse einen sogenannten  <span class='latex-texttt'>AnnotatedType</span> ,
der über ein Event mit dem Namen  <span class='latex-texttt'>ProcessAnnotatedType</span>  gefeuert wird.
Dieses Event ist das am häufigsten verwendete Event im Bootstrapping-Prozess,
da portable CDI-Erweiterungen über dieses Event Bean-Definitionen verändern oder entfernen können.
In  <span class='latex-textit'>IdeaFork</span>  nutzen wir dies, um im zweiten Teil dieses Kapitels bestimmte Typen für den CDI-Container zu deaktivieren.
Eine solche Deaktivierung von Bean-Kandidaten ist durch den Aufruf der  <span class='latex-texttt'>AnnotatedType</span> -Methode  <span class='latex-texttt'>#veto</span> in einer Observer-Methode für das  <span class='latex-texttt'>ProcessAnnotatedType</span> -Event möglich.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.3'><span class='entry-number'>4.1.3</span> AfterTypeDiscovery</a> </h3>
 Dieses Lifecycle-Event ist seit CDI 1.1 verfügbar und wird gefeuert sobald sämtliche Typen registriert wurden.
Die Methoden  <span class='latex-texttt'>#getAlternatives</span> ,  <span class='latex-texttt'>#getInterceptors</span>  und   <span class='latex-texttt'>#getDecorators</span> retournieren Listen der global aktivierten Klassen.
Sowohl die Reihenfolge als auch der Inhalt der Listen kann zu diesem Zeitpunkt noch verändert werden.
Globale Aktivierungen sind seit CDI 1.1 mit Hilfe der Annotation  <span class='latex-texttt'>@Priority</span>  standardisiert.
Wird beispielsweise ein Interceptor nur für ein BDA via  <span class='latex-texttt'>beans.xml</span>  aktiviert, so ist dieser hier nicht enthalten.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Mit  <span class='latex-texttt'>#addAnnotatedType</span>  ist es möglich zusätzlich eigene Typen hinzuzufügen.
Danach kennt der CDI-Container alle Definitionen, für die auch tatsächlich Bean-Definitionen erstellt werden sollen.
Alle via  <span class='latex-texttt'>#veto</span>  exkludierten Typen sind spätestens jetzt nicht mehr in den internen Datenstrukturen des CDI-Containers vorhanden.
Mit  <span class='latex-texttt'>ProcessBeanAttributes</span> , auf das wir etwas später im Detail eingehen,
ist seit CDI 1.1 ein solches Veto auch auf Basis der endgültigen Bean-Metadaten möglich.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.4'><span class='entry-number'>4.1.4</span> ProcessInjectionPoint</a> </h3>
 Dieses ebenfalls mit CDI 1.1 eingeführte Event wird für jeden Injection-Point einer verwalteten Ressource aufgerufen.
Hierzu zählen nicht nur CDI-Beans, sondern auch Artefakte wie beispielsweise EJBs.
Dieses Lifecycle-Event stellt seit CDI 1.1 den ersten Schritt in der Phase zur Definition der finalen Managed-Bean-Metadaten dar.
Davor war dies das nachfolgende Event namens  <span class='latex-texttt'>ProcessInjectionTarget</span> .
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span class='latex-texttt'>ProcessInjectionPoint</span>  wird nicht nur für Injection-Points in registrierten Typen,
sondern auch für Injection-Points aktiver Observer-Methoden und Producer erzeugt.
Via  <span class='latex-texttt'>#getInjectionPoint</span>  und  <span class='latex-texttt'>#setInjectionPoint</span> können Sie in speziellen Fällen den jeweiligen Injection-Point überprüfen bzw. ersetzen/dekorieren.
Wird bei der Überprüfung eine (für die Applikation) ungültige Definition gefunden,
so kann der Applikationsstart durch den Aufruf von  <span class='latex-texttt'>#addDefinitionError(Throwable)</span>  abgebrochen werden.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.5'><span class='entry-number'>4.1.5</span> ProcessInjectionTarget</a> </h3>
 Das Event  <span class='latex-texttt'>ProcessInjectionTarget</span>  ist auf den Typ der Komponente typisiert und
wird für jede Komponente (inkl. Java EE Komponenten) erzeugt, die Injizierung unterstützt.
 <span class='latex-texttt'>javax.enterprise.inject.spi.InjectionTarget</span>  ist für die gesamte Erzeugung und
Zerstörung, inklusive der Befüllung von Injection-Points,
sowie für Aufrufe von Callback-Methoden (Post-Construct- und Pre-Destroy-Callbacks) verantwortlich.
Da über dieses Event eine eigene Implementierung von  <span class='latex-texttt'>InjectionTarget</span> ,
bzw. ein Wrapper für die Default-Implementierung gesetzt werden kann,
ist es auf einfache Weise möglich die erwähnten Prozesse zu erweitern oder anzupassen.
Allerdings handelt es sich hierbei um sehr spezielle und tiefreichende Eingriffe, die nur in seltenen Fällen erforderlich sind.
Etwas interessanter ist hingegen die Auswertung der dazugehörenden  <span class='latex-texttt'>AnnotatedType</span> -Instanz,
die über  <span class='latex-texttt'>#getAnnotatedType</span>  verfügbar ist.
Über diese Instanz sind eigene Validierungen durchführbar und
im Fehlerfall können Sie den Containerstart via  <span class='latex-texttt'>#addDefinitionError(Throwable)</span>  abbrechen.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.6'><span class='entry-number'>4.1.6</span> ProcessBeanAttributes</a> </h3>
 Dieses Lifecycle-Event stellt das letzte mit CDI 1.1 eingeführte Event in unserer Beschreibung des Lifecycles dar.
Es wird für jedes Bean, sowie Interceptoren und Decoratoren gefeuert und
erlaubt mit Hilfe von  <span class='latex-texttt'>#getBeanAttributes</span>  und  <span class='latex-texttt'>#getAnnotated</span> die bestehenden Metadaten zu überprüfen.
Bei Bedarf ist es durch den Aufruf von  <span class='latex-texttt'>#addDefinitionError(Throwable)</span>  möglich einen Fehler zu melden,
wodurch wie üblich der Containerstart abgebrochen wird.
In seltenen Fällen kann es erforderlich sein die bestehenden Bean-Attribute mit  <span class='latex-texttt'>#setBeanAttributes</span>  zu verändern oder
das gesamte Bean durch den Aufruf von  <span class='latex-texttt'>#veto</span>  zu deaktivieren.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.7'><span class='entry-number'>4.1.7</span> ProcessProducer</a> </h3>
 Für jeden CDI-Producer, sowohl Producer-Methoden als auch Producer-Felder, wird dieses Lifecycle-Event gefeuert.
Das Interface dieses Events erlaubt die Validierung des Producers und
bei Bedarf kann mit dem Aufruf von  <span class='latex-texttt'>#addDefinitionError(Throwable)</span>  der Applikationsstart abgebrochen werden.
Darüber hinaus kann der Producer auch verändert werden.
Anpassungen sollten jedoch nur mit einem Wrapper vorgenommen werden,
der zumindest teilweise Aufrufe an die ursprüngliche Instanz delegiert.
Um Fehler wie beispielsweise Memory-Leaks zu vermeiden,
ist es empfehlenswert eine vollständige Implementierung des  <span class='latex-texttt'>Producer</span> -Interfaces mit Vorsicht umzusetzen.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.8'><span class='entry-number'>4.1.8</span> ProcessBean</a> </h3>
 Bevor ein aktives Bean effektiv registriert wird, feuert der CDI-Container das Event  <span class='latex-texttt'>ProcessBean</span> .
Dies stellt den letzten Punkt vor der Registrierung des entsprechenden Beans dar.
Zu diesem Zeitpunkt gibt es bereits die endgültige Managed-Bean Definition (Instanz von  <span class='latex-texttt'>javax.enterprise.inject.spi.Bean&lt;T&gt;</span> ).
Somit besteht die Möglichkeit die finale Repräsentation der Managed-Bean Metadaten zu überprüfen
und bei Bedarf den Containerstart via  <span class='latex-texttt'>#addDefinitionError(Throwable)</span>  abzubrechen.
Sind Sie nur an einem bestimmten Managed-Bean Typ interessiert,
dann ist es möglich die konkreten Untertypen  <span class='latex-texttt'>ProcessManagedBean</span> ,  <span class='latex-texttt'> ProcessProducerMethod </span>  und
 <span class='latex-texttt'>ProcessProducerField</span>  anzugeben. Mit  <span class='latex-texttt'>ProcessBean</span>  selbst können Sie alle Subtypen des Events überwachen.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.9'><span class='entry-number'>4.1.9</span> ProcessObserverMethod</a> </h3>
 Für Observer-Methoden gibt es ein separates Event namens  <span class='latex-texttt'>ProcessObserverMethod</span> ,
da für die Validierung solcher Methoden andere Metadaten erforderlich sind.
Neben der Bean-Klasse und den Qualifier-Annotationen stehen auch sämtliche Informationen über die Methode selbst zur Verfügung.
Das Grundkonzept entspricht dem von  <span class='latex-texttt'>ProcessBean</span> .<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.10'><span class='entry-number'>4.1.10</span> AfterBeanDiscovery</a> </h3>
 Sobald der CDI-Container mit dem Verarbeitungsprozess inklusive der Validierung aktiver Managed-Beans fertig ist,
wird das Event  <span class='latex-texttt'>AfterBeanDiscovery</span>  gefeuert.
Abgesehen von der bereits bekannten Methode  <span class='latex-texttt'>#addDefinitionError(Throwable)</span>  stellt dieses Event Methoden für die manuelle Registrierung
von eigenen Managed-Beans, Observer-Methoden und CDI-Context Implementierungen zur Verfügung.
Wird ein eigenes Managed-Bean mit Hilfe der Methode  <span class='latex-texttt'>#addBean</span>  hinzugefügt,
so wird das zuvor vorgestellte Event  <span class='latex-texttt'>ProcessBean</span>  gefeuert, bevor das Bean effektiv hinzugefügt wird.
Zu beachten ist, dass es sich hierbei nicht um vollwertige Managed-Beans handelt,
da beispielsweise keine Interceptoren unterstützt werden.
Solche Beans sind somit mehr mit Producern vergleichbar und ermöglichen beispielsweise die Integration anderer Bean-Container.<br /> <h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.11'><span class='entry-number'>4.1.11</span> AfterDeploymentValidation</a> </h3>
<span class='latex-texttt'>AfterDeploymentValidation</span>  stellt das letzte Event dar, bevor der CDI-Container vollständig gestartet ist.
Zu diesem Zeitpunkt müssen sämtliche Validierungen, für die der Container verantwortlich ist, abgeschlossen sein.
Sollten Sie in einem Observer für dieses Event eine invalide Situation in der Applikation feststellen,
so können Sie mit Hilfe der Methode  <span class='latex-texttt'>#addDeploymentProblem</span>  das erfolgreiche Deployment der Applikation
auch an diesem Punkt noch verhindern.<br /> <div class="tip"><b>Tipp: </b> Das Event  <span class='latex-texttt'>AfterDeploymentValidation</span>  wird oft zur manuellen Implementierung eines Startup-Events verwendet.
Dies funktioniert allerdings nur beschränkt und ermöglicht somit keine vollständig portable Implementierung.
Aus diesem Grund wurde die Annotation  <span class='latex-texttt'>@Initialized</span>  mit CDI 1.1 eingeführt.
Seit CDI 1.1 ist somit der bevorzugte Ansatz zur Implementierung von portabler Initialisierungslogik ein Observer
mit dem Qualifier  <span class='latex-texttt'>@Initialized(ApplicationScoped.class)</span> . </div><h3><a class='latex-index-anchor' name='!idx:/extensions.html:4.1.12'><span class='entry-number'>4.1.12</span> BeforeShutdown</a> </h3>
 Dieses Lifecycle-Event wird gefeuert, bevor der CDI-Container gestoppt wird und
ermöglicht beispielsweise die explizite Freigabe von geöffneten Ressourcen, bevor die Applikation beendet wird.<br />
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Mit CDI 4.0 (Jakarta EE 10) wurde eine zweite Art von Erweiterungen eingeführt: die sogenannten Build Compatible Extensions. Diese verwenden Annotationen wie <span class='latex-texttt' style='color:#2e7d32;'>@Discovery</span>, <span class='latex-texttt' style='color:#2e7d32;'>@Enhancement</span> und <span class='latex-texttt' style='color:#2e7d32;'>@Registration</span> statt Observer-Methoden auf <span class='latex-texttt' style='color:#2e7d32;'>Extension</span>-Klassen und sind besonders für Build-Zeit-Frameworks wie Quarkus relevant. Details finden Sie in Kapitel <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>.</div>
<h2><a class='latex-index-anchor' name='!idx:/extensions.html:4.2' ><span class='entry-number'>4.2</span> Eigene CDI Erweiterungen entwickeln</a> </h2>
 Um eine eigene portable CDI-Erweiterung zu entwickeln, muss nicht jedes der zuvor vorgestellten Events überwacht werden.
Die Stärke von CDI-Events, die absolute Entkoppelung zwischen Erzeuger und den Observer-Methoden, wird auch hier genutzt,
um CDI-Erweiterungen möglichst leichtgewichtig zu halten.
<div class="tip"><b>Tipp: </b><b>Brauchen Sie wirklich eine CDI-Erweiterung?</b> Bevor Sie eine Portable Extension implementieren, prüfen Sie, ob einfachere Mechanismen ausreichen:<br />
&bull; Möchten Sie Beans dynamisch bereitstellen? &rarr; <span class='latex-texttt'>@Produces</span>-Methode<br />
&bull; Möchten Sie eine Implementierung austauschen? &rarr; <span class='latex-texttt'>@Alternative</span> mit <span class='latex-texttt'>@Priority</span><br />
&bull; Möchten Sie Annotationen bündeln? &rarr; <span class='latex-texttt'>@Stereotype</span><br />
&bull; Müssen Sie den Bean-Discovery-Prozess oder Container-Lifecycle beeinflussen? &rarr; Dann ist eine Extension der richtige Weg.</div>
In  <span class='latex-textit'>IdeaFork</span>  möchten wir das  <span class='latex-texttt'>ProcessAnnotatedType</span> -Event dazu verwenden, um JPA-Entitäten für den CDI-Container zu deaktivieren.
Wie bereits im Kapitel  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  erwähnt, sollen Instanzen einer Klasse nur durch einen Container verwaltet werden,
da es sonst zu Seiteneffekten mit den verschiedenen Proxy-Bibliotheken kommen kann.
JPA-Entitäten können wir anhand der Annotation  <span class='latex-texttt'>@Entity</span>  erkennen.
Diesen Umstand nutzen wir, um Entity-Klassen für den CDI-Container unsichtbar zu machen.
Hierfür legen wir die Klasse  <span class='latex-texttt'>EntityVetoExtension</span>  an und
implementieren das Marker-Interface  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span> .
Damit eine Extension-Klasse durch den CDI-Container gefunden und verwendet wird,
müssen Sie diese in einer Datei namens  <span class='latex-texttt'>/META-INF/services/javax.enterprise.inject.spi.Extension</span> vollständig qualifiziert angeben. Listing  <a href='#!idx:/extensions.html:fig:activation_of_a_portable_cdi_extension'> Aktivierung einer portable CDI Erweiterung </a>  zeigt dies für unsere  <span class='latex-texttt'>EntityVetoExtension</span> .
 <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/extensions.html:fig:activation_of_a_portable_cdi_extension'></a>                     <pre><code>//content of /META-INF/services/javax.enterprise.inject.spi.Extension
at.irian.cdiatwork.ideafork.core.impl.infrastructure.EntityVetoExtension

</code></pre>
                </div> Vorerst sind wir nur an dem Event  <span class='latex-texttt'>ProcessAnnotatedType</span>  interessiert und fügen daher eine entsprechende Observer-Methode hinzu.
Wie Listing  <a href='#!idx:/extensions.html:fig:veto'> Eine Klasse für CDI exkludieren </a>  illustriert, ist es möglich die Implementierung sehr einfach zu halten.
Über  <span class='latex-texttt'>ProcessAnnotatedType#getAnnotatedType#getJavaClass</span>  können wir direkt auf die zugrundeliegende Klasse zugreifen.
In unserem Fall nehmen wir jedoch eine Abkürzung über  <span class='latex-texttt'>ProcessAnnotatedType#getAnnotatedType#isAnnotationPresent</span> .
Sobald wir die Annotation  <span class='latex-texttt'>@Entity</span>  vorfinden,
deaktivieren wir mit dem Aufruf  <span class='latex-texttt'>ProcessAnnotatedType#veto</span>  den dazugehörigen  <span class='latex-texttt'>AnnotatedType</span> .
Die nachfolgenden Container-Lifecycle-Events werden für diesen  <span class='latex-texttt'>AnnotatedType</span>  somit nicht mehr gefeuert.
Die Entity-Klassen sind außerdem nicht mehr via  <span class='latex-texttt'>@Inject</span>  in andere Beans injizierbar,
da sie der CDI-Container durch den Aufruf der  <span class='latex-texttt'>#veto</span> -Methode nicht mehr kennt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/extensions.html:fig:veto'></a>                     <pre><code>public class EntityVetoExtension implements Extension {
    protected void excludeEntityClasses(
      @Observes ProcessAnnotatedType pat) {
        if (pat.getAnnotatedType().isAnnotationPresent(Entity.class)) {
            pat.veto();
        }
    }
}
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Das hier gezeigte <span class='latex-texttt'>EntityVetoExtension</span>-Pattern ist eine CDI-1.0-Lösung. In späteren Versionen stehen elegantere Alternativen zur Verfügung: DeltaSpike bietet <span class='latex-texttt'>@Exclude</span> (siehe Kapitel <a href='#!idx:/extensions.html:chap:cdi-extensions'>5</a>), und seit CDI 1.1 existiert die standardisierte Annotation <span class='latex-texttt'>@Vetoed</span>, die eine Klasse direkt von der Bean-Erkennung ausschließt. Dieses Beispiel bleibt jedoch wertvoll, um das Extension-SPI zu verstehen.</div>
Wie zuvor erwähnt, können wir auch Validierungen von Beans mit Hilfe von CDI-Erweiterungen umsetzen.
Die im Kapitel  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  aufgezeigten Kombinationsmöglichkeiten von CDI, EJBs und JSF sind vielfältig.
Ein paar der erwähnten Fallstricke sind nicht unmittelbar erkennbar bzw. können sich erst im produktiven Betrieb auswirken und
setzen teilweise ein gutes Detailwissen voraus.
Um problematischen Konstellationen entgegenzuwirken und gleichzeitig eine etwas einheitlichere Applikationsstruktur sicherzustellen,
validieren wir mit Hilfe einer zusätzlichen CDI Erweiterung applikationsspezifische Richtlinien.
Dem Umfang für Validierungsregeln von Implementierungsdetails sind kaum Grenzen gesetzt.
Sämtliche Mechanismen, die durch die standardmäßige Reflection-API zur Verfügung stehen,
können für die Validierung der Applikationsstruktur genutzt werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  beschränken wir uns auf die Überprüfung von View-Controller-Beans und das Package für Services.
Im vorherigen Kapitel haben wir teilweise EJBs als View-Controller verwendet.
Dadurch haben wir uns in diesen Fällen ein eigenständiges transaktionales Service erspart.
In komplexeren Applikationen ist es allerdings oftmals erforderlich, dass nur ein Teil der JSF Action-Methode(n) transaktional ausgeführt wird.
Aus diesem und anderen Gründen, die bereits im Kapitel  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  erwähnt wurden,
soll unsere erste Validierungsregel daher sicherstellen, dass EJBs nicht gleichzeitig mit  <span class='latex-texttt'>@ViewController</span>  annotiert sind.
Jeder Regelverstoß soll aufgezeichnet werden.
Am Ende des Bootstrapping-Prozesses wollen wir im Fehlerfall den Applikationsstart abbrechen und
alle Verstöße gesammelt als Grund für das Deployment-Problem angeben.<br />Da wir die effektiven Bean-Metadaten validieren möchten, verwenden wir in Listing  <a href='#!idx:/extensions.html:fig:validate_view_controller'> Applikationsregeln validieren </a> einen Observer für das Event  <span class='latex-texttt'>ProcessManagedBean</span> .
Die Methode  <span class='latex-texttt'>#getAnnotatedBeanClass</span>  gibt nicht direkt die Klasse selbst zurück,
sondern eine Instanz vom Typ  <span class='latex-texttt'>AnnotatedType</span> .
Über diese Instanz können wir nicht nur physisch verfügbare Metadaten überprüfen,
sondern auch eventuell dynamisch hinzugefügte, die später effektiv für den CDI-Container sichtbar sind.
Soll hingegen nur die jeweils physische Klasse und deren Metadaten geprüft werden,
so können Sie die Methode  <span class='latex-texttt'>#getJavaClass</span>  von  <span class='latex-texttt'>AnnotatedType</span>  verwenden.
Regelverstöße sammeln wir als Fehlermeldungen in einer Liste.
In einem zweiten Observer, dieses Mal für das Event  <span class='latex-texttt'>AfterDeploymentValidation</span> ,
werten wir die gefundenen Verstöße aus.
Über  <span class='latex-texttt'>ProcessManagedBean</span>  könnten wir zwar ebenfalls den Startprozess abbrechen,
jedoch wäre hier eine gesammelte Ausgabe aller Regelverstöße nicht möglich.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/extensions.html:fig:validate_view_controller'></a>                     <pre><code>public class AppStructureValidationExtension implements Extension {
  private static final Logger LOG = Logger.getLogger(/*...*/);
  private List&lt;String&gt; violations = new ArrayList&lt;String&gt;();

  public void validateArtifacts(
    @Observes ProcessManagedBean pmb) {
      if (pmb.getAnnotatedBeanClass()
        .isAnnotationPresent(ViewController.class)) {
          validateViewController(pmb.getAnnotatedBeanClass());
      }
  }

  private void validateViewController(AnnotatedType annotatedType) {
    for (Annotation annotation : annotatedType.getAnnotations()) {
      if (annotation.annotationType()
        .getPackage().getName().equals("javax.ejb")) {
          this.violations.add(/*...*/); //violation message
      }
    }
  }

  public void checkAndAddViolations(
    @Observes AfterDeploymentValidation afterDeploymentValidation) {
      if (this.violations.isEmpty()) {
        LOG.info(/*...*/); //success message
        return;
      }

      StringBuilder violationMessage = new StringBuilder();

      for (String violation : this.violations) {
        violationMessage.append(violation);
      }
      this.violations.clear();
      afterDeploymentValidation.addDeploymentProblem(
        new IllegalStateException(violationMessage.toString()));
  }
}
</code></pre>
                </div> Mit einer zweiten Regel wollen wir sicherstellen, dass alle Beans in einem Service-Package als  <span class='latex-texttt'>@Stateless</span> -EJBs umgesetzt wurden.
Zusätzlich überprüfen wir Beans, die mit  <span class='latex-texttt'>@javax.ejb.Singleton</span>  annotiert sind, und loggen eine Warnung,
da durch Singleton-EJBs mit  <span class='latex-texttt'>ConcurrencyManagementType.CONTAINER</span>  schnell ein ungewollter Flaschenhals in der Applikation entstehen kann
bzw. Beans mit  <span class='latex-texttt'>ConcurrencyManagementType.BEAN</span>  nur in seltenen Fällen wirklich erforderlich sind.
Eine Warnung soll ebenfalls gelogged werden, wenn View-Controller-Beans nicht einer vorgegebenen Namenskonvention entsprechen.
Listing  <a href='#!idx:/extensions.html:fig:validate_naming_and_ejbs'> Erweiterte Applikationsregeln validieren </a>  zeigt die erforderlichen Änderungen im Vergleich zu  <a href='#!idx:/extensions.html:fig:validate_view_controller'> Applikationsregeln validieren </a> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/extensions.html:fig:validate_naming_and_ejbs'></a>                     <pre><code>public class AppStructureValidationExtension implements Extension {
  //...
  public void validateArtifacts(
    @Observes ProcessManagedBean pmb) {
      //...
      if (pmb.getAnnotatedBeanClass().getJavaClass()
        .getPackage().getName().endsWith(".service")) {
          validateService(pmb.getAnnotatedBeanClass());
      }
      if (pmb.getAnnotatedBeanClass()
        .isAnnotationPresent(Singleton.class)) {
          validateSingletonEjb(pmb.getAnnotatedBeanClass());
      }
  }

  private void validateViewController(AnnotatedType annotatedType) {
    //...
    if (!annotatedType.getJavaClass().getName().endsWith("ViewCtrl")) {
      LOG.warning(/*...*/);
    }
  }

  private void validateService(AnnotatedType annotatedType) {
    if (!annotatedType.isAnnotationPresent(Stateless.class)) {
      this.violations.add(/*...*/);
    }
  }

  private void validateSingletonEjb(AnnotatedType annotatedType) {
    ConcurrencyManagement cmAnnotation =
      annotatedType.getAnnotation(ConcurrencyManagement.class);

    if (cmAnnotation == null ||
      ConcurrencyManagementType.CONTAINER == cmAnnotation.value()) {
        LOG.warning(/*...*/);
    } else if (ConcurrencyManagementType.BEAN == cmAnnotation.value()) {
      LOG.warning(/*...*/);
    }
  }
}
</code></pre>
                </div> Die eben selbst definierten Applikationsrichtlinien führen mit dem aktuellen Stand von  <span class='latex-textit'>IdeaFork</span> zu zwei Warnungen und fünf Verstößen. Die erforderlichen Anpassungen sind sehr einfach.
Neben dem Austausch von einzelnen Annotationen
gegen äquivalente Annotationen, die ebenfalls im Kapitel  <a href='#!idx:/java_ee.html:chap:cdi-java_ee'>  CDI und Java EE </a>  vorgestellt werden,
wird vor allem ein zusätzliches EJB namens  <span class='latex-texttt'>IdeaService</span>  erforderlich.
Sämtliche Änderungen dieser Umstellung sowie die Aktivierung von  <span class='latex-texttt'>AppStructureValidationExtension</span> sind im Git-Repository von  <span class='latex-textit'>IdeaFork</span>  in einem Commit zusammengefasst.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Den Erweiterungsmöglichkeiten sind nur wenige Grenzen gesetzt, wodurch CDI beinahe mit beliebigen Konzepten erweiterbar ist.
Das nachfolgende Kapitel, zum Thema  <a href='#!idx:/deltaspike.html:chap:deltaspike'>  Apache DeltaSpike </a> , illustriert weitere Möglichkeiten, wie CDI portabel erweitert werden kann.
</section>
<section class="chapter-section" id="chapter-5">
<h1> <a class='latex-index-anchor' name='!idx:/deltaspike.html:5' ><span class='entry-number'>5</span> Apache DeltaSpike</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Der Text dieses Kapitels wurde von Claude (AI built by Anthropic) als Co-Autor überarbeitet. Diese Überarbeitung erfolgte ohne nachträgliches Review durch den Originalautor. Verwendung auf eigene Verantwortung.
</div>
<a name = '!idx:/deltaspike.html:chap:deltaspike'> </a> In den vorherigen Kapiteln haben wir verschiedene CDI-Konzepte anhand der Beispielapplikation  <span class='latex-textit'>IdeaFork</span>  kennengelernt.
Bevor wir im nächsten Kapitel  <span class='latex-textit'>IdeaFork</span>  auf ein effizientes Minimum reduzieren, bauen wir den aktuellen Stand von  <span class='latex-textit'>IdeaFork</span> in diesem Kapitel weiter aus. Hierfür verwenden wir eine beliebte portable CDI-Erweiterung namens Apache DeltaSpike,
die Ende 2011 als Nachfolger von Apache MyFaces CODI und JBoss Seam3 gegründet wurde.
Ein großer Teil aller CDI-basierten Applikationen setzte zum damaligen Zeitpunkt auf eine der beiden Erweiterungen,
um von zusätzlichen Konzepten zu profitieren.
CODI entstand aus Anforderungen großer Applikationen und zeichnete sich durch hohe Stabilität und
gute Performance in Kombination mit innovativen Konzepten aus. Seam3 bot ähnlich wie CODI einige Module,
die CDI verbesserten und mit anderen Technologien integrierten.
Obwohl CODI weniger Module zur Verfügung stellte, wurde das Framework in vielen CDI-basierten JSF-Applikationen bevorzugt,
da das Framework die tägliche Arbeit vor allem mit CDI und JSF erheblich erleichterte.
Knapp zwei Jahre nach der Gründung von CODI wurde der Community eine Fusion mit Seam3 angeboten,
die schließlich zu dem Top-Level-Projekt Apache DeltaSpike unter dem Dach der Apache Software Foundation (ASF) führte.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der Anfang gestaltete sich etwas träge, da teilweise überlappende Aspekte zu einem konsistenten API vereint werden mussten.
Mit Version 1.0 war es schließlich soweit und DeltaSpike deckte die erfolgreichsten Konzepte von CODI ab,
wodurch die Migration einer CODI-basierten Applikation in vielen Fällen in wenigen Stunden durchführbar war.
In fast allen Bereichen erfolgte jedoch eine komplette Neuimplementierung der bekannten Funktionalitäten,
um diese noch komfortabler und gleichzeitig flexibler zur Verfügung zu stellen.
Darüber hinaus wurden zusätzliche Mechanismen und Module hinzugefügt, die unter anderem durch Teile, die ursprünglich von Seam3 stammten,
einfacher umgesetzt werden konnten.
Nach einigen Diskussionen und Kompromissen wurden von Seam3 allerdings nur wenige Implementierungen übernommen,
wodurch der Migrationsaufwand einer Seam3-Applikation, abhängig von den eingesetzten Teilen, umfangreicher ausfallen kann.
Einige der Seam3 Module wurden in Projekte von Drittherstellern verschoben.
Bei diesen Modulen handelt es sich primär um die CDI-Integration der entsprechenden Projekte,
die in Zukunft von den Projekten selbst weiterentwickelt und gewartet werden.
DeltaSpike selbst sorgt somit primär für die direkte Verbesserung von CDI und anderer Java EE Spezifikationen und
ermöglicht darüber hinaus die portable Verwendung von CDI 1.x in Java SE Projekten.
Die praxisnahe Erweiterung von Java EE, aber auch von CDI selbst, ist das Erfolgsrezept von DeltaSpike.
Dies verhalf dem Projekt zu einer vielfältigen Community und 2014 sogar zu einem "Duke's Choice Award".<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ein weiterer Erfolgsfaktor ist die getestete Portabilität, die seit Beginn des Projekts eine zentrale Rolle spielt.
Mit Hilfe von JBoss Arquillian wurde ein umfangreiches Set an Tests aufgebaut.
Für Releases von OpenWebBeans und Weld wird jeweils ein eigener Build-Job im Continuous-Integration Cluster der Apache Software Foundation angelegt.
Dies ermöglicht automatisierte Tests, die die Kompatibilität von DeltaSpike mit möglichst vielen Konfigurationen sicherstellen.
Neben OpenWebBeans und Weld selbst wird die Test-Suite auch in Kombination mit mehreren Open-Source Servern regelmäßig ausgeführt.
Hierzu zählen verschiedene Versionen von Apache TomEE, JBoss AS7 und WildFly, sowie Oracle GlassFish.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Mittlerweile ist DeltaSpike so umfangreich, dass die Beschreibung sämtlicher Bestandteile den Rahmen dieses Buchs übersteigen würde.
In den nachfolgenden Teilen werden wir uns daher die zentralsten Bestandteile und ein paar der Erweiterungsmöglichkeiten ansehen.
Hierfür gehen wir von unserer CDI-basierten JSF-Beispielapplikation namens  <span class='latex-textit'>IdeaFork</span>  aus und stellen Teile dieser um.<br />  
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1' ><span class='entry-number'>5.1</span> Alle für einen Kern</a> </h2>
 DeltaSpike besteht aus mehreren größtenteils unabhängigen Modulen, die auf Basis von DeltaSpike-Core aufgebaut sind.
Die Verwendung einzelner Module ist optional.
Soll eine CDI-basierte Applikation mit DeltaSpike verbessert werden, dann muss mindestens DeltaSpike-Core hinzugefügt werden.
Neben verschiedenen Utilities für CDI enthält DeltaSpike-Core zusätzliche Funktionalitäten,
die sowohl in CDI-basierten Java SE als auch Java EE Applikationen nützlich sind.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bevor wir  <span class='latex-textit'>IdeaFork</span>  mit Mechanismen von DeltaSpike bereichern,
müssen wir DeltaSpike-Core als Dependency von  <span class='latex-textit'>IdeaFork</span>  hinzufügen.
Im Normalfall genügt es, Core-API als  <span class='latex-texttt'>compile</span> -Dependency und Core-Impl als  <span class='latex-texttt'>runtime</span> -Dependency zu definieren.
Beides ist in Listing  <a href='#!idx:/deltaspike.html:fig:ds-core_dependencies'> Maven Konfiguration für DeltaSpike Core </a>  ersichtlich und wird hier mit der separat definierten Maven-Property
 <span class='latex-texttt'>${ds.version}</span>  parametrisiert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-core_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.core&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-core-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.core&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-core-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> Neben DeltaSpike-Core werden wir in diesem Buch die folgenden Module auszugsweise betrachten:<br /> <div class='latex-begin-block'><ul><li class='latex-list'>  DeltaSpike Bean-Validation
 </li><li class='latex-list'>  DeltaSpike Data
 </li><li class='latex-list'>  DeltaSpike JPA
 </li><li class='latex-list'>  DeltaSpike JSF
 </li><li class='latex-list'>  DeltaSpike Scheduler
 </li><li class='latex-list'>  DeltaSpike Servlet
 </li><li class='latex-list'>  DeltaSpike Test-Control
 </li></ul></div> Die DeltaSpike-Module Security, Partial-Bean und Proxy sind teilweise für Funktionalitäten der zuvor aufgelisteten Module erforderlich.
Alle drei Module können auch eigenständig eingesetzt werden.
Allerdings werden wir uns primär ihren Einsatz in Kombination mit anderen Bestandteilen von DeltaSpike ansehen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div class="tip"><b>Tipp: </b><b>DeltaSpike-Module und ihre modernen Entsprechungen:</b><br />
&bull; <b>Core (Config):</b> MicroProfile Config (Kapitel <a href='#!idx:/quarkus.html:10.4'>10.4</a>)<br />
&bull; <b>Security:</b> Jakarta Security + <span class='latex-texttt'>@RolesAllowed</span> (Kapitel <a href='#!idx:/quarkus.html:10.6'>10.6</a>)<br />
&bull; <b>Data:</b> Quarkus Panache (Kapitel <a href='#!idx:/quarkus.html:10.6'>10.6</a>)<br />
&bull; <b>JSF:</b> Angular (Kapitel <a href='#!idx:/angular.html:11'>11</a>)<br />
&bull; <b>Scheduler:</b> Quarkus Scheduler (<span class='latex-texttt'>quarkus-scheduler</span>)<br />
&bull; <b>Servlet:</b> Quarkus HTTP / Vert.x Web<br />
Die Details zu jeder Migration finden Sie in den entsprechenden Kapiteln.</div>
Mit Hilfe von DeltaSpike-Core und den verschiedenen Modulen werden wir  <span class='latex-textit'>IdeaFork</span>  Schritt für Schritt verbessern.
Da einige Mechanismen primär in Kombination mit anderen sinnvoll veranschaulicht werden können, werden wir nicht jedes Modul isoliert betrachten,
sondern  <span class='latex-textit'>IdeaFork</span>  thematisch umstellen, indem verschiedene Teile von DeltaSpike kombiniert werden.
Bevor wir mit der Umstellung von  <span class='latex-textit'>IdeaFork</span>  beginnen, sehen wir uns die verfügbaren Module und deren Maven-Konfiguration im Überblick an.<br /> <h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.1' ><span class='entry-number'>5.1.0.1</span> DeltaSpike Bean-Validation</a></h4>
 In Java EE6 ist eine rudimentäre Integration zwischen Bean-Validation und CDI definiert.
Vor allem durch CDI verwaltete Constraint-Validatoren werden nicht unterstützt.
Diese Einschränkung wurde mit Java EE7 behoben.
In  <span class='latex-textit'>IdeaFork</span>  haben wir dies manuell in  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span>  umgesetzt.
Eine solche Integration wird auch durch das in Listing  <a href='#!idx:/deltaspike.html:fig:ds-bv_dependencies'> Maven Konfiguration für DeltaSpike Bean-Validation </a>  gezeigte Modul zur Verfügung gestellt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-bv_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-bean-validation-module-api&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-bean-validation-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Alle DeltaSpike Module bestehen aus einem API- und einem Impl-Teil.
Das BeanValidation-Modul hält sich an diese Konvention, um keine Verwirrung zu verursachen.
Allerdings ist derzeit kein API erforderlich und somit würde die Impl-Dependency ausreichen. </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.2' ><span class='entry-number'>5.1.0.2</span> DeltaSpike Data</a></h4>
 Das Data-Modul erlaubt eine effizientere Verwendung einfacher JPQL (Java Persistence Query Language) Queries.
Im Hintergrund wird die entsprechende JPQL-Query auf Basis der Methodensignatur bzw. optional auf Basis zusätzlicher Metadaten generiert.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/deltaspike.html:fig:ds-data_dependencies'> Maven Konfiguration für DeltaSpike Data </a>  zeigt die Einträge für die Maven Konfiguration.
Als transitive Dependencies bindet DeltaSpike-Data das JPA-, Partial-Bean- und Proxy-Modul ein.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-data_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-data-module-api&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-data-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.3' ><span class='entry-number'>5.1.0.3</span> DeltaSpike JPA</a></h4>
 Falls in einer CDI-basierten Anwendung EJBs nicht zur Wahl stehen oder reine CDI-Beans bevorzugt werden,
dann bietet dieses Modul ein alternatives Transaction-Handling.
Neben verschiedenen Strategien zur Behandlung von Transaktionen, die in Java SE und EE Applikationen verwendet werden können,
definiert dieses Modul beispielsweise einen CDI-Kontext, der die Lebensdauer entsprechender CDI-Beans auf die aktuelle Transaktion beschränkt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die in Listing  <a href='#!idx:/deltaspike.html:fig:ds-jpa_dependencies'> Maven Konfiguration für DeltaSpike JPA </a>  gezeigten Einträge müssen angegeben werden,
wenn dieses Modul nicht in Kombination mit DeltaSpike Data verwendet werden soll.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-jpa_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jpa-module-api&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jpa-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.4' ><span class='entry-number'>5.1.0.4</span> DeltaSpike JSF</a></h4>
 Die Build-Dependencies aus Listing  <a href='#!idx:/deltaspike.html:fig:ds-jsf_ee6_dependencies'> Maven Konfiguration für DeltaSpike JSF (EE6) </a>  sind erforderlich,
wenn eine JSF-Applikation noch effizienter entwickelt werden soll.
Einige Konzepte dieses Moduls ermöglichen eine höhere Typsicherheit, wodurch der Wartungsaufwand gesenkt werden kann.
Die Integration mit anderen Teilen von DeltaSpike erlaubt zusätzlich die einheitliche Verwendung verschiedener Mechanismen des Frameworks.
Hierfür ist neben dem Proxy-Modul vor allem das Security-Modul als transitive Dependency erforderlich.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-jsf_ee6_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jsf-module-api&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jsf-module-impl-ee6&lt;/artifactId&gt;
  &lt;version&gt;${deltaspike.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> Das normale JSF-Modul ist mit EE6 und EE7 kompatibel.
Einige EE6 Server loggen jedoch beim Applikationsstart einen Fehler.
Der Grund hierfür ist die Deaktivierung optionaler Klassen des JSF-Moduls, die für den EE7-Support nötig sind.
Die Applikation ist dennoch funktionsfähig.
Um eine mögliche Verunsicherung zu vermeiden, kann auf ein EE6-spezifisches Modul zurückgegriffen werden.
Daher ist es für EE6-basierte Applikationen ebenfalls möglich, die Build-Dependencies aus Listing  <a href='#!idx:/deltaspike.html:fig:ds-jsf_dependencies'> Maven Konfiguration für DeltaSpike JSF </a>  zu verwenden.
Durch diesen Ansatz ändert sich der Funktionsumfang nicht und der Wartungsaufwand der Module kann minimiert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-jsf_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jsf-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-jsf-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.5' ><span class='entry-number'>5.1.0.5</span> DeltaSpike Partial-Bean</a></h4>
 Partial-Beans sind Interfaces oder abstrakte Klassen, für die eine generische Behandlung zur Verfügung gestellt werden kann.
Die in Listing  <a href='#!idx:/deltaspike.html:fig:ds-partial-bean_dependencies'> Maven Konfiguration für DeltaSpike Partial-Bean </a>  aufgelisteten Build-Dependencies ermöglichen
eine solche Entkoppelung durch spezielle Bindings.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Dieses Konzept ist unter anderem die Basis für das Data-Modul.
Die Generierung von JPQL-Queries ist generisch im Data-Modul implementiert,
wodurch die Applikation hierfür keine Logik enthalten muss.
JPA-Repositories einer Applikation können dadurch auf Interfaces oder abstrakte Klassen reduziert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-partial-bean_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-partial-bean-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-partial-bean-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> Für die Funktionalität dieses Moduls sind Proxies erforderlich, wodurch das Proxy-Modul von DeltaSpike als transitive Dependency definiert ist.<br /> <h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.6' ><span class='entry-number'>5.1.0.6</span> DeltaSpike Proxy</a></h4>
 Das Proxy-Modul entkoppelt die Verwendung von Proxy-Funktionalitäten von einer konkreten Implementierung und wird,
wie in Listing  <a href='#!idx:/deltaspike.html:fig:ds-proxy_dependencies'> Maven Konfiguration für DeltaSpike Proxy </a>  zu sehen ist, etwas anders konfiguriert.
Derzeit ist das ASM5-Modul die einzige Implementierung.
In Zukunft kann es hier weitere Implementierungen geben, um beispielsweise neue JDK-Versionen zu unterstützen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-proxy_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-proxy-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-proxy-module-impl-asm5&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.7' ><span class='entry-number'>5.1.0.7</span> DeltaSpike Scheduler</a></h4>
 Dieses Modul erlaubt die Integration mit Schedulern, die eine Task-/Job-Konfiguration mit Cron-Ausdrücken unterstützen.
Da zusätzlich DeltaSpike CDI-Control benötigt wird, um je Task/Job beispielsweise den Request-Context zu starten und am Ende wieder zu stoppen,
ist dieses Modul nicht mit allen EE Servern kompatibel.
Moderne EE-Server, die aktuelle Versionen von OpenWebBeans oder Weld einsetzen, sind von dieser Einschränkung in der Regel nicht betroffen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Build-Dependencies für die Integration mit Quartz sind in Listing  <a href='#!idx:/deltaspike.html:fig:ds-scheduler_dependencies'> Maven Konfiguration für DeltaSpike Scheduler </a>  ersichtlich.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-scheduler_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-scheduler-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-scheduler-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
  &lt;artifactId&gt;quartz&lt;/artifactId&gt;
  &lt;version&gt;${quartz.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.8' ><span class='entry-number'>5.1.0.8</span> DeltaSpike Security</a></h4>
 Bei dem Security-Modul aus Listing  <a href='#!idx:/deltaspike.html:fig:ds-security_dependencies'> Maven Konfiguration für DeltaSpike Security </a>  handelt es sich nicht um ein vollständiges Security-Framework.
Stattdessen ermöglicht dieses Modul, bestehende Security-Frameworks mit CDI-Beans auf einfache Weise zu integrieren.
In Kombination mit dem JSF-Modul können zusätzlich JSF-Seiten mit den gleichen Konzepten abgesichert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-security_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-security-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-security-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.9' ><span class='entry-number'>5.1.0.9</span> DeltaSpike Servlet</a></h4>
 Ähnlich wie bei Bean-Validation wurde eine vollständige CDI-Integration für Servlets erst in Java EE7 umgesetzt.
Die in Listing  <a href='#!idx:/deltaspike.html:fig:ds-servlet_dependencies'> Maven Konfiguration für DeltaSpike Servlet </a>  enthaltenen Dependencies
stellen primär diese Funktionalitäten auch für Java-EE6-basierte Applikationen zur Verfügung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-servlet_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-servlet-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-servlet-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.10' ><span class='entry-number'>5.1.0.10</span> DeltaSpike Test-Control</a></h4>
 Diese CDI-Integration für JUnit verwenden wir für die Beispiele dieses Buchs seit dem ersten Commit im Git-Repository von  <span class='latex-textit'>IdeaFork</span> .
Neben DeltaSpike-Core ist auch DeltaSpike CDI-Control erforderlich,
damit die Test-Dependencies aus Listing  <a href='#!idx:/deltaspike.html:fig:ds-test-control_dependencies'> Maven Konfiguration für DeltaSpike Test-Control </a> für einfache Tests von CDI-basierten Applikationen genutzt werden können.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-test-control_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-test-control-module-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-test-control-module-impl&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><h4><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.1.0.11' ><span class='entry-number'>5.1.0.11</span> DeltaSpike CDI-Control</a></h4>
 DeltaSpike CDI-Control ist parallel zu DeltaSpike-Core zu sehen,
da dieser Teil von DeltaSpike nicht auf DeltaSpike-Core aufbaut, aber
die Basis für DeltaSpike-Scheduler und DeltaSpike-Test-Control ist.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ursprünglich für Java SE konzipiert, funktioniert CDI-Control auch mit modernen Java EE Servern.
Hierfür stellt DeltaSpike Implementierungen für OpenWebBeans, OpenEJB und Weld bereit.
Durch diesen Ansatz kann in einer CDI-basierten Applikation auf die direkte Verwendung proprietärer Container-APIs verzichtet werden.
CDI-Control verbirgt diese Aufrufe hinter einem einheitlichen API.
Der einzige Unterschied zur Laufzeit ist das jeweils eingebundene Implementierungsmodul.
Gleiches gilt auch für die manuelle Kontrolle der Standard-Scopes von CDI.
Implementierungen des Interfaces  <span class='latex-texttt'>ContextControl</span>  können die dahinter liegenden Kontexte
über proprietäre Container-APIs starten und stoppen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Abhängig vom Verwendungsziel kann das API-Modul aus Listing  <a href='#!idx:/deltaspike.html:fig:ds-cdi-control_dependencies'> Maven Konfiguration für DeltaSpike CDI-Control </a>  als
 <span class='latex-texttt'>compile</span>  oder  <span class='latex-texttt'>test</span> -Dependency eingebunden werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-cdi-control_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-cdictrl-api&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;...&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> Per Definition gibt es für das API-Modul von CDI-Control mehrere Implementierungsmodule,
die in den Listings
 <a href='#!idx:/deltaspike.html:fig:ds-cdi-control_owb_dependencies'> Maven Konfiguration für DeltaSpike OWB-Control </a> ,  <a href='#!idx:/deltaspike.html:fig:ds-cdi-control_weld_dependencies'> Maven Konfiguration für DeltaSpike Weld-Control </a>  und  <a href='#!idx:/deltaspike.html:fig:ds-cdi-control_openejb_dependencies'> Maven Konfiguration für DeltaSpike OpenEJB/TomEE-Control </a> ersichtlich sind.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-cdi-control_owb_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-cdictrl-owb&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;...&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-cdi-control_weld_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-cdictrl-weld&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;...&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-cdi-control_openejb_dependencies'></a>                     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
  &lt;artifactId&gt;deltaspike-cdictrl-openejb&lt;/artifactId&gt;
  &lt;version&gt;${ds.version}&lt;/version&gt;
  &lt;scope&gt;...&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div> 
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.2' ><span class='entry-number'>5.2</span> Flexible Spielregeln</a> </h2>
 In einem ersten Schritt beginnen wir mit der Verwendung von  <span class='latex-texttt'>@Exclude</span> ,
um die bisher verwendete CDI-Extension namens  <span class='latex-texttt'>EntityVetoExtension</span>  zu ersetzen.
Das Ziel von  <span class='latex-texttt'>EntityVetoExtension</span>  ist es, ein Veto auf alle JPA-Entitäten durchzuführen,
damit diese nicht als CDI-Beans zur Verfügung stehen.
In  <span class='latex-textit'>IdeaFork</span>  können wir das gleiche Ergebnis erzielen, indem wir die Klasse  <span class='latex-texttt'>BaseEntity</span>  mit  <span class='latex-texttt'>@Exclude</span>  annotieren.
Für  <span class='latex-textit'>IdeaFork</span>  funktioniert dies, da alle JPA-Entitäten von dieser Basisklasse ableiten.
Dennoch sind beide Lösungen nicht vollständig äquivalent,
da wir jetzt JPA-Entitäten als CDI-Beans zulassen, sobald diese nicht von  <span class='latex-texttt'>BaseEntity</span>  ableiten und
nicht explizit mit  <span class='latex-texttt'>@Exclude</span>  markiert sind.
In  <span class='latex-textit'>IdeaFork</span>  erhalten wir jedoch das gleiche Ergebnis und können dafür auf eine eigene Erweiterung verzichten.
Gleichzeitig erhöhen wir durch die explizite Angabe von  <span class='latex-texttt'>@Exclude</span>  die Lesbarkeit der Applikation.
Listing  <a href='#!idx:/deltaspike.html:fig:exclude_jpa-entities'> Klassen mit @Exclude für CDI exkludieren </a>  zeigt die eben beschriebene einfache Verwendung von  <span class='latex-texttt'>@Exclude</span> .
Abgesehen von dieser Ergänzung wird in  <span class='latex-textit'>IdeaFork</span>  die Klasse  <span class='latex-texttt'>EntityVetoExtension</span>  gelöscht und
der dazugehörige Konfigurationseintrag entfernt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:exclude_jpa-entities'></a>                     <pre><code>@Exclude
@MappedSuperclass
public abstract class BaseEntity implements Serializable {
  //...
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Für CDI selbst ist DeltaSpike eine Art Ideenpool.
So wurde beispielsweise ein Teil von  <span class='latex-texttt'>@Exclude</span>  in CDI 1.1 übernommen und steht seit dieser Version unter dem Namen  <span class='latex-texttt'>@Vetoed</span>  zur Verfügung.
 <span class='latex-texttt'>@Exclude</span>  ist jedoch weiterhin sinnvoll,
da diese Annotation die Verwendung zusätzlicher Bedingungen für die Deaktivierung von CDI-Beans unterstützt. </div> Zur Deaktivierung von CDI-Beans können auch Bedingungen verwendet werden.
Ein Beispiel hierfür sind die Project-Stages, die ebenfalls von DeltaSpike zur Verfügung gestellt werden.
In Java EE steht das Konzept der Project-Stages nur für JSF zur Verfügung.
DeltaSpike greift die Grundidee auf und stellt diese mit einem typsicheren und
gleichzeitig erweiterbaren Mechanismus für alle Teile einer Applikation zur Verfügung.
Jeder Project-Stage bildet einen anderen Schritt bei der Applikationsentwicklung ab.
Sollten die vordefinierten Stages
 <span class='latex-texttt'>UnitTest</span> ,  <span class='latex-texttt'>Development</span> ,  <span class='latex-texttt'>SystemTest</span> ,  <span class='latex-texttt'>IntegrationTest</span> ,  <span class='latex-texttt'>Staging</span>  und  <span class='latex-texttt'>Production</span> für eine Applikation nicht genügen, dann können eigene Typen registriert werden.
Bei der Verwendung von Stages gibt es keinen Unterschied zwischen den vordefinierten und selbst definierten Stages.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die Kombination von Project-Stages mit der Annotation  <span class='latex-texttt'>@Exclude</span>  ermöglicht die Deaktivierung von CDI-Beans in bestimmten Stages.
Listing  <a href='#!idx:/deltaspike.html:fig:conditional_exclude'> Bedingte Exkludierung von CDI-Beans mit @Exclude </a>  zeigt die einfachste Variante einer solchen Kombination.
In diesem Fall deaktivieren wir  <span class='latex-texttt'>IdeaSavedObserver</span>  für alle Stages außer  <span class='latex-texttt'>Development</span>  und  <span class='latex-texttt'>UnitTest</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:conditional_exclude'></a>                     <pre><code>@ApplicationScoped
@Exclude(exceptIfProjectStage =
  {ProjectStage.Development.class, ProjectStage.UnitTest.class})
public class IdeaSavedObserver {
  //...
}
</code></pre>
                </div> Wird dieses Konzept zusätzlich beispielsweise mit CDI-Beans kombiniert, die mit  <span class='latex-texttt'>@Alternative</span>  annotiert sind,
so können alternative Implementierungen für verschiedene Stages aktiviert werden, ohne spezielle Versionen der Applikation zu erstellen.
In  <span class='latex-textit'>IdeaFork</span>  werden wir etwas später ein Mail-Service hinzufügen,
für das wir eine gemockte alternative Implementierung umsetzen.
Zusätzlich könnten wir diese alternative Implementierung mit  <span class='latex-texttt'>@Exclude</span>  annotieren,
um diese gemockte Implementierung beispielsweise nur während der Entwicklung und für Unit-Tests zu verwenden.
Wird das alternative CDI-Bean später bei Project-Stage  <span class='latex-texttt'>Production</span>  durch eine solche Bedingung deaktiviert,
dann wird automatisch das ursprüngliche CDI-Bean aktiv.<br /> <div class="tip"><b>Tipp: </b> Das CDI-TestControl-Modul aktiviert standardmäßig den Project-Stage  <span class='latex-texttt'>UnitTest</span> .
Dieses Default-Verhalten kann mit der optionalen Annotation  <span class='latex-texttt'>@TestControl</span>  explizit je Test-Methode oder Test-Klasse übersteuert werden. </div> Die Konfiguration des aktuellen Project-Stages kann über den Konfigurationsmechanismus von DeltaSpike durchgeführt werden.
Hierfür muss der entsprechende Name eines Stages für den Key  <span class='latex-texttt'>org.apache.deltaspike.ProjectStage</span>  aktiviert werden.
Zusätzlich ist eine rudimentäre Integration mit JSF-Project-Stages verfügbar,
sofern der JSF-Project-Stage via JNDI und einem der Standardkeys
( <span class='latex-texttt'>javax.faces.PROJECT_STAGE</span>  oder  <span class='latex-texttt'>faces.PROJECT_STAGE</span> ) konfiguriert ist.<br /> <div class="tip"><b>Tipp: </b> Wird der JSF-Project-Stage mit einem Eintrag in der Datei  <span class='latex-texttt'>web.xml</span>  konfiguriert,
dann wird dieser von DeltaSpike bewusst ignoriert, weil diese Konfigurationsvariante oft zu Problemen in der Praxis geführt hat.
Hin und wieder kommt es vor, dass ein solcher Eintrag vergessen oder versehentlich geändert wurde und
Applikationen dadurch nicht mit Project-Stage Production auf einem produktiven System deployed wurden.
Da der Konfigurationsmechanismus von DeltaSpike erweiterbar ist,
kann bei Bedarf diese bewusst gewählte Einschränkung mit Hilfe einer eigenen Implementierung von
 <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span>  umgangen werden. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der Konfigurationsmechanismus von DeltaSpike ist sehr vielfältig.
In Kombination mit dem Qualifier  <span class='latex-texttt'>@ConfigProperty</span>  können konfigurierte Werte in CDI-Beans injiziert werden.
Ein einfaches Beispiel wird in Listing  <a href='#!idx:/deltaspike.html:fig:simple_config_injection'> Injizierung von Konfigurationen mit @ConfigProperty </a>  illustriert.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ursprünglich haben wir in  <span class='latex-texttt'>CurrentObjectConverterProducer</span>  unsere eigene typsichere Konfiguration verwendet.
In einfachen Fällen ist dies durchaus eine elegante Möglichkeit.
Allerdings mussten wir hierfür den Wert manuell laden.
Um dies zu vermeiden, können wir stattdessen  <span class='latex-texttt'>@ConfigProperty</span>  verwenden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:simple_config_injection'></a>                     <pre><code>@ApplicationScoped
public class CurrentObjectConverterProducer {
  @Produces
  @Default
  @Dependent
  protected ObjectConverter defaultConverter(
      @ExternalFormat(XML) ObjectConverter objectConverterXml,
      @ExternalFormat(JSON) ObjectConverter objectConverterJson,
      @ConfigProperty(name = "defaultExternalFormat")
        String defaultExternalFormat) {
    switch (ExternalFormat.TargetFormat.valueOf(defaultExternalFormat)) {
      case JSON:
        return objectConverterJson;
      default:
        return objectConverterXml;
    }
  }
}
</code></pre>
                </div> Standardmäßig wertet DeltaSpike verschiedene Konfigurationsquellen aus.
System-Properties werden vor Umgebungsvariablen und vor einem JNDI-Lookup abgefragt.
Als letzte Quelle lädt DeltaSpike alle Konfigurationen mit dem Namen  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> .
Werte aus einer Config-Source mit höherer Priorität übersteuern Werte aus nachgelagerten Quellen.<br /> <div class="tip"><b>Tipp: </b> Die vordefinierte Reihenfolge kann angepasst werden, da die Priorität einer Config-Source verändert werden kann.
Soll beispielsweise JNDI die höchste Priorität haben, so muss der Key deltaspike_ordinal mit Hilfe der Konfigurationsquelle selbst,
in diesem Fall als JNDI-Eintrag, mit dem höchsten Ordinal-Wert der aktivierten Konfigurationsquellen gesetzt werden.
Konkret müsste beispielsweise deltaspike_ordinal=500 via JNDI-Konfiguration festgelegt werden. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Normalerweise wollen wir für die Konfiguration einer Applikation eine eigene Konfigurationsdatei verwenden.
So sind auch in  <span class='latex-textit'>IdeaFork</span>  konfigurierte Werte in einer eigenen Datei namens  <span class='latex-texttt'>app-config.properties</span>  abgelegt.
Genau genommen kennt DeltaSpike nur das abstrakte Konzept von Konfigurationsquellen und
liefert Implementierungen für Quellen wie beispielsweise  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  mit.
Die Erweiterbarkeit des Konfigurationsmechanismus ermöglicht die Integration anderer Konfigurationsquellen
durch Implementierungen des Interfaces  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Für eigene Property-Dateien stellt DeltaSpike eine noch einfachere Integration zur Verfügung.
Listing  <a href='#!idx:/deltaspike.html:fig:integrate_custom_config'> Eigene Properties-Dateien einbinden </a>  zeigt die Verwendung der Basisklasse  <span class='latex-texttt'>PropertyFileConfig</span> .
Neben dem Namen selbst muss explizit angegeben werden, ob es sich um eine optionale Konfigurationsdatei handelt.
DeltaSpike sucht während des Applikationsstarts Implementierungen von  <span class='latex-texttt'>org.apache.deltaspike.core.api.config.PropertyFileConfig</span>  und
registriert diese automatisch in der Bootstrapping-Phase  <span class='latex-texttt'>AfterDeploymentValidation</span> .
Daher stehen so konfigurierte Werte erst am Ende des Containerstarts zur Verfügung.<br /> <div class="tip"><b>Tipp: </b> Soll ein konfigurierter Wert bereits während der Bootstrapping-Phase verfügbar sein,
dann ist eine Implementierung des Interfaces  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span>  erforderlich.
Die Aktivierung einer Implementierung dieses Interfaces folgt den Standard-Service-Loader-Regeln und ist somit unabhängig von CDI. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:integrate_custom_config'></a>                     <pre><code>public class IdeaForkConfigFile implements PropertyFileConfig {
  @Override
  public String getPropertyFileName() {
    return "app-config.properties";
  }

  @Override
  public boolean isOptional() {
    return false;
  }
}
</code></pre>
                </div><span class='latex-texttt'>IdeaForkConfigFile</span>  ermöglicht es uns, Werte aus der Konfigurationsdatei  <span class='latex-texttt'>app-config.properties</span> ebenfalls mit Hilfe der Qualifier-Annotation  <span class='latex-texttt'>@ConfigProperty</span>  zu injizieren.
Werte, die auf diese Weise injiziert werden, haben keinen eigenen Lifecycle.
In vielen Fällen handelt es sich um Strings und primitive Datentypen,
wodurch DeltaSpike selbst keinen automatischen Reload-Mechanismus für solche Werte bereitstellen kann.
Hier können wir allerdings auf Bordmittel von CDI zurückgreifen.
In Listing  <a href='#!idx:/deltaspike.html:fig:cached_config'> Injizierung und Caching von konfigurierten Werten </a>  wird ein Request-scoped Bean verwendet, um den konfigurierten Wert einmal je Request einzulesen.
Dies ist natürlich ein gewisser Overhead, den wir im nächsten Abschnitt durch einen eigenen Scope minimieren werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:cached_config'></a>                     <pre><code>@RequestScoped
public class MonitoringConfig {
  @Inject
  @ConfigProperty(name = "methodInvocationThreshold")
  private Integer methodInvocationThreshold;

  public Integer getMethodInvocationThreshold() {
    return methodInvocationThreshold;
  }
}
</code></pre>
                </div> Das CDI-Bean aus Listing  <a href='#!idx:/deltaspike.html:fig:cached_config'> Injizierung und Caching von konfigurierten Werten </a>  kann anschließend an beliebigen Stellen injiziert und verwendet werden,
um auf die aktuellen Werte zuzugreifen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Soll hingegen ein konfigurierter Wert direkt an mehreren Stellen in der Applikation injiziert werden,
so ist es möglich, einen eigenen Qualifier zu erstellen,
um die Typsicherheit zu erhöhen und den String für den Konfigurationskey an einer zentralen Stelle zu kapseln.
Listing  <a href='#!idx:/deltaspike.html:fig:config_qualifier'> Config-Qualifier für typsichere Injizierung </a>  zeigt einen solchen Qualifier.
Abgesehen von den Annotationen für CDI-Qualifier wird ein solcher Qualifier mit  <span class='latex-texttt'>@ConfigProperty</span>  annotiert.
Dadurch ist in diesem Beispiel  <span class='latex-texttt'>@ConfigProperty(name = "name")</span>  zentral in der Annotation  <span class='latex-texttt'>@ApplicationName</span>  gekapselt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:config_qualifier'></a>                     <pre><code>@ConfigProperty(name = "name")
@Target({METHOD, FIELD, PARAMETER})
@Retention(RUNTIME)
@Qualifier
public @interface ApplicationName {
}
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_config_injection'> Typsichere Injizierung von Konfigurationswerten </a>  zeigt den dazu passenden Injection-Point,
bei dem statt  <span class='latex-texttt'>@ConfigProperty</span>  der Qualifier aus Listing  <a href='#!idx:/deltaspike.html:fig:config_qualifier'> Config-Qualifier für typsichere Injizierung </a>  verwendet wird.
Da wir beim Injection-Point einen eigenen Qualifier verwenden,
müssen wir auch einen entsprechenden Producer zur Verfügung stellen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_config_injection'></a>                     <pre><code>@Inject
@ApplicationName
private String applicationName;
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:producer_for_typesafe_config'> Producer für typsichere Konfigurationswerte </a>  veranschaulicht die erforderliche Producer-Implementierung,
die durch die Verwendung von  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer</span>  sehr einfach gehalten werden kann.
Im konkreten Beispiel muss nur an  <span class='latex-texttt'>BaseConfigPropertyProducer#getStringPropertyValue</span>  delegiert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:producer_for_typesafe_config'></a>                     <pre><code>@ApplicationScoped
public class ConfigProducer extends BaseConfigPropertyProducer {
  @Produces
  @ApplicationName
  public String applicationName(InjectionPoint injectionPoint) {
    return getStringPropertyValue(injectionPoint);
  }

  //...
}
</code></pre>
                </div> Natürlich ist eine solche einfache Delegation nicht in jedem Fall möglich.
Listing  <a href='#!idx:/deltaspike.html:fig:producer_for_typesafe_config_with_defaults'> Default-Werte für typsichere Konfiguration </a>  zeigt beispielsweise eine weitere Producer-Methode in der gleichen Klasse,
die das geladene Ergebnis anschließend aufbereitet.
Der hierfür erforderliche Qualifier ist in Listing  <a href='#!idx:/deltaspike.html:fig:config_qualifier_with_default_value'> Config-Qualifier für typsichere Injizierung mit Default-Wert </a>  angegeben.
Das Annotation-Attribut  <span class='latex-texttt'>defaultValue</span>  wird in der Methode  <span class='latex-texttt'>ConfigProducer#maxNumberOfHighestRatedCategories</span>  manuell ausgewertet
und muss daher mit  <span class='latex-texttt'>@Nonbinding</span>  markiert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:config_qualifier_with_default_value'></a>                     <pre><code>@ConfigProperty(name = "maxNumberOfHighestRatedCategories")
@Target({METHOD, PARAMETER, FIELD})
@Retention(RUNTIME)
@Qualifier
public @interface MaxNumberOfHighestRatedCategories {
  @Nonbinding
  int defaultValue() default 15;
}
</code></pre>
                </div> Außerdem wird in Listing  <a href='#!idx:/deltaspike.html:fig:producer_for_typesafe_config_with_defaults'> Default-Werte für typsichere Konfiguration </a>  gezeigt,
dass eigene Qualifier auch eine zusätzliche Möglichkeit bieten, indem eigene Annotation-Attribute verwendet werden können.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:producer_for_typesafe_config_with_defaults'></a>                     <pre><code>@ApplicationScoped
public class ConfigProducer extends BaseConfigPropertyProducer {
  //...

  @Produces
  @MaxNumberOfHighestRatedCategories
  public Integer maxNumberOfHighestRatedCategories(
      InjectionPoint injectionPoint) {

    String configuredValue = getStringPropertyValue(injectionPoint);

    if (configuredValue == null || configuredValue.length() == 0) {
      return getAnnotation(
        injectionPoint, MaxNumberOfHighestRatedCategories.class)
        .defaultValue();
    }

    return Integer.parseInt(configuredValue);
  }
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Da wir Informationen vom Injection-Point auswerten müssen,
können wir in den vorherigen Beispielen laut den CDI-Regeln nur dependent-scoped Beans erzeugen. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bei Injection-Points mit dem Qualifier  <span class='latex-texttt'>@MaxNumberOfHighestRatedCategories</span>  kann notfalls sogar der Default-Wert verändert werden.
Normalerweise ist dies jedoch nicht erforderlich,
wodurch die in Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_config_injection_with_default_value'> Typsichere Injizierung von Konfigurationswerten mit Default-Werten </a> gezeigte Verwendung des Qualifiers bei einem Injection-Point in der Regel ausreichend ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_config_injection_with_default_value'></a>                     <pre><code>@Repository
public class IdeaJpaRepository
  extends GenericJpaRepository&lt;Idea&gt;
  implements IdeaRepository {

    @Inject
    @MaxNumberOfHighestRatedCategories
    private Integer maxNumberOfHighestRatedCategories;

    //...
}
</code></pre>
                </div> Im Hintergrund delegiert  <span class='latex-texttt'>BaseConfigPropertyProducer</span>  an die Klasse  <span class='latex-texttt'>ConfigResolver</span>  von DeltaSpike,
die natürlich auch manuell verwendet werden kann.
Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_config_without_config-property'> Typsichere Konfiguration ohne @ConfigProperty </a>  zeigt eine herkömmliche Producer-Methode ohne  <span class='latex-texttt'>@ConfigProperty</span>  und
ohne Analyse des Injection-Points.
Stattdessen wird  <span class='latex-texttt'>ConfigResolver#getPropertyValue</span>  in Kombination mit einem fixen Key verwendet und
das geladene Ergebnis wird durch die Klasse  <span class='latex-texttt'>ApplicationVersion</span>  als strukturiertes Objekt zur Verfügung gestellt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_config_without_config-property'></a>                     <pre><code>@ApplicationScoped
public class ConfigProducer extends BaseConfigPropertyProducer {
  //...

  @Produces
  @Dependent
  public ApplicationVersion applicationVersion() {
    String configuredValue = ConfigResolver.getPropertyValue("version");
    return new ApplicationVersion(configuredValue);
  }
}

public class ApplicationVersion {
  private final boolean released;
  private final String versionString;

  public ApplicationVersion(String versionString) {
    this.released = !versionString.contains("SNAPSHOT");
    this.versionString = versionString;
  }

  public boolean isReleased() {
    return released;
  }

  @Override
  public String toString() {
    return versionString;
  }
}
</code></pre>
                </div><span class='latex-texttt'>ApplicationVersion</span>  aus Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_config_without_config-property'> Typsichere Konfiguration ohne @ConfigProperty </a>  kann somit wie gewohnt in andere Beans injiziert werden.
<div class="tip"><b>Tipp: </b>Der DeltaSpike ConfigResolver war ein Vorreiter für die standardisierte Konfiguration in Java. MicroProfile Config (Kapitel <a href='#!idx:/quarkus.html:10.4'>10.4</a>) wurde direkt von diesem Mechanismus inspiriert und verwendet dasselbe Ordinal-Konzept für die Priorisierung von Konfigurationsquellen. Für moderne Quarkus-Projekte ist MicroProfile Config die bevorzugte Lösung.</div>
Listing  <a href='#!idx:/deltaspike.html:fig:using_project-stage_manually'> Project-Stage abhängige Logik </a>  verarbeitet die Information aus  <span class='latex-texttt'>ApplicationVersion</span>, falls ein bestimmter Project-Stage aktiv ist.
Die im vorherigen Abschnitt vorgestellten Project-Stages können nämlich auch manuell ausgewertet werden.
Der aktive Project-Stage kann injiziert und mit  <span class='latex-texttt'>==</span>  oder  <span class='latex-texttt'>#equals</span>  überprüft werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:using_project-stage_manually'></a>                     <pre><code>@Named
public class ApplicationInfo {
  private String versionText = "Public";

  @Inject
  public ApplicationInfo(ApplicationVersion appVersion,
                         ProjectStage projectStage) {

    if (projectStage == Staging) {
      if (appVersion.isReleased()) {
        versionText = "Release ";
      }
      versionText += "v" + appVersion.toString();
    }
  }

  public String getVersionText() {
    return versionText;
  }
}
</code></pre>
                </div> Bisher haben wir die Versionsnummer von  <span class='latex-textit'>IdeaFork</span>  in unserer Konfigurationsdatei fix abgelegt und
nur zur Veranschaulichung typsicherer Konfigurationsklassen verwendet.
Um Project-Stage basierte Logik in Kombination mit Methoden wie beispielsweise  <span class='latex-texttt'>#isReleased</span>  sinnvoller zu verwenden,
ist es allerdings naheliegend, die Versionsnummer aus der Build-Konfiguration zu verwenden.
Wie bei jeder Konfigurationsdatei in einem Projekt mit Maven-Build kann hierfür der Platzhalter  <span class='latex-texttt'>${project.version}</span>  verwendet werden.
Dadurch wird es in Listing  <a href='#!idx:/deltaspike.html:fig:using_project-stage_manually'> Project-Stage abhängige Logik </a>  möglich, bei Project-Stage  <span class='latex-texttt'>Staging</span>  die exakte Build-Version anzuzeigen,
ohne diese manuell zu warten.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im XHTML-Template von  <span class='latex-textit'>IdeaFork</span>  kann daher eine einfache EL-Expression,
in unserem Fall  <span class='latex-texttt'>#{applicationInfo.versionText}</span> , verwendet werden,
um abhängig vom aktuellen Project-Stage verschiedene Informationen anzuzeigen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Wie bereits im vorherigen Abschnitt erwähnt, kann der aktuelle Project-Stage mit dem Key
 <span class='latex-texttt'>org.apache.deltaspike.ProjectStage</span>  konfiguriert werden.
Da VM-Parameter eine der standardmäßig unterstützten Konfigurationsquellen sind,
können wir durch  <span class='latex-texttt'>-Dorg.apache.deltaspike.ProjectStage=Staging</span>  die Version von  <span class='latex-textit'>IdeaFork</span>  anzeigen lassen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der Project-Stage Mechanismus von DeltaSpike ist nicht nur typsicher, sondern auch erweiterbar.
Um einen zusätzlichen Stage zu definieren, muss das Interface  <span class='latex-texttt'>org.apache.deltaspike.core.api.projectstage.ProjectStageHolder</span> implementiert werden.
Anschließend müssen wir diese Klasse in der Datei
 <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.core.api.projectstage.ProjectStageHolder</span> nach den herkömmlichen Service-Loader Regeln konfigurieren.
Wie in Listing  <a href='#!idx:/deltaspike.html:fig:custom_project-stage_value'> Eigener Project-Stage Wert </a>  ersichtlich ist,
muss die Implementierung eine initialisierte (public static final) Variable zur Verfügung stellen.
Der Typ der Variable ist dabei der hinzugefügte Stage, der von  <span class='latex-texttt'>org.apache.deltaspike.core.api.projectstage.ProjectStage</span>  ableiten muss.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_project-stage_value'></a>                     <pre><code>public class CustomProjectStage implements ProjectStageHolder {
  public static final class Debugging extends ProjectStage {
    private static final long serialVersionUID = -2626602281649294170L;
  }

  public static final Debugging Debugging = new Debugging();
}
</code></pre>
                </div> Unseren neuen Debugging-Stage können wir beispielsweise in einem DeltaSpike Exception-Handler
aus Listing  <a href='#!idx:/deltaspike.html:fig:custom_project-stage_in_exception_handler'> Eigener Project-Stage in einem Exception-Handler </a>  verwenden,
um IO-Exceptions nur ins Log zu schreiben, wenn der Debugging-Stage aktiviert ist.
Der Exception-Handler-Mechanismus von DeltaSpike erlaubt es, explizit über das Event-API von CDI ein  <span class='latex-texttt'>ExceptionToCatchEvent</span>  zu feuern.
Listing  <a href='#!idx:/deltaspike.html:fig:custom_project-stage_in_exception_handler'> Eigener Project-Stage in einem Exception-Handler </a>  zeigt einen entsprechenden Observer,
der jedoch nicht auf dem Observer-API von CDI aufgebaut ist,
da unter anderem durch ein eigenes Konzept von DeltaSpike die Abarbeitungsreihenfolge der Handler-Methoden optional festgelegt werden kann.
Dieser und andere Aspekte erfordern eine etwas andere Umsetzung.
Als erster Schritt muss die Handler-Klasse mit  <span class='latex-texttt'>@ExceptionHandler</span>  markiert werden,
damit ein Exception-Handler überhaupt als solcher registriert wird.
Bei der Definition einer Handler-Methode selbst können wir den Regeln zu CDI-Observer-Methoden folgen.
Statt  <span class='latex-texttt'>@Observes</span>  müssen wir jedoch  <span class='latex-texttt'>@Handles</span>  verwenden.
Der Event-Typ ist mit ExceptionEvent ebenfalls anders,
da bei einem CDI-Observer der ursprüngliche Event-Typ ( <span class='latex-texttt'>ExceptionToCatchEvent</span> ) zu erwarten wäre.
 <span class='latex-texttt'>ExceptionEvent</span>  muss außerdem auf den zu überwachenden Exception-Typ typisiert werden und
stellt zusätzliche Methoden zur Steuerung des Exception-Flows zur Verfügung.
Da  <span class='latex-texttt'>LoggingExceptionHandler</span>  Exceptions nur loggen soll, wird am Ende  <span class='latex-texttt'>ExceptionEvent#throwOriginal</span>  aufgerufen.
Sollte danach keine Handler-Methode  <span class='latex-texttt'>#handled</span>  aufrufen,
so wird die ursprüngliche Exception nach dem Aufruf aller zuständigen Exception-Handler weiter geworfen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_project-stage_in_exception_handler'></a>                     <pre><code>@ApplicationScoped
@ExceptionHandler
public class LoggingExceptionHandler {
  private static final Logger LOG =
    Logger.getLogger(LoggingExceptionHandler.class.getName());

  public void onUnhandledException(
      @Handles ExceptionEvent&lt;IOException&gt; exceptionEvent,
      ProjectStage projectStage) {

    if (projectStage == CustomProjectStage.Debugging) {
      LOG.log(Level.FINE,
        "exception detected", exceptionEvent.getException());
    }

    exceptionEvent.throwOriginal();
  }
}
</code></pre>
                </div> DeltaSpike ruft Exception-Handler nicht automatisch beim Auftreten einer Exception auf.
Stattdessen muss das zuvor erwähnte  <span class='latex-texttt'>ExceptionToCatchEvent</span>  über das Event-API von CDI gefeuert werden.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ExceptionToCatchEvent'> Verwendung von ExceptionToCatchEvent </a>  zeigt die Verwendung in  <span class='latex-texttt'>CustomJsonWriter</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ExceptionToCatchEvent'></a>                     <pre><code>@Provider
@Produces(MediaType.APPLICATION_JSON)
public class CustomJsonWriter implements MessageBodyWriter&lt;Object&gt; {
  //...

  @Inject
  private BeanManager beanManager;

  @Override
  public void writeTo(Object o, Class&lt;?&gt; rawType,
                      Type genericType,
                      Annotation[] annotations,
                      MediaType mediaType,
                      MultivaluedMap&lt;String, Object&gt; httpHeaders,
                      OutputStream entityStream) throws IOException {
    //...

    try {
      //...
    } catch (IOException e) {
      ExceptionToCatchEvent exceptionToCatchEvent =
        new ExceptionToCatchEvent(e);

      beanManager.fireEvent(exceptionToCatchEvent);
    }
  }

  //...
}
</code></pre>
                </div> Da mit Methoden wie beispielsweise  <span class='latex-texttt'>ExceptionEvent#abort</span>  die Verarbeitung abgebrochen werden kann, ohne eine Exception zu werfen,
stellt  <span class='latex-texttt'>ExceptionToCatchEvent</span>  die Methode  <span class='latex-texttt'>#isHandled</span>  zur Verfügung.
Somit kann nach dem Feuern von  <span class='latex-texttt'>ExceptionToCatchEvent</span>  überprüft werden,
ob die Verarbeitung abgebrochen wurde oder ob die Exception von einem Handler tatsächlich behandelt wurde.
Außerdem kann  <span class='latex-texttt'>ExceptionToCatchEvent</span>  vor dem Feuern als optional markiert werden,
um die Exception-Handler zu notifizieren, aber das automatische Werfen der Exception zu unterdrücken,
falls diese nach dem Aufruf des letzten Handlers noch nicht behandelt wurde.<br /> <div class="tip"><b>Tipp: </b> DeltaSpike bietet weitere umfangreiche Möglichkeiten für den Umgang mit Exceptions.
Diese sollten mit Bedacht eingesetzt werden, da die Behandlung von Exceptions sonst unübersichtlich werden kann. </div> 
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.3' ><span class='entry-number'>5.3</span> Alles unter Kontrolle</a> </h2>
 Im vorherigen Abschnitt haben wir ein Request-scoped Bean zur Zwischenspeicherung und Aktualisierung von konfigurierten Werten verwendet.
In der Praxis kann dies einen unnötig hohen Overhead verursachen.
Konfigurierte Werte sind normalerweise eine bestimmte Zeit valide und müssen nicht ständig neu geladen werden.
Allerdings kann es erforderlich werden, zu bestimmten Zeitpunkten oder bei bestimmten Ereignissen solche Werte neu zu laden.
Wir könnten einen der verfügbaren Scopes verwenden, der die gewünschten Eigenschaften hat, um Konfigurationswerte zu speichern.
Sollte es einen solchen Scope noch nicht geben, dann können wir einen eigenen definieren und implementieren.
Auch hier hilft DeltaSpike mit der abstrakten Klasse  <span class='latex-texttt'>org.apache.deltaspike.core.util.context.AbstractContext</span> .
Für  <span class='latex-textit'>IdeaFork</span>  können wir beispielsweise einen eigenen Config-Scope umsetzen, der manuell zurückgesetzt werden kann.
Möchten wir eine entsprechende Annotation mit dem Namen  <span class='latex-texttt'>@ConfigScoped</span>  verwenden,
so müssen wir diese auf Basis der CDI-Regeln für Normal-Scopes definieren.
Das Ergebnis ist in Listing  <a href='#!idx:/deltaspike.html:fig:custom_scope-annotation'> Eigene Scope-Annotation </a>  ersichtlich.
Da wir keinen passivierbaren Context benötigen, genügt es, die Annotation  <span class='latex-texttt'>@NormalScope</span>  ohne Anpassungen zu verwenden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_scope-annotation'></a>                     <pre><code>@NormalScope
@Target({TYPE, METHOD, FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface ConfigScoped {}
</code></pre>
                </div> Eine Annotation alleine ist natürlich nicht ausreichend und daher implementieren wir im nächsten Schritt den dazugehörigen Kontext.
Listing  <a href='#!idx:/deltaspike.html:fig:custom_context'> Eigene Kontext-Implementierung </a>  veranschaulicht,
dass durch die Verwendung von  <span class='latex-texttt'>AbstractContext</span>  eine eigene Implementierung sehr einfach umgesetzt werden kann.
Die Methode  <span class='latex-texttt'>#getScope</span>  gibt die Klasse unserer eben angelegten Annotation zurück,
wodurch die Kontext-Implementierung mit dieser verknüpft wird.
 <span class='latex-texttt'>ContextualStorage</span>  ist eine vorgefertigte Datenstruktur zur Speicherung der Beans,
die im Konstruktor der Kontext-Implementierung auf einfache Art und Weise initialisiert werden kann.
Wir müssen uns primär durch den zweiten Parameter entscheiden, ob die interne Datenstruktur parallele Zugriffe synchronisieren soll,
um parallele Zugriffe korrekt zu unterstützen.
In unserem Fall wollen wir dies und daher verwenden wir den Wert  <span class='latex-texttt'>true</span> .
Durch die vordefinierte Getter-Methode namens  <span class='latex-texttt'>#getContextualStorage</span>  kann die  <span class='latex-texttt'>AbstractContext</span> -Implementierung
schließlich auf die aktuell gültige  <span class='latex-texttt'>ContextualStorage</span> -Instanz zugreifen.
Die Methode  <span class='latex-texttt'>#isActive</span>  gibt in unserem Fall immer  <span class='latex-texttt'>true</span>  zurück, da der Kontext immer aktiv sein soll.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Weitere Methoden sind nicht durch  <span class='latex-texttt'>javax.enterprise.context.spi.Context</span>  oder
 <span class='latex-texttt'>org.apache.deltaspike.core.util.context.AbstractContext</span>  vorgeschrieben und können daher selbst gewählt werden.
Unser Config-Context soll eine Methode für einen vollständigen Reset zur Verfügung stellen,
die zu beliebigen Zeitpunkten manuell aufgerufen werden kann.
In Listing  <a href='#!idx:/deltaspike.html:fig:custom_context'> Eigene Kontext-Implementierung </a>  delegiert hierfür die Methode  <span class='latex-texttt'>#reset</span>  an die statische Helper-Methode
 <span class='latex-texttt'>AbstractContext#destroyAllActive</span> , der das aktuell gültige  <span class='latex-texttt'>ContextualStorage</span>  übergeben werden muss,
um dessen Inhalt zurückzusetzen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_context'></a>                     <pre><code>public class ConfigContext extends AbstractContext {
  private final ContextualStorage contextualStorage;

  public ConfigContext(BeanManager beanManager) {
    super(beanManager);
    contextualStorage =
      new ContextualStorage(beanManager, true, isPassivatingScope());
  }

  @Override
  protected ContextualStorage getContextualStorage(
      Contextual&lt;?&gt; contextual, boolean createIfNotExist) {

    return this.contextualStorage;
  }

  @Override
  public Class&lt;? extends Annotation&gt; getScope() {
    return ConfigScoped.class;
  }

  @Override
  public boolean isActive() {
    return true;
  }

  public void reset() {
    AbstractContext.destroyAllActive(this.contextualStorage);
  }
}
</code></pre>
                </div> Wie jeder CDI-Context muss die Implementierung aus Listing  <a href='#!idx:/deltaspike.html:fig:custom_context'> Eigene Kontext-Implementierung </a>  mit Hilfe einer CDI-Extension registriert werden.
Listing  <a href='#!idx:/deltaspike.html:fig:register_custom_context'> Eigene Kontext-Implementierung registrieren </a>  illustriert diesen Mechanismus.
In einer Observer-Methode für das  <span class='latex-texttt'>AfterBeanDiscovery</span> -Event wird zusätzlich der  <span class='latex-texttt'>BeanManager</span>  injiziert,
der anschließend dem Konstruktor von  <span class='latex-texttt'>ConfigContext</span>  übergeben wird.
Die so erzeugte Context-Instanz wird abschließend über die Methode  <span class='latex-texttt'>AfterBeanDiscovery#addContext</span>  registriert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:register_custom_context'></a>                     <pre><code>public class ConfigContextExtension implements Extension {
  public void registerDeltaSpikeContexts(
      @Observes AfterBeanDiscovery afterBeanDiscovery,
      BeanManager beanManager) {

    ConfigContext configContext = new ConfigContext(beanManager);
    afterBeanDiscovery.addContext(configContext);
  }

  public void shutdownConfigContext(
      @Observes BeforeShutdown beforeShutdown,
      BeanManager beanManager) {

    ((ConfigContext)beanManager.getContext(ConfigScoped.class)).reset();
  }
}
</code></pre>
                </div> Wie bei CDI üblich, müssen CDI-Extensions in der Datei  <span class='latex-texttt'>META-INF/services/javax.enterprise.inject.spi.Extension</span> vollständig qualifiziert eingetragen werden.
Bei der vorliegenden CDI-Extension ist der neue Inhalt der Konfigurationsdatei:
 <span class='latex-texttt'>at.irian.cdiatwork.ideafork.core.impl.config.context.ConfigContextExtension</span><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_custom-scope_annotation'> Verwendung einer eigenen Scope-Annotation </a>  kann die Scope-Annotation des hiermit registrierten CDI-Kontextes
folglich für unseren Konfigurationszwischenspeicher namens  <span class='latex-texttt'>MonitoringConfig</span>  eingesetzt werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_custom-scope_annotation'></a>                     <pre><code>@ConfigScoped
public class MonitoringConfig {
  @Inject
  @ConfigProperty(name = "methodInvocationThreshold")
  private Integer methodInvocationThreshold;

  public Integer getMethodInvocationThreshold() {
    return methodInvocationThreshold;
  }
}
</code></pre>
                </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:register_custom_context'> Eigene Kontext-Implementierung registrieren </a>  wird die  <span class='latex-texttt'>#reset</span> -Methode von  <span class='latex-texttt'>ConfigContext</span> in der Observer-Methode für das  <span class='latex-texttt'>BeforeShutdown</span> -Event aufgerufen,
um eventuell vorhandene  <span class='latex-texttt'>@PreDestroy</span> -Callbacks der gespeicherten Beans aufzurufen.
Wäre dies der einzige Aufruf der Reset-Methode,
so würde sich unser neu implementierter Kontext wie der Standard-Application-Context von CDI verhalten.
In  <span class='latex-textit'>IdeaFork</span>  soll der Config-Context über verschiedene Mechanismen zurückgesetzt werden können.
In diesem Abschnitt möchten wir hierfür JMX verwenden.
DeltaSpike-Core erlaubt nämlich durch die Verwendung der Annotation  <span class='latex-texttt'>@MBean</span>  CDI-Beans automatisch als JMX-Beans zu registrieren.
Die Angabe eines Bean-Namens und einer Kategorie für JMX ist optional.
Listing  <a href='#!idx:/deltaspike.html:fig:jmx_integration'> CDI-Bean als JMX-Bean aktivieren </a>  veranschaulicht, wie wir beide Informationen explizit festlegen können.
Dadurch wird das CDI-Bean beispielsweise in der JMX-Konsole namens  <span class='latex-textit'>jconsole</span>  sichtbar.
Die Klasse  <span class='latex-texttt'>ConfigReloader</span>  definiert nur eine Methode, die zusätzlich mit  <span class='latex-texttt'>@JmxManaged</span>  annotiert ist.
Diese Annotation markiert Methoden, die über JMX aufrufbar sein sollen.
In der Methodenimplementierung holen wir uns über den injizierten  <span class='latex-texttt'>BeanManager</span>  unseren selbst implementierten Kontext,
um die Methode  <span class='latex-texttt'>#reset</span>  aufzurufen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:jmx_integration'></a>                     <pre><code>@ApplicationScoped
@MBean(name = "ConfigReloader", category = "IdeaFork")
public class ConfigReloader {
  @Inject
  private BeanManager beanManager;

  @JmxManaged
  public void reloadConfig() {
    ((ConfigContext)beanManager.getContext(ConfigScoped.class))
      .reset();
  }
}
</code></pre>
                </div> Als Ergebnis ist es jetzt möglich zu beliebigen Zeitpunkten den Zwischenspeicher für konfigurierte Werte via JMX zurückzusetzen,
wodurch sämtliche Werte, die in einem  <span class='latex-texttt'>@ConfigScoped</span>  CDI-Bean abgelegt sind, beim nächsten Zugriff neu geladen werden.<br />  
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.4' ><span class='entry-number'>5.4</span> Helfende Hände</a> </h2>
 DeltaSpike-Core stellt neben Basisklassen auch einige statische Helper-Methoden zur Verfügung.
In  <span class='latex-textit'>IdeaFork</span>  haben wir in  <span class='latex-texttt'>CdiUtils</span>  beispielsweise zwei statische Methoden umgesetzt, die wir ersetzen können.
Die erste dieser beiden Methoden heißt  <span class='latex-texttt'>#injectFields</span>  und
wird in  <span class='latex-texttt'>CustomJsonWriter</span> ,  <span class='latex-texttt'>IdeaExporter</span>  und  <span class='latex-texttt'>RestApplicationConfig</span>  verwendet,
um Injection-Points der aktuellen Instanz manuell zu befüllen.
Eine äquivalente Methode wird durch den sogenannten  <span class='latex-texttt'>BeanProvider</span>  von DeltaSpike zur Verfügung gestellt.
Listing  <a href='#!idx:/deltaspike.html:fig:manual_injection'> Manuelle Injizierung </a>  zeigt die Verwendung in der Klasse  <span class='latex-texttt'>IdeaExporter</span> .
Die Umstellung selbst ist sehr einfach, da nur der Klassennamen von  <span class='latex-texttt'>CdiUtils</span>  auf  <span class='latex-texttt'>BeanProvider</span>  geändert werden muss.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:manual_injection'></a>                     <pre><code>private synchronized void init() {
  if (ideaManager == null) {
    BeanProvider.injectFields(this);
  }
}
</code></pre>
                </div> Die Klasse  <span class='latex-texttt'>BeanProvider</span>  stellt darüber hinaus viele weitere Helper-Methoden bereit.
Die zweite Methode namens  <span class='latex-texttt'>#getContextualReference</span> ,
die wir bisher in  <span class='latex-texttt'>CdiUtils</span>  manuell implementiert haben,
kann ebenfalls durch eine gleichnamige Version von  <span class='latex-texttt'>BeanProvider</span>  ersetzt werden.
Listing  <a href='#!idx:/deltaspike.html:fig:manual_lookup'> Manueller Lookup </a>  zeigt die Umstellung in  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span> auf einen optionalen Lookup via  <span class='latex-texttt'>BeanProvider</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:manual_lookup'></a>                     <pre><code>@Override
public &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T
    getInstance(Class&lt;T&gt; validatorClass) {

  T managedConstraintValidator =
    BeanProvider.getContextualReference(validatorClass, true);

  if (managedConstraintValidator == null) {
    managedConstraintValidator =
      this.defaultFactory.getInstance(validatorClass);
  }
  return managedConstraintValidator;
}
</code></pre>
                </div> Die Methode  <span class='latex-texttt'>#getContextualReference</span>  ist in  <span class='latex-texttt'>BeanProvider</span>  mehrfach überladen,
wodurch verschiedene Parameterkombinationen verwendet werden können.
Neben optionalen Qualifiern kann ein solcher Lookup auch mit dem Namen eines Beans erfolgen, sofern dieser definiert wurde.
Dennoch sollte ein typsicherer Lookup bevorzugt werden.
Manuelle Lookups sollten jedoch mit großer Sorgfalt eingesetzt werden.
Normal-scoped Beans sind hierbei unproblematisch,
weil nur die Contextual-Reference und nicht die Contextual-Instance vom CDI-Container nach außen gegeben wird.
Für dependent-scoped Beans gilt dies aber nicht und daher stehen separate Lookup-Methoden unter dem Namen  <span class='latex-texttt'>#getDependent</span>  zur Verfügung.
Das Ergebnis wird in eine Datenstruktur namens  <span class='latex-texttt'>DependentProvider</span>  verpackt,
damit eine korrekte manuelle Zerstörung der dependent-scoped Instanz zu einem späteren Zeitpunkt möglich ist.
Würde ein dependent-scoped Bean in ein normal-scoped Bean injiziert,
dann würde der CDI-Container das dependent-scoped Bean zerstören, sobald das dazugehörige normal-scoped Bean zerstört wird.
Dieser Aufgabe kann der CDI-Container bei einem direkten Lookup eines dependent-scoped Beans nicht automatisch nachkommen und
daher ist es erforderlich diesen Prozess explizit anzustoßen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In der Klasse  <span class='latex-texttt'>ActiveUserHolder</span>  werfen wir bei einem Session-Timeout im  <span class='latex-texttt'>@PreDestroy</span> -Callback ein  <span class='latex-texttt'>UserActionEvent</span> .
Da hier kein (HTTP-)Request aktiv ist, können beispielsweise Request-scoped Beans nicht verwendet werden.
Ursprünglich war  <span class='latex-texttt'>MonitoringConfig</span>  ein Request-scoped Bean und wäre für einen solchen Anwendungsfall nicht einsetzbar,
da es zu einer  <span class='latex-texttt'>ContextNotActiveException</span>  gekommen wäre.
Durch die Verwendung von  <span class='latex-texttt'>@ConfigScoped</span>  müssten wir in  <span class='latex-textit'>IdeaFork</span>  aktuell diesen Fall nicht berücksichtigen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Da Session-Timeouts und deren Folgen oftmals bei Applikationstests vernachlässigt werden,
können wir dennoch in  <span class='latex-texttt'>ActiveUserHolder</span>  Vorkehrungen treffen,
dass es hier zu einem späteren Zeitpunkt zu keinen Problemen kommen kann.
Listing  <a href='#!idx:/deltaspike.html:fig:manual_lookup_of_dependent-scoped_beans'> Manuelle Verwendung von dependent-scoped Beans </a>  enthält gleich mehrere Aspekte, die in solchen und ähnlichen Fällen interessant sind.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Statt den  <span class='latex-texttt'>BeanManager</span>  zu injizieren,
kann dieser in einem ersten Schritt auch über den  <span class='latex-texttt'>BeanManagerProvider</span>  von DeltaSpike geholt werden.
Dies eignet sich vor allem für die Verwendung in statischen Methoden, sowie für die Verwendung in Instanzen,
die nicht durch den CDI-Container verwaltet werden.
Mit Hilfe des  <span class='latex-texttt'>BeanManager</span> s und von  <span class='latex-texttt'>BeanProvider#getDependent</span> wird im nächsten Schritt ein dependent-scoped Bean vom Typ  <span class='latex-texttt'>ContextControl</span>  abgerufen.
Dieses Interface ist nicht in DeltaSpike-Core enthalten, sondern in einem separaten Teil von DeltaSpike namens CDI-Control.
Rein technisch wäre der Umweg über  <span class='latex-texttt'>DependentProvider</span>  nicht erforderlich,
da die verfügbaren Implementierungen keine  <span class='latex-texttt'>@PreDestroy</span> -Callbacks verwenden.
Dennoch ist die in Listing  <a href='#!idx:/deltaspike.html:fig:manual_lookup_of_dependent-scoped_beans'> Manuelle Verwendung von dependent-scoped Beans </a>  gezeigte Verwendung sinnvoll,
da DeltaSpike sonst Warnungen ins Log schreibt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Nach dem Lookup via  <span class='latex-texttt'>BeanProvider#getDependent</span>  kann auf die Contextual-Instance selbst
über  <span class='latex-texttt'>DependentProvider#get</span>  zugegriffen werden.
In unserem Fall starten wir den Request-Context bevor  <span class='latex-texttt'>UserActionEvent</span>  gefeuert wird und
beenden ihn bevor wir die dependent-scoped Instanz von  <span class='latex-texttt'>ContextControl</span>  mit Hilfe von  <span class='latex-texttt'>DependentProvider#destroy</span>  wieder zerstören.<br /> <div class="tip"><b>Tipp: </b> Im Hintergrund wird ein gemockter Request mit dem aktuellen Thread verbunden,
wodurch bis zum Stopp des Request-Contexts beliebige Request-scoped CDI-Beans wiederverwendet werden können.
Durch Konzepte wie diese können alle Standardkontexte auch in einer CDI-basierten Java SE Applikation bzw. in Unit-Tests verwendet werden.
Indirekt verwenden wir diesen Vorteil seit dem ersten Beispiel, da das Test-Control-Modul intern ebenfalls CDI-Control verwendet,
um den CDI-Container zu starten und zu stoppen bzw. die Standardkontexte je nach Anforderung zu kontrollieren. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:manual_lookup_of_dependent-scoped_beans'></a>                     <pre><code>public void onLogout(User user, boolean manualLogout) {
  if (manualLogout) {
    userActionEvent
      .fire(new UserActionEvent(new UserAction(LOGOUT, user)));
  } else {
    BeanManager beanManager =
      BeanManagerProvider.getInstance().getBeanManager();

    DependentProvider&lt;ContextControl&gt; contextControlProvider =
      BeanProvider.getDependent(beanManager, ContextControl.class);

    try {
      contextControlProvider.get().startContext(RequestScoped.class);

      userActionEvent
        .fire(new UserActionEvent(new UserAction(AUTO_LOGOUT, user)));
    } finally {
      contextControlProvider.get().stopContext(RequestScoped.class);
      contextControlProvider.destroy();
    }
  }
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Seit Version 1.1 stellt CDI mit  <span class='latex-texttt'>CDI.current().getBeanManager()</span>  einen Ersatz für den  <span class='latex-texttt'>BeanManagerProvider</span>  zur Verfügung. </div> Neben diesen sehr CDI spezifischen Hilfsmitteln enthält DeltaSpike-Core auch allgemeinere Werkzeuge wie beispielsweise
 <span class='latex-texttt'>ProxyUtils</span>  und  <span class='latex-texttt'>AnnotationUtils</span> .
In  <span class='latex-textit'>IdeaFork</span>  haben wir die Erkennung von Proxy-Klassen bisher manuell gemacht.
Listing  <a href='#!idx:/deltaspike.html:fig:manual_assessments'> Manuelle Auswertungen </a>  zeigt das bisherige Vorgehen in  <span class='latex-texttt'>DefaultMonitoredInterceptorStrategy</span> ,
das in Listing  <a href='#!idx:/deltaspike.html:fig:utility_methods'> Utility Methoden von DeltaSpike </a>  durch die Verwendung von  <span class='latex-texttt'>ProxyUtils#getUnproxiedClass</span>  ersetzt werden kann.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:manual_assessments'></a>                     <pre><code>private Monitored extractMonitoredAnnotation(InvocationContext ic) {
  Monitored result = ic.getMethod().getAnnotation(Monitored.class);

  if (result != null) {
    return result;
  }

  Class&lt;?&gt; targetClass = ic.getTarget().getClass();

  if (targetClass.getName()
        .startsWith(targetClass.getSuperclass().getName()) &&
      targetClass.getName().contains("$$")) {

    targetClass = targetClass.getSuperclass();
  }

  result = targetClass.getAnnotation(Monitored.class);

  if (result == null) {
    return findAnnotation(
      beanManager, targetClass.getAnnotations(), Monitored.class);
  }

  return result;
}

private static &lt;T extends Annotation&gt; T findAnnotation(
    BeanManager beanManager,
    Annotation[] annotations,
    Class&lt;T&gt; targetAnnotationType) {

  for (Annotation annotation : annotations) {
    if (targetAnnotationType.equals(annotation.annotationType())) {
      return (T) annotation;
    }
    if (beanManager.isStereotype(annotation.annotationType())) {
      T result = findAnnotation(
        beanManager,
        annotation.annotationType().getAnnotations(),
        targetAnnotationType);
      if (result != null) {
        return result;
      }
    }
  }
  return null;
}
</code></pre>
                </div> Eine weitere Hilfsklasse, die in Listing  <a href='#!idx:/deltaspike.html:fig:utility_methods'> Utility Methoden von DeltaSpike </a>  verwendet wird, ist  <span class='latex-texttt'>AnnotationUtils</span> .
In  <span class='latex-texttt'>DefaultMonitoredInterceptorStrategy</span>  lässt sich die manuell implementierte Methode
 <span class='latex-texttt'>#findAnnotation</span>  mit  <span class='latex-texttt'>AnnotationUtils#findAnnotation</span>  ersetzen.
Ein zusätzlicher Vorteil von  <span class='latex-texttt'>AnnotationUtils#findAnnotation</span>  ist die Unterstützung von CDI-Stereotypen.
Dies ist auch der Grund, warum der  <span class='latex-texttt'>BeanManager</span>  als erster Parameter übergeben werden muss.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:utility_methods'></a>                     <pre><code>private Monitored extractMonitoredAnnotation(InvocationContext ic) {
  Monitored result = ic.getMethod().getAnnotation(Monitored.class);

  if (result != null) {
    return result;
  }

  Class&lt;?&gt; targetClass = ic.getTarget().getClass();

  targetClass = ProxyUtils.getUnproxiedClass(targetClass);

  result = targetClass.getAnnotation(Monitored.class);

  if (result == null) {
    return AnnotationUtils.findAnnotation(
      beanManager, targetClass.getAnnotations(), Monitored.class);
  }

  return result;
}
</code></pre>
                </div> DeltaSpike-Core enthält viele interessante Hilfsmittel wie diese.
Ein Blick in das Package  <span class='latex-texttt'>org.apache.deltaspike.core.util</span>  ist sehr empfehlenswert.
Selbst für Hilfsmittel, die nicht direkt im Zusammenhang mit CDI selbst stehen.<br />  
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.5' ><span class='entry-number'>5.5</span> Sicher ist sicher</a> </h2>
 Neben Hilfsmitteln rund um CDI stellt DeltaSpike auch neue Konzepte für andere Spezifikationen wie beispielsweise JSF zur Verfügung,
um die Entwicklung von Applikationen durch zusätzliche Typsicherheit zu erleichtern und die Wartbarkeit zu verbessern.
Ein Beispiel hierfür ist die View-Config. Dieser Mechanismus erlaubt die typsichere Konfiguration von (JSF-)Seiten.<br /> <div class="tip"><b>Tipp: </b> View-Configs sind derzeit speziell für JSF implementiert.
Das Konzept selbst ist jedoch unabhängig von JSF, und daher enthält DeltaSpike-Core die meisten Interfaces und Annotationen.
Somit sind auch Implementierungen für andere UI-Frameworks auf Basis von DeltaSpike-Core möglich.
Das JSF-Modul von DeltaSpike stellt eine Implementierung für JSF zur Verfügung und
ermöglicht zusätzlich die Verwendung der optionalen Annotationen  <span class='latex-texttt'>@View</span>  und  <span class='latex-texttt'>@Folder</span> . </div> Wie eingangs beschrieben, fügen wir jetzt in  <span class='latex-textit'>IdeaFork</span>  das JSF-Modul hinzu,
damit wir für beliebige JSF-Seiten eine typsichere View-Config anlegen können.
Listing  <a href='#!idx:/deltaspike.html:fig:minimal_view-config'> Minimale View-Config </a>  veranschaulicht die einfachste Variante ohne zusätzliche Metadaten.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_view-config'></a>                     <pre><code>public class Index implements ViewConfig {
}
</code></pre>
                </div> 
Ohne eine zusätzliche Verwendung in der Applikation führt die Konfiguration
aus Listing  <a href='#!idx:/deltaspike.html:fig:minimal_view-config'> Minimale View-Config </a>  nur zu einer Pfad-Validierung.
Die zuvor gezeigte Seitenkonfiguration definiert den Dateipfad  <span class='latex-texttt'>/index.xhtml</span> .
In  <span class='latex-textit'>IdeaFork</span>  ist diese Datei allerdings nicht vorhanden.
Wird eine Anwendung mit einer ungültigen Seitenkonfiguration gestartet,
dann bricht DeltaSpike den Startvorgang ab und meldet eine ungültige Konfiguration.
Die Datei  <span class='latex-texttt'>index.xhtml</span>  ist in unserem Fall im Verzeichnis  <span class='latex-texttt'>pages</span>  abgelegt.
Entsprechend ist die in Listing  <a href='#!idx:/deltaspike.html:fig:minimal_view-config_in_directory'> Minimale View-Config in einem Verzeichnis </a>  dargestellte View-Config erforderlich.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_view-config_in_directory'></a>                     <pre><code>public interface Pages {
  class Index implements ViewConfig {}
}
</code></pre>
                </div> 
Verzeichnisse werden durch verschachtelbare Interfaces repräsentiert und konkrete Seiten durch Klassen, die direkt oder
indirekt das Interface  <span class='latex-texttt'>ViewConfig</span>  implementieren.
Bei der Konvertierung in eine JSF View-ID wird jeweils der erste Buchstabe in einen Kleinbuchstaben umgewandelt und
für JSF-Seiten wird ein Suffix hinzugefügt,
wodurch im Falle von Listing  <a href='#!idx:/deltaspike.html:fig:minimal_view-config_in_directory'> Minimale View-Config in einem Verzeichnis </a>  der Pfad  <span class='latex-texttt'>/pages/index.xhtml</span>  entsteht.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Abgesehen von der automatischen Validierung der Pfade
kann diese typsichere Konfiguration auch ohne zusätzliche Metadaten bereits sinnvoll verwendet werden.
View-Configs können nämlich zusätzlich für eine typsichere JSF-Navigation verwendet werden.
Listing  <a href='#!idx:/deltaspike.html:fig:minimal_typesafe_jsf-navigation'> Minimale typsichere JSF-Navigation </a>  veranschaulicht dies anhand einer Action-Methode,
die im Gegensatz zu einer herkömmlichen Action-Methode keinen String als Return-Typ verwendet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_typesafe_jsf-navigation'></a>                     <pre><code>public Class&lt;? extends ViewConfig&gt; onJsfAction() {
  //...
  return Pages.Index.class;
}
</code></pre>
                </div> 
DeltaSpike konvertiert  <span class='latex-texttt'>Pages.Index.class</span>  automatisch in  <span class='latex-texttt'>/pages/index.xhtml</span> ,
wodurch die JSF Implementierung eine normale View-ID als Navigationsziel erhält und
sich somit wie bei einer standardmäßigen impliziten JSF-Navigation verhält, die seit JSF 2.0 von der Spezifikation unterstützt wird.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Wirklich sinnvoll wird das View-Config Konzept in Kombination mit zusätzlichen Metadaten.
Listing  <a href='#!idx:/deltaspike.html:fig:folder_structure_with_view-configs'> Verzeichnishierarchie mit View-Configs </a>  zeigt eine Konfiguration, wie sie oft in der Praxis verwendet wird.
Mit  <span class='latex-texttt'>@View</span>  lassen sich JSF-spezifische Informationen wie der Navigationsmodus festlegen und explizite Namen vergeben.
 <span class='latex-texttt'>@View</span>  muss jedoch nicht für jede Seite erneut definiert werden, sondern kann über die Vererbungshierarchie vererbt werden.
Da eine Seite nur indirekt  <span class='latex-texttt'>ViewConfig</span>  implementieren muss,
wird in Listing  <a href='#!idx:/deltaspike.html:fig:folder_structure_with_view-configs'> Verzeichnishierarchie mit View-Configs </a>   <span class='latex-texttt'>Pages</span>  von  <span class='latex-texttt'>ViewConfig</span>  abgeleitet,
wodurch alle anderen Konfigurationen keine direkte Verbindung zu einem der Interfaces von DeltaSpike benötigen.
Durch die Vererbungshierarchie wird  <span class='latex-texttt'>@View</span>  an alle Seitenkonfigurationen vererbt,
die direkt oder indirekt das  <span class='latex-texttt'>Pages</span> -Interface implementieren.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die Angabe von  <span class='latex-texttt'>REDIRECT</span>  als Navigationsmodus verändert die generierten Navigationsstrings.
So wird beispielsweise aus  <span class='latex-texttt'>/pages/index.xhtml</span>  der Wert  <span class='latex-texttt'>/pages/index.xhtml?faces-redirect=true</span> .
Gleiches gilt auch für alle andere Seiten mit Ausnahme von  <span class='latex-texttt'>Pages.User.Login.class</span> ,
da nur diese Seitenkonfiguration nicht das Interface  <span class='latex-texttt'>Pages</span>  implementiert.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span class='latex-texttt'>Pages.User.Login.class</span>  erweitert stattdessen die Klasse  <span class='latex-texttt'>org.apache.deltaspike.core.api.config.view.DefaultErrorView</span> .
Diese Markerklasse für die Error-Seite einer Applikation darf nur von einer Konfigurationsklasse erweitert werden.
DeltaSpike benötigt diesen Marker, um generisch zur Default-Error-Seite einer Applikation zu navigieren,
falls es in der Applikation zu einem unbehandelten Fehler kommt.
Soll zu einem späteren Zeitpunkt eine andere Seite als Error-Seite verwendet werden,
dann müssen nur die betroffenen Konfigurationsklassen entsprechend angepasst werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:folder_structure_with_view-configs'> Verzeichnishierarchie mit View-Configs </a>  ist ebenfalls ersichtlich,
dass  <span class='latex-texttt'>User</span>  als Interface im  <span class='latex-texttt'>Pages</span> -Interface verschachtelt ist.
Dies ist immer dann erforderlich, wenn es einen Unterordner im Dateisystem gibt.
Somit spiegelt sich die Struktur des Dateisystems in der Konfiguration wider.
Würden wir etwas später nur einen der Ordner umbenennen und die typsichere Konfiguration nicht entsprechend nachziehen,
dann würde der nächste Applikationsstart mit einer Exception enden.
Da es sich bei der View-Config für die Pfadkonfiguration um Interfaces und Klassen handelt, ist eine Aktualisierung sehr einfach möglich.
Alle modernen Java-IDEs können Klassen- bzw. Interface-Namen automatisch im gesamten Projekt aktualisieren.
Spätestens der Java Compiler überprüft, ob alle Verweise korrekt geändert wurden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:folder_structure_with_view-configs'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  class Index implements Pages {}

  interface User extends Pages {
    class Login extends DefaultErrorView {}

    class Registration implements User {}

    class Profile implements User {}
  }
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Die zuvor beschriebene Namenskonvention kann angepasst werden.
Eine einfache Anpassung werden wir uns im nächsten Abschnitt dieses Kapitels ansehen. </div> 
Listing  <a href='#!idx:/deltaspike.html:fig:page-config_for_ideafork'> Seitenkonfigurationen für IdeaFork </a>  zeigt die Seitenkonfiguration von  <span class='latex-textit'>IdeaFork</span>  für die bestehenden JSF-Seiten.
Wir müssten nicht für jede Seite zwingend eine View-Config anlegen,
aber für jede Konfigurationsklasse muss die dazugehörige JSF-Seite existieren.
Daher ist es grundsätzlich möglich, auf die Konfiguration von konkreten Seiten zu verzichten.
Werden nur Verzeichnisse konfiguriert, so ist es beispielsweise möglich, Security-Constraints für gesamte Ordner zu definieren.
In  <span class='latex-textit'>IdeaFork</span>  werden wir als einen der nächsten Schritte eine Kombination verwenden,
indem wir Security-Constraints auf Ordner-Ebene definieren und für bestimmte Seiten zusätzliche Metadaten hinterlegen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:page-config_for_ideafork'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  class Index implements Pages {}

  interface User extends Pages {
    class Login extends DefaultErrorView {}

    class Registration implements User {}

    class Profile implements User {}
  }

  interface Idea extends Pages {
    class Overview implements Idea {}

    class Create implements Idea {}
    class Edit implements Idea {}

    class List implements Idea {}
    class Details implements Idea {}
  }

  interface Search extends Pages {
    class Fork implements Search {}
  }

  interface Import extends Pages {
    class Upload implements Import {}
    class Summary implements Import {}
  }
}
</code></pre>
                </div> 
Da Verzeichnisse durch Interfaces repräsentiert sind und somit einen eigenen Typ haben,
kann das Navigationsziel sogar durch den Return-Typ von Action-Methoden eingeschränkt werden.
Listing  <a href='#!idx:/deltaspike.html:fig:restrict_navigation-target'> Navigationsziel einschränken via Return-Typ </a>  zeigt eine der umgestellten Action-Methoden von  <span class='latex-textit'>IdeaFork</span> .
Statt  <span class='latex-texttt'>Class&lt;? extends ViewConfig&gt;</span>  wird  <span class='latex-texttt'>Class&lt;? extends Pages.Idea&gt;</span>  verwendet.
Da hier unsere eigenen Interfaces verwendet werden, wird die Implementierung lesbarer und zusätzlich stellt der Java Compiler sicher,
dass das Navigationsziel im Verzeichnis  <span class='latex-texttt'>/pages/idea</span>  liegen muss.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:restrict_navigation-target'></a>                     <pre><code>@ViewController
public class IdeaCreateViewCtrl implements Serializable {
  //...

  public Class&lt;? extends Pages.Idea&gt; save() {
    //...
    ideaService.save(ideaToSave);
    return Pages.Idea.Overview.class;
  }
}
</code></pre>
                </div> 
Rein technisch sind auch Mischungen möglich.
Listing  <a href='#!idx:/deltaspike.html:fig:possible_return_types'> Möglichkeiten für Return-Typen </a>  stellt die entsprechend angepasste Version der Klasse  <span class='latex-texttt'>MenuController</span>  dar.
Hier wird ersichtlich, dass – wie bei der Methode  <span class='latex-texttt'>#home</span> – durch die Angabe von  <span class='latex-texttt'>Class&lt;? extends Pages&gt;</span> das oberste Basisverzeichnis als Navigationsziel festgelegt werden kann.
Die Navigation selbst kann zu einer Seite in diesem Verzeichnis oder zu einer Seite in einem der Unterverzeichnisse durchgeführt werden.
Als Alternative kann auch der komplette Pfad bereits durch den Return-Typ vorgegeben werden.
Dies wird beispielsweise bei der Methode  <span class='latex-texttt'>#login</span>  umgesetzt.
Im Gegensatz hierzu stehen die Methoden  <span class='latex-texttt'>#logout</span>  und  <span class='latex-texttt'>#start</span> ,
bei denen zu jeder gültigen View-Config Konfiguration navigiert werden kann.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:possible_return_types'></a>                     <pre><code>@Named("menuBean")
@Model
public class MenuController {
  @Inject
  private ActiveUserHolder userHolder;

  public Class&lt;? extends Pages&gt; home() {
    return Pages.Index.class;
  }

  public Class&lt;Pages.User.Login&gt; login() {
    return Pages.User.Login.class;
  }

  public Class&lt;? extends ViewConfig&gt; logout() {
    userHolder.setAuthenticatedUser(null);
    return Pages.User.Login.class;
  }

  public Class&lt;? extends ViewConfig&gt; start() {
    if (userHolder.isLoggedIn()) {
      return Pages.Idea.Overview.class;
    }
    return Pages.User.Login.class;
  }

  public Class&lt;? extends Pages.User&gt; register() {
    return Pages.User.Registration.class;
  }
}
</code></pre>
                </div> 
Abgesehen von JSF Action-Methoden können typsichere Ordner- und Seitenkonfigurationen auch außerhalb von JSF,
beispielsweise für eine typsichere Navigation, verwendet werden.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_view-config-resolver'> Verwendung von ViewConfigResolver </a>  illustriert, wie  <span class='latex-texttt'>IdeaImportServlet</span>  in  <span class='latex-textit'>IdeaFork</span> von diesem Konzept profitieren kann.
Im Vergleich zu der bisherigen Implementierung dieses Servlets kann ein sogenannter  <span class='latex-texttt'>ViewConfigResolver</span>  injiziert werden.
Über die Methode  <span class='latex-texttt'>#getViewConfigDescriptor</span>  können wir mit einer Pfadangabe als String oder
einer Klasse vom Typ  <span class='latex-texttt'>ViewConfig</span>  die dazugehörige Konfiguration inklusive aller Metadaten abfragen.
In unserem Fall holen wir uns die Konfiguration für  <span class='latex-texttt'>Pages.Import.Summary.class</span>  und
rufen die Methode  <span class='latex-texttt'>#getViewId</span>  auf den resultierenden Descriptor auf, um die Pfadangabe als String zu erhalten.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_view-config-resolver'></a>                     <pre><code>@WebServlet("/idea/import")
@MultipartConfig
public class IdeaImportServlet extends HttpServlet {
  @Inject
  private ActiveUserHolder userHolder;

  @Inject
  private FileUploadService fileUploadService;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  protected void doPost(HttpServletRequest request,
                        HttpServletResponse response)
        throws ServletException, IOException {

    fileUploadService.storeUploadedFiles(
      request.getParts(), userHolder.getAuthenticatedUser());

    ViewConfigDescriptor viewConfigDescriptor =
      viewConfigResolver.getViewConfigDescriptor(
        Pages.Import.Summary.class);

    request.getRequestDispatcher(viewConfigDescriptor.getViewId())
      .forward(request, response);
  }
}
</code></pre>
                </div> 
Bei zukünftigen Refactorings müssen wir somit keinen fest definierten String mehr manuell nachziehen.
Darüber hinaus vereinfachen moderne Java IDEs nicht nur das Refactoring selbst,
sondern auch die Suche nach Verweisen auf bestimmte Seiten.
Im Git-Repository von  <span class='latex-textit'>IdeaFork</span>  sind sämtliche Änderungen zu diesem Thema in einem Commit zusammengefasst und
die gesamte Applikation ist somit auf View-Configs umgestellt.<br /> <div class="tip"><b>Tipp: </b> Vererbte Metadaten können überschrieben oder erweitert werden.
So ist es beispielsweise möglich,  <span class='latex-texttt'>@View</span>  bei einer konkreten Seitenkonfiguration zu verwenden,
um für einzelne Seiten das Verhalten anzupassen oder die vererbten Informationen mit zusätzlichen Angaben zu erweitern. </div> Die zuvor definierte Error-Seite haben wir in  <span class='latex-textit'>IdeaFork</span>  noch nicht explizit verwendet.
Ein naheliegendes Einsatzgebiet ist die Fehlerbehandlung von bestimmten Exceptions.
Das Exception-Handling Konzept von DeltaSpike haben wir in einem kurzen Beispiel bereits kennengelernt.
Im nächsten Schritt wollen wir diese und weitere Mechanismen kombinieren,
um bei unbehandelten Exceptions vom Typ  <span class='latex-texttt'>IllegalStateException</span>  die festgelegte Error-Seite anzuzeigen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:exception-handler_and_navigation'> Exception-Handler mit Navigation zu DefaultErrorView </a>  werden unbehandelte Exceptions vom Typ
 <span class='latex-texttt'>IllegalStateException</span>  als behandelt markiert.
Zusätzlich wird in dem Request-scoped Exception-Handler das Flag  <span class='latex-texttt'>exceptionDetected</span>  in einem solchen Fall auf  <span class='latex-texttt'>true</span>  gesetzt.
Der Null-Check für den  <span class='latex-texttt'>FacesContext</span>  ist erforderlich,
da Request-scoped CDI Beans auch außerhalb eines JSF-Requests aktiviert werden können.
Schließlich stellt  <span class='latex-texttt'>@Handles(ordinal = Integer.MIN_VALUE)</span>  sicher, dass die Handler-Methode am Ende der Handler-Kette aufgerufen wird.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In einem weiteren Schritt erhält die Klasse  <span class='latex-texttt'>ErrorViewAwareExceptionHandler</span>  einen CDI-Observer
mit dem Qualifier  <span class='latex-texttt'>@BeforePhase(JsfPhaseId.RENDER_RESPONSE)</span>  für den Event-Typ  <span class='latex-texttt'>PhaseEvent</span> .
Wurde im aktuellen Request das Flag  <span class='latex-texttt'>exceptionDetected</span>  auf  <span class='latex-texttt'>true</span>  gesetzt,
so kann mit  <span class='latex-texttt'>ViewNavigationHandler#navigateTo</span>  in Kombination mit einer Konfigurationsklasse
zu einer JSF-Seite navigiert werden.
Wir wollen jedoch nicht zu einer fest definierten Seite navigieren, sondern zu der aktuell konfigurierten Error-Seite.
Aus diesem Grund wird  <span class='latex-texttt'>DefaultErrorView.class</span>  als Argument übergeben.
Da DeltaSpike diesen Marker kennt, wird im Hintergrund die Seitenkonfiguration gesucht, die von dieser Marker-Klasse ableitet.
Sofern es eine solche Seitenkonfiguration gibt,
wird intern der Pfad, der durch die Konfiguration repräsentiert wird, für die effektive Navigation verwendet.<br /> <div class="tip"><b>Tipp: </b> DeltaSpike definiert mit  <span class='latex-texttt'>@BeforePhase</span>  und  <span class='latex-texttt'>@AfterPhase</span>  zwei Qualifier,
die in Kombination mit jeder beliebigen Phase des JSF Request-Lifecycles verwendet werden können. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:exception-handler_and_navigation'></a>                     <pre><code>@RequestScoped
@ExceptionHandler
public class ErrorViewAwareExceptionHandler {
  private boolean exceptionDetected = false;

  public void onUnhandledException(
      @Handles(ordinal = Integer.MIN_VALUE)
      ExceptionEvent&lt;IllegalStateException&gt; exceptionEvent) {

    FacesContext facesContext = FacesContext.getCurrentInstance();

    if (facesContext == null) {
      return;
    }

    if (!exceptionEvent.isMarkedHandled()) {
      exceptionEvent.handled();
      exceptionDetected = true;
    }
  }

  protected void navigateOnDetectedException(
      @Observes @BeforePhase(JsfPhaseId.RENDER_RESPONSE)
      PhaseEvent phaseEvent,
      ViewNavigationHandler viewNavigationHandler) {

    if (exceptionDetected) {
      viewNavigationHandler.navigateTo(DefaultErrorView.class);
    }
  }
}
</code></pre>
                </div> 
Neben den bisher vorgestellten Metadaten für View-Configs integriert das JSF-Modul auch die  <span class='latex-texttt'>@Secured</span> -Annotation
des Security-Moduls von DeltaSpike.
Grundsätzlich handelt es sich hier um eine Art Interceptor, mit dem Klassen oder einzelne Methoden annotiert werden können.
Bei diesem Interceptor muss mindestens eine Implementierung von  <span class='latex-texttt'>AccessDecisionVoter</span>  angegeben werden,
die verwendet wird, um den Zugriff auf die auszuführende Methode zu überprüfen.
In Verbindung mit dem View-Config Konzept wird kein Methodenaufruf abgesichert,
sondern das jeweils konfigurierte Verzeichnis oder einzelne Seiten.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:protect_pages'> Absicherung von Seiten mit @Secured </a>  wird der View-Config von  <span class='latex-textit'>IdeaFork</span>  ein zusätzliches Marker-Interface
mit dem Namen  <span class='latex-texttt'>SecuredPages</span>  hinzugefügt.
 <span class='latex-texttt'>SecuredPages</span>  sieht wie die Konfiguration eines Verzeichnisses aus.
Tatsächlich handelt es sich jedoch um ein Interface zur Sammlung von Metadaten.
Technisch gesehen könnte dieses Interface auch separat definiert werden.
In unserem Fall erweitert  <span class='latex-texttt'>SecuredPages</span>  das Interface Pages, um dessen Metadaten zu übernehmen.
Außerdem wird  <span class='latex-texttt'>SecuredPages</span>  mit der Annotation  <span class='latex-texttt'>@Secured</span>  versehen.
Alle Verzeichniskonfigurationen, die von  <span class='latex-texttt'>SecuredPages</span>  ableiten, werden durch den  <span class='latex-texttt'>UserAwareAccessDecisionVoter</span>  abgesichert,
da dieser bei  <span class='latex-texttt'>@Secured</span>  angegeben ist und entsprechend vererbt wird.
Sofern Klassen für die Seitenkonfiguration in solchen Verzeichnissen vorhanden sind und
eine mit  <span class='latex-texttt'>@Secured</span>  gesicherte Verzeichniskonfiguration implementieren,
erben auch diese Seitenkonfigurationen laut der allgemeinen View-Config-Regel die Definition von  <span class='latex-texttt'>@Secured</span> .
In diesen Fällen wird nicht nur der Zugriff auf das Verzeichnis geprüft,
sondern auch auf einzelne Seiten, die mit View-Config Klassen abgebildet werden.
Listing  <a href='#!idx:/deltaspike.html:fig:protect_pages'> Absicherung von Seiten mit @Secured </a>  veranschaulicht durch  <span class='latex-texttt'>Pages.User.Profil.class</span> ,
dass auch einzelne Seiten abgesichert werden können, selbst wenn sie nicht in einem abgesicherten Verzeichnis enthalten sind.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:protect_pages'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  class Index implements Pages {}

  @Secured(UserAwareAccessDecisionVoter.class)
  interface SecuredPages extends Pages {}

  interface User extends Pages {
    class Login extends DefaultErrorView {}

    class Registration implements User {}

    class Profile implements SecuredPages {}
  }

  interface Idea extends SecuredPages {
    class Overview implements Idea {}

    class Create implements Idea {}
    class Edit implements Idea {}

    class List implements Idea {}
    class Details implements Idea {}
  }

  interface Search extends SecuredPages {
    class Fork implements Search {}
  }

  interface Import extends SecuredPages {
    class Upload implements Import {}
    class Summary implements Import {}
  }
}
</code></pre>
                </div> 
Auch  <span class='latex-texttt'>SecuredPages</span>  kann durch die indirekte Erweiterung von  <span class='latex-texttt'>ViewConfig</span>  zur Einschränkung der Navigationsziele verwendet werden.
Listing  <a href='#!idx:/deltaspike.html:fig:secured-pages_as_navigation-target'> SecuredPages als Navigationsziel </a>  zeigt den auf View-Configs umgestellten  <span class='latex-texttt'>NavigationController</span>  von  <span class='latex-textit'>IdeaFork</span> .
Die Methode  <span class='latex-texttt'>#toUserProfile</span>  definiert  <span class='latex-texttt'>Class&lt;? extends Pages.SecuredPages&gt;</span>  als Return-Typ,
wodurch nur zu Seiten in gesicherten Verzeichnissen navigiert werden kann.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:secured-pages_as_navigation-target'></a>                     <pre><code>@Named
@ApplicationScoped
public class NavigationController {
  public Class&lt;? extends Pages.Idea&gt; toNewIdea() {
    return Pages.Idea.Create.class;
  }

  public Class&lt;? extends Pages.Idea&gt; toIdeaList() {
    return Pages.Idea.List.class;
  }

  public Class&lt;? extends Pages.Import&gt; toIdeaImport() {
    return Pages.Import.Upload.class;
  }

  public Class&lt;? extends Pages.SecuredPages&gt; toUserProfile() {
    return Pages.User.Profile.class;
  }
}
</code></pre>
                </div> 
Ein  <span class='latex-texttt'>AccessDecisionVoter</span>  kann entweder wie  <span class='latex-texttt'>UserAwareAccessDecisionVoter</span>  an eine eigene Security-Logik delegieren oder
die Überprüfung an ein beliebiges Security-Framework weiterleiten.
In Listing  <a href='#!idx:/deltaspike.html:fig:access-decision-voter_with_typesafe_messages'> AccessDecisionVoter mit typsicheren Nachrichten </a>  delegieren wir an das  <span class='latex-texttt'>ActiveUserHolder</span> -Bean von  <span class='latex-textit'>IdeaFork</span> .<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Wird  <span class='latex-texttt'>@Secured</span>  über eine Verzeichniskonfiguration an Seitenkonfigurationen vererbt,
dann wird jeder  <span class='latex-texttt'>AccessDecisionVoter</span> , der durch  <span class='latex-texttt'>@Secured</span>  referenziert wird, mehrfach aufgerufen.
Der erste Aufruf wird für die Seite selbst durchgeführt und
anschließend erfolgt je Verzeichnisebene, die @Secured vererbt bekommen hat, ein eigener Aufruf.
Je Aufruf wird ein manueller Bean-Lookup mit der angegebenen  <span class='latex-texttt'>AccessDecisionVoter</span> -Klasse durchgeführt.
Beispielsweise wird im Falle von  <span class='latex-texttt'>Pages.Idea.Overview.class</span>  die Methode
 <span class='latex-texttt'>UserAwareAccessDecisionVoter#checkPermission</span>  für
 <span class='latex-texttt'>Pages.Idea.Overview.class</span>  und  <span class='latex-texttt'>Pages.Idea.class</span>  auf das gefundene CDI-Bean aufgerufen.
Die Aufrufe für die Zugriffskontrolle von Verzeichnissen und Seiten unterscheiden sich nur durch den Inhalt der Metadaten,
auf die mit der Methode  <span class='latex-texttt'>AccessDecisionVoterContext#getMetaData</span>  zugegriffen werden kann.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:access-decision-voter_with_typesafe_messages'></a>                     <pre><code>@RequestScoped
public class UserAwareAccessDecisionVoter
    extends AbstractAccessDecisionVoter {

  @Inject
  private ActiveUserHolder activeUserHolder;

  @Inject
  private UserMessage userMessage;

  @Override
  protected void checkPermission(
      AccessDecisionVoterContext accessDecisionVoterContext,
      Set&lt;SecurityViolation&gt; securityViolations) {

    if (!activeUserHolder.isLoggedIn()) {
      securityViolations.add(
        newSecurityViolation(userMessage.pleaseLogin()));
    }
  }
}
</code></pre>
                </div> 
Listing  <a href='#!idx:/deltaspike.html:fig:access-decision-voter_with_typesafe_messages'> AccessDecisionVoter mit typsicheren Nachrichten </a>  zeigt neben einem einfachen  <span class='latex-texttt'>AccessDecisionVoter</span> zusätzlich die Verwendung von typsicheren Messages.
<div class="tip"><b>Tipp: </b>Das DeltaSpike-Sicherheitsmodell mit <span class='latex-texttt'>@Secured</span> und <span class='latex-texttt'>AccessDecisionVoter</span> wird in Quarkus durch Jakarta Security mit <span class='latex-texttt'>@RolesAllowed</span> und <span class='latex-texttt'>SecurityIdentity</span> ersetzt (Kapitel <a href='#!idx:/quarkus.html:10.6'>10.6</a>). Auf der Clientseite übernehmen Angular Route Guards eine ähnliche Rolle &mdash; allerdings nur als UX-Verbesserung, nicht als Sicherheitsgrenze (Kapitel <a href='#!idx:/angular.html:11.6'>11.6</a>).</div>
 <span class='latex-texttt'>UserMessage</span>  ist ein eigenes Interface, das mit  <span class='latex-texttt'>@MessageBundle</span>  annotiert ist.
Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_message'> Definition typsicherer Nachrichten </a>  zeigt einen Ausschnitt von  <span class='latex-texttt'>UserMessage</span> .
Jede Methode definiert einen Key, der in einem Resource-Bundle vorhanden sein muss.
Wird der Name des Resource-Bundles nicht explizit angegeben,
dann entspricht der Name des Bundles dem vollständig qualifizierten Namen des Interfaces.
Soll der Namen des Keys anders sein, so kann auch dieser explizit angegeben werden.
Lautet der Key beispielsweise  <span class='latex-texttt'>please_login</span>  statt  <span class='latex-texttt'>pleaseLogin</span> ,
dann kann die Methode mit  <span class='latex-texttt'>@MessageTemplate("{please_login}")</span>  annotiert werden.
Alternativ können Texte wie in Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_message'> Definition typsicherer Nachrichten </a>  fix angegeben werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_message'></a>                     <pre><code>@MessageBundle
public interface UserMessage {
    @MessageTemplate("Welcome %s!")
    String welcomeNewUser(String nickName);

    @MessageTemplate("Login failed!")
    String loginFailed();

    @MessageTemplate("Please login")
    String pleaseLogin();

    //...
}
</code></pre>
                </div> 
Die Methode  <span class='latex-texttt'>#welcomeNewUser</span>  illustriert zusätzlich, dass Message-Parameter mit Hilfe von Methodenparametern befüllt werden können.
Im Nachrichtentext sind beliebig viele Platzhalter  <span class='latex-texttt'>("%s")</span>  erlaubt,
die der Reihenfolge nach mit den Werten ersetzt werden, die der Methode als Argumente übergeben werden.
Handelt es sich bei einem Parameter-Typ nicht um einen String, dann wird die Methode  <span class='latex-texttt'>#toString</span>  aufgerufen.
Somit ist eine typsichere Parametrisierung möglich.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Für JSF gibt es darüber hinaus eine Erweiterung dieses Konzepts, die in Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_jsf-message'> Typsichere JSF-Messages </a>  veranschaulicht wird.
Im Gegensatz zu der direkten Injizierung von  <span class='latex-texttt'>UserMessage</span>  und Verwendung von  <span class='latex-texttt'>#pleaseLogin</span>  aus dem vorherigen Beispiel
wird in diesem Fall ein vom JSF-Modul zur Verfügung gestelltes Interface namens  <span class='latex-texttt'>JsfMessage</span>  injiziert,
das auf  <span class='latex-texttt'>UserMessage</span>  typisiert wird.
Dies ermöglicht, über Methoden wie beispielsweise  <span class='latex-texttt'>#addInfo</span>  und  <span class='latex-texttt'>#addError</span> , die implizite Erzeugung entsprechender Faces-Messages.
In unserem Beispiel wird der Text für  <span class='latex-texttt'>#welcomeNewUser</span>  auf der Oberfläche als Informationsmeldung angezeigt.
Im Hintergrund verwendet DeltaSpike das Locale, das für den aktuellen JSF-Request aktiv ist, und
fügt die erzeugte  <span class='latex-texttt'>FacesMessage</span> -Instanz dem aktuellen  <span class='latex-texttt'>FacesContext</span>  hinzu.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_jsf-message'></a>                     <pre><code>@ViewController
public class LoginViewCtrl {
  //...

  @Inject
  private JsfMessage&lt;UserMessage&gt; userMessage;

  public Class&lt;? extends Pages.Idea&gt; login() {
    userService.login(email, password);

    final Class&lt;? extends Pages.Idea&gt; navigationTarget;
    if (userHolder.isLoggedIn()) {
      userMessage.addInfo()
        .welcomeNewUser(
          userHolder.getAuthenticatedUser().getNickName());
      navigationTarget = Pages.Idea.Overview.class;
    } else {
      userMessage.addError().loginFailed();
      navigationTarget = null;
    }

    return navigationTarget;
  }

  //...
}
</code></pre>
                </div> 
Typsichere Messages können auch in EL-Ausdrücken verwendet werden.
Hierfür muss das mit  <span class='latex-texttt'>@MessageBundle</span>  annotierte Interface zusätzlich mit  <span class='latex-texttt'>@Named</span>  annotiert werden.
Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_messages_and_el'> EL Integration für typsichere Nachrichten </a>  zeigt den entsprechenden Teil von  <span class='latex-texttt'>UserMessage</span> ,
der mit dem EL-Ausdruck  <span class='latex-texttt'>#{userMessage.warning()}</span>  angesprochen werden kann.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_messages_and_el'></a>                     <pre><code>@Named
@MessageBundle
public interface UserMessage {
  //...

  @MessageTemplate("Warning!")
  String warning();
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Mit  <span class='latex-texttt'>@MessageBundle</span>  annotierte Interfaces können zusätzlich mit  <span class='latex-texttt'>@MessageContextConfig</span>  versehen werden.
Mit dieser Annotation ist es möglich das Standardverhalten über entsprechende SPI-Implementierungen abzuändern.
So kann beispielsweise eigene Locale-Logik mit einem  <span class='latex-texttt'>LocaleResolver</span>  umgesetzt werden oder
beliebige Message-Quellen referenziert oder ein eigener  <span class='latex-texttt'>MessageResolver</span>  integriert werden. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> 
JSF-Seiten können nicht nur mit typsicheren Nachrichten verbessert werden.
Auch  <span class='latex-texttt'>POST</span> -Requests können mit einer Komponente namens  <span class='latex-texttt'>preventDoubleSubmit</span>  "sicherer" gemacht werden.
Diese Komponente ist im Namespace  <span class='latex-texttt'>http://deltaspike.apache.org/jsf</span>  verfügbar und
stellt sicher, dass ein  <span class='latex-texttt'>POST</span> -Request nicht mehrfach gesendet werden kann.
Hierfür muss, wie in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_preventDoubleSubmit'> Verwendung von preventDoubleSubmit </a> , die Komponente in einer JSF-Form eingebettet werden.
Im Hintergrund wird ein eindeutiger Request-Token verwendet, der serverseitig überprüft wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_preventDoubleSubmit'></a>                     <pre><code>&lt;h:form&gt;
  &lt;!-- ... --&gt;
  &lt;ds:preventDoubleSubmit/&gt;
&lt;/h:form&gt;
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Für Ajax-Requests via  <span class='latex-texttt'>POST</span>  übernimmt laut Spezifikation JSF selbst das entsprechende Management.
Daher wird für solche Requests keine Überprüfung eines Request-Tokens durchgeführt. </div> 
  <br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.6' ><span class='entry-number'>5.6</span> Bestehendes verbessern</a> </h2>
 DeltaSpike bereichert CDI und Java EE im Allgemeinen.
Darüber hinaus werden bestehende Konzepte verbessert.
Ein Beispiel hierfür ist die Annotation  <span class='latex-texttt'>@JsfPhaseListener</span> , die in Listing  <a href='#!idx:/deltaspike.html:fig:phase-listener_as_cdi-bean'> PhaseListener als CDI-Bean </a>  verwendet wird.
JSF Phase-Listener können mit dieser Annotation markiert werden, um sie automatisch zu aktivieren.
Daher entfällt die sonst übliche Konfiguration in der Datei  <span class='latex-texttt'>faces-config.xml</span> .
Optional kann eine Priorität via  <span class='latex-texttt'>@JsfPhaseListener#ordinal</span>  angegeben werden und
andere CDI-Beans können in den Phase-Listener injiziert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:phase-listener_as_cdi-bean'></a>                     <pre><code>@JsfPhaseListener
public class DebugPhaseListener implements PhaseListener {
  //...
}
</code></pre>
                </div> 
Darüber hinaus kann  <span class='latex-texttt'>@JsfPhaseListener</span>  mit  <span class='latex-texttt'>@Exclude</span>  kombiniert werden.
Der in Listing  <a href='#!idx:/deltaspike.html:fig:conditional_activation_of_a_phase-listener'> PhaseListener bedingt aktivieren </a>  dargestellte JSF Phase-Listener wird durch die Verwendung von
 <span class='latex-texttt'>@Exclude(exceptIfProjectStage = ProjectStage.Development.class)</span>  nur aktiviert,
wenn der Wert  <span class='latex-texttt'>Development</span>  für den Project-Stage gesetzt ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:conditional_activation_of_a_phase-listener'></a>                     <pre><code>@JsfPhaseListener
@Exclude(exceptIfProjectStage = ProjectStage.Development.class)
public class DebugPhaseListener implements PhaseListener {
  private static final Logger LOG =
    Logger.getLogger(DebugPhaseListener.class.getName());

  @Override
  public void beforePhase(PhaseEvent event) {
    LOG.info("before " + event.getPhaseId());
  }

  @Override
  public void afterPhase(PhaseEvent event) {
    LOG.info("after " + event.getPhaseId());
  }

  @Override
  public PhaseId getPhaseId() {
    return PhaseId.ANY_PHASE;
  }
}
</code></pre>
                </div> Ebenfalls verbessert wird das Fenstermanagement, das seit JSF 2.2 optional aktiviert werden kann.
Das Ziel dieser Funktionalität ist die korrekte Behandlung von verschiedenen Browser-Fenstern/Tabs,
da dies nicht durch den Session-Scope unterstützt wird.
Die abstrakte Klasse  <span class='latex-texttt'>javax.faces.lifecycle.ClientWindow</span>  wurde auf Basis von Erfahrungen aus Frameworks wie MyFaces CODI definiert und
diente als Vorlage für das gleichnamige Interface  <span class='latex-texttt'>org.apache.deltaspike.jsf.spi.scope.window.ClientWindow</span> ,
das auch mit JSF 2.0 bzw. 2.1 verwendet werden kann.
Vor JSF 2.2 muss für ein vollständig korrektes Fenstermanagement die Komponente  <span class='latex-texttt'>windowId</span> aus dem Namespace  <span class='latex-texttt'>http://deltaspike.apache.org/jsf</span>  in jede Seite eingebunden werden.
In  <span class='latex-textit'>IdeaFork</span>  fügen wir diese Komponente daher am Ende des Templates ein.
Listing  <a href='#!idx:/deltaspike.html:fig:activate_window-handling'> Fenstermanagement aktivieren </a>  zeigt den entscheidenden Ausschnitt aus der Datei  <span class='latex-texttt'>main-template.xhtml</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:activate_window-handling'></a>                     <pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://java.sun.com/jsf/html"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:ds="http://deltaspike.apache.org/jsf"&gt;

&lt;!-- ... --&gt;

&lt;h:body&gt;
    &lt;!-- ... --&gt;
    &lt;ds:windowId/&gt;
&lt;/h:body&gt;
&lt;/html&gt;
</code></pre>
                </div> Seit JSF 2.2 kann zwischen dem Standard-Fenstermanagement der JSF Implementierung und dem von DeltaSpike gewählt werden.
Wird die  <span class='latex-texttt'>ClientWindow</span> -Funktionalität von JSF explizit per Konfiguration aktiviert,
dann verwendet DeltaSpike die Window-ID, die mit  <span class='latex-texttt'>javax.faces.lifecycle.ClientWindow#getId</span>  abgefragt werden kann und
deaktiviert das eigene Fenstermanagement automatisch.
Anderenfalls übernimmt DeltaSpike selbst das Fenstermanagement und
leitet die Information intern via  <span class='latex-texttt'>javax.faces.lifecycle.Lifecycle#attachWindow</span>  an JSF weiter,
wodurch JSF Implementierungen intern einige Optimierungen bei der Verwaltung vom serverseitigen Zustand der Komponenten durchführen können.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die korrekte serverseitige Zuordnung von Browser-Fenstern/Tabs ist erforderlich,
damit DeltaSpike zusätzliche Scopes zur Verfügung stellen kann.
Der einfachste dieser Scopes ist der Window-Scope,
da dieser mit einer Session je Browser-Fenster/Tab vergleichbar ist.
Das JSF-Modul von DeltaSpike aktiviert den zugrundeliegenden Window-Context vor dem Durchlauf des JSF Request-Lifecycles
über die Methode  <span class='latex-texttt'>org.apache.deltaspike.core.spi.scope.window.WindowContext#activateWindow</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:window-handling_via_window-context'> Fenstermanagement mit WindowContext </a>  verdeutlicht, dass das  <span class='latex-texttt'>WindowContext</span> -Interface auch verwendet werden kann
um beispielsweise nach einem Logout Window-scoped Beans mit Hilfe der Methode  <span class='latex-texttt'>WindowContext#closeWindow</span>  zu zerstören.
Anschließend kann der Window-Context für das aktuelle Fenster wieder über die Methode  <span class='latex-texttt'>WindowContext#activateWindow</span>  aktiviert werden.
Hierfür kann die vorherige Window-ID wiederverwendet werden,
da diese nach dem Aufruf von  <span class='latex-texttt'>WindowContext#closeWindow</span>  nicht mehr verwendet wird und
somit nicht schlechter als eine neu generierte ID ist.
Der Vorteil hierbei ist, dass wir uns nicht um die Aktualisierung der clientseitigen Window-ID kümmern müssen.
Je nachdem welche Implementierung von  <span class='latex-texttt'>ClientWindow</span>  aktiv ist, könnte dies nämlich mitunter sehr aufwändig werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:window-handling_via_window-context'></a>                     <pre><code>@Named("menuBean")
@Model //or just @RequestScoped, since @Named is overruled
public class MenuController {
  @Inject
  private WindowContext windowContext;

  //...

  public Class&lt;? extends ViewConfig&gt; logout() {
    resetWindowContext();
    userHolder.setAuthenticatedUser(null);
    return Pages.User.Login.class;
  }

  //...

  private void resetWindowContext() {
    String currentWindowId = windowContext.getCurrentWindowId();
    windowContext.closeWindow(currentWindowId);
    windowContext.activateWindow(currentWindowId);
  }
}
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span>  müssen wir durch die Aktivierung des Fenstermanagements sicherstellen,
dass die Window-ID bei manuellen Aufrufen nicht verloren geht.
Einen solchen Aufruf haben wir beispielsweise in  <span class='latex-texttt'>IdeaImportServlet</span> .
Listing  <a href='#!idx:/deltaspike.html:fig:explicit_window-handling'> Explizites Fenstermanagement </a>  veranschaulicht, wie die Window-ID manuell weitergereicht werden kann.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:explicit_window-handling'></a>                     <pre><code>@WebServlet("/idea/import")
@MultipartConfig
public class IdeaImportServlet extends HttpServlet {
  @Inject
  private ActiveUserHolder userHolder;

  @Inject
  private FileUploadService fileUploadService;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  @Inject
  private WindowContext windowContext;

  protected void doPost(HttpServletRequest request,
                        HttpServletResponse response)
        throws ServletException, IOException {

    fileUploadService.storeUploadedFiles(
      request.getParts(), userHolder.getAuthenticatedUser());

    ViewConfigDescriptor viewConfigDescriptor = viewConfigResolver
      .getViewConfigDescriptor(Pages.Import.Summary.class);

    request.getRequestDispatcher(
      viewConfigDescriptor.getViewId() +
      "?dswid=" + request.getParameter("dswid"))
      .forward(request, response);
  }
}
</code></pre>
                </div> Gleiches gilt für unser manuelles Formular auf der Seite  <span class='latex-texttt'>upload.xhtml</span> .
Bei manuell definierten Formularen und Links müssen wir die aktuelle Window-ID explizit hinzufügen,
da dies weder DeltaSpike noch JSF selbst übernehmen kann, wie es bei den äquivalenten JSF-Komponenten umgesetzt ist.
In Listing  <a href='#!idx:/deltaspike.html:fig:window-id_in_el-expressions'> Window-ID in EL-Ausdrücken </a>  wird die aktuelle Window-ID mit dem EL-Ausdruck
 <span class='latex-texttt'>#{dsWindowContext.currentWindowId}</span>  im Markup der Seite hinzugefügt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:window-id_in_el-expressions'></a>                     <pre><code>&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                template="/templates/main-template.xhtml"&gt;

  &lt;ui:define name="content-container"&gt;
    &lt;div class="panel panel-default"&gt;
      &lt;!-- ... --&gt;
      &lt;div class="panel-body"&gt;
        &lt;form method="post" enctype="multipart/form-data"
          action="#{jsf.contextPath}/idea/import?dswid=
                  #{dsWindowContext.currentWindowId}"&gt;
                 &lt;!-- ... --&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/ui:define&gt;
&lt;/ui:composition&gt;
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span>  haben wir außerdem an einer zweiten Stelle einen selbst erzeugten HTML-Link.
Listing  <a href='#!idx:/deltaspike.html:fig:window-id_with_html-links'> Window-ID bei HTML-Links </a>  zeigt, dass wir auch diesen mit der aktuellen Window-ID erweitern müssen,
damit das Fenstermanagement serverseitig zuverlässig funktioniert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:window-id_with_html-links'></a>                     <pre><code>&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:h="http://java.sun.com/jsf/html"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                template="/templates/main-template.xhtml"&gt;
  &lt;!-- ... --&gt;

  &lt;ui:define name="content"&gt;
    &lt;!-- ... --&gt;
    &lt;a href="#{jsf.contextPath}/public/idea/export/all?dswid=
        #{dsWindowContext.currentWindowId}" class="btn"&gt;
      &lt;span class="glyphicon glyphicon-import"/&gt; Export My Ideas
    &lt;/a&gt;

    &lt;!-- ... --&gt;
  &lt;/ui:define&gt;
&lt;/ui:composition&gt;
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Die explizite Angabe der Window-ID kann entfallen, wenn JSF-Komponenten statt HTML-Tags verwendet werden.
Soll dies hingegen bewusst nicht gemacht werden,
so muss beispielsweise eine JSF Command-Komponente in die DeltaSpike-Komponente  <span class='latex-texttt'>disableClientWindow</span>  eingebettet werden.
Der gerenderte Link bzw. Button erhält dadurch keine Window-ID. </div> Bei welchen Beans der Window-Scope sinnvoll ist, hängt stark von den konkreten Anforderungen ab.
In  <span class='latex-textit'>IdeaFork</span>  können wir ein zusätzliches Konzept einführen, um einen möglichen Anwendungsfall zu illustrieren.
Bisher wurden auch Navigationen zur vorherigen Seite fix definiert.
Dies können wir generisch umsetzen, indem wir einen  <span class='latex-texttt'>BackNavigator</span>  einführen,
der die bisherige Navigationshistorie je Browser-Fenster/Tab serverseitig aufzeichnet.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_WindowScope_and_PreViewConfigNavigateEvent'> Verwendung von @WindowScoped und PreViewConfigNavigateEvent </a>  zeigt eine erste Version von  <span class='latex-texttt'>BackNavigator</span> ,
die mit  <span class='latex-texttt'>@WindowScoped</span>  annotiert ist.
Dies ermöglicht, dass wir mit einem CDI-Observer für das Event  <span class='latex-texttt'>PreViewConfigNavigateEvent</span>  die Navigationshistorie
je Browser-Fenster/Tab speichern können.
DeltaSpike feuert dieses Event für jede JSF-Navigation, für die eine typsichere View-Config verwendet wird.
In  <span class='latex-textit'>IdeaFork</span>  gibt es für jede JSF-Seite bereits eine typsichere Konfiguration,
wodurch wir problemlos dieses Event zur Umsetzung des Anwendungsfalles verwenden können.
Über dieses Event kann in der Observer-Methode sogar das Navigationsziel verändert werden.
In der Methode  <span class='latex-texttt'>BackNavigator#onNavigation</span>  ist keine Änderung erforderlich,
da diese Methode nur die Navigationshistorie aufzeichnen muss.
Da wir nicht auf jeder Seite einen expliziten Back-Button haben, können wir die aufgezeichnete Navigationshistorie auf
beispielsweise 10 Einträge beschränken, um ein Speicherleck zu vermeiden.
Etwas später werden wir diesen fix definierten Maximalwert durch ein eleganteres Konzept ersetzen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die Klasse  <span class='latex-texttt'>BackNavigator</span>  enthält zusätzlich eine zweite Observer-Methode namens  <span class='latex-texttt'>#onFacesRequestEnd</span> ,
die aufgerufen wird, bevor der  <span class='latex-texttt'>FacesContext</span>  am Ende eines Requests zerstört wird.
Dies wird durch den Qualifier  <span class='latex-texttt'>org.apache.deltaspike.core.api.lifecycle.Destroyed</span>  ermöglicht,
der hier in Kombination mit  <span class='latex-texttt'>FacesContext</span>  als Event-Typ verwendet werden kann.
Eine solche Observer-Methode ist eine einfache Alternative zu einem  <span class='latex-texttt'>@PreDestroy</span> -Callback eines Request-scoped Beans und
bietet zusätzlich den Vorteil, dass bei Bedarf noch auf den aktuellen  <span class='latex-texttt'>FacesContext</span>  zugegriffen werden kann.
In unserem Fall setzen wir das Flag  <span class='latex-texttt'>backNavigationActive</span>  zurück,
da dieses sonst bei einem nachfolgenden Request noch den alten Zustand haben könnte.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_WindowScope_and_PreViewConfigNavigateEvent'></a>                     <pre><code>@Named
@WindowScoped
public class BackNavigator implements Serializable {
  private Stack&lt;Class&lt;? extends ViewConfig&gt;&gt; previousViewStack =
    new Stack&lt;Class&lt;? extends ViewConfig&gt;&gt;();

  private boolean backNavigationActive;

  public Class&lt;? extends ViewConfig&gt; toPreviousView() {
    backNavigationActive = true;
    return previousViewStack.pop();
  }

  protected void onNavigation(
      @Observes PreViewConfigNavigateEvent navigateEvent) {

    Class&lt;? extends ViewConfig&gt; previousView =
      navigateEvent.getFromView();

    if (previousView != null && !this.backNavigationActive &&
       (previousViewStack.isEmpty() ||
        !previousViewStack.peek().equals(previousView))) {

      previousViewStack.push(previousView);

      if (previousViewStack.size() &gt; 10) {
        previousViewStack.remove(0);
      }
    }
  }

  protected void onFacesRequestEnd(
      @Observes(notifyObserver = IF_EXISTS) @Destroyed
      FacesContext facesContext) {

    this.backNavigationActive = false;
  }
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Die Observer-Methode  <span class='latex-texttt'>#onFacesRequestEnd</span>  selbst wird nur aufgerufen, wenn  <span class='latex-texttt'>BackNavigator</span>  bereits verwendet wurde.
Dies ist nur erforderlich, da  <span class='latex-texttt'>BackNavigator</span>  im Window-Context abgelegt wird und
dieser beim ersten Request in einem Browser-Fenster/Tab nicht aktiv sein muss.
Der Grund hierfür ist rein technisch. Abhängig vom konfigurierten Modus für das Fenstermanagement ist es möglich,
dass ein initialer Request durch einen Redirect an die gleiche URL abgebrochen wird,
damit der angefragten URL die neu erzeugte Window-ID hinzugefügt werden kann.
Dies ist beispielsweise erforderlich, um bei einem Browser-Refresh einer Seite die Window-ID nicht zu verlieren. </div> In JSF-Seiten kann dieser Mechanismus mit dem EL-Ausdruck  <span class='latex-texttt'>#{backNavigator.toPreviousView}</span>  verwendet werden.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_BackNavigator'> Verwendung von BackNavigator </a>  zeigt einen entsprechenden Button,
der in  <span class='latex-textit'>IdeaFork</span>  auf der Seite  <span class='latex-texttt'>profile.xhtml</span>  verwendet wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_BackNavigator'></a>                     <pre><code>&lt;h:commandButton class="btn btn-default" value="Back"
                 action="#{backNavigator.toPreviousView}"/&gt;
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Der Window-Context speichert Beans gruppiert nach der Window-ID in der aktuellen Session ab.
Somit werden Window-scoped Beans ebenfalls repliziert, sobald in einem Cluster Session-Replication durchgeführt wird.
Folglich werden Window-scoped Beans auch automatisch zerstört, sobald eine Session geschlossen wird. </div> Eine noch komfortablere Alternative zu  <span class='latex-texttt'>@WindowScoped</span>  ist ein Scope
der auf dem Window-Scope basiert und eine effizientere Speichernutzung ermöglicht.
Hierbei handelt es sich um den sogenannten View-Access Scope.
Kurz zusammengefasst existieren  <span class='latex-texttt'>@ViewAccessScoped</span>  Beans für eine JSF-Seite, sobald auf sie zugegriffen wird und
werden erst wieder entsorgt, wenn nach einer JSF-Navigation auf eine andere Seite nicht mehr auf sie zugegriffen wird.
Dies ist sehr ähnlich dem View-Scope von JSF selbst.
Der Hauptunterschied liegt darin,
dass View-Access-scoped Beans nicht durch die Navigation auf eine andere Seite vor dem Rendering-Prozess zerstört werden.
Erst wenn während des Renderings der neuen Seite nicht mehr auf ein Bean zugegriffen wird, erfolgt die Zerstörung dieser einen Contextual-Instance.
Somit kann jede Instanz, die in diesem Context abgelegt ist, eine eigene Lebensdauer haben.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Wird beispielsweise in einem Wizard ein  <span class='latex-texttt'>@ViewAccessScoped</span>  Bean als Wizard-Controller verwendet und
somit bei jedem Wizard-Schritt angesprochen, so steht das  <span class='latex-texttt'>@ViewAccessScoped</span>  Bean für den gesamten Wizard zur Verfügung und
wird automatisch von DeltaSpike entsorgt, sobald der Wizard beendet wird und die nachfolgende Seite den Wizard-Controller nicht mehr verwendet.
Im Hintergrund sammelt der View-Access Kontext die Contextual-Instances in einem  <span class='latex-texttt'>@WindowScoped</span>  Bean.
Aus diesem Grund werden  <span class='latex-texttt'>@ViewAccessScoped</span>  Beans per Definition je Browser-Fenster/Tab verwaltet, und
sobald die Session oder der Window-Context beendet wird, werden auch alle  <span class='latex-texttt'>@ViewAccessScoped</span>  Beans zerstört.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div class="tip"><b>Tipp: </b><b>Lebenszyklus von @ViewAccessScoped im Detail:</b> Eine <span class='latex-texttt'>@ViewAccessScoped</span>-Bean-Instanz wird beim ersten Zugriff auf einer JSF-Seite erzeugt und bleibt aktiv, solange nachfolgende Requests dieselbe Bean referenzieren. Beim Wechsel zu einer neuen Seite, die diese Bean nicht mehr verwendet, wird die Instanz nach dem Rendering der neuen Seite zerstört. Dies ermöglicht seitenübergreifende Workflows (z.B. Master-Detail-Navigation), ohne die gesamte Session zu belasten. In Quarkus existiert kein direktes Äquivalent &mdash; die clientseitige Alternative in Angular wird in Kapitel <a href='#!idx:/angular.html:11.4'>11.4</a> beschrieben.</div>
Im vorherigen Schritt haben wir im Seitentemplate von  <span class='latex-textit'>IdeaFork</span>  bereits mit der Komponente  <span class='latex-texttt'>windowId</span>  dafür gesorgt,
dass das Fenstermanagement vollständig aktiviert ist.
Daher können wir ohne weitere Vorbereitungen die View-Controller Beans in  <span class='latex-textit'>IdeaFork</span>  auf den View-Access Scope umstellen.
Hierfür stellen wir die Stereotyp-Annotation  <span class='latex-texttt'>@ViewController</span>  um.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ViewAccessScoped'> Verwendung von @ViewAccessScoped </a>  zeigt die neue Implementierung dieser Annotation,
in der wir statt  <span class='latex-texttt'>@RequestScoped</span>  die Annotation  <span class='latex-texttt'>@ViewAccessScoped</span>  verwenden.
Da der View-Access-Scope wie der Session-Scope passivierbar ist, müssen wir lt. den CDI-Regeln,
die wir in Kapitel  <a href='#!idx:/cdi_basics.html:chap:cdi-basics'>  CDI Grundkonzepte </a>  kennengelernt haben,
sämtliche  <span class='latex-texttt'>@ViewController</span>  Beans mit dem Marker-Interface  <span class='latex-texttt'>java.io.Serializable</span>  versehen.
Außerdem haben wir in  <span class='latex-textit'>IdeaFork</span>  bisher einige  <span class='latex-texttt'>@ViewController</span>  Beans angepasst,
indem wir sie explizit als  <span class='latex-texttt'>@SessionScoped</span>  Beans definiert haben.
Dies ist jetzt nicht mehr erforderlich, da wir initial die Lebensdauer dieser View-Controller nur ein wenig ausdehnen wollten.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ViewAccessScoped'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Stereotype

@ViewAccessScoped
@Named
public @interface ViewController {
}
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span>  verwenden wir bisher zwei Listener für das  <span class='latex-texttt'>PreRenderView</span> -Event von JSF,
die mit dem Tag  <span class='latex-texttt'>f:event</span>  in den Seiten  <span class='latex-texttt'>index.xhtml</span>  und  <span class='latex-texttt'>list.xhtml</span>  eingebunden sind.
Als typsichere Alternative kann die Annotation  <span class='latex-texttt'>@PreRenderView</span>  von DeltaSpike für solche Callback-Methoden verwendet werden.
Da es im Normalfall mehrere View-Controller in einer Applikation gibt, muss eine Verbindung zwischen einer Seite und
dem zuständigen View-Controller definiert werden.
Hierfür kann beispielsweise die Annotation  <span class='latex-texttt'>@ViewControllerRef</span>  von DeltaSpike verwendet werden.
Es ist naheliegend, dass die Konfiguration des View-Controllers ebenfalls in der View-Config der Applikation vorgenommen wird.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ViewControllerRef'> Verwendung von @ViewControllerRef </a>  zeigt einen entsprechend erweiterten Ausschnitt der View-Config von  <span class='latex-textit'>IdeaFork</span> .
Als Wert wird die View-Controller-Klasse referenziert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ViewControllerRef'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  @ViewControllerRef(IndexViewCtrl.class)
  class Index implements Pages {}

  //...

  interface Idea extends SecuredPages {
    //...

    @ViewControllerRef(IdeaListViewCtrl.class)
    class List implements Idea {}
  }

  //...
}
</code></pre>
                </div> Diese Konfiguration ermöglicht typsichere Callback-Methoden im angegebenen CDI-Bean.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_PreRenderView'> Verwendung von @PreRenderView </a>  zeigt stellvertretend die Umsetzung in  <span class='latex-texttt'>IdeaListViewCtrl</span> ,
bei der die Methode  <span class='latex-texttt'>#onPreRenderView</span>  mit  <span class='latex-texttt'>@PreRenderView</span>  annotiert wird.
Dies ermöglicht, dass der dazugehörige  <span class='latex-texttt'>f:event</span> -Tag aus der JSF-Seite entfernt werden kann.
Im Falle von  <span class='latex-texttt'>@PreRenderView</span>  wird zur Laufzeit vor dem Rendering-Prozess überprüft, ob es für die zu rendernde Seite eine View-Config gibt,
die mit  <span class='latex-texttt'>@ViewControllerRef</span>  annotiert ist.
Ist dies der Fall, dann wird die mit  <span class='latex-texttt'>@PreRenderView</span>  annotierte Methode aufgerufen, sofern eine solche vorhanden ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_PreRenderView'></a>                     <pre><code>@ViewController
public class IdeaListViewCtrl implements Serializable {
  @Inject
  private IdeaService ideaService;

  @Inject
  private ActiveUserHolder userHolder;

  private List&lt;Idea&gt; ideaList;

  @PreRenderView
  public void onPreRenderView() {
    ideaList = ideaService.loadAllOfAuthor(
      userHolder.getAuthenticatedUser());
  }
  //...
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b><span class='latex-texttt'>@PreRenderView</span>  ist die gebräuchlichste View-Controller Annotation.
Weiters gibt es noch die View-Controller Annotationen  <span class='latex-texttt'>@InitView</span> ,  <span class='latex-texttt'>@PreViewAction</span>  und  <span class='latex-texttt'>@PostRenderView</span> .
 <span class='latex-texttt'>@InitView</span>  Callback-Methoden werden vor- oder nach einer JSF Request-Lifecycle Phase aufgerufen,
wenn die View-ID gesetzt ist bzw. wenn sich der Wert der View-ID geändert hat.
 <span class='latex-texttt'>@PreViewAction</span>  Callback-Methoden werden vor einer Action-Methode ausgeführt,
wobei die nachfolgende Action-Methode unabhängig von der konfigurierten Callback-Methode ist.
 <span class='latex-texttt'>@PostRenderView</span>  Callback-Methoden werden aufgerufen sobald der Rendering-Prozess der dazugehörigen Seite beendet ist.
So können beispielsweise Ressourcen freigegeben werden, ohne die Latenzzeit aus Sicht des Browsers zu erhöhen. </div> Bisher haben wir einige Aspekte des View-Config-Konzepts kennengelernt, die ohne zusätzlichen Aufwand direkt verwendet werden können.
Darüber hinaus erlaubt DeltaSpike eigene View-Config-Metadaten zu definieren, um eigene Konzepte umzusetzen.
Eigene Metadaten werden auf gleiche Art und Weise erstellt, wie die bereits verfügbaren Metadaten von DeltaSpike selbst.
Der einzige Unterschied liegt in der Auswertung. Während DeltaSpike die zur Verfügung gestellten Annotationen auswertet und
die entsprechenden Implementierungen enthält, werden selbst definierte Metadaten auf Basis der gleichen Regeln dem Metadatenmodell hinzugefügt,
das anschließend abgefragt werden kann.
Da es sich um eigene Metadaten handelt, muss natürlich entsprechende Logik umgesetzt werden,
die die gespeicherten Metadaten verwertet, indem die entsprechende Funktionalität aufgerufen wird.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  können wir beispielsweise die eigene Annotation  <span class='latex-texttt'>@EntryPoint</span>  anlegen.
Hierbei müssen grundsätzlich die standard Java-Regeln für Annotationen befolgt werden.
Wie in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ViewMetaData'> Verwendung von @ViewMetaData </a>  zu sehen ist, muss die Annotation  <span class='latex-texttt'>@EntryPoint</span> zusätzlich mit der Annotation  <span class='latex-texttt'>@ViewMetaData</span>  markiert werden,
damit DeltaSpike einen entsprechenden Eintrag im  <span class='latex-texttt'>ViewConfig</span> -Metadatenmodell erzeugt.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ViewMetaData'></a>                     <pre><code>@Target({TYPE})
@Retention(RUNTIME)
@Documented

@ViewMetaData
public @interface EntryPoint {
}
</code></pre>
                </div> Wie zuvor erwähnt ist es nicht genug, eine Annotation anzulegen.
Zusätzlich muss noch die dazugehörige Funktionalität umgesetzt werden.
Die Annotation  <span class='latex-texttt'>@EntryPoint</span>  soll in  <span class='latex-textit'>IdeaFork</span>  für die Markierung aller Seiten dienen,
die eigenständig sind.
Daher können gewisse angesammelte Daten zurückgesetzt werden, sobald auf solche Seiten navigiert wird.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_custom_view-metadata'> Verwendung von eigenen View-Metadaten </a>  zeigt einen Ausschnitt der View-Config von  <span class='latex-textit'>IdeaFork</span> bei dem einige Seitenkonfigurationen um die Annotation  <span class='latex-texttt'>@EntryPoint</span>  erweitert wurden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_custom_view-metadata'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  @ViewControllerRef(IndexViewCtrl.class)
  class Index implements Pages {}

  @Secured(UserAwareAccessDecisionVoter.class)
  interface SecuredPages extends Pages {}

  interface User extends Pages {
    @EntryPoint
    class Login extends DefaultErrorView {}

    @EntryPoint
    class Registration implements User {}

    class Profile implements SecuredPages {}
  }

  interface Idea extends SecuredPages {
    @EntryPoint
    class Overview implements Idea {}

    class Create implements Idea {}
    class Edit implements Idea {}

    @ViewControllerRef(IdeaListViewCtrl.class)
    class List implements Idea {}
    class Details implements Idea {}
  }

  //...
}
</code></pre>
                </div> Die bisherige Implementierung von  <span class='latex-texttt'>BackNavigator</span>  kann diese neue Marker-Annotation dazu nutzen, um die Navigationshistorie zurückzusetzen,
statt eine Obergrenze für die Einträge der Navigationshistorie zu definieren.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_EntryPointNavigationEvent'> Verwendung von EntryPointNavigationEvent </a>  zeigt einen Ausschnitt aus dem erweiterten  <span class='latex-texttt'>BackNavigator</span> .
In der Methode  <span class='latex-texttt'>#onNavigation</span>  wird auf die Überprüfung der fix definierten Obergrenze verzichtet.
Als Ausgleich gibt es eine Observer-Methode für das neu angelegte (Marker-)Event  <span class='latex-texttt'>EntryPointNavigationEvent</span> ,
in der die bisherige Navigationshistorie zurückgesetzt wird und anschließend die aktuelle Seite hinzugefügt wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_EntryPointNavigationEvent'></a>                     <pre><code>@Named
@WindowScoped
public class BackNavigator implements Serializable {
  //...

  protected void onNavigation(
      @Observes PreViewConfigNavigateEvent navigateEvent) {

    Class&lt;? extends ViewConfig&gt; previousView =
      navigateEvent.getFromView();

    if (previousView != null && !this.backNavigationActive &&
       (previousViewStack.isEmpty() ||
        !previousViewStack.peek().equals(previousView))) {

      previousViewStack.push(previousView);
    }
  }

  protected void onEntryPointNavigation(
      @Observes EntryPointNavigationEvent entryPointNavigationEvent) {

    this.previousViewStack.clear();
    this.previousViewStack.push(entryPointNavigationEvent.getView());
  }

  //...
}
</code></pre>
                </div> Da  <span class='latex-texttt'>EntryPointNavigationEvent</span>  ebenfalls ein eigenes Event ist,
muss dieses bei der Navigation zu einer mit  <span class='latex-texttt'>@EntryPoint</span>  markierten Seite erzeugt werden.
Daher erstellen wir in  <span class='latex-textit'>IdeaFork</span>  eine Klasse namens  <span class='latex-texttt'>EntryPointHandler</span> ,
die die in Listing  <a href='#!idx:/deltaspike.html:fig:assessments_of_custom_view-metadata'> Auswertung eigener View-Metadaten </a>  gezeigte Observer-Methode  <span class='latex-texttt'>#checkEntryPoints</span>  enthält.
 <span class='latex-texttt'>EntryPointNavigationEvent</span>  wird wie üblich über das injizierte Interface  <span class='latex-texttt'>javax.enterprise.event.Event</span>  gefeuert.
Damit dieses Event überhaupt gefeuert werden darf,
muss überprüft werden, ob die Seitenkonfiguration mit  <span class='latex-texttt'>@EntryPoint</span>  markiert ist.
Für solche Auswertungen stellt DeltaSpike das injizierbare Interface  <span class='latex-texttt'>ViewConfigResolver</span>  zur Verfügung.
Der Methode  <span class='latex-texttt'>#getViewConfigDescriptor</span>  kann die aktuelle View-ID übergeben werden,
die der aktuelle  <span class='latex-texttt'>FacesContext</span>  bzw. der aktuelle View-Root enthält.
Sofern es einen View-Config-Eintrag gibt, kann mit der Methode  <span class='latex-texttt'>ViewConfigDescriptor#getMetaData</span>  überprüft werden,
ob im  <span class='latex-texttt'>ViewConfigDescriptor</span>  dieser Seite die Annotation  <span class='latex-texttt'>@EntryPoint</span>  hinterlegt wurde.
Da wir dieses Event nicht feuern wollen, wenn der aktuelle Request von der gleichen Entry-Point Seite kommt,
können wir uns die View-Config-Klasse vom letzten Entry-Point merken.
Daher ist es naheliegend  <span class='latex-texttt'>EntryPointHandler</span>  vom Window-Context verwalten zu lassen,
weshalb wir die Klasse mit  <span class='latex-texttt'>@WindowScoped</span>  annotieren.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:assessments_of_custom_view-metadata'></a>                     <pre><code>@WindowScoped
public class EntryPointHandler implements Serializable {
  private Class&lt;? extends ViewConfig&gt; previousEntryPoint;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  @Inject
  private Event&lt;EntryPointNavigationEvent&gt; entryPointEvent;

  protected void checkEntryPoints(
      @Observes @BeforePhase(JsfPhaseId.RENDER_RESPONSE)
      PhaseEvent phaseEvent) {

    UIViewRoot viewRoot = phaseEvent.getFacesContext().getViewRoot();

    if (viewRoot == null) {
      return;
    }
    String viewIdToRender = viewRoot.getViewId();
    ViewConfigDescriptor viewConfigDescriptor =
      viewConfigResolver.getViewConfigDescriptor(viewIdToRender);

    if (viewConfigDescriptor == null) {
      return;
    }

    if (viewConfigDescriptor.getConfigClass()
        .equals(this.previousEntryPoint)) {

      return;
    }

    if (!viewConfigDescriptor
        .getMetaData(EntryPoint.class).isEmpty()) {

      this.previousEntryPoint =
        viewConfigDescriptor.getConfigClass();

      this.entryPointEvent.fire(
        new EntryPointNavigationEvent(
          viewConfigDescriptor.getConfigClass()));
    }
  }
}
</code></pre>
                </div> Es bedarf aber nicht immer eigener Metadaten, um Anpassungen vorzunehmen.
Soll beispielsweise nur der Name eines Verzeichnisses oder
einer Datei geändert werden, kann dies direkt mit Hilfe von  <span class='latex-texttt'>@Folder</span>  bzw.  <span class='latex-texttt'>@View</span>  gemacht werden.
Um weitere Funktionalitäten von DeltaSpike zu verwenden, erstellen wir einen Wizard, mit dem eigene Ideen promotet werden können.
Hierfür soll ein  <span class='latex-texttt'>PromotionRequest</span>  erzeugt werden können.
Promotion-Requests können durch andere User gesucht und promotet werden.
Promotete Ideen sollen anschließend auf der Startseite für alle User sichtbar sein.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der Wizard zur Erstellung eines Promotion-Requests soll aus den Seiten
 <span class='latex-texttt'>pages/promotion/step1.xhtml</span> ,  <span class='latex-texttt'>pages/promotion/step2.xhtml</span>  und  <span class='latex-texttt'>pages/promotion/summary.xhtml</span>  bestehen.
Listing  <a href='#!idx:/deltaspike.html:fig:custom_naming'> Explizite Vergabe von Namen </a>  veranschaulicht die Anpassung der Verzeichnis- und Dateinamen.
Das Konfigurationsinterface für das Verzeichnis des Wizards heißt  <span class='latex-texttt'>PromotionWizard</span> .
Der Pfad für dieses Verzeichnis lautet jedoch  <span class='latex-texttt'>pages/promotion/</span>  statt  <span class='latex-texttt'>pages/promotionWizard</span> ,
da das Interface mit  <span class='latex-texttt'>@Folder(name = "promotion")</span>  annotiert ist.
Die Konfigurationsklasse für die letzte Seite des Wizards heißt
in Listing  <a href='#!idx:/deltaspike.html:fig:custom_naming'> Explizite Vergabe von Namen </a>   <span class='latex-texttt'>Pages.PromotionWizard.FinalStep.class</span>  und
ist mit  <span class='latex-texttt'>@View(name = "summary")</span>  annotiert,
wodurch der Pfad für diese Seite ebenfalls angepasst wird und  <span class='latex-texttt'>pages/promotion/summary.xhtml</span>  lautet.
 <span class='latex-texttt'>Pages.PromotionWizard.FinalStep.class</span>  implementiert das Interface  <span class='latex-texttt'>PromotionWizard</span> ,
das  <span class='latex-texttt'>SecuredPages</span>  erweitert.
Da  <span class='latex-texttt'>SecuredPages</span>  selbst das Interface Pages erweitert, erbt  <span class='latex-texttt'>FinalStep</span>  über diese Vererbungshierarchie
in diesem Fall die Metadaten von Pages.
 <span class='latex-texttt'>@View(navigation = REDIRECT)</span>  wird jedoch nicht von  <span class='latex-texttt'>@View(name = "summary")</span>  überschrieben,
sondern DeltaSpike fügt die Informationen automatisch zusammen,
wodurch zur Laufzeit das Ergebnis  <span class='latex-texttt'>@View(name = "summary", navigation = REDIRECT)</span>  lautet.
Informationen werden jedoch nur zusammengeführt, wenn ein Wert nicht explizit angegeben wird.
Würden wir  <span class='latex-texttt'>FinalStep</span>  mit  <span class='latex-texttt'>@View(name = "summary", navigation = FORWARD)</span>  annotieren,
dann würden wir den Navigationsmodus, der ursprünglich durch das  <span class='latex-texttt'>Pages</span> -Interface definiert ist, überschreiben.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_naming'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Secured(UserAwareAccessDecisionVoter.class)
  interface SecuredPages extends Pages {}

  @Folder(name = "promotion")
  interface PromotionWizard extends SecuredPages {
    @EntryPoint
    @ViewControllerRef(PromotionWizardCtrl.class)
    class Step1 implements PromotionWizard {}

    class Step2 implements PromotionWizard {}

    @View(name = "summary")
    class FinalStep implements PromotionWizard {}
  }
}
</code></pre>
                </div> Bei Bedarf kann sogar eine komplett eigene Namenskonvention eingeführt werden.
 <span class='latex-texttt'>JsfBaseConfig</span>  definiert neben einigen anderen Konfigurationsoptionen auch Optionen für Default- <span class='latex-texttt'>NameBuilder</span> s
wie beispielsweise  <span class='latex-texttt'>JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER</span> .
Der hinterlegte Konfigurationskey heißt  <span class='latex-texttt'>org.apache.deltaspike.jsf.api.config.view.Folder$DefaultFolderNameBuilder</span>  und
ermöglicht eine eigene Implementierung von  <span class='latex-texttt'>org.apache.deltaspike.jsf.api.config.view.Folder$NameBuilder</span> ,
die über den bereits vorgestellten Konfigurationsmechanismus von DeltaSpike aktiviert und für die gesamte Applikation verwendet werden kann.
Alternativ kann die Namensgebung für einen Teil der View-Config angepasst werden.
Für Verzeichnisse ist dies durch  <span class='latex-texttt'>@Folder#folderNameBuilder</span>  möglich.
Listing  <a href='#!idx:/deltaspike.html:fig:change_single_paths'> Einzelne Pfade verändern </a>  zeigt, wie die View-Config von  <span class='latex-textit'>IdeaFork</span>  für den zweiten neuen Bereich erweitert werden kann,
wenn die Struktur der View-Config nicht der tatsächlichen Verzeichnisstruktur in der Applikation entsprechen soll.
Das Interface  <span class='latex-texttt'>PromotionSelectionArea</span>  ist mit
 <span class='latex-texttt'>@Folder(folderNameBuilder = PromotionSelectionArea.CustomFolderNameBuilder.class)</span>  annotiert,
um die Namenskonvention für diese Verzeichniskonfiguration zu ändern.
Unser Ziel ist es JSF-Seiten im Verzeichnis  <span class='latex-texttt'>/pages/promotion/selection</span>  abzulegen.
Die Verzeichniskonfiguration wird in Listing  <a href='#!idx:/deltaspike.html:fig:change_single_paths'> Einzelne Pfade verändern </a>  allerdings durch
 <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span>  repräsentiert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:change_single_paths'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(folderNameBuilder =
    PromotionSelectionArea.CustomFolderNameBuilder.class)
  interface PromotionSelectionArea extends SecuredPages {
    //...

    class CustomFolderNameBuilder
        extends Folder.DefaultFolderNameBuilder {

      //...
    }
  }
}
</code></pre>
                </div><span class='latex-texttt'>CustomFolderNameBuilder</span>  in Listing  <a href='#!idx:/deltaspike.html:fig:custom_folder-name-builder'> Eigener Folder-NameBuilder </a>  stellt die einfachste Variante dar,
wie ein einzelnes Verzeichnis geändert werden kann.
Bevor DeltaSpike die endgültigen Definitionen einer View-Config als unveränderlichen  <span class='latex-texttt'>ViewConfigDescriptor</span>  speichert,
steht die View-Config als veränderbare Node-Struktur zur Verfügung, wobei ViewConfigNode der Typ eines Nodes ist.
Wie View-Config Metadaten geändert werden können werden wir etwas später betrachten.
Da wir nur den Pfad eines Verzeichnisses verändern wollen,
genügt es die Klasse  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span>  mit dem Ergebnis der Methode  <span class='latex-texttt'>ViewConfigNode#getSource</span>  zu vergleichen.
Handelt es sich bei der Quelle um die fragliche Konfigurationsklasse, so wird das Flag  <span class='latex-texttt'>customPathUsed</span>  auf  <span class='latex-texttt'>true</span>  gesetzt,
damit die Methode  <span class='latex-texttt'>#isDefaultValueReplaced</span>  diese Information später zur Verfügung stellen kann.
Außerdem wird der String  <span class='latex-texttt'>"/pages/promotion/selection"</span>  zurückgegeben.
Die Erzeugung der restlichen Verzeichnisnamen wird an  <span class='latex-texttt'>DefaultFolderNameBuilder</span>  delegiert,
wodurch sich das Ergebnis für die anderen Verzeichniskonfigurationen nicht verändert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_folder-name-builder'></a>                     <pre><code>class CustomFolderNameBuilder extends Folder.DefaultFolderNameBuilder {
  private boolean customPathUsed = false;

  @Override
  public String build(Folder folder, ViewConfigNode viewConfigNode) {
    if (Pages.PromotionSelectionArea.class
        .equals(viewConfigNode.getSource())) {

      this.customPathUsed = true;
      return "/pages/promotion/selection";
    }
    return super.build(folder, viewConfigNode);
  }

  @Override
  public boolean isDefaultValueReplaced() {
    return super.isDefaultValueReplaced() || this.customPathUsed;
  }
}
</code></pre>
                </div> Üblicherweise implementieren eigene  <span class='latex-texttt'>NameBuilder</span>  eigene Namenskonventionen und ersetzen nicht nur einzelne Namen.
Solche  <span class='latex-texttt'>NameBuilder</span> -Implementierungen werden wie zuvor erwähnt global aktiviert.
Eine Umsetzung wie in Listing  <a href='#!idx:/deltaspike.html:fig:combine_customized_names'> Angepasste Namen kombinieren </a>  kann hingegen sinnvoll sein,
wenn eine Applikation noch keiner einheitlichen Namenskonvention folgt und
eine entsprechende Umstellung nur Schritt für Schritt durchgeführt wird.
 <span class='latex-texttt'>NameBuilder</span> -Implementierungen können nicht nur für Verzeichnisse, sondern auch für Dateien angepasst werden.
Name-Builder für Verzeichnisse und Dateien sind unabhängig voneinander und
daher kann die View-Config wie in Listing  <a href='#!idx:/deltaspike.html:fig:combine_customized_names'> Angepasste Namen kombinieren </a>  mit  <span class='latex-texttt'>@View</span>  erweitert werden,
um zusätzlich die Namen der Dateien explizit festzulegen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:combine_customized_names'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(folderNameBuilder =
    PromotionSelectionArea.CustomFolderNameBuilder.class)
  interface PromotionSelectionArea extends SecuredPages {

    @View(name = "list")
    @ViewControllerRef(PromotionRequestListViewCtrl.class)
    class ListPromotions implements PromotionSelectionArea {}

    @View(name = "promote")
    class SelectPromotion implements PromotionSelectionArea {}

    //...
  }
}
</code></pre>
                </div> Seit JSF 2.0 sind JSF-Actions auch via GET-Requests möglich.
Um Request-Parameter automatisch zu übernehmen kann dem Navigationsstring der Marker  <span class='latex-texttt'>"includeViewParams=true"</span>  hinzugefügt werden.
Hierfür stellt  <span class='latex-texttt'>@View</span>  ebenfalls eine typsichere Konfiguration bereit,
die in Listing  <a href='#!idx:/deltaspike.html:fig:navigation_parameters_via_view-config'> Navigationsparameter via View-Config </a>  zu sehen ist.
Auch Parameter können durch die Verwendung von  <span class='latex-texttt'>@NavigationParameter</span>  auf Ebene der View-Config angegeben werden.
Der Parameter-Wert kann dabei ein fixer String oder eine EL-Expression sein.
Als Alternative können Action-Methoden mit  <span class='latex-texttt'>@NavigationParameter</span>  bzw. mit  <span class='latex-texttt'>@NavigationParameter.List</span>  annotiert werden,
um Parameter auf bestimmte Action-Methoden zu beschränken.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:navigation_parameters_via_view-config'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(folderNameBuilder =
    PromotionSelectionArea.CustomFolderNameBuilder.class)
  interface PromotionSelectionArea extends SecuredPages {

    @View(name = "list", viewParams = INCLUDE)
    @NavigationParameter(key = "searchHint", value = "*")
    @ViewControllerRef(PromotionRequestListViewCtrl.class)
    class ListPromotions implements PromotionSelectionArea {}

    @View(name = "promote")
    class SelectPromotion implements PromotionSelectionArea {}

    //...
  }
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Sollen Parameter dynamisch hinzugefügt werden, dann müssten wir  <span class='latex-texttt'>NavigationParameterContext</span>  beispielsweise
in einen View-Controller injizieren und dynamisch dessen Methoden aufrufen. </div> Nach der erfolgreichen Anpassung einzelner Pfadangaben, betrachten wir die Controller der beiden neuen Bereiche genauer.
Bei der View-Config für den neuen Wizard haben wir einen View-Controller für  <span class='latex-texttt'>Pages.PromotionWizard.Step1.class</span>  festgelegt.
Der Wizard soll durchgängig von einem Controller namens  <span class='latex-texttt'>PromotionWizardCtrl</span>  gesteuert werden.
Hierfür bietet sich der zuvor vorgestellte View-Access-Scope an.
Allerdings wollen wir in unserem Fall die Lebensdauer des Controllers explizit definieren.
Am Ende des Wizards soll die Controller-Instanz sofort zerstört werden.
Wäre dies die einzige Anforderung, dann könnten wir den Conversation-Scope von CDI selbst verwenden.
Allerdings hat dieser einige Einschränkungen und
es kann sogar schlimmstenfalls zu unerwarteten  <span class='latex-texttt'>BusyConversationException</span>  bei Ajax-Requests kommen.
Aus diesen und anderen Gründen wurde in DeltaSpike ein eigenes Conversation-Konzept umgesetzt,
das genau wie  <span class='latex-texttt'>@WindowScoped</span>  und  <span class='latex-texttt'>@ViewAccessScoped</span>  von MyFaces CODI übernommen wurde.
In DeltaSpike wurde der Name der Annotation jedoch umbenannt und
somit stehen CODI-Conversations in DeltaSpike unter dem Namen Grouped-Conversations zur Verfügung.
Entsprechend heißt die dazugehörige Annotation  <span class='latex-texttt'>@GroupedConversationScoped</span>  und
wird in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_grouped-conversations'> Verwendung von gruppierten Conversations </a>  für  <span class='latex-texttt'>PromotionWizardCtrl</span>  verwendet.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Grouped-Conversations unterscheiden sich in einigen Aspekten von standardmäßigen CDI-Conversations.
Jedes Bean existiert in einer separaten Conversation, die nicht explizit gestartet werden muss.
Im Gegensatz hierzu gibt es beim CDI-Conversation-Scope nur eine große Conversation die explizit gestartet werden muss.
Der in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_grouped-conversations'> Verwendung von gruppierten Conversations </a>  gezeigte Ausschnitt von  <span class='latex-texttt'>PromotionWizardCtrl</span> zeigt zusätzlich wie die aktuelle Grouped-Conversation des Beans beendet werden kann.
 <span class='latex-texttt'>GroupedConversation</span>  stellt nur die Methode  <span class='latex-texttt'>#close</span>  zur Verfügung,
die in unserem Fall die aktuelle Instanz von  <span class='latex-texttt'>PromotionWizardCtrl</span>  sofort aus dem Grouped-Conversation-Context entfernt.
Die aktuelle Instanz existiert dann nur noch für die restliche Ausführungszeit der Methode, in der
 <span class='latex-texttt'>GroupedConversation#close</span>  aufgerufen wurde.
Für den nächsten (externen) Methodenaufruf wird eine neue Instanz der Klasse erzeugt und im Grouped-Conversation-Context gespeichert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_grouped-conversations'></a>                     <pre><code>@Named
@GroupedConversationScoped
public class PromotionWizardCtrl implements Serializable {
    @Inject
    private GroupedConversation conversation;

    //...

    public Class&lt;? extends Pages&gt; savePromotionRequest() {
        this.ideaService.requestIdeaPromotion(this.promotionRequest);
        this.conversation.close();
        return Pages.Index.class;
    }
}
</code></pre>
                </div> Da per Default jedes  <span class='latex-texttt'>@GroupedConversationScoped</span>  Bean in einer isolierten Conversation abgelegt wird,
kann es mehrere parallele und unabhängige Conversations geben.
Sollte es erforderlich werden alle aktiven Grouped-Conversations zu beenden,
dann kann auf  <span class='latex-texttt'>GroupedConversationManager</span>  zurückgegriffen werden.
Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_GroupedConversationManager'> Verwendung von GroupedConversationManager </a>  zeigt eine mögliche Erweiterung von  <span class='latex-texttt'>EntryPointHandler</span> ,
um bei jeder Entry-Point Seite alle Grouped-Conversations zu schließen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_GroupedConversationManager'></a>                     <pre><code>@WindowScoped
public class EntryPointHandler implements Serializable {
  private Class&lt;? extends ViewConfig&gt; previousEntryPoint;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  @Inject
  private GroupedConversationManager conversationManager;

  @Inject
  private Event&lt;EntryPointNavigationEvent&gt; entryPointEvent;

  protected void checkEntryPoints(
      @Observes @BeforePhase(JsfPhaseId.RENDER_RESPONSE)
      PhaseEvent phaseEvent) {

    //...

    if (!viewConfigDescriptor.getMetaData(EntryPoint.class).isEmpty()) {
      this.previousEntryPoint = viewConfigDescriptor.getConfigClass();
      this.conversationManager.closeConversations();
      this.entryPointEvent.fire(
        new EntryPointNavigationEvent(
          viewConfigDescriptor.getConfigClass()));
    }
  }
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Wird ein Bean nicht durch einen expliziten Methodenaufruf zerstört,
dann erfolgt dies sobald der Window-Context oder die darunter liegende Session geschlossen wird. </div> In dem neuen Seitenbereich, der durch  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span>  definiert ist,
soll man nicht einen Controller für alle Seiten verwenden, sondern jeweils einen eigenen.
Wird eine Idee auf der Seite  <span class='latex-texttt'>/pages/promotion/selection/promote.xhtml</span>  promotet,
dann sollen jedoch nicht alle (Grouped-)Conversations beendet werden und auch nicht nur der Controller dieser Seite.
Daher können wir für alle Controller-Beans im Seitenbereich  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span>  eine Gruppe definieren,
wodurch alle Beans einer Gruppe gesammelt beendet werden können.
Sollte es noch andere aktive  <span class='latex-texttt'>@GroupedConversationScoped</span>  Beans geben,
die einer anderen Gruppe zugeordnet sind, bleiben diese weiterhin aktiv.
Listing  <a href='#!idx:/deltaspike.html:fig:explicit_grouping_of_conversations'> Explizite Gruppierung von Conversations </a>  zeigt einen Ausschnitt aus den Klassen
 <span class='latex-texttt'>PromotionRequestListViewCtrl</span>  und  <span class='latex-texttt'>PromotionRequestSelectionViewCtrl</span> .
Beide Klassen sind zusätzlich zu der Annotation  <span class='latex-texttt'>@GroupedConversationScoped</span>  mit dem CDI-Qualifier  <span class='latex-texttt'>@ConversationGroup</span>  annotiert,
mit der die Gruppe typsicher angegeben wird.
Hierfür kann eine beliebige Klasse oder ein (Marker-)Interface verwendet werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:explicit_grouping_of_conversations'></a>                     <pre><code>@Named
@GroupedConversationScoped
@ConversationGroup(Pages.PromotionSelectionArea.class)
public class PromotionRequestListViewCtrl implements Serializable {

    //...
}

@Named
@GroupedConversationScoped
@ConversationGroup(Pages.PromotionSelectionArea.class)
public class PromotionRequestSelectionViewCtrl implements Serializable {

    //...
}
</code></pre>
                </div> Unser Ziel war es alle View-Controller des Seitenbereichs  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span>  gesammelt zu beenden.
Somit ist es naheliegend dieses Interface auch zur Gruppierung der Beans in Listing  <a href='#!idx:/deltaspike.html:fig:close_grouped_conversaitons'> Beenden von gruppierten Conversations </a>  wiederzuverwenden.
Eine Idee wird schließlich durch die Methode  <span class='latex-texttt'>PromotionRequestSelectionViewCtrl#promote</span>  promotet,
in der die gesamte (Conversation-)Gruppe durch den Aufruf von  <span class='latex-texttt'>GroupedConversationManager#closeConversationGroup</span>  beendet wird.
Als Parameter wird hier wieder die typsichere Gruppe, in diesem Fall  <span class='latex-texttt'>Pages.PromotionSelectionArea.class</span> , verwendet.<br /> <div class="tip"><b>Tipp: </b> Rein technisch kann für die Gruppierung von  <span class='latex-texttt'>@GroupedConversationScoped</span> -Beans
jede beliebige Klasse bzw. jedes Interface verwendet werden.
Normalerweise ist es jedoch naheliegend, beispielsweise die typsichere View-Config auch hier zu verwenden. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:close_grouped_conversaitons'></a>                     <pre><code>@Named
@GroupedConversationScoped
@ConversationGroup(Pages.PromotionSelectionArea.class)
public class PromotionRequestSelectionViewCtrl implements Serializable {

  @Inject
  private GroupedConversationManager conversationManager;

  public Class&lt;? extends Pages&gt; promote() {
    conversationManager
      .closeConversationGroup(Pages.PromotionSelectionArea.class);

    ideaService.promoteIdea(this.selectedPromotionRequest);
    return Pages.Index.class;
  }

  //...
}
</code></pre>
                </div> Der zuvor erstellte Wizard zur Erstellung eines Promotion-Requests funktioniert grundsätzlich.
Allerdings wird nicht sichergestellt, dass der Wizard über den festgelegten Entry-Point gestartet wird.
Durch Bookmarks oder die manuelle Eingabe der URL kann direkt zu einem beliebigen Wizard-Schritt gesprungen werden.
Dadurch kann es zu einem inkonsistenten Zustand in der Applikation kommen.
Um dies zu vermeiden, können wir eine weitere eigene Annotation für die View-Config erstellen.
Listing  <a href='#!idx:/deltaspike.html:fig:change_view-metadata'> View-Metadaten verändern </a>  zeigt eine mögliche Variante mit dem Namen  <span class='latex-texttt'>@Wizard</span> .
Im Gegensatz zu  <span class='latex-texttt'>@EntryPoint</span>  ist diese Annotation nicht nur mit  <span class='latex-texttt'>@ViewMetaData</span>  markiert,
sondern es wird zusätzlich ein  <span class='latex-texttt'>ConfigPreProcessor</span>  verwendet,
um die mit  <span class='latex-texttt'>@EntryPoint</span>  annotierte Seitenkonfiguration eines Wizards zu finden,
sofern der Entry-Point nicht explizit mit  <span class='latex-texttt'>Wizard#entryPoint</span>  angegeben wird.
Damit die nachfolgende Logik nicht unterschiedliche Konstellationen abdecken muss,
wird eine neue Instanz von  <span class='latex-texttt'>@Wizard</span>  mit Hilfe von  <span class='latex-texttt'>AnnotationInstanceProvider#of</span>  erzeugt und
die mit  <span class='latex-texttt'>@EntryPoint</span>  annotierte Seitenkonfiguration als Wert für  <span class='latex-texttt'>Wizard#entryPoint</span>  gesetzt.
Mit einer eigenen Literal-Klasse für  <span class='latex-texttt'>@Wizard</span>  kann das gleiche Ergebnis erzielt werden.
Durch die Verwendung von  <span class='latex-texttt'>AnnotationInstanceProvider</span>  ersparen wir uns daher primär die Erstellung einer solchen Literal-Klasse.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:change_view-metadata'></a>                     <pre><code>@Target({ TYPE })
@Retention(RUNTIME)
@Documented

@ViewMetaData(preProcessor = Wizard.EntryPointProcessor.class)
public @interface Wizard {
  Class&lt;? extends ViewConfig&gt; entryPoint() default ViewConfig.class;

  class EntryPointProcessor implements ConfigPreProcessor&lt;Wizard&gt; {
    @Override
    public Wizard beforeAddToConfig(
        Wizard wizard, ViewConfigNode viewConfigNode) {

      if (!ViewConfig.class.equals(wizard.entryPoint())) {
        return wizard;
      }

      for (ViewConfigNode childNode : viewConfigNode.getChildren()) {
        for (Annotation childMetaData : childNode.getMetaData()) {
          if (EntryPoint.class.equals(childMetaData.annotationType())) {
            Map&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();
            values.put("entryPoint", childNode.getSource());

            return AnnotationInstanceProvider.of(Wizard.class, values);
          }
        }
      }
      return wizard;
    }
  }
}
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_editable_view-metadata'> Verwendung änderbarer View-Metadaten </a>  zeigt die Verwendung von  <span class='latex-texttt'>@Wizard</span>  bei dem Interface  <span class='latex-texttt'>Pages.PromotionWizard</span> .
Die zuvor erwähnte Veränderung der Metadaten führt zur Laufzeit zu der Information
 <span class='latex-texttt'>@Wizard(entryPoint = Pages.PromotionWizard.Step1.class)</span> , die durch die Metadaten-Vererbung an
 <span class='latex-texttt'>Pages.PromotionWizard.Step1.class</span> ,  <span class='latex-texttt'>Pages.PromotionWizard.Step2.class</span>  und  <span class='latex-texttt'>Pages.PromotionWizard.FinalStep.class</span> vererbt wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_editable_view-metadata'></a>                     <pre><code>@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(name = "promotion")
  @Wizard
  interface PromotionWizard extends SecuredPages {
    @EntryPoint
    @ViewControllerRef(PromotionWizardCtrl.class)
    class Step1 implements PromotionWizard {}

    class Step2 implements PromotionWizard {}

    @View(name = "summary")
    class FinalStep implements PromotionWizard {}
  }
}
</code></pre>
                </div> Wie bei  <span class='latex-texttt'>@EntryPoint</span>  muss auch  <span class='latex-texttt'>@Wizard</span>  an der entsprechenden Stelle ausgewertet werden.
Dies kann ebenfalls in der Klasse  <span class='latex-texttt'>EntryPointHandler</span>  umgesetzt werden.
Die ursprüngliche Methode  <span class='latex-texttt'>#checkEntryPoints</span>  wird in Listing  <a href='#!idx:/deltaspike.html:fig:combined_assessment_of_custom_view-metadata'> Kombinierte Auswertung eigener Metadaten </a><span class='latex-texttt'>#checkEntryPointsAndWizardSteps</span>  genannt und
um einen zusätzlichen Block erweitert, in dem bei einer vorhandenen  <span class='latex-texttt'>@Wizard</span>  Annotation für die aktuelle Seite überprüft wird,
ob der Wizard ursprünglich über den referenzierten Entry-Point betreten wurde.
Ist dies nicht der Fall, dann wird über den injizierten  <span class='latex-texttt'>ViewNavigationHandler</span>  eine Navigation an diesen Entry-Point durchgeführt.
Somit kann es zu keinem inkonsistenten Zustand in der Applikation kommen, da der Wizard immer über den festgelegten Entry-Point betreten wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:combined_assessment_of_custom_view-metadata'></a>                     <pre><code>@WindowScoped
public class EntryPointHandler implements Serializable {
  private Class&lt;? extends ViewConfig&gt; previousEntryPoint;

  @Inject
  private ViewConfigResolver viewConfigResolver;

  @Inject
  private ViewNavigationHandler viewNavigationHandler;

  @Inject
  private GroupedConversationManager conversationManager;

  @Inject
  private Event&lt;EntryPointNavigationEvent&gt; entryPointEvent;

  protected void checkEntryPointsAndWizardSteps(
      @Observes @BeforePhase(JsfPhaseId.RENDER_RESPONSE)
      PhaseEvent phaseEvent) {

    //...

    if (!viewConfigDescriptor.getMetaData(EntryPoint.class).isEmpty()) {
      this.previousEntryPoint = viewConfigDescriptor.getConfigClass();
      this.conversationManager.closeConversations();
      this.entryPointEvent.fire(
        new EntryPointNavigationEvent(
          viewConfigDescriptor.getConfigClass()));
    } else if (!viewConfigDescriptor
                  .getMetaData(Wizard.class).isEmpty()) {

      Wizard wizard =
        viewConfigDescriptor.getMetaData(Wizard.class).iterator().next();

      Class&lt;? extends ViewConfig&gt; entryPointOfWizard =
        wizard.entryPoint();

      if (!entryPointOfWizard.equals(this.previousEntryPoint)) {
        this.viewNavigationHandler.navigateTo(entryPointOfWizard);
      }
    }
  }
}
</code></pre>
                </div> Die bisher implementierte Logik für  <span class='latex-texttt'>@Wizard</span>  stellt jedoch nicht sicher,
dass ein Wizard auch wirklich einen definierten Entry-Point besitzt.
Um dies während des Applikationsstartes zu überprüfen, kann ein  <span class='latex-texttt'>ConfigDescriptorValidator</span>  implementiert werden und
wie in Listing  <a href='#!idx:/deltaspike.html:fig:usage_of_ViewConfigRoot'> Verwendung von @ViewConfigRoot </a>  via  <span class='latex-texttt'>@ViewConfigRoot</span>  aktiviert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:usage_of_ViewConfigRoot'></a>                     <pre><code>@ViewConfigRoot(
  configDescriptorValidators = IdeaForkViewMetaDataValidator.class)
@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  //...

  @Folder(name = "promotion")
  @Wizard
  interface PromotionWizard extends SecuredPages {
    @EntryPoint
    @ViewControllerRef(PromotionWizardCtrl.class)
    class Step1 implements PromotionWizard {}

    class Step2 implements PromotionWizard {}

    @View(name = "summary")
    class FinalStep implements PromotionWizard {}
  }

  //...
}
</code></pre>
                </div> Implementierungen des Interfaces  <span class='latex-texttt'>ConfigDescriptorValidator</span>  können wie in
Listing  <a href='#!idx:/deltaspike.html:fig:implementation_of_ConfigDescriptorValidator'> Implementierung von ConfigDescriptorValidator </a>  logische Zusammenhänge von View-Config-Metadaten validieren.
In  <span class='latex-texttt'>IdeaForkViewMetaDataValidator</span>  wird validiert,
ob je  <span class='latex-texttt'>ViewConfigDescriptor</span> -Instanz maximal eine  <span class='latex-texttt'>@Wizard</span> -Instanz existiert und
der Default-Wert für  <span class='latex-texttt'>Wizard#entryPoint</span>  gegen einen konkreten Entry-Point ersetzt wurde.
Entweder durch die explizite Angabe mit der  <span class='latex-texttt'>@Wizard</span>  Annotation selbst oder durch die Kombination mit  <span class='latex-texttt'>@EntryPoint</span> ,
die wir anfänglich in  <span class='latex-texttt'>Wizard$EntryPointProcessor</span>  umgesetzt haben.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:implementation_of_ConfigDescriptorValidator'></a>                     <pre><code>public class IdeaForkViewMetaDataValidator
    implements ConfigDescriptorValidator {

  @Override
  public boolean isValid(ConfigDescriptor configDescriptor) {
    List&lt;Wizard&gt; wizardMetaData =
      configDescriptor.getMetaData(Wizard.class);

    if (wizardMetaData.isEmpty()) {
      return true;
    }

    if (wizardMetaData.size() &gt; 1) {
      throw new IllegalStateException("...");
    }

    Wizard wizardAnnotation = wizardMetaData.iterator().next();

    if (ViewConfig.class.equals(wizardAnnotation.entryPoint())) {
      throw new IllegalStateException("...");
    }

    return true;
  }
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Mit  <span class='latex-texttt'>@ViewConfigRoot</span>  kann nicht nur das View-Config Konzept erweitert oder angepasst werden,
sondern in Kombination mit beispielsweise  <span class='latex-texttt'>@ApplicationScoped</span>  ist diese Annotation erforderlich
wenn der seit CDI 1.1 verfügbare  <span class='latex-texttt'>bean-discovery-mode</span>   <span class='latex-texttt'>annotated</span>  aktiviert ist. </div> In diesem Kapitel haben wir unter anderem einige View-Config Mechanismen kennengelernt und
wie diese mit anderen Funktionalitäten von DeltaSpike kombiniert werden können.
Darüber hinaus stehen noch weitere Anpassungsmöglichkeiten und Annotationen zur Verfügung.
So kann beispielsweise mit  <span class='latex-texttt'>@ViewRef</span>  die Konfiguration von View-Controller dezentralisiert werden.
Im nachfolgenden Teil werden wir uns die Integration mit anderen Bibliotheken,
alternative Konzepte für Java EE Mechanismen und die frühzeitige Verwendung von EE7 Funktionalitäten in einer EE6 Applikation näher ansehen.<br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.7' ><span class='entry-number'>5.7</span> Flexibilität mit Alternativen</a> </h2>
 Bisher haben wir DeltaSpike in diesem Kapitel primär zur Erweiterung
von standard CDI-Konzepten bzw. von anderen Java EE Spezifikationen wie beispielsweise JSF verwendet.
Abgesehen von solchen Erweiterungen stellt DeltaSpike auch Alternativen zu bestehenden Java EE Konzepten zur Verfügung.
Einige Alternativen, wie beispielsweise typsichere Project-Stages und die typsichere JSF-Navigation, haben wir bereits kennengelernt.
In diesem Abschnitt geht es jedoch um Alternativen, die jeweils als eigenes Modul von DeltaSpike verfügbar sind.
Der Hauptunterschied zu den äquivalenten Mechanismen von Java EE ist die höhere Flexibilität.
Sämtliche Alternativen können beispielsweise auch außerhalb von Java EE Servern eingesetzt werden.
Außerdem ergeben sich durch zusätzliche Erweiterungspunkte neue Möglichkeiten, das Standardverhalten zu erweitern bzw. vollständig zu ändern.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Wir beginnen mit der Automatisierung eines Bereichs in  <span class='latex-textit'>IdeaFork</span> ,
den wir in diesem Kapitel neu hinzugefügt haben.
Bisher kann unser Config-Context nur manuell über JMX zurückgesetzt werden,
um eventuell geänderte Werte aus den Konfigurationsquellen erneut einzulesen.
Zusätzlich zu dieser Möglichkeit können wir in regelmäßigen Intervallen einen automatischen Reset der Beans im Config-Context durchführen,
damit die entsprechenden CDI-Beans und somit die geladenen Konfigurationswerte regelmäßig aktualisiert werden.<br />In Java EE würden wir hierfür die EJB Annotation  <span class='latex-texttt'>@javax.ejb.Schedule</span>  verwenden.
Der Vorteil dieser Annotation ist eine hohe Portabilität zwischen Java EE Servern.
Sobald wir eine Applikation außerhalb eines Java EE Servers deployen wollen,
müssten wir einen zusätzlichen Container wie beispielsweise die Embedded Version von Apache OpenEJB verwenden.
Alternativ ermöglicht das Scheduler-Modul von DeltaSpike die Verwendung von Quartz-Jobs als CDI-Beans.
Listing  <a href='#!idx:/deltaspike.html:fig:quartz-job_as_cdi-bean'> Quartz-Job als CDI-Bean </a>  veranschaulicht die Verwendung der Annotation  <span class='latex-texttt'>@org.apache.deltaspike.scheduler.api.Scheduled</span> .
In diesem Beispiel ist die Klasse  <span class='latex-texttt'>ConfigReloaderJob</span>  eine Implementierung von  <span class='latex-texttt'>org.quartz.Job</span> .
Durch die Annotation  <span class='latex-texttt'>@Scheduled</span>  wird dieser Quartz-Job automatisch aktiviert und CDI-basierte Injizierung verfügbar.
Aus diesem Grund ist keine zusätzliche Konfiguration erforderlich und das  <span class='latex-texttt'>ConfigReloader</span> -Bean kann wie gewohnt einfach injiziert werden.
Die Angabe eines CDI-Scopes für den Quartz-Job ist optional. Grundsätzlich kann jeder aktive Scope gewählt werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:quartz-job_as_cdi-bean'></a>                     <pre><code>@ApplicationScoped
@Scheduled(cronExpression = "0 0/10 * * * ?")
public class ConfigReloaderJob implements Job {
  @Inject
  private ConfigReloader configReloader;

  @Override
  public void execute(JobExecutionContext context)
    throws JobExecutionException {
      configReloader.reloadConfig();
  }
}
</code></pre>
                </div> Neben der Steuerung der Ausführungszeitpunkte mit Hilfe einer CRON-Expression kann auch die Context-Steuerung angepasst werden.
Der Default-Wert für  <span class='latex-texttt'>@Scheduled#startScopes</span>  ist  <span class='latex-texttt'>SessionScoped.class</span>  und  <span class='latex-texttt'>RequestScoped.class</span> .
Ohne eine explizite Angabe anderer Scope-Annotationen
wird im Hintergrund für jeden gestarteten Quartz-Job automatisch der Request- und Session-Scope gestartet und nach der Ausführung der
 <span class='latex-texttt'>#execute</span> -Methode wieder beendet.
Gestartet und gestoppt werden die angegebenen Contexte hierbei mithilfe von DeltaSpike CDI-Control,
das wir bei der Verwendung des Test-Control-Moduls noch im Detail kennenlernen werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die explizite Steuerung des Schedulers und einzelner Scheduler-Jobs kann optional über das
 <span class='latex-texttt'>org.apache.deltaspike.scheduler.spi.Scheduler</span> -SPI umgesetzt werden.
So ist es beispielsweise möglich, mit  <span class='latex-texttt'>@Scheduled(onStartup = false)</span>  die automatische Konfiguration eines
Scheduling-Jobs zu deaktivieren, um beispielsweise eine Contextual-Reference auf  <span class='latex-texttt'>Scheduler</span>  in ein beliebiges CDI-Bean zu injizieren und
einen solchen Scheduling-Job abhängig von einer Konfiguration manuell via  <span class='latex-texttt'>Scheduler#startJobManually</span>  auszuführen.<br /> <div class="tip"><b>Tipp: </b> Durch das  <span class='latex-texttt'>Scheduler</span> -SPI kann selbst Quartz als Scheduling-Framework ersetzt werden.
Sofern das favorisierte Scheduling-Framework mindestens Scheduling-Jobs auf Basis von CRON-Expressions unterstützt,
kann eine Implementierung von  <span class='latex-texttt'>org.apache.deltaspike.scheduler.spi.Scheduler</span>  als Adapter zu diesem Scheduling-Framework dienen. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ein weiteres Modul, das primär als CDI-basierte Alternative zu EJBs geschaffen wurde, ist das JPA-Modul von DeltaSpike.
Die Annotationen  <span class='latex-texttt'>@org.apache.deltaspike.jpa.api.transaction.Transactional</span> ,
 <span class='latex-texttt'>@org.apache.deltaspike.jpa.api.transaction.TransactionScoped</span>  und  <span class='latex-texttt'>@PersistenceUnitName</span> stellen die zentralen Bestandteile dieses Moduls dar.
Für die ersten beiden Annotationen gibt es seit Java EE 7 (bzw. JTA v1.2) gleichnamige Äquivalente,
wobei beide  <span class='latex-texttt'>@Transactional</span> -Varianten zwar grundsätzlich das gleiche Ziel haben,
dieses jedoch im Detail anders umsetzen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  werden Transaktionen bisher implizit durch EJBs auf Service-Ebene gesteuert.
Zusammengefasst wird eine Proxy-Instanz für den  <span class='latex-texttt'>EntityManager</span>  in der Klasse  <span class='latex-texttt'>EntityManagerProducer</span>  vom EE-Server injiziert.
Durch die selbst definierte CDI Producer-Methode können wir diesen  <span class='latex-texttt'>EntityManager</span>  in EJBs bzw. CDI-Beans typsicher injizieren.
Im Hintergrund erzeugt der EJB-Container je Transaktion eine neue  <span class='latex-texttt'>EntityManager</span> -Instanz.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/deltaspike.html:fig:entity-manager-producer_without_ejb'> EntityManager-Producer unabhängig von EJBs </a> zeigt wie wir mit dem JPA-Modul von DeltaSpike das gleiche Verhalten ohne EJBs umsetzen können.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:entity-manager-producer_without_ejb'></a>                     <pre><code>@ApplicationScoped
public class EntityManagerProducer {
  @PersistenceUnit(unitName = "ideaForkPU")
  private EntityManagerFactory entityManagerFactory;

  @Produces
  @Default
  @TransactionScoped
  protected EntityManager exposeEntityManagerProxy() {
    return entityManagerFactory.createEntityManager();
  }

  protected void onTransactionEnd(
    @Disposes @Default EntityManager entityManager) {
      if (entityManager.isOpen()) {
        entityManager.close();
      }
  }
}
</code></pre>
                </div> Da wir auf den EJB-Support verzichten, müssen wir auf die threadsichere  <span class='latex-texttt'>EntityManagerFactory</span>  ausweichen.
In einem EE-Server wird  <span class='latex-texttt'>EntityManagerFactory</span>  in Kombination mit  <span class='latex-texttt'>@PersistenceUnit</span>  durch den Container selbst injiziert.
Außerhalb eines EE-Servers müssten wir auf Plug-ins für den CDI-Container zurückgreifen.
OpenWebBeans stellt beispielsweise mit dem Resource-Modul ein entsprechendes Plugin zur Verfügung.
Dieses ist jedoch nicht portabel und somit nur mit OpenWebBeans verwendbar.
Ein portables Ergebnis können wir außerhalb des EE-Servers mit der Annotation
 <span class='latex-texttt'>@org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName</span>  erzielen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bevor wir diese Annotation verwenden betrachten wir das bisherige Vorgehen bei unseren Tests.
In  <span class='latex-textit'>IdeaFork</span>  verwenden wir für Unit-Tests In-Memory-Repositories.
Ein solches Vorgehen wird oft empfohlen, wenn nicht die Repositories selbst getestet werden.
Werden allerdings zu viele zentrale Klassen für Tests ausgetauscht, können Fehler oft nicht früh genug erkannt werden.
In den Tests von  <span class='latex-textit'>IdeaFork</span>  haben wir dies in der Test-Klasse  <span class='latex-texttt'>EventTest</span>  symbolisch illustriert.
Konkret rufen wir in verschiedenen Test-Methoden die Methode  <span class='latex-textit'>UserManager#createUserFor</span>  auf.
Danach werden Ideen für diesen User erzeugt und gespeichert.
Durch die In-Memory-Repositories im Test-Code ist jedoch nicht aufgefallen, dass die erzeugte User-Instanz nicht gespeichert wurde.
Dies fällt erst auf, wenn wir auch in den Tests die produktiven Repository-Implementierungen verwenden.
Um auch in Tests unsere normalen JPA-Repositories beizubehalten, löschen wir einfach die spezialisierten Repository-Implementierungen,
wodurch die produktiven Implementierungen wieder automatisch aktiv werden.
Wie zuvor erwähnt kann der in Listing  <a href='#!idx:/deltaspike.html:fig:entity-manager-producer_without_ejb'> EntityManager-Producer unabhängig von EJBs </a>  beschriebene CDI-Producer für den  <span class='latex-texttt'>EntityManager</span> nicht portabel außerhalb eines EE-Servers eingesetzt werden.
Stattdessen können wir im Testmodul die in Listing  <a href='#!idx:/deltaspike.html:fig:entity-manager-producer_for_tests'> Portabler Test-EntityManager-Producer </a>  ersichtliche spezialisierte Variante
der  <span class='latex-texttt'>EntityManagerProducer</span> -Klasse einführen.
Durch den Einsatz der Qualifier-Annotation  <span class='latex-texttt'>@PersistenceUnitName</span> können wir weiterhin den Injection-Point für  <span class='latex-texttt'>EntityManagerFactory</span>  automatisch befüllen lassen.
Die restliche Producer-Logik ist äquivalent zu  <span class='latex-texttt'>EntityManagerProducer</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:entity-manager-producer_for_tests'></a>                     <pre><code>@Specializes
public class TestEntityManagerProducer extends EntityManagerProducer {
  @Inject
  @PersistenceUnitName("ideaForkPU")
  private EntityManagerFactory entityManagerFactory;

  //...
}
</code></pre>
                </div> Die entsprechenden Änderungen sind im Git-Repository von  <span class='latex-textit'>IdeaFork</span>  in einem Commit zusammengefasst.
Dieser Commit zeigt zusätzlich, dass weitere Test-Dependencies für JPA in Unit-Tests und
eine eigene JPA-Konfiguration (siehe  <span class='latex-texttt'>META-INF/persistence.xml</span> ) erforderlich sind.
Beides ist unabhängig von CDI bzw. DeltaSpike und aus diesem Grund gehen wir auf diese Details nicht näher ein.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> An diesem Punkt haben wir den  <span class='latex-texttt'>EntityManagerProducer</span>  umgestellt, und
die erzeugte  <span class='latex-texttt'>EntityManager</span> -Instanz wird durch  <span class='latex-texttt'>@TransactionScoped</span>  im Transaction-Kontext für den aktuellen Thread abgelegt.
Der Transaction-Kontext ist jedoch nicht automatisch aktiv,
sondern wird durch den  <span class='latex-texttt'>@Transactional</span> -Interceptor von DeltaSpike aktiviert, da dieser Interceptor die Transaktionen steuert.
Aus diesem Grund kann  <span class='latex-texttt'>@TransactionScoped</span>  nur in Verbindung mit  <span class='latex-texttt'>@Transactional</span>  eingesetzt werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  haben wir die Transaktionsbehandlung bisher im EE6-Modul durch EJBs definiert.
Im Core von  <span class='latex-textit'>IdeaFork</span>  hatten wir somit keine transaktionalen Beans.
Unsere Umstellung von In-Memory-Repositories auf JPA-Repositories erfordert daher transaktionale Beans in  <span class='latex-textit'>IdeaFork</span> -Core.
Listing  <a href='#!idx:/deltaspike.html:fig:extended_stereotype'> Erweiterung eines Stereotyps </a>  zeigt die erforderliche Erweiterung der  <span class='latex-texttt'>@Repository</span> -Stereotype-Annotation.
Sobald wir die  <span class='latex-texttt'>@Transactional</span> -Annotation in unserer  <span class='latex-texttt'>@Repository</span> -Annotation hinzufügen
sind alle Repository-Implementierungen in  <span class='latex-textit'>IdeaFork</span>  transaktional.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:extended_stereotype'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Stereotype
@ApplicationScoped
@Monitored

@Transactional
public @interface Repository {
}
</code></pre>
                </div> Dies setzt allerdings CDI 1.1 bzw. Java EE7 voraus.
Mit CDI 1.0 und dadurch auch mit EE6 müssen wir den Interceptor noch in der Datei  <span class='latex-texttt'>META-INF/beans.xml</span>  angeben.
In manchen EE6-Servern, wie beispielsweise Apache TomEE, kann darauf bereits verzichtet werden und in anderen sind die BDA-Regeln so strikt umgesetzt,
dass der Interceptor in jedem CDI-Archiv erneut aktiviert werden muss.
In solchen Fällen muss die Klasse  <span class='latex-texttt'>org.apache.deltaspike.jpa.impl.transaction.TransactionalInterceptor</span> als Interceptor-Klasse,
wie es in Listing  <a href='#!idx:/deltaspike.html:fig:configure_transactional_interceptor_ee6'> Aktivierung von TransactionalInterceptor für EE6-Server </a>  ersichtlich ist, hinzugefügt werden.
Ohne diese Aktivierung würden die Annotation  <span class='latex-texttt'>@Transactional</span>  einfach ignoriert werden.<br />Listing  <a href='#!idx:/deltaspike.html:fig:configure_transactional_interceptor_ee6'> Aktivierung von TransactionalInterceptor für EE6-Server </a>  zeigt den erforderlichen Konfigurationseintrag.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:configure_transactional_interceptor_ee6'></a>                     <pre><code>&lt;beans&gt;
  &lt;!-- ... --&gt;

  &lt;interceptors&gt;
    &lt;!-- ... --&gt;
    &lt;class&gt;
      org.apache.deltaspike.jpa.impl.transaction.TransactionalInterceptor
    &lt;/class&gt;
  &lt;/interceptors&gt;

  &lt;!-- ... --&gt;
&lt;/beans&gt;
</code></pre>
                </div> Bei den Service-Implementierungen des EE6-Moduls von  <span class='latex-textit'>IdeaFork</span>  können wir einen ähnlichen Weg gehen.
Allerdings müssen wir hier erst eine Stereotype-Annotation anlegen.
Listing  <a href='#!idx:/deltaspike.html:fig:stereotype_for_transactional_services'> Stereotype für transaktionale Services </a>  veranschaulicht diese Stereotype-Annotation namens  <span class='latex-texttt'>@Service</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:stereotype_for_transactional_services'></a>                     <pre><code>@Target(TYPE)
@Retention(RUNTIME)

@Stereotype
@ApplicationScoped

@Transactional
public @interface Service {
}
</code></pre>
                </div> Beans, die mit diesem neuen  <span class='latex-texttt'>@Service</span> -Stereotype markiert sind, werden automatisch zu transaktionalen application-scoped Beans.
 <span class='latex-texttt'>@Transactional</span>  können wir entweder auf Klassenebene oder auf Methodenebene verwenden.
Durch die Verwendung von  <span class='latex-texttt'>@Transactional</span>  in den beiden Stereotype-Annotationen  <span class='latex-texttt'>@Repository</span>  und  <span class='latex-texttt'>@Service</span> ,
werden alle Methoden des annotierten CDI-Beans transaktional.
Würden wir stattdessen einzelne Methoden explizit mit  <span class='latex-texttt'>@Transactional</span>  annotieren,
dann würden nur diese Methoden in einer Transaktion ausgeführt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  sind sowohl Repository-Beans als auch Service-Beans transaktional,
damit Repository-Beans fein-granular und ohne zusätzliche Konstrukte getestet werden können bzw.
 <span class='latex-textit'>IdeaFork</span> -Core als eigenständiges Modul verwendbar ist.
Im EE6-Modul optimieren wir die Transaktionsgrenzen für die JSF-Applikation durch die Definition von transaktionalen Service-Beans.
Wir könnten somit neben dem EE6-Modul auch Module für andere UI-Technologien umsetzen,
die beispielsweise andere Anforderungen an Transaktionsgrenzen haben.
In jedem der möglichen Fälle stellt  <span class='latex-textit'>IdeaFork</span> -Core sicher,
dass zumindest Repository-Beans im Kontext einer aktiven Transaktion ausgeführt werden.
Beim Aufruf einer transaktionalen Methode überprüft DeltaSpike automatisch, ob für den aktuellen Thread bereits eine Transaktion aktiv ist.
Ruft eine transaktionale Service-Methode eine oder mehrere transaktionale Repository-Methode/n auf,
so wird nur eine Transaktion auf Service-Ebene gestartet und nach dem Aufruf wieder beendet.
Alle Repository-Aufrufe werden in dieser Konstellation im Transaktionskontext der Service-Methode ausgeführt und
erhalten daher keine eigene Transaktion.
Werden transaktionale Repository-Methoden hingegen von einem nicht-transaktionalen (CDI-)Bean aufgerufen,
dann wird jede Repository-Methode in einer eigenen Transaktion ausgeführt.
Daraus resultiert, dass eine Transaktion immer durch die äußerste transaktionale Methode gestartet und gestoppt wird.
Das Ergebnis ähnelt stark den Konzepten die durch EJBs definiert werden.
Ein großer Unterschied besteht darin, dass transaktionale CDI-Beans explizit mit  <span class='latex-texttt'>@Transactional</span>  markiert werden müssen.
Außerdem ist die Transaktionsstrategie von DeltaSpike bei Bedarf anpassbar.<br />Mit diesen Informationen können wir unsere bisherigen EJBs auf transaktionale CDI-Beans umstellen.
Listing  <a href='#!idx:/deltaspike.html:fig:transactional_cdi-beans_instead_of_ejbs'> Transaktionale CDI-Beans statt EJBs </a>  veranschaulicht diese Umstellung stellvertretend für  <span class='latex-texttt'>IdeaService</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:transactional_cdi-beans_instead_of_ejbs'></a>                     <pre><code>//old
@Stateless
public class IdeaService {
  @Inject
  private IdeaManager ideaManager;

  //...
}

//new
@Service
public class IdeaService {
  @Inject
  private IdeaManager ideaManager;

  //...
}
</code></pre>
                </div> Auch möglicherweise aufgetretene Exceptions werden auf dieser obersten Ebene behandelt.
Wird eine transaktionale Methode von einer anderen transaktionalen Methode aufgerufen,
dann wird die Transaktion erst zurückgerollt wenn die äußerste transaktionale Methode eine Exception nicht fängt und behandelt bzw. selbst wirft.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der Commit im Git-Repository enthält auch eine Änderung in der Klasse  <span class='latex-texttt'>AppStructureValidationExtension</span> .
Diese Änderung ist erforderlich, da die Service-Implementierungen in  <span class='latex-textit'>IdeaFork</span>  keine EJBs mehr sind,
sondern mittlerweile mit @Service annotiert werden sollen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bei der Verwaltung von Transaktionen stellt DeltaSpike mehrere Varianten bereit und
ermöglicht zusätzlich die Umsetzung eigener Konzepte.
Dies ist durch das  <span class='latex-texttt'>org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy</span> -SPI möglich.
In  <span class='latex-texttt'>TransactionalInterceptor</span>  wird ein CDI-Bean injiziert, das dieses Interface implementiert.
Standardmäßig ist eine Implementierung namens  <span class='latex-texttt'>ResourceLocalTransactionStrategy</span>  aktiv,
die für Persistence-Units  <span class='latex-texttt'>"RESOURCE_LOCAL"</span>  als Wert für  <span class='latex-texttt'>"transaction-type"</span>  voraussetzt.
Aus diesem Grund kann  <span class='latex-texttt'>@Transactional</span>  innerhalb und außerhalb von Java EE Servern eingesetzt werden.
Darüber hinaus stellt DeltaSpike zwei weitere Implementierungen des  <span class='latex-texttt'>TransactionStrategy</span> -Interfaces zur Verfügung.
 <span class='latex-texttt'>BeanManagedUserTransactionStrategy</span>  ermöglicht die Verwendung von  <span class='latex-texttt'>"JTA"</span>  als Wert für  <span class='latex-texttt'>"transaction-type"</span>  und
 <span class='latex-texttt'>EnvironmentAwareTransactionStrategy</span>  unterstützt beide Konfigurationen
indem für jede aktive Transaktion der Transaktionstyp ermittelt wird.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Soll die aktive Implementierung geändert werden,
so kann die gewünschte alternative Klasse in der Datei  <span class='latex-texttt'>META-INF/beans.xml</span>  konfiguriert werden.
Vor allem bei Weld-basierten EE6-Servern ist dies durch die striktere Auslegung der BDA-Regeln nicht möglich.
Um bei solchen Servern dennoch eine alternative Implementierung global zu aktivieren,
können wir auf das Global-Alternative Konzept von DeltaSpike zurückgreifen.
In unserem Fall legen wir hierfür die Datei  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  an und
fügen die Zeile aus Listing  <a href='#!idx:/deltaspike.html:fig:global_alternatives'> Globale Alternativen mit CDI 1.0 </a>  hinzu.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:global_alternatives'></a>                     <pre><code>globalAlternatives.org.apache.deltaspike.jpa
.spi.transaction.TransactionStrategy=org.apache.deltaspike.jpa
.impl.transaction.EnvironmentAwareTransactionStrategy
</code></pre>
                </div> Diese Konfigurationsdatei ist wie jede andere Konfigurationsquelle im Konfigurationsmechanismus von DeltaSpike eingebunden und
wird intern durch die Klasse  <span class='latex-texttt'>PropertyFileConfigSource</span>  geladen.
In diesem Kapitel haben wir bereits die Priorisierung von Konfigurationsquellen kennengelernt.
 <span class='latex-texttt'>PropertyFileConfigSource</span>  verwendet standardmäßig den Wert  <span class='latex-texttt'>100</span>  für Konfigurationsdateien
mit dem Namen  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> .
Gleiches gilt für Konfigurationsdateien, die durch Implementierungen des Interfaces  <span class='latex-texttt'>PropertyFileConfig</span>  automatisch eingebunden werden.
Jede Konfigurationsquelle, so auch jede Datei mit dem Namen  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> ,
kann die vordefinierte Priorität selbst festlegen.
Hierfür müssen wir einen Konfigurationseintrag mit dem Key  <span class='latex-texttt'>deltaspike_ordinal</span>  hinzufügen.
Als Wert wählen wir den gewünschten Platz in der Konfigurationskette.
DeltaSpike verwendet für eigene Konfigurationsquellen die Werte 100, 200, 300 und 400.
Möchten wir sicherstellen, dass unsere eben definierte Konfiguration für die globale Transaction-Strategy
immer Vorrang vor Werten in den Standardquellen hat, dann müssen wir einen höheren Wert als 400 wählen.
In unserem Fall fügen wir in der Datei  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  den Konfigurationseintrag
 <span class='latex-texttt'>deltaspike_ordinal=1000</span>  hinzu.<br /> <div class="tip"><b>Tipp: </b> Die Annotation  <span class='latex-texttt'>@Transactional</span>  ist zwar als Alternative zu EJBs gedacht,
aber kann auch mit diesen kombiniert werden.
Verwendet  <span class='latex-texttt'>@Transactional</span>  die aktuelle  <span class='latex-texttt'>UserTransaction</span>  und somit JTA,
dann kann ein transaktionales CDI-Bean die  <span class='latex-texttt'>UserTransaction</span>  eines EJBs übernehmen,
sofern das EJB eine transaktionale Methode eines CDI-Beans aufruft. </div><h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.8' ><span class='entry-number'>5.8</span> Eigene Konzepte</a> </h2>
 In  <span class='latex-textit'>IdeaFork</span>  haben wir bisher mehrere Zugriffsmöglichkeiten auf konfigurierte Werte kennengelernt,
die auf Basis von DeltaSpike umgesetzt wurden.
Die gezeigten Möglichkeiten veranschaulichen einige Konzepte, die durch DeltaSpike direkt unterstützt werden.
Jede der beschriebenen Varianten hatte zumindest einen Aspekt, der verbesserungswürdig ist.
In vielen Fällen liegt dies in der Natur der Sache, da wir möglichst typsicher auf untypisierte Konfigurationswerte zugreifen wollen.
So erfordert die Verwendung von  <span class='latex-texttt'>@ConfigProperty</span> , dass der Key bei jedem Injection-Point angegeben werden und
bei Änderungen aktualisiert werden muss.
Hier könnten wir natürlich beispielsweise auf ein Interface zurückgreifen, das die Keys als statische Strings definiert.
Dennoch muss bei der Implementierung eine entsprechend hohe Disziplin eingehalten werden.
Bei der zweiten Variante, den Producer-Klassen, die von  <span class='latex-texttt'>BaseConfigPropertyProducer</span>  ableiten,
benötigen wir je Key eine eigene Producer-Methode.
Solche Methoden sind zwar trivial in der Umsetzung, dennoch ist für jeden Key eine Implementierung und in vielen Fällen auch ein CDI-Qualifier nötig.
Ähnlich sieht es bei eigenen Konfigurationsbeans aus.
Der Vorteil von  <span class='latex-texttt'>MonitoringConfig</span>  war die optionale Verwendung eines beliebigen Scopes,
dennoch mussten wir je Konfigurationskey eine eigene Methode implementieren.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die eben erwähnten Einschränkungen können wir jedoch in wenigen Schritten durch die Umsetzung eines eigenen Konzepts überwinden.
Um dies zu bewerkstelligen, können wir uns des Partial-Bean Moduls von DeltaSpike bedienen.
Dieses Modul erlaubt die Umsetzung von Interfaces und abstrakten Klassen,
für die es nur einen generischen Handler statt konkreter Implementierungen gibt.
Die Verbindung von Interfaces bzw. abstrakten Klassen mit dem dazugehörigen generischen Handler
wird über eine selbst definierte Binding-Annotation durchgeführt.
Eine solche Binding-Annotation ist in Listing  <a href='#!idx:/deltaspike.html:fig:partial-bean_binding'> Partial-Bean Binding </a>  zu sehen und muss mit der Annotation
 <span class='latex-texttt'>@org.apache.deltaspike.partialbean.api.PartialBeanBinding</span>  markiert werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:partial-bean_binding'></a>                     <pre><code>@PartialBeanBinding

@Retention(RUNTIME)
@Target(TYPE)
public @interface TypedConfig {
}
</code></pre>
                </div> Sowohl Interfaces bzw. abstrakte Klassen als auch die Handler-Klasse muss mit der gleichen Binding-Annotation versehen werden,
um eine Verbindung herzustellen.
In  <span class='latex-textit'>IdeaFork</span>  haben wir in diesem Kapitel den Qualifier  <span class='latex-texttt'>@MaxNumberOfHighestRatedCategories</span>  eingeführt,
um den konfigurierten Wert typsicher zu injizieren.
Ein Qualifier je Konfigurationskey verbessert zwar die Sicherheit bei der Verwendung,
aber erhöht zugleich den Aufwand bei der initialen Umsetzung.
Vor diesem Qualifier hatten wir eine Klasse namens  <span class='latex-texttt'>ApplicationConfig</span> ,
die mehrere Konfigurationswerte typsicher bereitstellte.
Allerdings mussten wir die Konfiguration selbst laden und die einzelnen Properties aufbereiten, bzw.
bei mehreren Konfigurationsquellen wäre sogar eine Priorisierung je Quelle nötig.
Das Ergebnis haben wir unabhängig von den vorgelagerten Schritten
in diesem Fall über die Methode  <span class='latex-texttt'>#getMethodInvocationThreshold</span>  konsumiert.
Abgesehen von der manuellen Verarbeitung der Konfiguration war dieser Ansatz durchaus praktisch.
Daher wollen wir unsere ursprüngliche Herangehensweise mit dem Partial-Bean Konzept
auf Basis der Konfigurationsinfrastruktur von DeltaSpike etwas verfeinern.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Als erste Vereinfachung entfernen wir den Qualifier  <span class='latex-texttt'>@MaxNumberOfHighestRatedCategories</span>  wieder und legen
 <span class='latex-texttt'>ApplicationConfig</span>  diesmal als Interface mit der Methode  <span class='latex-texttt'>#maxNumberOfHighestRatedCategories</span>  an.
Das in Listing  <a href='#!idx:/deltaspike.html:fig:minimal_partial_bean'> Minimales Partial-Bean </a>  gezeigte Interface verbinden wir durch die  <span class='latex-texttt'>@TypedConfig</span> -Annotation
mit einem generischen Handler. Als Ergebnis erhalten wir unser erstes Partial-Bean.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_partial_bean'></a>                     <pre><code>@TypedConfig
public interface ApplicationConfig {
  Integer maxNumberOfHighestRatedCategories();
}
</code></pre>
                </div> Bisher haben wir eine Binding-Annotation und ein Interface erstellt.
Der zuvor erwähnte generische Handler wird im nächsten Schritt realisiert.
Dieser Handler muss  <span class='latex-texttt'>java.lang.reflect.InvocationHandler</span>  implementieren und mit unserer Binding-Annotation versehen werden.
In Listing  <a href='#!idx:/deltaspike.html:fig:minimal_partial-bean_handler'> Minimaler Partial-Bean Handler </a>  ist eine vereinfachte Variante eines Handlers dargestellt.
Der Methodenname wird als Key der bereits vorgestellten Methode  <span class='latex-texttt'>ConfigResolver#getPropertyValue</span>  übergeben.
Anschließend wird der von DeltaSpike geladene Wert auf Basis des Return-Typs der Methode geparsed.
Dieses Ergebnis stellt folglich das Resultat der Partial-Bean-Methode dar.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:minimal_partial-bean_handler'></a>                     <pre><code>@TypedConfig
public class TypedConfigHandler implements InvocationHandler {
  public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {

      String key = method.getName();
      Class&lt;?&gt; configType = method.getReturnType();

      String loadedValue = ConfigResolver.getPropertyValue(key);
      return parseValue(loadedValue, configType);
  }

  private Object parseValue(String loadedValue, Class&lt;?&gt; configType) {
    //...
  }
}
</code></pre>
                </div> Ohne zusätzliche Konfiguration oder Aktivierung ist unser erstes Partial-Bean sofort einsatzbereit und
wir können  <span class='latex-texttt'>ApplicationConfig</span>  wie ein herkömmliches CDI-Bean in andere CDI-Beans injizieren.
Bei jedem Methodenaufruf, in unserem Fall von der Methode  <span class='latex-texttt'>#maxNumberOfHighestRatedCategories</span> ,
wird im Hintergrund der generische Handler für dieses Partial-Bean aufgerufen.<br />Listing  <a href='#!idx:/deltaspike.html:fig:using_partial-beans'> Verwendung von Partial-Beans </a>  veranschaulicht,
dass bei der Verwendung eines Partial-Beans keine weiteren Aspekte berücksichtigt werden müssen.
Allein durch die Betrachtung der Verwendung beispielsweise in  <span class='latex-texttt'>IdeaJpaRepository</span> können wir keinen Unterschied zu einem herkömmlichen CDI-Bean feststellen.
Erst bei der Suche nach der dazugehörigen Implementierung würden wir herausfinden,
dass keine explizite Implementierung des Interfaces vorhanden ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:using_partial-beans'></a>                     <pre><code>@Repository
public class IdeaJpaRepository extends GenericJpaRepository&lt;Idea&gt;
  implements IdeaRepository {

    @Inject
    private ApplicationConfig applicationConfig;

    //...

    @Override
    public List&lt;CategoryView&gt; getHighestRatedCategories() {
      return entityManager.createQuery("...")
        .setMaxResults(
          applicationConfig.maxNumberOfHighestRatedCategories())
        .getResultList();
    }
}
</code></pre>
                </div> In unserem Fall haben wir in  <span class='latex-texttt'>ApplicationConfig</span>  bisher nur eine Methode,
wodurch der Aufwand unverhältnismäßig hoch erscheint.
Ziel von Partial-Beans ist es natürlich, Interfaces mit mehreren Methoden zu verwenden,
bzw. mehrere Partial-Beans mit einem generischen Handler zu verbinden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bei der Definition weiterer Konfigurationsbeans profitieren wir unmittelbar von der zugrundeliegenden Idee.
Listing  <a href='#!idx:/deltaspike.html:fig:config_as_cdi-bean'> MonitoringConfig als einfaches CDI-Beans </a>  zeigt die Klasse  <span class='latex-texttt'>MonitoringConfig</span> , die wir in diesem Kapitel hinzugefügt haben.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:config_as_cdi-bean'></a>                     <pre><code>@ConfigScoped
public class MonitoringConfig {
  @Inject
  @ConfigProperty(name = "methodInvocationThreshold")
  private Integer methodInvocationThreshold;

  public Integer getMethodInvocationThreshold() {
    return methodInvocationThreshold;
  }
}
</code></pre>
                </div> Das Vorgehen ist zwar sehr direkt, allerdings können wir diese Konfigurationsklasse wesentlich vereinfachen.
Listing  <a href='#!idx:/deltaspike.html:fig:config_as_partial-bean'> MonitoringConfig als PartialBean </a>  zeigt die Umstellung von  <span class='latex-texttt'>MonitoringConfig</span>  auf ein Partial-Bean.
Da wir sowohl das Partial-Bean-Binding als auch den generischen Handler bereits umgesetzt haben,
ist der Erstellungsaufwand für alle weiteren Partial-Beans bzw. die Erweiterung um zusätzliche Methoden minimal.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:config_as_partial-bean'></a>                     <pre><code>@TypedConfig
public interface MonitoringConfig {
  Integer methodInvocationThreshold();
}
</code></pre>
                </div> Bei der Umstellung von  <span class='latex-texttt'>MonitoringConfig</span>  haben wir jedoch einen Mechanismus verloren.
Die geladenen Werte werden jetzt nicht mehr in unserem Config-Context gespeichert und
müssen daher bei jedem Zugriff erneut durch DeltaSpike geladen werden.
Wir könnten unser Partial-Bean selbst wieder mit der  <span class='latex-texttt'>@ConfigScoped</span> -Annotation versehen.
Allerdings würden wir in diesem Fall nur die intern generierte Instanz in diesem Context ablegen.
Methodenaufrufe würden weiterhin an den generischen Handler weitergeleitet werden,
der bei jedem Zugriff den Wert erneut lädt.
Aus diesem Grund müssen wir den generischen Handler selbst im Config-Context speichern und die geladenen Werte lokal cachen.
Listing  <a href='#!idx:/deltaspike.html:fig:caching_via_partial-bean_handler'> Konfigurationswerte in TypedConfigHandler cachen </a>  illustriert die erforderlichen Änderungen in der Klasse  <span class='latex-texttt'>TypedConfigHandler</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:caching_via_partial-bean_handler'></a>                     <pre><code>@TypedConfig
@ConfigScoped
public class TypedConfigHandler implements InvocationHandler {
  private Map&lt;String, Object&gt; loadedValues =
    new ConcurrentHashMap&lt;String, Object&gt;();

  public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {

      String key = method.getName();
      Object result = loadedValues.get(key);

      if (result != null) {
        return result;
      }

      String loadedValue = ConfigResolver.getPropertyValue(key);

      Class&lt;?&gt; configType = method.getReturnType();
      result = parseValue(loadedValue, configType);

      loadedValues.put(key, result);
      return result;
  }

  //...
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Falls es erforderlich werden sollte, einzelne Methoden eines Partial-Beans manuell zu implementieren,
kann hierfür auf abstrakte Klassen zurückgegriffen werden.
Abstrakte Methoden werden hierbei weiterhin an den entsprechenden generischen Handler weitergeleitet.
Explizit implementierte Methoden werden hingegen normal ausgeführt, wodurch der Handler in solchen Fällen übergangen wird. </div> Dieser Ansatz hat zusätzlich den Vorteil, dass wir Veränderungen zentral umsetzen können.
Statt jede Konfigurationsklasse einzeln mit  <span class='latex-texttt'>@ConfigScoped</span>  zu annotieren,
ist dies jetzt nur für die Klasse  <span class='latex-texttt'>TypedConfigHandler</span>  erforderlich.
Auch andere Änderungen könnten wir zentral für alle Konfigurationen vornehmen.
So könnten wir beispielsweise, wie in Listing  <a href='#!idx:/deltaspike.html:fig:project-stage_based_config-values'> Umstellung auf Project-Stage abhängige Konfigurationswerte </a>  dargestellt,
statt der Methode  <span class='latex-texttt'>ConfigResolver#getPropertyValue</span>  die Methode
 <span class='latex-texttt'>ConfigResolver#getProjectStageAwarePropertyValue</span>  verwenden,
um Konfigurationswerte an einen Project-Stage zu binden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:project-stage_based_config-values'></a>                     <pre><code>@TypedConfig
@ConfigScoped
public class TypedConfigHandler implements InvocationHandler {
  //...

  public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {

    //...
    String loadedValue =
      ConfigResolver.getProjectStageAwarePropertyValue(key);

    //...
    return result;
  }

  //...
}
</code></pre>
                </div> Diese Änderung erlaubt es, Konfigurationswerte für bestimmte Project-Stages zu überschreiben.
Für den Key  <span class='latex-texttt'>maxNumberOfHighestRatedCategories</span>  lautet unser Konfigurationseintrag beispielsweise  <span class='latex-texttt'>maxNumberOfHighestRatedCategories=10</span> .
Dieser Eintrag ist weiterhin gültig, außer es gibt für den aktuellen Project-Stage einen expliziten Eintrag.
Würden wir den Project-Stage  <span class='latex-texttt'>Development</span>  aktivieren, dann könnten wir den Eintrag
 <span class='latex-texttt'>maxNumberOfHighestRatedCategories=10</span>  beispielsweise mit  <span class='latex-texttt'>maxNumberOfHighestRatedCategories.Development=100</span>  übersteuern.
So könnten wir während der Entwicklung beispielsweise Versuche durchführen,
wie sich die Seite bei der Darstellung einer hohen Anzahl an Kategorien verhält, ohne Gefahr zu laufen,
eine produktive Konfiguration irrtümlich zu verändern.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Manche Konfigurationen erfordern nicht unbedingt eine regelmäßige Aktualisierung.
In  <span class='latex-textit'>IdeaFork</span>  haben wir in diesem Kapitel beispielsweise einen CDI-Qualifier namens  <span class='latex-texttt'>ApplicationName</span>  erstellt,
der zusätzlich mit  <span class='latex-texttt'>@ConfigProperty</span>  annotiert war, damit der konfigurierte Applikationsname typsicher injizierbar wird und
gleichzeitig die dazugehörige Producer-Logik den konfigurierten Wert generisch auf Basis von  <span class='latex-texttt'>@ConfigProperty</span>  laden kann.
Die Umstellung der Konfigurationsklassen in  <span class='latex-textit'>IdeaFork</span>  auf Partial-Beans berücksichtigt bisher allerdings keine CDI-Qualifier.
Ersetzen wir den bisher verwendeten  <span class='latex-texttt'>ConfigProducer</span> , so würden wir ein Partial-Bean namens  <span class='latex-texttt'>ApplicationConfig</span>  erhalten,
wie es in Listing  <a href='#!idx:/deltaspike.html:fig:partial-bean_without_producer'> Partial-Bean ohne Producer </a>  zu sehen ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:partial-bean_without_producer'></a>                     <pre><code>@TypedConfig
public interface ApplicationConfig {
  Integer maxNumberOfHighestRatedCategories();

  String name();

  ApplicationVersion version();

  ExternalFormat.TargetFormat defaultExternalFormat();
}
</code></pre>
                </div> Entsprechend könnten wir beispielsweise den Applikationsnamen nicht mehr als String in Kombination mit dem  <span class='latex-texttt'>@ApplicationName</span> -Qualifier injizieren.
Damit wir diese Möglichkeit weiterhin nutzen können, ist eine kleine Erweiterung des Partial-Beans erforderlich.
Wie in Listing  <a href='#!idx:/deltaspike.html:fig:partial-bean_with_producer'> Partial-Bean mit Producer </a>  dargestellt, können wir auch Methoden in einem Partial-Bean mit  <span class='latex-texttt'>@Produces</span>  und
optional mit einer Qualifier-Annotation annotieren.
Producer-Methoden in Partial-Beans agieren wie herkömmliche CDI-Producer mit dem einzigen Unterschied,
dass auch hier der Partial-Bean-Handler die Ausführung der Methoden übernimmt.
Ein positiver Zusatzaspekt ist,
dass wir Qualifier, wie in unserem Fall die  <span class='latex-texttt'>@ApplicationName</span> -Annotation, nicht mehr mit  <span class='latex-texttt'>@ConfigProperty</span>  markieren müssen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:partial-bean_with_producer'></a>                     <pre><code>@TypedConfig
public interface ApplicationConfig {
  Integer maxNumberOfHighestRatedCategories();

  @Produces
  @ApplicationName
  String name();

  @Produces
  ApplicationVersion version();

  @Produces
  ExternalFormat.TargetFormat defaultExternalFormat();
}
</code></pre>
                </div> Da wir bei keiner Producer-Methode in  <span class='latex-texttt'>ApplicationConfig</span>  eine Scope-Annotation verwenden,
ist das Ergebnis hier immer ein dependent-scoped Bean.
Wie auch bisher können so erzeugte Konfigurationswerte nur dann aktualisiert werden,
wenn der entsprechende Injection-Point neu befüllt wird.
Natürlich könnten wir auch  <span class='latex-texttt'>ApplicationConfig</span>  injizieren und direkt auf sämtliche Methoden zugreifen.
Bei Informationen wie dem Applikationsnamen sind wir jedoch nicht darauf angewiesen, durch den direkten Aufruf von
 <span class='latex-texttt'>ApplicationConfig#name</span>  immer den aktuell gecachten Wert zu verwenden und
daher können wir solche Informationen auch direkt ohne den Umweg über  <span class='latex-texttt'>ApplicationConfig</span>  in anderen CDI-Beans verwenden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-texttt'>ApplicationConfig</span>  haben wir auch das Ergebnis von  <span class='latex-texttt'>defaultExternalFormat</span>  als dependent-scoped Bean definiert.
Hierfür gibt es allerdings einen technischen Grund, denn für Enum-Werte kann kein Proxy erzeugt werden,
wodurch wir keine CDI-Normal-Scopes verwenden können.
In unserem Fall möchten wir  <span class='latex-texttt'>CurrentObjectConverterProducer</span>  vereinfachen,
da bisher der konfigurierte Wert mit Hilfe von  <span class='latex-texttt'>@ConfigProperty</span>  injiziert und der String manuell ausgewertet wurde.
Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_strategy_selection'> Aktivierung von Implementierungen nach Konfigurationsänderungen </a>  zeigt die geänderte Implementierung von  <span class='latex-texttt'>CurrentObjectConverterProducer</span> .
Durch den Producer für  <span class='latex-texttt'>ExternalFormat.TargetFormat</span>  können wir den aktuellen Wert direkt injizieren.
Die vorherige Version von  <span class='latex-texttt'>CurrentObjectConverterProducer</span>  hat den selektierten  <span class='latex-texttt'>ObjectConverter</span> als dependent-scoped Bean für den  <span class='latex-texttt'>@Default</span> -Qualifier zur Verfügung gestellt.
Würden wir dies weiterhin machen, dann würde sich ein Refresh der Konfiguration nicht konsistent in der Applikation verbreiten.
Injizieren wir beispielsweise den  <span class='latex-texttt'>@Default</span> - <span class='latex-texttt'>ObjectConverter</span>  in einem application-scoped Bean,
dann würde dieses Bean den dependent-scoped  <span class='latex-texttt'>ObjectConverter</span>  bis zum Neustart der Applikation verwenden.
Eine Injizierung in einem request-scoped Bean würde hingegen dazu führen,
dass wir je Request eine neue Referenz auf den aktuellen  <span class='latex-texttt'>ObjectConverter</span>  erhalten.
Ändert sich der konfigurierte Wert für den Key  <span class='latex-texttt'>defaultExternalFormat</span>  während der Laufzeit,
dann würde das request-scoped Bean diesen neuen Wert erhalten, sobald der Cache in  <span class='latex-texttt'>TypedConfigHandler</span>  aktualisiert wird.
Das application-scoped Bean würde hingegen weiterhin mit dem ursprünglichen  <span class='latex-texttt'>ObjectConverter</span>  arbeiten.
Um solche Inkonsistenzen zur Laufzeit zu vermeiden, können wir die Producer-Methode
in Listing  <a href='#!idx:/deltaspike.html:fig:typesafe_strategy_selection'> Aktivierung von Implementierungen nach Konfigurationsänderungen </a>  zusätzlich um die Annotation  <span class='latex-texttt'>@ConfigScoped</span>  erweitern.
Durch diese Änderung wird der aktuelle  <span class='latex-texttt'>ObjectConverter</span>  für alle Injection-Points aktualisiert,
sobald der Config-Context zurückgesetzt wird.
Das heißt gleichzeitig, dass alle Beans immer den aktuellen  <span class='latex-texttt'>ObjectConverter</span>  verwenden unabhängig von ihrem Scope.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:typesafe_strategy_selection'></a>                     <pre><code>@ApplicationScoped
public class CurrentObjectConverterProducer {
  @Produces
  @Default
  @ConfigScoped
  protected ObjectConverter defaultConverter(
    @ExternalFormat(XML) ObjectConverter objectConverterXml,
    @ExternalFormat(JSON) ObjectConverter objectConverterJson,
    ExternalFormat.TargetFormat defaultFormat) {
      switch (defaultFormat) {
        case JSON:
          return objectConverterJson;
        default:
          return objectConverterXml;
      }
    }
}
</code></pre>
                </div> Das Ergebnis unserer Umstellung ist eine einfache, einheitliche und aktualisierbare Konfiguration, die darüber hinaus typsicher ist.
Für jeden neuen Konfigurationseintrag muss im einfachsten Fall nur eine Methode in einem Interface hinzugefügt werden.
Ändert sich der Key des Konfigurationseintrags, dann muss nur diese eine Methode entsprechend umbenannt werden.
Alle modernen Java-IDEs stellen bei einem solchen Refactoring die dazugehörigen Methodenaufrufe automatisch um.
Wird dies nicht korrekt gemacht, dann würde spätestens der Java-Compiler einen Fehler melden.
Die gesamte Logik zum Laden, Parsen und Cachen der Werte kann zentral in einem Handler durchgeführt werden.
Änderungen können somit ebenfalls zentral durchgeführt werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Dennoch haben wir eine wichtige Fehlerquelle bei unserer typsicheren Konfiguration noch nicht beseitigt.
Wir haben zwar sichergestellt, dass wir typsicher auf die konfigurierten Werte zugreifen,
aber wir wissen nicht, ob jede Interface-Methode wirklich zu einem konfigurierten Wert führt.
So könnte sich beispielsweise der Key eines Eintrags ändern und unsere Applikation würde weiterhin normal starten,
selbst wenn die dazugehörige Methode nicht umbenannt wurde.
Die Auswirkung wird folglich erst zur Laufzeit beim Zugriff auf die Methode sichtbar.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Um dies zu vermeiden, können wir das Interface  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigValidator</span>  implementieren und
in der Datei  <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.core.spi.config.ConfigValidator</span>  aktivieren.
Damit wir die Interfaces finden, die mit unserer selbst erstellten Annotation  <span class='latex-texttt'>@TypedConfig</span>  annotiert sind,
implementiert unser Validator zusätzlich  <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>  und
muss ebenfalls in der Datei  <span class='latex-texttt'>META-INF/services/javax.enterprise.inject.spi.Extension</span>  hinzugefügt werden.
In Listing  <a href='#!idx:/deltaspike.html:fig:validating_typesafe_configs'> Extension zur Validierung typsicherer Konfiguration </a>  wird diese Implementierung  <span class='latex-texttt'>TypedConfigValidationExtension</span>  genannt.
Die Methode  <span class='latex-texttt'>#findTypedConfigClasses</span>  überprüft,
ob es sich bei dem gefundenen Bean um eine Implementierung von  <span class='latex-texttt'>InvocationHandler</span>  handelt,
die zusätzlich mit  <span class='latex-texttt'>@TypedConfig</span>  annotiert ist.
In diesem Fall wird die gefundene Klasse einer Liste hinzugefügt,
die in der Methode  <span class='latex-texttt'>#processValidation</span>  für die Validierung verwendet wird.
Bei der Validierung wird jeder Methodenname als Key für den Methodenaufruf  <span class='latex-texttt'>getPropertyValue</span>  genutzt.
Kann für einen Key kein konfigurierter Wert gefunden werden, dann wird eine passende Fehlermeldung erzeugt.
Hätten wir optionale Konfigurationen, dann müssten wir zusätzlich eine weitere Annotation für Methoden einführen.
Diese könnte beispielsweise  <span class='latex-texttt'>@OptionalKey</span>  heißen und Methoden mit einer solchen Annotation würden einfach bei der Validierung übersprungen werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:validating_typesafe_configs'></a>                     <pre><code>public class TypedConfigValidationExtension
  implements ConfigValidator, Extension {

  private static List&lt;Class&gt; foundConfigClasses =
    new CopyOnWriteArrayList&lt;Class&gt;();

  public void findTypedConfigClasses(@Observes ProcessAnnotatedType pat) {
    Class&lt;?&gt; beanClass = pat.getAnnotatedType().getJavaClass();
    TypedConfig typedConfig = beanClass.getAnnotation(TypedConfig.class);

    if (typedConfig != null &&
        !InvocationHandler.class.isAssignableFrom(beanClass)) {
      foundConfigClasses.add(beanClass);
    }
  }

  @Override
  public Set&lt;String&gt; processValidation() {
    Set&lt;String&gt; violations = new HashSet&lt;String&gt;();
    for (Class configClass : foundConfigClasses) {
      validateConfigKeys(configClass.getMethods(), violations);
    }

    foundConfigClasses.clear();
    return violations;
  }

  private void validateConfigKeys(
    Method[] methods, Set&lt;String&gt; violations) {

      for (Method method : methods) {
        String key = method.getName();
        String configuredValue = ConfigResolver.getPropertyValue(key);

        if (configuredValue == null) {
          violations.add("missing config-key: " + key);
        }
      }
  }
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Manche Server sind nicht spezifikationskonform,
wodurch wir in der Klasse  <span class='latex-texttt'>TypedConfigValidationExtension</span>  eine statische Variable verwenden müssen.
In spezifikationskonformen Servern könnten wir auch eine Instanzvariable verwenden,
wodurch es einfacher wird, solche Extensions in geteilten Modulen für mehrere Module zu verwenden.
In diesem Fall müssten wir in der Methode  <span class='latex-texttt'>#processValidation</span>  einen Bean-Lookup auf  <span class='latex-texttt'>TypedConfigValidationExtension</span>  verwenden,
damit wir die  <span class='latex-texttt'>Extension</span> -Instanz mit der befüllten Liste bekommen. </div><h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.9' ><span class='entry-number'>5.9</span> Flexibilität weiter erhöhen</a> </h2>
 In vielen Projekten wird zusätzlich die Möglichkeit geschaffen, konfigurierte Werte aus einer Datenbank zu laden,
damit notfalls zur Laufzeit eine Konfiguration geändert werden kann, ohne die Applikation neu zu deployen.
Dieses Konzept ist im Normalfall einfach und schnell umsetzbar.
In unserem Fall wollen wir diese Implementierung möglichst minimalistisch halten und
zusätzlich mit dem zuvor vorgestellten Konfigurationsmechanismus von DeltaSpike integrieren.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im ersten Schritt erstellen wir eine einfache JPA-Entität namens  <span class='latex-texttt'>ConfigEntry</span> ,
die in Listing  <a href='#!idx:/deltaspike.html:fig:jpa-entity_for_dynamic_configs'> JPA-Entität für dynamische Konfigurationen </a>  zu sehen ist.
Diese Entität könnten wir wie gewohnt mit Hilfe einer Repository-Implementierung verwenden.
Mit  <span class='latex-texttt'>GenericJpaRepository</span>  haben wir bereits eine Basisimplementierung im Core von  <span class='latex-textit'>IdeaFork</span> mit der wir nur eine konkrete Implementierung auf unseren neuen Entity-Typ typisieren müssten.
In DeltaSpike wird ein ähnlicher Ansatz durch das Data-Modul zur Verfügung gestellt,
wodurch wir auf eine eigene Basisimplementierung verzichten und von zusätzlichen Funktionalitäten profitieren können.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:jpa-entity_for_dynamic_configs'></a>                     <pre><code>@Entity
public class ConfigEntry extends BaseEntity {
  @Column(unique = true, nullable = false)
  private String entryKey;

  @Column
  private String value;

  //+ getter and setter ...
}
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:ds-data_repository'> Entity-Repository auf Basis von DeltaSpike-Data </a>  zeigt ein Partial-Bean,
das durch einen generischen Handler im Data-Modul von DeltaSpike zum Leben erweckt wird.
Die Annotation  <span class='latex-texttt'>@org.apache.deltaspike.data.api.Repository</span>  markiert dieses Interface als Partial-Bean,
wodurch der Handler von DeltaSpike Queries auf Basis der Methodennamen bzw. der optionalen Metadaten erzeugt.
In unserem Fall fügen wir mit  <span class='latex-texttt'>@Query(singleResult = OPTIONAL)</span>  Metadaten hinzu,
die ein optionales Ergebnis ermöglichen.
Außerdem leitet  <span class='latex-texttt'>ConfigRepository</span>  von dem Interface  <span class='latex-texttt'>org.apache.deltaspike.data.api.EntityRepository</span>  ab,
wodurch Methoden wie beispielsweise  <span class='latex-texttt'>#save</span> ,  <span class='latex-texttt'>#remove</span> ,  <span class='latex-texttt'>#count</span> ,  <span class='latex-texttt'>#findAll</span>  und viele mehr verwendet werden können.
Bei der Typisierung geben wir neben dem Entity-Typ auch den Typ des Primärschlüssels an.
In unserem Fall ist der Entity-Typ die Klasse  <span class='latex-texttt'>ConfigEntry</span>  und der Primärschlüssel ist in  <span class='latex-texttt'>BaseEntity</span>  als String definiert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-data_repository'></a>                     <pre><code>@org.apache.deltaspike.jpa.api.transaction.Transactional
@org.apache.deltaspike.data.api.Repository
public interface ConfigRepository
  extends EntityRepository&lt;ConfigEntry, String&gt; {

    @Query(singleResult = OPTIONAL)
    ConfigEntry findByEntryKey(String key);
}
</code></pre>
                </div> Unser Repository könnten wir ohne weitere Annotation beispielsweise in EJBs oder transaktionale Services wie üblich mit  <span class='latex-texttt'>@Inject</span>  injizieren.
Anschließend können wir die vordefinierten oder selbst definierten Methoden aufrufen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Soll das Repository selbst transaktional sein, dann muss dieses zusätzlich mit  <span class='latex-texttt'>@Transactional</span>  markiert werden.
Partial-Beans haben allerdings kleine Einschränkungen, da beispielsweise keine CDI-Decoratoren verwendbar sind.
Werden Decoratoren benötigt, müssten wir bei  <span class='latex-texttt'>GenericJpaRepository</span>  von  <span class='latex-textit'>IdeaFork</span> -Core bleiben.
Aus diesem Grund stellen wir die restlichen Repositories von  <span class='latex-textit'>IdeaFork</span> -Core nicht um.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  möchten wir  <span class='latex-texttt'>ConfigRepository</span>  mit einer zusätzlichen  <span class='latex-texttt'>ConfigSource</span>  einbinden.
Die Klasse  <span class='latex-texttt'>DataBaseAwareConfigSource</span>  aus Listing  <a href='#!idx:/deltaspike.html:fig:db_aware_config-source'> Config-Source zum Laden von Werten aus einer Datenbank </a>  implementiert diesmal direkt das Interface
 <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span> .
Als Ordinal-Wert wählen wir einen hohen Wert der dafür sorgt, dass diese Config-Source als erste in der Kette befragt wird.
Die Methode  <span class='latex-texttt'>#getProperties</span>  muss nur sinnvoll implementiert werden,
wenn die Methode  <span class='latex-texttt'>#isScannable</span>  den Wert  <span class='latex-texttt'>"true"</span>  zurückliefert.
Dies ist nur erforderlich, wenn wir in unserer Applikation die Methode  <span class='latex-texttt'>ConfigResolver#getAllProperties</span>  benötigen.
Die Methode  <span class='latex-texttt'>#getConfigName</span>  wird primär für Logeinträge benötigt, damit beispielsweise eine mögliche Fehlersuche einfacher wird.
Der Hauptteil von  <span class='latex-texttt'>DataBaseAwareConfigSource </span>  ist in der Methode  <span class='latex-texttt'>#getPropertyValue</span>  zu finden.
Mit  <span class='latex-texttt'>BeanManagerProvider#isActive</span>  können wir überprüfen, ob  <span class='latex-texttt'>BeanProvider</span>  bereits verwendet werden kann.
Diesen benötigen wir nämlich für einen dynamischen Lookup von  <span class='latex-texttt'>ConfigRepository</span> .
Zusätzlich können wir noch Keys die mit  <span class='latex-texttt'>"deltaspike."</span>  beginnen herausfiltern,
da wir die Konfiguration von DeltaSpike selbst nicht aus der Datenbank laden wollen.
Sobald unser Partial-Bean namens  <span class='latex-texttt'>ConfigRepository</span>  gefunden wird,
können wir über die Methode  <span class='latex-texttt'>#findByEntryKey</span>  versuchen den Konfigurationseintrag in der Datenbank für den gesuchten Key zu laden.
Wird ein entsprechender Eintrag gefunden, dann verwenden wir das Ergebnis der Methode  <span class='latex-texttt'>#getValue</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:db_aware_config-source'></a>                     <pre><code>public class DataBaseAwareConfigSource implements ConfigSource {
  private final static int ordinal = 2000;

  @Override
  public int getOrdinal() {
    return ordinal;
  }

  @Override
  public String getPropertyValue(String key) {
    if (!BeanManagerProvider.isActive() ||
        key.startsWith("deltaspike.")) {

          return null;
    }

    ConfigRepository configRepository =
      BeanProvider.getContextualReference(ConfigRepository.class, true);

    if (configRepository != null) {
      ConfigEntry configEntry = configRepository.findByEntryKey(key);

      if (configEntry != null) {
        return configEntry.getValue();
      }
    }
    return null;
  }

  @Override
  public String getConfigName() {
    return "config-db";
  }

  @Override
  public boolean isScannable() {
    return false;
  }

  @Override
  public Map&lt;String, String&gt; getProperties() {
    return Collections.emptyMap();
  }
}
</code></pre>
                </div> Implementierungen von  <span class='latex-texttt'>org.apache.deltaspike.core.spi.config.ConfigSource</span>  werden von DeltaSpike nicht als CDI-Beans verwendet,
da dieser Mechanismus ursprünglich primär dazu gedacht war Teile von DeltaSpike selbst zu konfigurieren,
die schon während des Containerstartes fixiert sein müssen.
Folglich handelt es sich um ein klassisches Java-SPI und wir müssen unsere Klasse voll qualifiziert in der Datei
 <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.core.spi.config.ConfigSource</span>  aktivieren.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Mit diesem letzten Schritt haben wir unsere typsichere Konfiguration um eine zusätzliche Konfigurationsquelle erweitert,
ohne eine weitere Anpassung in  <span class='latex-textit'>IdeaFork</span>  vorzunehmen.
Default-Werte können wir weiterhin in den statischen Konfigurationsquellen hinterlegen.
Wird eine Änderung zur Laufzeit benötigt, dann können wir den neuen Wert in der Datenbank hinterlegen.
Sobald die gecachte Konfiguration manuell oder automatisch aktualisiert wird,
werden die neuen Werte aus der Datenbank durch das höhere Ordinal unserer Konfigurationsquelle bevorzugt und somit aktiv.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaFork</span>  können wir dies beim Start der Applikation simulieren, wenn wir den Project-Stage  <span class='latex-texttt'>Development</span>  verwenden.
In Java EE gibt es viele Möglichkeiten Initialisierungs-Code umzusetzen.
So kann beispielsweise die  <span class='latex-texttt'>@Startup</span> -Annotation für EJBs,
das  <span class='latex-texttt'>ServletContainerInitializer</span> -Interface für Servlets oder das JSF-Event  <span class='latex-texttt'>PostConstructApplicationEvent</span>  verwendet werden.
Seit CDI 1.1 und somit Java EE 7 können auch Observer-Methoden für die Überwachung von Standard-Scopes verwendet werden.
Eine Observer-Methode, die  <span class='latex-texttt'>@Observes @Initialized(ApplicationScoped.class)</span>  verwendet,
wird beispielsweise aufgerufen, sobald der Application-Context initialisiert wurde.
Alle Varianten haben gemein, dass nur ein Teil des Servers gestartet ist.
Keine dieser Varianten garantiert jedoch die Umsetzung einer portablen Initialisierungslogik,
die nach dem vollständigen Serverstart ausgeführt wird.
Für Java EE Applikationen mit JSF-Seiten, wie es  <span class='latex-textit'>IdeaFork</span>  ist, können wir ein JSF-Add-on für DeltaSpike verwenden.
Dieses Add-on führt die Initialisierungslogik beim ersten JSF-Request aus, wodurch garantiert ist,
dass der gesamte Java EE Container vollständig initialisiert ist.
Dieses Add-on veranschaulicht zusätzlich den Konfigurationsmechanismus von DeltaSpike.
Das Add-on definiert den Konfigurationskey  <span class='latex-texttt'>first-faces-request_event-class</span> , um die Klasse des Startup-Events festzulegen.
Standardmäßig wird hierfür die Klasse  <span class='latex-texttt'>FirstFacesRequestEvent</span>  festgelegt.
Dieser Konfigurationseintrag ist in der Datei  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  des Add-ons abgelegt.
In der gleichen Datei wird mit  <span class='latex-texttt'>deltaspike_ordinal=1</span>  ein sehr niedriger Ordinal-Wert definiert.
Da der Standardwert höher ist,
müssten wir in  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  von  <span class='latex-textit'>IdeaFork</span>  keinen Wert für  <span class='latex-texttt'>deltaspike_ordinal</span>  vergeben,
damit die Default-Konfiguration übersteuert wird.
Bei der Konfiguration einer gobalen Transaktionsstrategie haben wir allerdings bereits den Wert 1000 gewählt,
den wir natürlich ebenfalls beibehalten können.
In  <span class='latex-textit'>IdeaFork</span>  wollen wir die Klasse  <span class='latex-texttt'>IdeaForkStartedEvent</span>  verwenden und
fügen daher einen entsprechenden Eintrag in der Datei  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  von  <span class='latex-textit'>IdeaFork</span>  hinzu.
Das Add-on für DeltaSpike verwendet ebenfalls die zuvor vorgestellte Methode  <span class='latex-texttt'>ConfigResolver#getProjectStageAwarePropertyValue</span> ,
wodurch wir beispielsweise für den Project-Stage  <span class='latex-texttt'>Development</span>  ein eigenes Event festlegen können.
Listing  <a href='#!idx:/deltaspike.html:fig:ds-addon_config'> Stageabhängiges Startup-Event </a>  veranschaulicht beide Konfigurationseinträge.
Bei beiden Klassen handelt es sich um simple (Marker-)Klassen ohne zusätzliche Logik.
Im Falle von Project-Stage  <span class='latex-texttt'>Development</span>  wird zuerst der Wert für  <span class='latex-texttt'>first-faces-request_event-class.Development</span>  gesucht.
Erst wenn dieser nicht vorhanden ist, dann wird der Wert für  <span class='latex-texttt'>first-faces-request_event-class</span>  geladen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-addon_config'></a>                     <pre><code>first-faces-request_event-class=
  at.irian.cdiatwork.ideafork.core.api.startup.IdeaForkStartedEvent
first-faces-request_event-class.Development=
  at.irian.cdiatwork.ideafork.ee.infrastructure.DevStartupEvent
</code></pre>
                </div> Listing  <a href='#!idx:/deltaspike.html:fig:custom_startup-event'> Stageabhängiges Startup-Event überwachen </a>  zeigt wie wir ein solches Startup-Event verwenden können.
Im konkreten Fall ändern wir bei Project-Stage  <span class='latex-texttt'>Development</span>  einen konfigurierten Wert ab,
indem wir den gewünschten Wert mit Hilfe der Entität  <span class='latex-texttt'>ConfigEntry</span>  in der Datenbank speichern.
Bei allen nachfolgenden Zugriffen auf  <span class='latex-texttt'>maxNumberOfHighestRatedCategories</span> ,
wird der in der Datenbank konfigurierte Wert verwendet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:custom_startup-event'></a>                     <pre><code>public class DataImporter {
  @Inject
  private ConfigRepository configRepository;

  protected void init(@Observes DevStartupEvent devStartupEvent) {
    configRepository.save(
      new ConfigEntry("maxNumberOfHighestRatedCategories", "2"));
  }
}
</code></pre>
                </div> Alternativ zu  <span class='latex-texttt'>DevStartupEvent</span>  könnten wir einen Observer für das Event  <span class='latex-texttt'>IdeaForkStartedEvent</span>  in einem Bean definieren,
das mit  <span class='latex-textit'>@Exclude(exceptIfProjectStage = ProjectStage.Development.class)</span>  annotiert ist.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In unserer Applikation können wir die Klasse  <span class='latex-texttt'>DevStartupEvent</span>  zusätzlich von  <span class='latex-texttt'>IdeaForkStartedEvent</span>  ableiten,
wodurch beim Feuern des Events  <span class='latex-texttt'>DevStartupEvent</span>  auch Observer für das Event  <span class='latex-texttt'>IdeaForkStartedEvent</span>  aufgerufen werden.
Der Observer in Listing  <a href='#!idx:/deltaspike.html:fig:observer_for_custom_startup-event'> Observer für ein portables Startup-Event </a> wird somit sowohl in Project-Stage  <span class='latex-texttt'>Development</span>  als auch in Project-Stage  <span class='latex-texttt'>Production</span>  aufgerufen.
In unserem Fall verwenden wir diesen Observer, um  <span class='latex-texttt'>DataBaseAwareConfigSource</span>  dynamisch hinzuzufügen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:observer_for_custom_startup-event'></a>                     <pre><code>@ApplicationScoped
public class IdeaForkCoreStartupObserver {
    protected void onStartup(
      @Observes IdeaForkStartedEvent ideaForkStartedEvent,
      DataBaseAwareConfigSource configSource) {

        ConfigResolver.addConfigSources(
          Arrays.&lt;ConfigSource&gt;asList(configSource));
    }
}
</code></pre>
                </div> Durch die dynamische Registrierung ist es nicht mehr erforderlich die Config-Source-Implementierung in der Datei
 <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.core.spi.config.ConfigSource</span>  zu konfigurieren.
Ein weiterer Vorteil ist die einfachere Implementierung von  <span class='latex-texttt'>DataBaseAwareConfigSource</span> ,
die in Listing  <a href='#!idx:/deltaspike.html:fig:changed_config-source'> Änderung von DataBaseAwareConfigSource </a>  zu sehen ist.
Statt der manuellen Verwendung von  <span class='latex-texttt'>BeanManagerProvider</span>  und  <span class='latex-texttt'>BeanProvider</span> können wir  <span class='latex-texttt'>ConfigRepository</span>  wie gewohnt via  <span class='latex-texttt'>@Inject</span>  injizieren,
weil  <span class='latex-texttt'>DataBaseAwareConfigSource</span>  jetzt vom CDI-Container verwaltet wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:changed_config-source'></a>                     <pre><code>@ApplicationScoped
public class DataBaseAwareConfigSource implements ConfigSource {
  //...

  @Inject
  private ConfigRepository configRepository;

  @Override
  public String getPropertyValue(String key) {
    if (key.startsWith("deltaspike.")) {
      return null;
    }

    ConfigEntry configEntry = configRepository.findByEntryKey(key);

    if (configEntry != null) {
      return configEntry.getValue();
    }
    return null;
  }

  //...
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.10' ><span class='entry-number'>5.10</span> Besser früher als Später</a> </h2>
 Wie wir in diesem Kapitel bereits gesehen haben, erweitert DeltaSpike die Java EE Plattform mit vielfältigen und innovativen Konzepten.
Ein weiterer Aspekt von DeltaSpike ist die frühzeitige Bereitstellung von neuen Java EE Konzepten für ältere Versionen von Java EE.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Beispiele hierfür sind das Servlet- und das Bean-Validation Modul.
Das Servlet-Modul ermöglicht beispielsweise eine portable Injizierung der aktuellen  <span class='latex-texttt'>HttpServletResponse</span> -Instanz.
In einem Java EE6 Server wird dies bereits mit  <span class='latex-texttt'>@Context</span>  unterstützt.
Erst ab Java EE7 kann hierfür auch  <span class='latex-texttt'>@Inject</span>  verwendet werden.
Das Servlet-Modul von DeltaSpike erlaubt die Injizierung via  <span class='latex-texttt'>@Inject</span>  in Verbindung mit dem Qualifier  <span class='latex-texttt'>@DeltaSpike</span> .
Durch den Qualifier ist der Injection-Point nicht nur mit Java EE6 und in einem Servlet-Container mit CDI verwendbar,
sondern auch ohne Änderung in einem Java EE7 Server und jeder nachfolgenden Version.
Die Funktionalität steht folglich schon vor EE7 zur Verfügung und ist darüber hinaus völlig portabel.
Listing  <a href='#!idx:/deltaspike.html:fig:ds-qualifier'> Injizierung via @DeltaSpike Qualifier </a>  zeigt einen Ausschnitt von  <span class='latex-texttt'>IdeaExporter</span> , der entsprechend angepasst ist.
Sobald das Servlet-Modul von DeltaSpike hinzugefügt wird, kann der Injection-Point in  <span class='latex-texttt'>IdeaExporter</span>  befüllt werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds-qualifier'></a>                     <pre><code>@Path("/idea/")
@Produces(MediaType.APPLICATION_JSON)
public class IdeaExporter {
    @Inject
    @DeltaSpike
    private HttpServletResponse response;

  //...
}
</code></pre>
                </div> Neben der Injizierung von  <span class='latex-texttt'>(Http)ServletResponse</span>  unterstützt das Servlet-Modul noch die Injizierung der aktuellen
 <span class='latex-texttt'>ServletContext</span> -,  <span class='latex-texttt'>(Http)ServletRequest</span> -,  <span class='latex-texttt'>HttpSession</span> - und  <span class='latex-texttt'>Principal</span> -Instanz.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Einen ähnlichen Vorteil bietet das Bean-Validation Modul von DeltaSpike.
Im vorherigen Kapitel haben wir  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span>  implementiert,
wodurch wir CDI-basierte Injizierung in Constraint-Validatoren ermöglicht haben.
Genau diese Funktionalität stellt auch DeltaSpike bereit.
Hierfür müssen wir das Bean-Validation-Modul hinzufügen und den Konfigurationseintrag in der Datei  <span class='latex-texttt'>validation.xml</span>  ändern.
Listing  <a href='#!idx:/deltaspike.html:fig:ds_bean-validation'> Aktivierung von CDIAwareConstraintValidatorFactory </a>  illustriert den neuen Inhalt dieser Konfigurationsdatei.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:ds_bean-validation'></a>                     <pre><code>&lt;validation-config&gt;
  &lt;constraint-validator-factory&gt;
    org.apache.deltaspike.beanvalidation.impl
      .CDIAwareConstraintValidatorFactory
  &lt;/constraint-validator-factory&gt;
&lt;/validation-config&gt;
</code></pre>
                </div> Im Gegensatz zu der ursprünglichen Implementierung namens  <span class='latex-texttt'>BeanAwareConstraintValidatorFactory</span> ,
kann  <span class='latex-texttt'>CDIAwareConstraintValidatorFactory</span>  von DeltaSpike auch mit Java EE7 verwendet werden.
EE7 stellt diese Funktionalität zwar bereits automatisch zur Verfügung,
aber durch die zusätzliche Kompatibilität mit EE7 ist  <span class='latex-textit'>IdeaFork</span>  ohne Änderung auch mit EE7-Servern kompatibel.
Mit EE7 könnten wir diese Konfiguration und das dazugehörige Modul zwar komplett aus  <span class='latex-textit'>IdeaFork</span>  entfernen,
aber in diesem Fall wäre  <span class='latex-textit'>IdeaFork</span>  nicht mehr mit EE6 kompatibel.<br /> <h2><a class='latex-index-anchor' name='!idx:/deltaspike.html:5.11' ><span class='entry-number'>5.11</span> Sichere Wege</a> </h2>
 Wir schließen dieses Kapitel mit einem Page-Bean-Test ab.
In unserem Fall möchten wir den Promotion-Wizard typsicher testen.
Abgesehen von der Page-Bean Logik soll auch das persistierte Ergebnis überprüft werden.
Im Gegensatz zu Frameworks wie beispielsweise JBoss Arquillian erstellen wir keine Micro-Test-Deployments,
die in einem vollständigen EE-Server deployed und getestet werden können.
Bisher haben wir  <span class='latex-texttt'>CdiTestRunner</span>  aus dem Test-Control-Modul verwendet.
Dieses Modul startet mit Hilfe des CDI-Control-Moduls von DeltaSpike den jeweils gewünschten CDI-Container,
aber keinen kompletten EE-Server.
Für Page-Bean-Tests benötigen wir allerdings auch einen gestarteten JSF-Container.
Um andere Container wie beispielsweise einen gemockten JSF-Container zu integrieren,
kann das  <span class='latex-texttt'>org.apache.deltaspike.testcontrol.spi.ExternalContainer</span> -SPI verwendet werden.
Das Test-Control-Modul von DeltaSpike enthält verschiedene Adapter für MyFaces-Test.
So können wir beispielsweise  <span class='latex-texttt'>org.apache.deltaspike.testcontrol.impl.jsf.MyFacesContainerAdapter</span>  in der Datei
 <span class='latex-texttt'>META-INF/services/org.apache.deltaspike.testcontrol.spi.ExternalContainer</span>  aktivieren.
Durch diese Konfiguration und die entsprechenden Test-Dependencies für MyFaces-Test wird nicht nur ein gemockter JSF-Container
automatisch gestartet, sondern es werden auch wie für CDI der Request- und Session-Scope gestartet.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Listing  <a href='#!idx:/deltaspike.html:fig:register_user'> User Registrierung und Login via Page-Bean-Test </a>  registrieren wir über das  <span class='latex-texttt'>RegistrationViewCtrl</span> -Bean von  <span class='latex-textit'>IdeaFork</span>  einen neuen  <span class='latex-texttt'>User</span> .
Unsere Page-Beans sind mit unserer eigenen Stereotyp Annotation  <span class='latex-texttt'>@ViewController</span>  definiert.
Dieser Stereotyp gibt den View-Access Scope von DeltaSpike als Default Scope vor.
Da dieser Scope auf dem Window-Scope aufbaut,
müssen wir den dazugehörigen Window-Context vor jeder Test-Methode aktivieren,
sofern im Test Methoden eines Page-Beans aufgerufen werden.
In unserem Test ist dies im  <span class='latex-texttt'>@Before</span> -Callback namens  <span class='latex-texttt'>#initTestWindow</span> mit dem Aufruf der Methode  <span class='latex-texttt'>#activateWindow</span>  umgesetzt.
Folglich können wir in unserem Test beispielsweise  <span class='latex-texttt'>RegistrationViewCtrl#getNewUser</span>  aufrufen.
Als Window-ID können wir einen beliebigen String verwenden.
Bei Page-Bean-Tests wird durch diesen Aufruf vor jeder Test-Methode ein simuliertes Browser-Fenster mit der ID  <span class='latex-texttt'>"testWindow"</span>  erzeugt.
Wie bisher startet  <span class='latex-texttt'>CdiTestRunner</span>  natürlich weiterhin für jede Test-Methode den Request- und Session-Scope erneut.
Im Hintergrund speichert der Window-Context alle Daten unter der angegebenen Window-ID in der Session ab.
Diese beiden Aspekte gewährleisten, dass jede Test-Methode von einem neuen Window-Context ausgehen kann.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Für die Tests der Promotion-Wizard-Beans benötigen wir einen registrierten und eingeloggten  <span class='latex-texttt'>User</span> .
Dies könnten wir manuell mit Hilfe der zuständigen Services und Beans machen oder ebenfalls mit Page-Beans dieser Seiten.
Wir entscheiden uns für die zweite Variante und beginnen in unserer Test-Methode namens  <span class='latex-texttt'>#flowFromRegistrationToIdeaPromotion</span> mit dem Aufruf der Setter-Methoden,
die normalerweise automatisch durch JSF auf Basis der Value-Bindings in der Seite  <span class='latex-texttt'>registration.xhtml</span>  befüllt werden.
Anschließend rufen wir die Action-Methode  <span class='latex-texttt'>#register</span>  auf und überprüfen das Navigationsergebnis.
Durch die Verwendung der typsicheren View-Config als Navigationsergebnis
können wir auch in Tests von der Typsicherheit und den damit verbundenen Vorteilen profitieren.
Wir beenden die Überprüfung dieses ersten Teiles mit dem Aufruf der JSF-API,
um zu überprüfen, ob nicht nur das Navigationsergebnis den Erwartungen entspricht,
sondern auch eine Nachricht hinzugefügt wurde.
Hierin besteht auch einer der Hauptunterschiede von Page-Bean-Tests zu vollständigen UI-Tests.
Der Vorteil ist die einfachere Erstellung der Tests.
Allerdings müssen zumindest ein paar der Abläufe, die normalerweise automatisch ausgeführt werden, manuell nachgestellt werden.
Manche Ergebnisse können darüber hinaus nicht im gerenderten Response überprüft werden,
sondern über die entsprechenden JSF-APIs.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:register_user'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  @Inject
  private WindowContext windowContext;

  @Inject
  private RegistrationViewCtrl registrationViewCtrl;

  @Before
  public void initTestWindow() {
    windowContext.activateWindow("testWindow");
  }

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    registrationViewCtrl.getNewUser().setNickName("os890");
    registrationViewCtrl.getNewUser().setEmail("os890@test.org");
    registrationViewCtrl.getNewUser().setPassword("test");
    Class&lt;? extends ViewConfig&gt; navigationResult =
      registrationViewCtrl.register();

    Assert.assertEquals(Pages.User.Login.class, navigationResult);
    Assert.assertFalse(
      FacesContext.getCurrentInstance().getMessageList().isEmpty());

    //...
  }
}
</code></pre>
                </div> Wenn wir mit einer Test-Methode einen Use-Case testen wollen, der sich über mehrere Seiten erstreckt,
ist es erforderlich, die Test-Methode in mehrere logische Requests zu unterteilen.
Listing  <a href='#!idx:/deltaspike.html:fig:simulate_requests'> Restart des Request-Scopes in einer Test-Methode </a>  veranschaulicht, wie wir mit Hilfe der CDI-Control API den Request-Scope restarten können.
Nachdem der Request-Context gestoppt wird, kann dieser unmittelbar danach gleich wieder gestartet werden.
Normalerweise sorgt das JSF-Modul von DeltaSpike automatisch dafür, dass die Window-ID am Anfang jedes Requests wiederhergestellt wird.
Auch diesen Aspekt müssen wir manuell nachbilden, indem wir in der Methode  <span class='latex-texttt'>#newRequest</span> die zuvor vorgestellte Methode  <span class='latex-texttt'>#initTestWindow</span>  aufrufen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:simulate_requests'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...
  @Inject
  private ContextControl contextControl;

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    newRequest();

    //...
  }

  private void newRequest() {
    contextControl.stopContext(RequestScoped.class);
    contextControl.startContext(RequestScoped.class);
    initTestWindow();
  }
}
</code></pre>
                </div> Nach der erfolgreichen Registrierung eines Test-Users starten wir einen neuen logischen Request,
um den eben angelegten User über das  <span class='latex-texttt'>LoginViewCtrl</span> -Page-Bean einzuloggen.
Dabei gehen wir auf ähnliche Art und Weise wie bei der Registrierung vor.
Nachdem wir die entsprechenden Setter-Methoden und schließlich die Action-Methode aufgerufen haben,
können wir das Navigationsergebnis überprüfen.
Auch hier können wir anschließend über die JSF-API überprüfen, ob eine Nachricht hinzugefügt wurde.
Um zu überprüfen, ob es sich nicht um die Nachricht des vorherigen Requests handelt,
beginnen wir in Listing  <a href='#!idx:/deltaspike.html:fig:check_faces-messages'> Überprüfung von Messages in einem logischen Request </a>  mit der Überprüfung auf eine leere Message-Liste.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:check_faces-messages'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...

  @Inject
  private LoginViewCtrl loginViewCtrl;

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    Assert.assertTrue(
      FacesContext.getCurrentInstance().getMessageList().isEmpty());

    loginViewCtrl.setEmail("os890@test.org");
    loginViewCtrl.setPassword("test");
    navigationResult = loginViewCtrl.login();
    Assert.assertEquals(Pages.Idea.Overview.class, navigationResult);

    Assert.assertFalse(
      FacesContext.getCurrentInstance().getMessageList().isEmpty());

    //...
  }

  //...
}
</code></pre>
                </div> Im vorherigen Beispiel haben wir allerdings einen Aspekt nicht beachtet.
Zwischen der Ausführung der Action-Methode und dem Rendern der hinzugefügten Message wird in der realen Applikation ein Redirect durchgeführt.
Dies könnten wir durch einen erneuten Aufruf der Methode  <span class='latex-texttt'>#newRequest</span>  simulieren.
Hätten wir dies vor der Überprüfung der Nachrichten gemacht, dann würde diese fehlschlagen.
Der Grund hierfür liegt darin, dass DeltaSpike JSF-Messages nur über einen echten Redirect rettet.
Wenn es nicht um die Behandlung von Nachrichten geht,
können wir die Methode  <span class='latex-texttt'>#newRequest</span>  dennoch zur Simulierung eines Redirects verwenden.
In Listing  <a href='#!idx:/deltaspike.html:fig:test_with_view-controller_methods'> Testen mit View-Controller Methoden </a>  können wir beispielsweise
nach dem Aufruf der Action-Methode  <span class='latex-texttt'>#save</span>  durch den Aufruf der Methode  <span class='latex-texttt'>#newRequest</span> einen neuen logischen Request starten, bevor manuell die Callback-Methode  <span class='latex-texttt'>#onPreRenderView</span>  aufgerufen und
das Ergebnis der Methode  <span class='latex-texttt'>#getSelectableIdeaList</span>  überprüft wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:test_with_view-controller_methods'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...

  @Inject
  private IdeaCreateViewCtrl ideaCreateViewCtrl;

  @Inject
  private NavigationController navigationController;

  @Inject
  private PromotionWizardCtrl promotionWizardCtrl;

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    newRequest();

    final String topic = "Test Page-Beans";
    final String category = "test";

    ideaCreateViewCtrl.setTopic(topic);
    ideaCreateViewCtrl.setCategory(category);
    navigationResult = ideaCreateViewCtrl.save();
    Assert.assertEquals(Pages.Idea.Overview.class, navigationResult);

    newRequest();

    navigationResult = navigationController.toIdeaPromotionWizard();
    Assert.assertEquals(
      Pages.PromotionWizard.Step1.class, navigationResult);

    newRequest(); //simulates a redirect

    promotionWizardCtrl.onPreRenderView();

    List&lt;SelectableEntity&lt;Idea&gt;&gt; selectableIdeas =
      promotionWizardCtrl.getSelectableIdeaList();
    Assert.assertNotNull(selectableIdeas);
    Assert.assertEquals(1, selectableIdeas.size());

    //...
  }

  //...
}
</code></pre>
                </div> In  <span class='latex-textit'>IdeaFork</span>  verwenden wir eine Tabelle für die Auswahl von Ideen, die promotet werden können.
Auch hier müssen wir in unserem Page-Bean-Test eine Idee auswählen und manuell der Action-Methode namens  <span class='latex-texttt'>#select</span>  übergeben.
Im vorherigen Listing haben wir der lokalen Variable  <span class='latex-texttt'>selectableIdeas</span>  das Ergebnis der Page-Bean-Methode  <span class='latex-texttt'>#getSelectableIdeaList</span> bereits zugewiesen.
In Listing  <a href='#!idx:/deltaspike.html:fig:simulate_ui-selection'> Auswahl eines Eintrags </a>  wählen wir einen Eintrag aus dieser Liste und
übergeben diesen der Methode  <span class='latex-texttt'>promotionWizardCtrl#select</span> .
Anschließend navigieren wir wie gewohnt mit dem nachfolgenden Request auf die nächste Seite des Wizards.
Mit dem Aufruf der Action-Methode  <span class='latex-texttt'>#toStep2</span>  bestätigen wir diesen Wizard-Schritt zur Auswahl einer Idee.
In den verbleibenden Wizard-Schritten geben wir eine Beschreibung für den Promotion-Request und speichern diesen schließlich.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:simulate_ui-selection'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    newRequest();

    promotionWizardCtrl.select(selectableIdeas.iterator().next());

    newRequest();

    navigationResult = promotionWizardCtrl.toStep2();
    Assert.assertEquals(
      Pages.PromotionWizard.Step2.class, navigationResult);

    newRequest(); //simulates a redirect

    promotionWizardCtrl.onPreRenderView();

    newRequest();

    promotionWizardCtrl.getPromotionRequest()
      .setDescription("promote it");
    navigationResult = promotionWizardCtrl.showConfirmation();
    Assert.assertEquals(
      Pages.PromotionWizard.FinalStep.class, navigationResult);

    newRequest(); //simulates a redirect

    promotionWizardCtrl.onPreRenderView();

    newRequest();

    promotionWizardCtrl.savePromotionRequest();

    //...
  }

  //...
}
</code></pre>
                </div> Wie man Page-Bean-Tests im Detail umsetzt, kann auf die konkreten Gegebenheiten angepasst werden.
Auch in Page-Bean-Tests können wir aus technischer Sicht wie bisher beliebige CDI-Beans verwenden.
In Listing  <a href='#!idx:/deltaspike.html:fig:mixed_page-bean_test'> Direkter Zugriff auf Services </a>  wählen wir für den letzten Schritt eine Abkürzung über das  <span class='latex-texttt'>IdeaService</span> -Bean.
Da für die Bestätigung von Promotion-Requests ein anderer User benötigt wird,
müssten wir mit einem Test, der nur Page-Beans verwendet, diesen User erneut registrieren und einloggen.
Erst dann könnten wir mit  <span class='latex-texttt'>PromotionRequestListViewCtrl</span>  die Promotion-Requests anderer User überprüfen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/deltaspike.html:fig:mixed_page-bean_test'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  //...

  @Inject
  private IdeaService ideaService;

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    //...

    newRequest();

    User testUser = new User("tester", null, null);
    List&lt;PromotionRequest&gt; foundPromotionRequests =
      ideaService.loadRecentIdeaPromotions(testUser, "*");
    Assert.assertNotNull(foundPromotionRequests);
    Assert.assertEquals(1, foundPromotionRequests.size());

    PromotionRequest loadedPromotionRequest =
      foundPromotionRequests.iterator().next();

    Assert.assertEquals("promote it",
      loadedPromotionRequest.getDescription());
    Assert.assertEquals(topic,
      loadedPromotionRequest.getIdeaForPromotion().getTopic());
    Assert.assertEquals(category,
      loadedPromotionRequest.getIdeaForPromotion().getCategory());

    //...
    newRequest();

    foundPromotionRequests =
      ideaService.loadRecentIdeaPromotions(testUser, "x");
    Assert.assertNotNull(foundPromotionRequests);
    Assert.assertTrue(foundPromotionRequests.isEmpty());
  }

  //...
}
</code></pre>
                </div><div class="tip"><b>Tipp: </b> Im Git-Repository von  <span class='latex-textit'>IdeaFork</span>  sind neben den beiden Überprüfungen zu  <span class='latex-texttt'>#loadRecentIdeaPromotions</span> noch weitere Varianten enthalten, die verschiedene Parameterwerte überprüfen. </div> In unserem Test haben wir einen kompletten Durchlauf von der Registrierung eines neuen Users
bis hin zur Überprüfung von Promotion-Requests anderer User veranschaulicht.
Dabei haben wir verschiedene Aspekte wie die Simulierung neuer Requests, Verwendung von Page-Beans
bis hin zur typsicheren Überprüfung von Navigationsergebnissen in Tests kennengelernt.
In der Praxis werden je Test-Methode eher kleinere Ausschnitte der Applikation getestet.
Auch für solche Fälle können beispielsweise Daten zuerst mit anderen CDI-Beans erzeugt werden,
um mit dem so erzeugten Zustand in der Applikation einzelne Page-Beans zu testen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><div class="tip"><b>Tipp: </b> Tests, die von UI-Logik bis hin zur Datenzugriffsschicht komplette Use-Cases überprüfen,
dauern im Normalfall etwas länger als simple Unit-Tests und
daher wird im Git-Repository von  <span class='latex-textit'>IdeaFork</span>  ein eigenes Test-Profil namens  <span class='latex-texttt'>DeltaSpikeTest</span>  für diese Tests verwendet. </div> In diesem Kapitel haben wir uns einen groben Überblick über den Funktionsumfang von Apache DeltaSpike verschafft.
Außerdem haben wir mit einer eigenen typsicheren Konfiguration die verfügbaren Mechanismen erweitert.
Im nächsten Kapitel werden wir mit Hilfe von DeltaSpike andere Container wie beispielsweise Spring und Akka mit CDI integrieren.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Mit DeltaSpike 2.0 wurde die Migration auf den <span class='latex-texttt' style='color:#2e7d32;'>jakarta.*</span>-Namespace vollzogen, um die Kompatibilität mit Jakarta EE 10 sicherzustellen. Darüber hinaus ersetzt MicroProfile Config in modernen Laufzeitumgebungen wie Quarkus wesentliche Teile des hier beschriebenen Konfigurationsmechanismus. Details zur Namespace-Migration finden Sie in Kapitel <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a>, Informationen zu den Quarkus-Alternativen für DeltaSpike-Module in Kapitel <a href='#!idx:/quarkus.html:10' style='color:#2e7d32;'>10</a>.</div>
</section>
<section class="chapter-section" id="chapter-6">
<h1> <a class='latex-index-anchor' name='!idx:/cdi_lite.html:6' ><span class='entry-number'>6</span> CDI Lite</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Der Text dieses Kapitels wurde von Claude (AI built by Anthropic) als Co-Autor überarbeitet. Diese Überarbeitung erfolgte ohne nachträgliches Review durch den Originalautor. Verwendung auf eigene Verantwortung.
</div>
<a name = '!idx:/cdi_lite.html:chap:cdi_lite'> </a> In den bisherigen Kapiteln mag bei manchen der Eindruck entstanden sein, dass CDI sehr umfangreich ist.
Die Spezifikation wurde zwar von Grund auf neu geschrieben und leidet nicht unter Altlasten,
allerdings sind am Ende auch Konzepte spezifiziert worden, die eher exotisch wirken können.
In der Praxis ist es jedoch nicht erforderlich bzw. nur selten sinnvoll, alle CDI-Konzepte in einer Applikation zu verwenden.
Daher machen wir in diesem Kapitel eine Inventur des Zwischenstandes und vereinfachen die Implementierung von  <span class='latex-textit'>IdeaFork</span> ,
indem wir nur die für  <span class='latex-textit'>IdeaFork</span>  sinnvollen Konzepte behalten.<br />
<div class="tip"><b>Tipp: </b>Der Name &bdquo;IdeaForkLite&ldquo; bezieht sich auf eine vereinfachte Version der Applikation und hat nichts mit der CDI Lite-Spezifikation (CDI 4.0) zu tun. Die CDI Lite-Spezifikation definiert ein Build-Zeit-kompatibles Subset von CDI &mdash; siehe Kapitel <a href='#!idx:/upgrade.html:9.3'>9.3</a> für die formale Definition.</div>
 <h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.1' ><span class='entry-number'>6.1</span> Weniger Alternativen</a> </h2>
 In  <span class='latex-textit'>IdeaFork</span>  haben wir das Konzept alternativer Implementierungen verwendet,
um zur Entwicklungszeit einfach zwischen Frameworks wie beispielsweise GSon und Jackson wechseln zu können.
Da wir in  <span class='latex-textit'>IdeaFork</span>  recht früh auf  <span class='latex-texttt'>@com.fasterxml.jackson.annotation.JsonView</span>  zurückgegriffen haben,
sind unsere Implementierungen vom  <span class='latex-texttt'>ObjectConverter</span> -Interface nicht vollständig portabel.
Folglich würde die Verwendung von Gson in  <span class='latex-textit'>IdeaFork</span>  aktuell zu einem anderen Resultat führen.
Durch die Aktivierung von  <span class='latex-texttt'>@JacksonConverter</span>  in der Datei  <span class='latex-texttt'>beans.xml</span>  haben wir diesen Effekt nicht aktiv beobachtet.
Sofern wir unsere auf Gson basierte Implementierung nicht ergänzen, haben wir für diese keine Verwendung mehr.
Auch die beschriebenen Mechanismen zur dynamischen Bestimmung des aktuellen Export-Formats können
zwar in verschiedenen Bereichen vielfältig eingesetzt werden, in  <span class='latex-textit'>IdeaFork</span>  können wir uns dennoch auf JSON als Export-Format beschränken.
Die Kombination beider Vereinfachungen ermöglicht es neben  <span class='latex-texttt'>@JacksonConverter</span>  auch den Qualifier  <span class='latex-texttt'>@ExternalFormat</span> ,
das  <span class='latex-texttt'>ObjectConverter</span> -Interface, sämtliche JAXB-Annotationen wie beispielsweise  <span class='latex-texttt'>@XmlRootElement</span>  und
das  <span class='latex-texttt'>CurrentObjectConverterProducer</span> -Bean zu entfernen.
Übrig bleibt ein einfaches CDI-Bean, das direkt an Jackson delegiert und in Listing  <a href='#!idx:/cdi_lite.html:fig:minimal_object-converter'> Object-Converter ohne Abstraktionen </a>  zu sehen ist.
Somit werden wir in diesem Bereich sämtliche Abstraktionen los,
die wir primär zur Veranschaulichung diverser CDI-Mechanismen in  <span class='latex-textit'>IdeaFork</span>  eingeführt haben.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_lite.html:fig:minimal_object-converter'></a>                     <pre><code>public class ObjectConverter {
  //...

  public String toString(Object entity, Class typeSafeDataView) {
    try {
      ObjectMapper objectMapper = new ObjectMapper();
      if (typeSafeDataView != null) {
        objectMapper.configure(
          MapperFeature.DEFAULT_VIEW_INCLUSION, false);
        return objectMapper.writerWithView(typeSafeDataView)
                 .writeValueAsString(entity);
      }
      return objectMapper.writeValueAsString(entity);
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(e);
    }
  }
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.2' ><span class='entry-number'>6.2</span> Von Decoratoren zu Interceptoren</a> </h2>
 CDI-Decoratoren gehören zu den Konzepten, die in der freien (Applikations-)Wildbahn eher selten anzutreffen sind.
In vielen Fällen ist ein einfacher Interceptor ausreichend.
In  <span class='latex-textit'>IdeaFork</span>  haben wir mit Decoratoren zusätzliche Logik für  <span class='latex-texttt'>UserRepository</span>  und  <span class='latex-texttt'>IdeaRepository</span>  umgesetzt.
Der primäre Vorteil besteht hierbei in der Typsicherheit von Decoratoren.
Würden wir beispielsweise die Methode  <span class='latex-texttt'>GenericRepository#save</span>  umbenennen,
dann ist sichergestellt, dass diese Änderung in sämtlichen Implementierungen berücksichtigt wird.
Hierzu zählt auch  <span class='latex-texttt'>GenericRepositoryDecorator</span> .
Hätten wir hingegen einen Interceptor, dann müssten wir manuell mit Strings arbeiten, wodurch die Typsicherheit nicht mehr gegeben ist.
Der Zusatzaufwand für Decoratoren kann somit durchaus gerechtfertigt sein.
In manchen Fällen kann es auch sinnvoll sein, auf die Vorteile von Decoratoren zu verzichten.
So können wir beispielsweise  <span class='latex-texttt'>GenericRepository</span> ,  <span class='latex-texttt'>GenericJpaRepository</span> , sowie unsere eigene  <span class='latex-texttt'>@Repository</span> -Annotation
durch die Verwendung von DeltaSpike-Data entsorgen.
Wir sind allerdings nicht nur auf die von DeltaSpike-Data generierte Logik angewiesen.
Wollen wir diese mit eigenen Implementierungen kombinieren, dann müssen wir statt Interfaces auf abstrakte Klassen zurückgreifen.
Während implementierte Methoden unverändert aufgerufen werden, formt DeltaSpike-Data abstrakte Methoden zu entsprechenden JPA-Queries um.
Dieser Mechanismus erlaubt es, auf einfache Art und Weise eigene Logik mit generierter Logik zu mischen,
wodurch wir sämtliche Repository-Beans deutlich vereinfachen können.
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In einem weiteren Schritt können wir unseren Decorator-Mechanismus für Repositories überarbeiten.
Da das  <span class='latex-texttt'>org.apache.deltaspike.data.api.EntityRepository</span> -Interface alle Methoden,
die wir in unseren Decoratoren bisher "erweitert" haben, enthält und sich diese nicht ändern,
können wir die typsicheren Decoratoren bedenkenlos durch einen generischen Interceptor ersetzen.<br />Listing  <a href='#!idx:/cdi_lite.html:fig:ds-data_with_interceptors'> DeltaSpike-Data Repository mit Interceptoren </a>  zeigt eine mögliche Umstellung von  <span class='latex-texttt'>UserRepository</span>  auf Basis von DeltaSpike-Data.
Nachdem wir alle anderen Repositories in  <span class='latex-textit'>IdeaFork</span>  ebenfalls umgestellt haben, können wir die zuvor genannten Artefakte,
wie beispielsweise  <span class='latex-texttt'>GenericJpaRepository</span>  und  <span class='latex-texttt'>UserRepositoryDecorator</span> , löschen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_lite.html:fig:ds-data_with_interceptors'></a>                     <pre><code>@Monitored
@EntityProcessor

@Transactional
@Repository
public abstract class UserRepository
  implements EntityRepository&lt;User, String&gt; {

  @Inject
  private EntityManager entityManager;

  public User loadByNickName(String nickName) {
    //...
  }

  public User loadByEmail(String email) {
    //...
  }
}
</code></pre>
                </div> Statt der entfernten Decoratoren können wir einen Interceptor namens  <span class='latex-texttt'>EntityProcessorInterceptor</span>  einführen.
Wie Listing  <a href='#!idx:/cdi_lite.html:fig:entity-processor_interceptor'> EntityProcessor Interceptor </a>  verdeutlicht, müssen wir bei  <span class='latex-texttt'>EntityProcessorInterceptor</span>  auf Strings zurückgreifen,
wodurch die Implementierung nicht typsicher ist. In unserem Fall nutzen wir jedoch den Vorteil,
dass die für uns interessanten Methoden durch DeltaSpike-Data vordefiniert sind und sich somit nicht ändern.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_lite.html:fig:entity-processor_interceptor'></a>                     <pre><code>@Interceptor
@EntityProcessor
public class EntityProcessorInterceptor implements Serializable {

  @Inject
  private BeanManager beanManager;

  @Inject
  @Default
  private Event&lt;UserChangedEvent&gt; userChangedEvent;

  @Inject
  @Default
  private Event&lt;IdeaChangedEvent&gt; ideaChangedEvent;

  @AroundInvoke
  public Object intercept(InvocationContext ic) throws Exception {
    boolean saveMethod = false;
    boolean validateEntityParameter = false;

    Object[] parameters = ic.getParameters();
    if (parameters.length == 1) {
      Class parameterType = resolveParameterType(ic.getTarget());

      if (parameterType != null &&
          BaseEntity.class.isAssignableFrom(parameterType)) {

          String methodName = ic.getMethod().getName();

          if ("save".equals(methodName)) {
            saveMethod = true;
            validateEntityParameter = true;
          } else if ("remove".equals(methodName) ||
              "attachAndRemove".equals(methodName)) {

            validateEntityParameter = true;
          }
      }
    }

    if (validateEntityParameter) {
      checkEntity((BaseEntity) ic.getParameters()[0]);
    }

    Object result = ic.proceed();

    if (saveMethod) {
      if (parameters[0] instanceof User) {
        broadcastUserChangedEvent((User) ic.getParameters()[0]);
      } else if (parameters[0] instanceof Idea) {
        broadcastIdeaChangedEvent((Idea) ic.getParameters()[0]);
      }
    }

    return result;
  }

  private void checkEntity(BaseEntity entity) {
    //...
  }

  private Class resolveParameterType(Object target) {
    //...
  }

  private void broadcastUserChangedEvent(User entity) {
    UserChangedEvent userChangedEvent = new UserChangedEvent(entity);
        this.userChangedEvent.fire(userChangedEvent);
  }

  public void broadcastIdeaChangedEvent(Idea entity) {
        IdeaChangedEvent ideaChangedEvent = new IdeaChangedEvent(entity);
        this.ideaChangedEvent.fire(ideaChangedEvent);
  }
}
</code></pre>
                </div> Durch die Umstellung auf einen Interceptor und auf DeltaSpike-Data hat sich der auf Reflection basierte Teil von  <span class='latex-texttt'>GenericJpaRepository#detectConcreteEntityType</span>  nach  <span class='latex-texttt'>EntityProcessorInterceptor#resolveParameterType</span>  verlagert.
Somit haben wir zwar einige Teile wesentlich vereinfacht, aber ein kleiner Teil mit Reflection ist geblieben.
Diesen könnten wir nur mit spezialisierten Interceptoren vermeiden, die allerdings etwas aufwändiger wären.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.3' ><span class='entry-number'>6.3</span> Weniger ist mehr</a> </h2>
 Genau genommen können wir in  <span class='latex-textit'>IdeaFork</span>  auch auf Interceptor-Strategies verzichten,
da wir in einem der nachfolgenden Schritte das  <span class='latex-texttt'>ideafork-core</span> -Modul auflösen werden und
die Anpassbarkeit der vorkonfigurierten  <span class='latex-texttt'>MonitoredInterceptor</span> -Klasse an Bedeutung verliert.
Folglich können wir das Interface  <span class='latex-texttt'>MonitoredInterceptorStrategy</span>  entfernen und
die dazugehörige Implementierung nach  <span class='latex-texttt'>MonitoredInterceptor</span>  verschieben.
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In anderen Fällen, wie bei den Project-Stages von DeltaSpike, ist es oftmals ausreichend, bestehende Mechanismen unverändert zu verwenden.
So können wir in  <span class='latex-textit'>IdeaFork</span>  die vorgegebenen Project-Stages von DeltaSpike ohne die  <span class='latex-texttt'>CustomProjectStage</span> -Erweiterung einsetzen.
Besonders in großen Projekten kann es erforderlich werden, zusätzliche Stages zu definieren.
DeltaSpike ist für solche Fälle erweiterbar und folglich gut für Anforderungen realer Applikationen gerüstet.
In  <span class='latex-textit'>IdeaFork</span>  ist die Unterscheidung von Project-Stage  <span class='latex-texttt'>Development</span> ,  <span class='latex-texttt'>UnitTest</span>  und  <span class='latex-texttt'>Production</span>  jedoch ausreichend.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.4' ><span class='entry-number'>6.4</span> Konventionen einhalten</a> </h2>
 DeltaSpike ist sehr flexibel und anpassbar. Eine Anpassungsmöglichkeit haben wir bei der typsicheren View-Config kennengelernt.
In wenigen Schritten haben wir die Pfadkonvention eines Teilbereiches abändern können.
Halten wir uns jedoch an die vordefinierten Konventionen, dann ist die resultierende View-Config einfacher und transparenter.
Listing  <a href='#!idx:/cdi_lite.html:fig:convention_based_view-config'> Vereinfachte View-Config </a>  zeigt den vereinfachten Ausschnitt für  <span class='latex-textit'>IdeaFork</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_lite.html:fig:convention_based_view-config'></a>                     <pre><code>@ViewConfigRoot(
  configDescriptorValidators = IdeaForkViewMetaDataValidator.class)
@View(navigation = REDIRECT)
public interface Pages extends ViewConfig {
  @ViewControllerRef(IndexViewCtrl.class)
  class Index implements Pages {}

  @Secured(UserAwareAccessDecisionVoter.class)
  interface SecuredPages extends Pages {}

  interface User extends Pages {
    @EntryPoint
    class Login extends DefaultErrorView {}

    @EntryPoint
    class Registration implements User {}

    class Profile implements SecuredPages {}
  }

  //...

  interface Promotion extends SecuredPages {
    interface Selection extends Promotion {
      @View(viewParams = INCLUDE)
      @NavigationParameter(key = "searchHint", value = "*")
      @ViewControllerRef(PromotionRequestListViewCtrl.class)
      class List implements Selection {}

      @View(name = "promote")
      class SelectPromotion implements Selection {}
    }

    @Folder(name = "wizard")
    @Wizard
    interface PromotionWizard extends Promotion {
      @EntryPoint
      @ViewControllerRef(PromotionWizardCtrl.class)
      class Step1 implements PromotionWizard {}

      class Step2 implements PromotionWizard {}

      @View(name = "summary")
      class FinalStep implements PromotionWizard {}
    }
  }
}
</code></pre>
                </div> Natürlich müssen die JSF-Seiten passend zur neuen View-Config ebenfalls verschoben werden,
damit die Applikation weiterhin wie gewünscht funktioniert.
Bei dieser Umstellung wird auch eine der Stärken von View-Configs erneut sichtbar.
Während die Existenz der konfigurierten Seiten beim Applikationsstart geprüft wird,
stellt der Compiler bereits beim Build-Prozess der Applikation sicher, dass alle betroffenen Seitennavigationen aktualisiert wurden.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_lite.html:6.5' ><span class='entry-number'>6.5</span> Ebenen einsparen</a> </h2>
 Im letzten Schritt vereinfachen wir auch die Struktur, indem wir das unabhängige  <span class='latex-texttt'>ideafork-core</span> -Modul auflösen und
dadurch überflüssige Layer entfernen.
Ursprünglich haben wir das  <span class='latex-texttt'>ideafork-core</span> -Modul von der restlichen Java EE Applikation abgegrenzt,
um zu verdeutlichen, dass CDI auch unabhängig von Java EE verwendet werden kann.
Um weiterhin die namentliche Trennung der beiden Teile zu behalten, verschieben wir das Package  <span class='latex-texttt'>at.irian.cdiatwork.ideafork.core</span> in das existierende  <span class='latex-texttt'>ideafork-ee6</span> -Modul.
Diese Änderung spiegelt sich auch im Maven-Build wider.
In der Konfiguration für  <span class='latex-texttt'>ideafork-ee6</span>  entfernen wir die Verweise auf  <span class='latex-texttt'>ideafork-core</span>  und
fügen stattdessen alle Dependencies hinzu, die bisher in  <span class='latex-texttt'>ideafork-core</span>  definiert waren.
Durch diese Vereinfachung können wir außerdem einige Buildkonfigurationen für die unterschiedlichen EE-Server stark vereinfachen.<br /> <div class="tip"><b>Tipp: </b> Wegen der starken Umstrukturierung sind sämtliche Änderungen in einem eigenen Git-Repository von  <span class='latex-textit'>IdeaFork</span> namens  <span class='latex-textit'>IdeaForkLite</span>  zusammengefasst.
In diesem Repository gibt es für jede Umstellung in diesem Kapitel einen eigenen Commit.
Folglich lassen sich sämtliche Änderungen einfach nachvollziehen. </div> Die Umstrukturierung ermöglicht zusätzlich die Einsparung der Manager-Ebene,
da wir diese Kapselung in  <span class='latex-textit'>IdeaFork</span> -Core nicht mehr benötigen.
Stattdessen verschieben wir die implementierte Logik in die entsprechenden Service-Klassen,
die schließlich direkt auf die neuen und stark vereinfachten Repository-Beans zugreifen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Mit den gezeigten Vereinfachungen sind wir für die nachfolgenden Kapitel gut gerüstet,
da wir beispielsweise im nächsten Kapitel durch die Integration von anderen Frameworks die Komplexität wieder etwas erhöhen.
In realen Applikationen ist es keine Seltenheit, dass mehrere Frameworks kombiniert werden müssen.
Je geringer wir die Komplexität der Grundstruktur halten, desto wartbarer wird die gesamte Applikation.
Sowohl CDI als auch DeltaSpike ermöglichen nicht nur innovative und flexible Ansätze,
sondern auch die Reduktion von Komplexität in Bereichen, in denen diese nicht erforderlich ist.
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Seit CDI 4.0 (Jakarta EE 10) hat der Begriff „CDI Lite" eine offizielle Bedeutung als Spezifikationsprofil erhalten, das die build-time-kompatible Teilmenge von CDI definiert. Das in diesem Kapitel beschriebene Konzept – nur die tatsächlich benötigten Features zu verwenden – ist davon unabhängig, verfolgt aber eine ähnliche Philosophie. Die Unterscheidung zwischen beiden Bedeutungen wird in Kapitel <a href='#!idx:/upgrade.html:9' style='color:#2e7d32;'>9</a> erläutert.</div>
<div class="tip"><b>Tipp: </b><span class='latex-textit'>IdeaForkLite</span> hat gezeigt, dass CDI auch außerhalb eines vollständigen Java-EE-Servers effizient arbeitet. Kapitel <a href='#!idx:/cdi_usecases.html:8'>8</a> führt diesen Ansatz mit <span class='latex-textit'>IdeaForkMicro</span> weiter &mdash; einer Microservice-Architektur, die CDI als zentrales Komponentenmodell nutzt.</div>
</section>
<section class="chapter-section" id="chapter-7">
<h1> <a class='latex-index-anchor' name='!idx:/integration.html:7' ><span class='entry-number'>7</span> CDI oder nicht CDI</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Der Text dieses Kapitels wurde von Claude (AI built by Anthropic) als Co-Autor überarbeitet. Diese Überarbeitung erfolgte ohne nachträgliches Review durch den Originalautor. Verwendung auf eigene Verantwortung.
</div>
<a name = '!idx:/integration.html:chap:cdi-integration'> </a> Die Relevanz einer beliebten Technologie stellt sich oft erst nach Jahren heraus, sobald der anfängliche Hype abgeklungen ist.
Bei CDI ist das Ergebnis eindeutig. Viele Java EE Applikationen profitieren von CDI, da Applikations- und
Testlogik sehr effizient umgesetzt werden können.
Darüber hinaus wird aktuell mit jeder Version von Java EE die CDI-Integration anderer Spezifikationen wie beispielsweise JSF weiter ausgebaut,
wodurch CDI immer stärker zu einem essenziellen Aspekt von Java EE wird.
Im Falle von JSF werden verschiedene neue Funktionalitäten sogar nur noch in Verbindung mit CDI unterstützt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Auch außerhalb der Java EE Plattform erfreut sich CDI großer Beliebtheit.
So gut wie jedes populäre Framework, das mit Dependency-Injection Frameworks integriert ist,
unterstützt CDI direkt oder ermöglicht zumindest eine einfache Integration.
Es ist mittlerweile gar nicht mehr einfach, ein beliebtes Framework ohne CDI-Modul zu finden.
Ein Applikationsframework ohne mitgelieferten CDI-Support ist das Aktorenframework Akka (siehe http://akka.io).
Dies nehmen wir zum Anlass, um die einfache Integration von CDI mit anderen Frameworks zu veranschaulichen.<br />
<div class="tip"><b>Tipp: </b><b>DeltaSpike 2.0 und der aktuelle Projektstatus:</b> DeltaSpike 2.0 unterstützt den <span class='latex-texttt'>jakarta.*</span>-Namespace und ist damit auf Jakarta EE 10+ vorbereitet. Allerdings hat die Entwicklungsaktivität des Projekts seit der Veröffentlichung von MicroProfile und Quarkus deutlich abgenommen. Für neue Projekte sollte geprüft werden, welche DeltaSpike-Module noch benötigt werden &mdash; viele Funktionen sind inzwischen in Standards aufgegangen.</div>
<div class="tip"><b>Tipp: </b>Viele DeltaSpike-Innovationen wurden in CDI-Spezifikationen oder MicroProfile absorbiert: Die Konfiguration lebt in MicroProfile Config weiter, <span class='latex-texttt'>@Exclude</span> hat ein Pendant in <span class='latex-texttt'>@Vetoed</span>, und das Security-Modul wurde durch Jakarta Security standardisiert. Evaluieren Sie bei Migrationsprojekten, welche Module Ihr Projekt tatsächlich noch benötigt und welche durch Standard-Alternativen ersetzt werden können.</div>
 <h2><a class='latex-index-anchor' name='!idx:/integration.html:7.1' ><span class='entry-number'>7.1</span> CDI-Integration durch Producer</a> </h2>
 Bevor wir mit der Integration von CDI und Akka beginnen können, ist es wichtig, die grundlegenden Eigenschaften beider Technologien zu kennen und
zu verstehen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Zu CDI haben wir uns bereits in den vorherigen Kapiteln einige Details angesehen.
Daher können wir uns an dieser Stelle auf die wichtigsten Aspekte von Akka beschränken.
Das zentrale Konzept von Akka sind Aktoren.
Aktoren verarbeiten Nachrichten asynchron, wobei eine Aktoreninstanz für die Verarbeitung einer Nachricht von einem Thread ausgeführt wird.
Sendet ein Aktor eine Nachricht an einen anderen Aktor, dann erfolgt die Weiterverarbeitung im Normalfall durch einen anderen Thread.
Daher können wir nicht wie bei Java EE davon ausgehen,
dass es eine Art Request gibt, der von einem Thread komplett verarbeitet wird und nur im Ausnahmefall asynchron verzweigt.
Lediglich die Nachrichtenverarbeitung innerhalb eines Aktors ist einem bestimmten Thread zugeordnet, wodurch Threadsicherheit garantiert ist.
Einem Aktor kann über eine sogenannte Aktorenreferenz eine Nachricht übermittelt werden.
Diese Referenz ist nicht wie eine Contextual-Reference von CDI unbeschränkt gültig.
Da Akka in einigen Versionen andere Regeln für verschiedene Aktorentypen definiert,
ist für die nachfolgenden Integrationsschritte primär wichtig, dass Aktorenreferenzen nicht immer unbeschränkt gültig sind und
es sicherer ist, regelmäßig neue Referenzen zu erzeugen.<br /> <div class="tip"><b>Tipp: </b> Eine weitere Regel, die spezifisch für Akka gilt, betrifft den Scope einer Aktoreninstanz.
In der Dokumentation von Akka wird empfohlen, nur Instanzen zu verwenden, die durch keinen anderen Container verwaltet werden.
Im Falle von CDI bedeutet dies beispielsweise die Verwendung von einfachen dependent-scoped Beans für Aktoren.
Denn für dependent-scoped Beans ohne Interceptoren und
Decoratoren erzeugt der CDI-Container normalerweise keine Contextual-Referenz in Form eines Proxies.
In den Aktor-Instanzen selbst können wir CDI-Beans mit anderen Scopes injizieren,
sofern der entsprechende Context beim Zugriff auf die Contextual-Reference aktiv ist.
Die Injizierung muss bei Akka jedoch via Constructor-Injection erfolgen. </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaForkLite</span>  können wir Akka zum asynchronen Versenden von CDI-Events verwenden.
Da Aktoren selbst bereits in eigenen Threads ausgeführt werden,
müssen wir hierfür nur CDI-basierte Injizierung für Aktoreninstanzen ermöglichen, um in diesen anschließend CDI-Events synchron zu feuern.
Darüber hinaus können wir auch für CDI-Beans das Versenden von Nachrichten an Aktoren erleichtern.
In  <span class='latex-texttt'>EntityProcessorInterceptor</span>  von  <span class='latex-textit'>IdeaForkLite</span>  wird bisher das Event  <span class='latex-texttt'>IdeaChangedEvent</span>  synchron gefeuert.
Um über einen Aktor die asynchrone Variante dieses Events zu feuern, müssen wir eine entsprechende Aktorenreferenz hinzufügen.
Da Interceptoren die Lebensdauer des jeweils intercepteten CDI-Beans erhalten, sollten wir diese Aktorenreferenz nicht direkt injizieren.
Technisch wäre dies zwar möglich, aber wie eingangs erwähnt können Aktorenreferenzen ungültig werden.
Somit bietet es sich an einen möglichst kurzen Scope für CDI-Beans zu wählen, in denen Aktorenreferenzen injiziert werden sollen.
Eine mögliche Variante in  <span class='latex-textit'>IdeaForkLite</span>  ist die Auslagerung der zuvor erwähnten Event-Logik
in ein CDI-Bean namens  <span class='latex-texttt'>IdeaEventBroadcaster</span> , das beispielsweise im bereits vorgestellten Transaction-Scope von DeltaSpike abgelegt wird.
Wie wir in den weiteren Schritten sehen werden, muss die Aktorenreferenz selbst ein dependent-scoped CDI-Bean sein.
Durch die Kombination aus einer dependent-scoped Aktorenreferenz und
der Verwendung in einem Transaction-Scope Bean beschränken wir die Lebensdauer einer Aktorenreferenz in unserem Beispiel auf eine Transaktion.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Akka stellt für Aktorenreferenzen eine eigene Klasse namens  <span class='latex-texttt'>ActorRef</span>  zur Verfügung.
Da diese Klasse unabhängig von einem konkreten Aktor ist, müssen wir, wie in Listing  <a href='#!idx:/integration.html:fig:notify_akka_actor'> Notifizierung von Akka-Aktoren </a>  zu sehen ist,
einen eigenen CDI-Qualifier namens  <span class='latex-texttt'>@Actor</span>  verwenden.
Dieser selbst definierte CDI-Qualifier ermöglicht die Angabe der Aktorenklasse,
damit wir später feststellen können, welchem Aktor die Nachricht übermittelt werden soll.
Den dazugehörigen Producer werden wir in einem der nächsten Schritte betrachten.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:notify_akka_actor'></a>                     <pre><code>@TransactionScoped
public class EntityChangedEventBroadcaster {
  //...

  @Inject
  @Actor(type = IdeaChangedEventActor.class)
  private ActorRef asyncBroadcaster;

  public void broadcastIdeaChangedEvent(Idea entity) {
    IdeaChangedEvent ideaChangedEvent = new IdeaChangedEvent(entity);
    this.asyncBroadcaster.tell(ideaChangedEvent, this.asyncBroadcaster);
    //...
  }
}
</code></pre>
                </div> Mit der Methode  <span class='latex-texttt'>ActorRef#tell</span>  können wir dem dahinterliegenden Aktor eine Nachricht senden, die asynchron durch Akka zugestellt wird.
Die Verarbeitung der so übermittelten Nachricht kann beispielsweise wie in Listing  <a href='#!idx:/integration.html:fig:actor_with_cdi-support'> Aktor mit CDI-Support </a>  erfolgen.
Die einzige Vorgabe von Akka zur Implementierung eines Java-Aktors ist hierbei die Erweiterung der Klasse  <span class='latex-texttt'>UntypedActor</span> ,
wodurch die Aktorenmethode  <span class='latex-texttt'>#onReceive</span>  vorgegeben wird.
Jede Nachricht an einen Aktor wird durch diese Methode in einem eigenen Aktor-Thread verarbeitet.<br />In Listing  <a href='#!idx:/integration.html:fig:actor_with_cdi-support'> Aktor mit CDI-Support </a>  wird zusätzlich über Constructor-Injection
ein CDI-Event ( <span class='latex-texttt'>javax.enterprise.event.Event</span> ) injiziert.
Durch die Typisierung auf  <span class='latex-texttt'>IdeaChangedEvent</span>  und
den selbst definierten  <span class='latex-texttt'>@Async</span> -Qualifier können wir innerhalb der Aktoreninstanz ein speziell qualifiziertes CDI-Event feuern.
Das effektive Feuern des CDI-Events mit Hilfe der Methode  <span class='latex-texttt'>#fire</span>  erfolgt synchron.
Da die Methode  <span class='latex-texttt'>#onReceive</span>  selbst jedoch asynchron ausgeführt wird,
ist das Feuern des CDI-Events aus der Sicht von  <span class='latex-texttt'>EntityChangedEventBroadcaster</span>  asynchron und
blockiert dessen weitere Ausführung somit nicht.
Der Qualifier  <span class='latex-texttt'>@Async</span>  dient lediglich zur Unterscheidung bzw. Selektion dieses neuen Event-Typs.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:actor_with_cdi-support'></a>                     <pre><code>public class IdeaChangedEventActor extends UntypedActor {
  private final Event&lt;IdeaChangedEvent&gt; entityChangedEvent;

  @Inject
  public IdeaChangedEventActor(
    @Async Event&lt;IdeaChangedEvent&gt; entityChangedEvent) {

    this.entityChangedEvent = entityChangedEvent;
  }

  @Override
  public void onReceive(Object message) throws Exception {
    if (message instanceof IdeaChangedEvent) {
      this.entityChangedEvent.fire((IdeaChangedEvent)message);
    } else {
      unhandled(message);
    }
  }
}
</code></pre>
                </div><span class='latex-texttt'>@Async IdeaChangedEvent</span>  repräsentiert ein synchrones CDI-Event, das in einem asynchronen Aktor-Thread gefeuert wird.
Der in Listing  <a href='#!idx:/integration.html:fig:async_event-observer'> CDI Event-Observer für @Async IdeaChangedEvent </a>  ersichtliche CDI Event-Observer folgt dementsprechend den herkömmlichen Regeln für CDI-Observer.
Der  <span class='latex-texttt'>@Async</span> -Qualifier schränkt den Observer nur auf Events ein, die in unserem Fall durch  <span class='latex-texttt'>IdeaChangedEventActor</span>  gefeuert wurden.
Somit wird der Observer im gleichen Thread wie  <span class='latex-texttt'>IdeaChangedEventActor</span>  ausgeführt,
jedoch in einem anderen Thread als  <span class='latex-texttt'>EntityChangedEventBroadcaster</span> .
Folglich wird auch die Ausführung von  <span class='latex-texttt'>EntityProcessorInterceptor</span>  bzw. die Abarbeitung des gesamten Web-Requests nicht blockiert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:async_event-observer'></a>                     <pre><code>@ApplicationScoped
public class IdeaHistoryProcessor {
    @Inject
    private ObjectConverter currentObjectConverter;

    @Inject
    private EntityChangeRepository entityChangeRepository;

    public void onIdeaCreated(
      @Observes @Async IdeaChangedEvent changedEvent) {
        Idea entity = changedEvent.getEntity();
        String ideaSnapshot = currentObjectConverter.toString(entity);
        EntityChange entityChange = new EntityChange(
                entity.getId(),
                entity.getVersion() != null ? entity.getVersion() : 0,
                ideaSnapshot,
                changedEvent.getCreationTimestamp());

        entityChangeRepository.save(entityChange);
    }
}
</code></pre>
                </div> Der nächste Schritt deckt zwei Aspekte ab.
In Listing  <a href='#!idx:/integration.html:fig:notify_akka_actor'> Notifizierung von Akka-Aktoren </a>  haben wir einen Injection-Point vom Typ  <span class='latex-texttt'>ActorRef</span>  verwendet.
Da Akka derzeit kein eigenes CDI-Modul hat, benötigen wir einen CDI-Producer für diesen Typ.
Wie bereits erwähnt benötigen wir einen zusätzlichen CDI-Qualifier,
damit wir im Producer feststellen können, für welchen Aktorentyp eine Aktorenreferenz erstellt werden soll.
Listing  <a href='#!idx:/integration.html:fig:custom_actor-qualifier'> Eigener CDI-Qualifier für Aktoren </a>  zeigt eine mögliche Variante eines solchen Qualifiers.
Damit wir nicht für jeden konkreten Aktorentyp einen CDI-Producer benötigen,
sondern nur einen generischen Producer für alle Injection-Points vom Typ  <span class='latex-texttt'>ActorRef</span> , müssen wir alle Annotationmembers,
die nicht für die Zuordnung zu einer generischen Producer-Methode benötigt werden, mit  <span class='latex-texttt'>@Nonbinding</span>  markieren.
In unserem Beispiel werten wir alle Annotationmembers in der Producer-Methode selbst aus und
müssen daher auch alle mit  <span class='latex-texttt'>@Nonbinding</span>  annotieren.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:custom_actor-qualifier'></a>                     <pre><code>@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD})
public @interface Actor {
  String AKKA_DEFAULT = "default";

  @Nonbinding
  Class&lt;? extends akka.actor.Actor&gt; type();

  @Nonbinding
  String systemName() default AKKA_DEFAULT;
}
</code></pre>
                </div> Statt für jeden Aktoren-Typ, in unserem Fall  <span class='latex-texttt'>IdeaChangedEventActor</span>  und im nächsten Abschnitt  <span class='latex-texttt'>UserRegisteredEventActor</span> ,
einen separaten CDI-Producer anzulegen,
veranschaulicht Listing  <a href='#!idx:/integration.html:fig:actor-ref_producer'> Producer für Aktorenreferenzen </a>  eine generische Producer-Methode für sämtliche Injection-Points
vom Typ  <span class='latex-texttt'>ActorRef</span>  in Kombination mit dem Qualifier  <span class='latex-texttt'>@Actor</span> .
Die hierfür benötigte Aktorenklasse wird mit  <span class='latex-texttt'>@Actor#type</span>  erst im CDI-Bean,
in unserem aktuellen Beispiel mit  <span class='latex-texttt'>@Actor(type = IdeaChangedEventActor.class)</span> , angegeben.
Bei den bisherigen CDI-Producern haben wir CDI-Qualifier meistens nur für die Zuordnung von Injection-Point und Producer verwendet.
Solche Producer haben dann unabhängig vom Injection-Point eine Instanz erzeugt, die dem Injection-Point zugeordnet wurde.
In unserem aktuellen Beispiel ist dies nicht möglich, weil das Ergebnis des Producers von Metadaten des jeweiligen Injection-Points abhängig ist.
Das heißt unsere Producer-Methode muss Metadaten des Injection-Points dynamisch auswerten,
um im konkreten Fall die erforderliche Information von  <span class='latex-texttt'>@Actor</span>  zu erfahren.
Anders gesagt müssen wir die Metadaten der Referenzvariablen, in unserem Beispiel  <span class='latex-texttt'>ActorRef asyncBroadcaster</span> , auswerten,
bevor wir eine Contextual-Instance erzeugen können, die vom CDI-Container dieser Referenzvariablen zugewiesen wird.
Dieser Ansatz erscheint auf den ersten Blick eventuell unnötig kompliziert, ist aber immer dann erforderlich,
wenn ein generischer Producer für Injection-Points eines Typs mit unterschiedlichen Metadaten umgesetzt werden soll.
CDI definiert für solche Spezialfälle das Interface  <span class='latex-texttt'>javax.enterprise.inject.spi.InjectionPoint</span> .
Jede Producer-Methode für dependent-scoped Beans kann optional einen Parameter vom Typ  <span class='latex-texttt'>InjectionPoint</span>  verwenden,
um die Definition des jeweiligen Injection-Points auszuwerten.
Je Aufruf einer solchen Producer-Methode befüllt der CDI-Container diesen Parameter mit einer  <span class='latex-texttt'>InjectionPoint</span> -Instanz,
die den aktuellen  <span class='latex-texttt'>InjectionPoint</span>  repräsentiert.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Über Methoden wie beispielsweise  <span class='latex-texttt'>InjectionPoint#getAnnotated#getAnnotation</span>  kann auf Metadaten des aktuellen Injection-Points zugegriffen werden.
In Listing  <a href='#!idx:/integration.html:fig:actor-ref_producer'> Producer für Aktorenreferenzen </a>  holen wir uns vom Injection-Point die  <span class='latex-texttt'>@Actor</span> -Instanz über die eben erwähnte Methode.
Diese Instanz der  <span class='latex-texttt'>@Actor</span> -Annotation enthält alle Werte, die wir beim Injection-Point angegeben haben, und
für die Erzeugung einer passenden  <span class='latex-texttt'>ActorRef</span>  benötigen.
 <span class='latex-texttt'>@Actor#type</span>  liefert in unserem Beispiel  <span class='latex-texttt'>IdeaChangedEventActor.class</span>  zurück und
 <span class='latex-texttt'>@Actor#systemName</span>  den Default-Wert  <span class='latex-texttt'>default</span> .<br /> <div class="tip"><b>Tipp: </b> Wir wissen, dass  <span class='latex-texttt'>@Actor</span>  in unserem Beispiel vorhanden ist,
da unsere Producer-Methode für alle Injection-Points vom Typ  <span class='latex-texttt'>ActorRef</span>  zuständig ist,
die mit dem  <span class='latex-texttt'>@Actor</span> -Qualifier markiert sind. </div> Mit der soeben extrahierten Information können wir die Erzeugung des Aktorensystems an Akka delegieren.
Der hierfür nötige Aufruf von Akka ist in der Methode  <span class='latex-texttt'>#getActorSystem</span>  gekapselt.
Das Ergebnis dieses Aufrufs ist eine Instanz vom Typ  <span class='latex-texttt'>akka.actor.ActorSystem</span> ,
die für die Erzeugung einer  <span class='latex-texttt'>ActorRef</span>  verwendet werden kann.
Details hierzu sind im Git-Repository von  <span class='latex-textit'>IdeaForkLite</span>  ersichtlich.
Das von Akka erzeugte Aktorensystem kann in einer Map abgelegt werden.
Bei jedem weiteren Zugriff auf das gleiche Aktorensystem wird das bereits erzeugte Aktorensystem herangezogen.
Um die Aktorensysteme direkt in einer  <span class='latex-texttt'>ActorRefProducer</span> -Instanz für die Laufzeit der Applikation zu cachen,
ist diese Klasse mit  <span class='latex-texttt'>@ApplicationScoped</span>  annotiert.<br /> <div class="tip"><b>Tipp: </b> Die Producer-Methode wird neben  <span class='latex-texttt'>@Produces</span>  auch mit dem Qualifier  <span class='latex-texttt'>@Actor</span>  annotiert.
Da  <span class='latex-texttt'>@Actor#type</span>  keinen Default-Wert definiert,
wie es bei  <span class='latex-texttt'>@Actor#systemName</span>  der Fall ist, müssen wir einen beliebigen aber gültigen Wert an dieser Stelle angeben,
damit es zu keinem Kompilierungsfehler kommt. Der hier angegebene Wert  <span class='latex-texttt'>akka.actor.Actor.class</span>  wird zur Laufzeit ignoriert,
da er nur für den Kompilierungsprozess erforderlich ist. </div> Der letzte Schritt in der Producer-Methode aus Listing  <a href='#!idx:/integration.html:fig:actor-ref_producer'> Producer für Aktorenreferenzen </a>  ermöglicht die Injizierung von CDI-Beans in Aktor-Instanzen.
Handelt es sich um eine Aktor-Implementierung, die von  <span class='latex-texttt'>UntypedActor</span>  ableitet, so wird dem Aktorensystem mitgeteilt,
dass  <span class='latex-texttt'>CdiAwareCreator</span>  zur Erzeugung der Aktoreninstanzen verwendet werden soll.
 <span class='latex-texttt'>CdiAwareCreator</span>  implementiert das Interface  <span class='latex-texttt'>akka.japi.Creator</span>  und wird mit der gewünschten Aktorenklasse initialisiert.
Da wir dependent-scoped Beans als Aktoren verwenden sollen,
delegieren wir in der Methode  <span class='latex-texttt'>CdiAwareCreator#create</span>  an  <span class='latex-texttt'>BeanProvider#getDependent#get</span> .
Der Methode  <span class='latex-texttt'>BeanProvider#getDependent</span>  wird die Klasse der zu erzeugenden Aktoren-Instanz übergeben.
Als Ergebnis liefert diese Hilfsmethode von DeltaSpike eine Instanz vom Typ  <span class='latex-texttt'>org.apache.deltaspike.core.api.provider.DependentProvider</span> .
Diese Datenstruktur kapselt die dependent-scoped Instanz zusammen mit den dazugehörigen Metadaten,
die für eine spätere Zerstörung der Instanz durch den Aufruf  <span class='latex-texttt'>DependentProvider#destroy</span>  benötigt werden.
Durch den Aufruf der Methode  <span class='latex-texttt'>#get</span>  stellen wir Akka die dependent-scoped Instanz zur Verfügung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:actor-ref_producer'></a>                     <pre><code>@ApplicationScoped
public class ActorRefProducer {
  private Map&lt;String, ActorSystem&gt; actorSystemMap =
    new HashMap&lt;String, ActorSystem&gt;();

  @Produces
  @Actor(type = akka.actor.Actor.class)
  protected ActorRef createActorRef(InjectionPoint injectionPoint) {
    final Actor actorQualifier = injectionPoint.getAnnotated()
      .getAnnotation(Actor.class);

    ActorSystem actorSystem = getActorSystem(actorQualifier.systemName());

    if (!UntypedActor.class.isAssignableFrom(actorQualifier.type())) {
      actorSystem.actorOf(Props.create(actorQualifier.type()));
    }
    return actorSystem.actorOf(Props.create(
      new CdiAwareCreator(actorQualifier.type())));
  }

  public ActorSystem getActorSystem(String actorSystemName) {
    ActorSystem actorSystem = actorSystemMap.get(actorSystemName);
    if (actorSystem == null || actorSystem.isTerminated()) {
      actorSystem = bootActorSystem(actorSystemName);
    }

    return actorSystem;
  }

  private synchronized ActorSystem bootActorSystem(
    String actorSystemName) {

    ActorSystem actorSystem = actorSystemMap.get(actorSystemName);
    if (actorSystem != null && !actorSystem.isTerminated()) {
      return actorSystem;
    }

    actorSystem = ActorSystem.create(actorSystemName);
    actorSystemMap.put(actorSystemName, actorSystem);
    return actorSystem;
  }

  @PreDestroy
  protected void cleanup() {
        for (ActorSystem actorSystem : actorSystemMap.values()) {
            if (!actorSystem.isTerminated()) {
                actorSystem.shutdown();
            }
        }
  }

  private static class CdiAwareCreator
    implements Creator&lt;akka.actor.Actor&gt; {

    private static final long serialVersionUID = 3739310463390426896L;

    private final Class&lt;? extends akka.actor.Actor&gt; actorClass;

    public CdiAwareCreator(Class&lt;? extends akka.actor.Actor&gt; actorClass) {
      this.actorClass = actorClass;
    }

    @Override
    public akka.actor.Actor create() throws Exception {
      return BeanProvider.getDependent(actorClass).get();
    }
  }
}
</code></pre>
                </div> Akka registriert die zur Verfügung gestellte Instanz intern und erzeugt die dazugehörige Instanz vom Typ  <span class='latex-texttt'>ActorRef</span> ,
die wir schließlich als Ergebnis der Producer-Methode zurückgeben.
Producer-Methoden, in denen Informationen des Injection-Points ausgewertet werden, müssen dependent-scoped Beans erzeugen.
Da Akka ohnedies kein erweitertes Scope-Konzept hat, müssen wir hier keine zusätzlichen Aspekte bei der Integration beider Container beachten.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die Zerstörung von Aktor-Instanzen übernimmt Akka (derzeit) selbst,
wodurch wir nicht wie üblich  <span class='latex-texttt'>DependentProvider#destroy</span>  aufrufen können.
Aus diesem Grund können wir in derart integrierten Aktoren zwar  <span class='latex-texttt'>@PostConstruct</span> , aber nicht  <span class='latex-texttt'>@PreDestroy</span>  verwenden.
Würden wir eine Callback-Methode mit  <span class='latex-texttt'>@PreDestroy</span>  annotieren, dann würde diese nicht aufgerufen werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die erzeugten Aktor-Systeme selbst müssen wir allerdings beim Herunterfahren der Applikation manuell beenden.
In der  <span class='latex-texttt'>@PreDestroy</span> -Callback-Methode namens  <span class='latex-texttt'>ActorRefProducer#cleanup</span>  rufen wir hierfür
die Methode  <span class='latex-texttt'>akka.actor.ActorSystem#shutdown</span>  auf die jeweilige Instanz auf.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bedingt durch die Integration von Akka und CDI-Beans müssen wir den Scope von  <span class='latex-texttt'>MonitoredStorage</span>  ändern.
Bisher haben wir dieses CDI-Bean mit  <span class='latex-texttt'>@RequestScoped</span>  dem Request-Context zugeordnet.
Allerdings ist der Request-Context in einem Aktor-Thread nicht aktiv und somit müssen wir beispielsweise auf den  <span class='latex-texttt'>@ApplicationScoped</span>  zurückgreifen,
da dieser immer aktiv ist. Diese Änderung setzt natürlich voraus, dass das Bean thread-safe ist.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In unserer CDI-Extension zur Validierung von Applikationsstrukturen können wir eine zusätzliche Überprüfung für Aktoren hinzufügen.
Listing  <a href='#!idx:/integration.html:fig:actor-validation'> Validierung von Actor-Beans </a>  zeigt ein Beispiel für eine solche Validierung.
In unserem Fall überprüfen wir, ob alle Aktor-Klassen explizit oder implizit als dependent-scoped Beans umgesetzt sind.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:actor-validation'></a>                     <pre><code>public class AppStructureValidationExtension implements Extension {
  private List&lt;String&gt; violations = new ArrayList&lt;String&gt;();

  public void validateArtifacts(@Observes ProcessManagedBean pmb,
                                BeanManager beanManager) {
    Class beanClass = pmb.getAnnotatedBeanClass().getJavaClass();
    //...

    if (Actor.class.isAssignableFrom(beanClass)) {
      validateActor(beanClass,
        pmb.getAnnotatedBeanClass().getAnnotations(),
        beanManager);
    }
  }

  public void checkAndAddViolations(
    @Observes AfterDeploymentValidation afterDeploymentValidation) {

    //...
  }

  private void validateActor(Class beanClass, Set&lt;Annotation&gt; annotations,
                             BeanManager beanManager) {
    for (Annotation annotation : annotations) {
      if (beanManager.isScope(annotation.annotationType()) &&
        !Dependent.class.isAssignableFrom(annotation.annotationType())) {

        this.violations.add(
          "It isn't allowed to use " + annotation.annotationType() +
          " for Akka-Actors. " +
          "Please remove the annotation from " + beanClass.getName());
      }
    }
  }
}
</code></pre>
                </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im zweiten Abschnitt dieses Kapitels integrieren wir CDI und Spring.
In den dazugehörigen Beispielen bauen wir darüber hinaus auf der Integration mit Akka auf.<br /> <h2><a class='latex-index-anchor' name='!idx:/integration.html:7.2' ><span class='entry-number'>7.2</span> Beans aus anderen Welten</a> </h2>
 Im Laufe der Zeit entstanden verschiedene Dependency-Injection Frameworks.
Einige dienten der CDI Expert-Group bei der Definition von CDI sogar direkt oder indirekt als Inspiration.
Während beispielsweise JBoss Seam durch CDI und Apache DeltaSpike abgelöst worden ist,
existieren Projekte wie Google Guice und das Spring-Framework parallel zu CDI weiter.
Der Funktionsumfang ist bei einigen der verfügbaren Alternativen ähnlich.
CDI wird in vielen Java EE Applikationen gerne eingesetzt,
da CDI seit Java EE 6 ein Bestandteil der Plattform ist und im Vergleich zu den Alternativen kaum Wünsche offen lässt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> So ähnlich die einzelnen Dependency-Injection Frameworks sind, so unterschiedlich sind die dazugehörigen Ökosysteme.
Vor allem das Spring-Framework hat durch seine lange Historie sehr viele Erweiterungen.
Wie sinnvoll bzw. erforderlich die einzelnen Erweiterungen sind, hängt sehr stark vom Einsatzgebiet ab.
In vielen Fällen stellt das Spring-Framework Adapter für andere Technologien zur Verfügung,
um eine etwas einfachere Verwendung dieser Technologien zu ermöglichen.
Aus Sicht einer Java EE Applikation kann es folglich sinnvoll erscheinen, solche Vorteile zu nutzen,
wenn es keine äquivalente Erweiterung für CDI gibt.
Dies ist jedoch kein Grund, eine CDI-basierte Applikation vollständig auf ein anderes Framework wie Spring umzustellen.
Wie zuvor bei der Integration mit Akka können wir auch hier durch die starke Erweiterbarkeit von CDI die Vorteile beider Technologien nutzen.
Wir können eine portable Erweiterung implementieren, die es ermöglicht, Spring-Beans in CDI-Beans zu nutzen.
Eine solche Integration ist weitläufig als CDI/Spring-Bridge bekannt.
Im Laufe der Jahre sind in der CDI-Community verschiedene Bridges entstanden.
Der überwiegende Teil davon ist unidirektional, aber auch bidirektionale Umsetzungen sind mit Einschränkungen möglich.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In  <span class='latex-textit'>IdeaForkLite</span>  möchten wir eine rudimentäre Spring-Bridge umsetzen,
mit der eine unidirektionale Injizierung von Spring-Beans in CDI-Beans ermöglicht werden soll.
Über eine solche Bridge sind anschließend Spring-Erweiterungen in einer primär CDI-basierten Applikation, wie es  <span class='latex-textit'>IdeaForkLite</span>  ist, verwendbar.
Konkret werden wir  <span class='latex-textit'>IdeaForkLite</span>  mit Spring-Mail erweitern.
Abgesehen davon können solche Bridges auch für die schrittweise Migration von Spring nach CDI verwendet werden.<br /> <div class="tip"><b>Tipp: </b> Bidirektionale CDI/Spring-Bridges erlauben neben der Injizierung von Spring-Beans in CDI-Beans
auch die Injizierung von CDI-Beans in Spring-Beans.
Sowohl bei unidirektionalen als auch bei bidirektionalen Bridges muss jedoch ein primärer Container definiert werden.
Dieser wird als erster gestartet und ist dafür verantwortlich den Startvorgang des jeweils anderen Containers zu initialisieren. </div> Ausgehend von einer einfachen Basiskonfiguration für Spring werden wir mit Hilfe einer portablen CDI Erweiterung den Spring-Container starten und
für jedes Spring-Bean einen entsprechenden Adapter als CDI-Bean registrieren,
der bei der Erzeugung einer Contextual-Instance den Aufruf an den Spring-Container weiterleitet.
Listing  <a href='#!idx:/integration.html:fig:portable-extension_to_start_spring'> Spring via CDI-Extension starten </a>  zeigt das Grundgerüst für eine CDI-Extension Klasse namens  <span class='latex-texttt'>SpringBridgeExtension</span> .
Diese Extension-Klasse muss, wie bei CDI üblich, in der Service-Loader Konfigurationsdatei
 <span class='latex-texttt'>META-INF/services/javax.enterprise.inject.spi.Extension</span>  aktiviert werden.
Nach dem erfolgreichen Start des Spring-Containers in der Observer-Methode für das  <span class='latex-texttt'>AfterBeanDiscovery</span> -Event
können wir die erzeugte  <span class='latex-texttt'>ConfigurableApplicationContext</span> -Instanz einer Instanzvariablen der Extension zuweisen.
In Listing  <a href='#!idx:/integration.html:fig:portable-extension_to_start_spring'> Spring via CDI-Extension starten </a>  wird diese Variable  <span class='latex-texttt'>springContext</span>  genannt.
Da der CDI-Container je Applikation und Extension-Klasse nur eine Instanz erzeugt,
können wir in verschiedenen Phasen des Container-Lifecycles auf den abgelegten Spring-Context zugreifen.
Im  <span class='latex-texttt'>AfterBeanDiscovery</span> -Observer können wir die Spring-Bean-Definitionen über die Bean-Factory auswerten.
Allerdings sind wir nur an selbst erstellten Spring-Beans interessiert, die wir in unserer Applikation umsetzen.
Mit der Methode  <span class='latex-texttt'>AfterBeanDiscovery#addBean</span>  fügen wir somit nur für jene Spring-Beans CDI-Adapter-Beans hinzu,
deren Packages nicht mit  <span class='latex-texttt'>org.springframework</span>  beginnen.<br /> <div class="tip"><b>Tipp: </b> Vor allem in älteren EE Servern kann es vorkommen, dass Instanzvariablen in Extension-Klassen, in unserem Fall  <span class='latex-texttt'>springContext</span> ,
nur je Observer-Methode verwendbar sind. In solchen Fällen muss auf Klassenvariablen zurückgegriffen werden.
Die einzige Alternative wäre ein Server-Update. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:portable-extension_to_start_spring'></a>                     <pre><code>public class SpringBridgeExtension implements Extension {
  private ConfigurableApplicationContext springContext;

  public void initContainerBridge(
    @Observes AfterBeanDiscovery abd, BeanManager beanManager) {

    springContext = bootContainer();

    for (String beanName : springContext.getBeanDefinitionNames()) {
      BeanDefinition beanDefinition = springContext.getBeanFactory()
        .getBeanDefinition(beanName);
      Class&lt;?&gt; beanClass = springContext.getType(beanName);

      if (!beanClass.getName().startsWith("org.springframework.")) {
        abd.addBean(createBeanAdapter(
          beanClass, beanName, beanDefinition,
          springContext, beanManager));
      }
    }
  }

  public void cleanup(@Observes BeforeShutdown beforeShutdown) {
    springContext.close();
  }

  private &lt;T&gt; Bean&lt;T&gt; createBeanAdapter(
    Class&lt;T&gt; beanClass, String beanName,
    BeanDefinition beanDefinition,
    ConfigurableApplicationContext applicationContext,
    BeanManager bm) {

    //...
  }

  private ConfigurableApplicationContext bootContainer() {
    //...
  }
}
</code></pre>
                </div> Die Implementierung der Methode  <span class='latex-texttt'>#createBeanAdapter</span>  aus Listing  <a href='#!idx:/integration.html:fig:create_adapter-beans'> CDI Bean-Adapter für Spring-Beans erzeugen </a>  veranschaulicht,
dass auch hier DeltaSpike hilfreiche Konzepte zur Verfügung stellt.
Mit  <span class='latex-texttt'>AnnotatedTypeBuilder</span>  kann auf Basis von beliebigen Klassen eine  <span class='latex-texttt'>AnnotatedType</span> -Instanz erzeugt werden.
In unserem Beispiel könnten wir hierfür auch  <span class='latex-texttt'>BeanManager#createAnnotatedType</span>  verwenden.
Allerdings könnten wir mit  <span class='latex-texttt'>AnnotatedTypeBuilder</span>  das erzeugte Ergebnis beeinflussen,
um beispielsweise Bean-Metadaten hinzuzufügen oder zu entfernen.
Einen vergleichbaren Builder namens  <span class='latex-texttt'>BeanBuilder</span>  gibt es auch für  <span class='latex-texttt'>javax.enterprise.inject.spi.Bean</span> .
Mit diesem Builder verändern wir in Listing  <a href='#!idx:/integration.html:fig:create_adapter-beans'> CDI Bean-Adapter für Spring-Beans erzeugen </a>  verschiedene Eigenschaften,
damit der Adapter für das Spring-Bean möglichst effizient funktioniert.
Beispielsweise verwenden wir als Scope-Annotation in jedem Fall  <span class='latex-texttt'>@Dependent</span> ,
da der Spring-Container für den Scope der Spring-Beans verantwortlich ist.
Die vom Spring-Context herausgegebene Referenz auf ein Spring-Bean wird somit unverändert weiterverwendet.
Der Bean-Name wird in unserem Beispiel ebenfalls von Spring übernommen.
Da der Spring-Container die Injection-Points von Spring-Beans befüllt,
können wir in einem weiteren Schritt mit der Methode  <span class='latex-texttt'>#injectionPoints</span>  sämtliche Injection-Points aus Sicht von CDI entfernen.
Bis zu diesem Punkt erzeugen wir allerdings nur einen leeren Adapter.
Erst durch die Implementierung und Registrierung einer  <span class='latex-texttt'>ContextualLifecycle</span> -Instanz
können wir bei der Erzeugung des CDI-Beans an den Spring-Context delegieren.
In unserem Fall nennen wir die Implementierung  <span class='latex-texttt'>SpringAwareBeanLifecycle</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:create_adapter-beans'></a>                     <pre><code>private &lt;T&gt; Bean&lt;T&gt; createBeanAdapter(
  Class&lt;T&gt; beanClass, String beanName,
  BeanDefinition beanDefinition,
  ConfigurableApplicationContext applicationContext, BeanManager bm) {

  String beanScope = beanDefinition.getScope();
  ContextualLifecycle lifecycleAdapter =
    new SpringAwareBeanLifecycle(applicationContext, beanName, beanScope);

   beanClass = ProxyUtils.getUnproxiedClass(beanClass);
    return new BeanBuilder&lt;T&gt;(bm)
      .readFromType(new AnnotatedTypeBuilder&lt;T&gt;()
        .readFromType(beanClass).create())
      .name(beanName)
      .beanLifecycle(lifecycleAdapter)
      .injectionPoints(Collections.&lt;InjectionPoint&gt;emptySet())
      .scope(Dependent.class)
      .create();
}
</code></pre>
                </div><span class='latex-texttt'>SpringAwareBeanLifecycle</span>  aus Listing  <a href='#!idx:/integration.html:fig:contextual-lifecycle_for_spring-beans'> Contextual-Lifecycle für Spring-Beans </a> delegiert die Verwaltung der Bean-Instanzen mit Hilfe der Methode  <span class='latex-texttt'>#getBean</span>  an den Spring-Context.
Für den CDI-Container ist das Ergebnis ein einfaches dependent-scoped Bean.
Entsprechend werden auch die Regeln für dependent-scoped Beans umgesetzt.
Der äquivalente Spring-Scope wird als Prototype-Scope bezeichnet.
Somit dürfen wir bei der Zerstörung der Contextual-Instance durch den CDI-Container
den Aufruf nur an die Methode  <span class='latex-texttt'>#destroyBean</span>  weiterleiten,
wenn es sich um den Prototype-Scope handelt.
Anderenfalls muss der Spring-Container die Lebensdauer des entsprechenden Spring-Beans abhängig vom Scope des Beans verwalten.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:contextual-lifecycle_for_spring-beans'></a>                     <pre><code>class SpringAwareBeanLifecycle implements ContextualLifecycle {
  private final ConfigurableApplicationContext applicationContext;
  private final String beanName;
  private final boolean prototypeScope;

  public SpringAwareBeanLifecycle(
    ConfigurableApplicationContext applicationContext,
    String beanName, String scope) {

    this.applicationContext = applicationContext;
    this.beanName = beanName;
    this.prototypeScope = "prototype".equalsIgnoreCase(scope);
  }

  @Override
  public Object create(Bean bean, CreationalContext creationalContext) {
    return this.applicationContext.getBean(this.beanName);
  }

  @Override
  public void destroy(Bean bean, Object instance,
                      CreationalContext creationalContext) {

    if (this.prototypeScope) {
      this.applicationContext.getBeanFactory()
        .destroyBean(this.beanName, instance);
    }
  }
}
</code></pre>
                </div> Unsere rudimentäre CDI/Spring-Bridge ist hiermit fertiggestellt und wir können unser erstes Spring-Bean implementieren,
das wir in einem weiteren Schritt in ein CDI-Bean injizieren.
Wie eingangs erwähnt werden wir zu Demonstrationszwecken Spring-Mail verwenden.
In der Praxis ist es natürlich naheliegender Alternativen wie beispielsweise Apache Commons Email zu evaluieren,
da hierfür kein zusätzlicher Container erforderlich ist.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing  <a href='#!idx:/integration.html:fig:simple_spring-bean'> Einfaches Spring-Bean </a>  zeigt eine simple Implementierung eines Spring-Beans,
das das effektive Versenden an  <span class='latex-texttt'>JavaMailSender#send</span>  von Spring-Mail delegiert.
Da wir nur ein Spring-Bean in  <span class='latex-textit'>IdeaForkLite</span>  implementieren, legen wir kein eigenes Modul an.
Aus diesem Grund sieht auch der CDI-Container dieses Bean.
Jedoch bekommt das CDI-Adapter-Bean für dieses Spring-Bean den gleichen Typ.
Somit müssen wir diese Klasse für den CDI-Container unsichtbar machen.
In unserem Beispiel greifen wir hierfür auf  <span class='latex-texttt'>@Exclude</span>  von DeltaSpike zurück.
Dies wäre natürlich nicht erforderlich, wenn wir Spring-Beans außerhalb eines BDAs für CDI bereitstellen.<br /> <div class="tip"><b>Tipp: </b> Einen ähnlichen Aspekt müssen wir auch aus der Sicht vom Spring-Container beachten.
Würde der Spring-Container alle CDI-Beans von  <span class='latex-textit'>IdeaForkLite</span>  sehen, dann würden wir Adapter-Beans für Spring-Beans registrieren,
die bereits CDI-Beans sind und nur für den CDI-Container sichtbar sein sollen.
Für diese etwas kompliziert klingende zyklische Konstellation gibt es eine einfache Lösung.
Hierfür müssen wir in  <span class='latex-textit'>IdeaForkLite</span> , neben Konfigurationen für Spring-Mail, das Basis-Package für Spring-Beans unserer Applikation
in der Spring-Konfigurationsdatei namens  <span class='latex-texttt'>applicationContext.xml</span>  definieren. </div><div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:simple_spring-bean'></a>                     <pre><code>@Exclude
public class SpringMailSender {
  @Autowired
  private JavaMailSender mailSender;

  public void send(String senderAddress, String recipientAddress,
                   String subject, String text) {
    SimpleMailMessage message = new SimpleMailMessage();
    message.setTo(recipientAddress);
    message.setFrom(senderAddress);
    message.setSubject(subject);
    message.setText(text);
    this.mailSender.send(message);
  }
}
</code></pre>
                </div> Das Spring-Bean aus Listing  <a href='#!idx:/integration.html:fig:simple_spring-bean'> Einfaches Spring-Bean </a> können wir im nächsten Schritt in ein CDI-Bean namens  <span class='latex-texttt'>MailService</span>  injizieren.
Listing  <a href='#!idx:/integration.html:fig:injection_of_a_spring-bean_into_a_cdi-bean'> Injizierung eines Spring-Beans in ein CDI-Bean </a>  verdeutlicht,
dass sich der Injection-Point nicht von einem regulären Injection-Point für ein CDI-Bean unterscheidet.
Das zuvor implementierte CDI-Adapter-Bean wird zur Laufzeit aufgerufen,
wenn der CDI-Container den Injection-Point in  <span class='latex-texttt'>MailService</span>  befüllen möchte.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:injection_of_a_spring-bean_into_a_cdi-bean'></a>                     <pre><code>@ApplicationScoped
public class MailService {
  @Inject
  private SpringMailSender mailSender;

  public void sendWelcomeMessage(User user) {
    String senderAddress = ConfigResolver
      .getProjectStageAwarePropertyValue(
        "ideafork.sender", "admin@ideafork.com");
    String subject = "Welcome " + user.getNickName();
    String text = "Welcome @ IdeaFork!";
    this.mailSender.send(senderAddress, user.getEmail(), subject, text);
  }
}
</code></pre>
                </div> Auf Basis dieser Vorarbeiten können wir in  <span class='latex-textit'>IdeaForkLite</span>  einen weiteren Aktor hinzufügen,
über den asynchron E-Mails nach einer erfolgreichen Registrierung versendet werden können.
Wir könnten auch hier wieder im asynchronen Aktor-Thread ein synchrones CDI-Event mit dem  <span class='latex-texttt'>@Async</span> -Qualifier triggern.
Für unseren Anwendungsfall ist dies nicht erforderlich und
folglich delegieren wir im Listing  <a href='#!idx:/integration.html:fig:async-mails'> Mails asynchron senden </a>  direkt an das zuvor umgesetzte  <span class='latex-texttt'>MailService</span> .
Außerdem benötigen wir ein Event namens  <span class='latex-texttt'>UserRegisteredEvent</span> , das im gleichen Listing dargestellt ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:async-mails'></a>                     <pre><code>public class UserRegisteredEvent extends EntityChangedEvent&lt;User&gt; {
    public UserRegisteredEvent(User createdEntity) {
        super(createdEntity);
    }
}

public class UserRegisteredEventActor extends UntypedActor {
  private final MailService mailService;

  @Inject
  public UserRegisteredEventActor(MailService mailService) {
    this.mailService = mailService;
  }

  @Override
  public void onReceive(Object message) throws Exception {
    if (message instanceof UserRegisteredEvent) {
      this.mailService.sendWelcomeMessage(((UserRegisteredEvent)message)
        .getEntity());
    } else {
      unhandled(message);
    }
  }
}
</code></pre>
                </div> Via Constructor-Injection können wir unser  <span class='latex-texttt'>MailService</span> -Bean injizieren,
um in der Methode  <span class='latex-texttt'>#onReceive</span>  mit Hilfe dieses CDI-Beans und dem dahinterliegenden Spring-Bean E-Mails zu versenden.
In unserem Beispiel wollen wir eine Willkommensnachricht versenden nachdem eine neue User-Entität gespeichert wurde.<br />Die Registrierungslogik befindet sich in  <span class='latex-textit'>IdeaForkLite</span>  in der Methode  <span class='latex-texttt'>UserService#registerUser</span> .
Der in Listing  <a href='#!idx:/integration.html:fig:improved_registration-method'> CDI- und Akka-Events triggern </a>  veranschaulichte Ausschnitt zeigt neben der erweiterten Methode auch
den neuen  <span class='latex-texttt'>UserRegisteredEventBroadcaster</span> , der zuerst ein asynchrones Actor-Event über Akka und
anschließend ein synchrones CDI-Event triggert.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:improved_registration-method'></a>                     <pre><code>@Service
public class UserService {
  //...

  @Inject
  private UserRegisteredEventBroadcaster userRegisteredEventBroadcaster;

  public User registerUser(User newUser) {
    if (userRepository.loadByEmail(newUser.getEmail()) == null) {
      newUser.setPassword(
        passwordManager.createPasswordHash(newUser.getPassword()));
      userRepository.save(newUser);
      User registeredUser = userRepository.findBy(newUser.getId());

      if (registeredUser != null) {
        userRegisteredEventBroadcaster
          .broadcastUserRegisteredEvent(registeredUser);
        return registeredUser;
      }
    }
    return null;
  }
}

@TransactionScoped
public class UserRegisteredEventBroadcaster {
    @Inject
    @Default
    private Event&lt;UserRegisteredEvent&gt; userRegisteredEvent;

    @Inject
    @Actor(type = UserRegisteredEventActor.class)
    private ActorRef asyncBroadcaster;

    public void broadcastUserRegisteredEvent(User entity) {
        UserRegisteredEvent userRegisteredEvent =
          new UserRegisteredEvent(entity);
        asyncBroadcaster.tell(userRegisteredEvent, this.asyncBroadcaster);
        userRegisteredEvent.fire(userRegisteredEvent);
    }
}
</code></pre>
                </div> Die bisher beschriebene Umsetzung funktioniert einwandfrei, hat jedoch vor allem bei Unit-Tests den Nachteil,
dass bei der Durchführung einer Registrierung immer versucht wird ein E-Mail zu verschicken.
Stattdessen würde es uns genügen zu überprüfen, ob ein E-Mail versendet werden würde bzw. ob der Inhalt korrekt ist.
Listing  <a href='#!idx:/integration.html:fig:specialized_mail-service'> Mail-Service für Unit-Tests </a>  zeigt, wie wir den ersten Fall ermöglichen können,
indem wir im Test-Package ein spezialisiertes CDI-Bean erstellen und die Methode  <span class='latex-texttt'>#sendWelcomeMessage</span>  überschreiben.
Da wir dieses CDI-Bean nur im Test-Package verwenden ist im produktiven Package von  <span class='latex-textit'>IdeaForkLite</span>  immer die ursprüngliche
 <span class='latex-texttt'>MailService</span> -Implementierung aktiv, weil es dort die Klasse  <span class='latex-texttt'>TestMailService</span>  nicht gibt.
Falls wir  <span class='latex-texttt'>TestMailService</span>  für Integration-Tests ebenfalls nicht verwenden wollen,
dann könnten wir beispielsweise die Klasse zusätzlich mit  <span class='latex-texttt'>@Exclude(ifProjectStage = ProjectStage.IntegrationTest.class)</span>  annotieren.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:specialized_mail-service'></a>                     <pre><code>@Specializes
public class TestMailService extends MailService {
    private AtomicInteger sentWelcomeMessageCount = new AtomicInteger();

    @Override
    public void sendWelcomeMessage(User user) {
        sentWelcomeMessageCount.incrementAndGet();
    }

    public Integer getSentWelcomeMessageCount() {
        int result = sentWelcomeMessageCount.get();
        if (result == 0) {
            return null;
        }
        return result;
    }
}
</code></pre>
                </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Schließlich können wir in unserem JUnit-Test das  <span class='latex-texttt'>TestMailService</span> -Bean injizieren,
um das Ergebnis nach einem erfolgreichen Registrierungsversuch zu überprüfen.
Da wir E-Mails immer über einen asynchronen Aktor-Thread versenden, müssen wir eine Verzögerung einbauen.
Hierfür gibt es mehrere Realisierungsmöglichkeiten.
In Listing  <a href='#!idx:/integration.html:fig:registration_test_with_specialized_mail-service'> Test mit spezialisiertem Mail-Service </a>  ist dies mit einem  <span class='latex-texttt'>RetryHelper</span>  umgesetzt.
Die vollständige Implementierung ist im Git-Repository von  <span class='latex-textit'>IdeaForkLite</span>  ersichtlich.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/integration.html:fig:registration_test_with_specialized_mail-service'></a>                     <pre><code>@RunWith(CdiTestRunner.class)
public class IdeaForkBaseFlowTest {
  @Inject
  private RegistrationViewCtrl registrationViewCtrl;

  @Inject
  private TestMailService testMailService;

  @Inject
  private EntityChangeRepository entityChangeRepository;

  //...

  @Test
  public void flowFromRegistrationToIdeaPromotion() {
    registrationViewCtrl.getNewUser().setNickName("os890");
    registrationViewCtrl.getNewUser().setEmail("os890@test.org");
    registrationViewCtrl.getNewUser().setPassword("test");
    Class&lt;? extends ViewConfig&gt; navigationResult =
      registrationViewCtrl.register();

    //...

    int sentWelcomeMessageCount = getSentWelcomeMessageCount();
    Assert.assertEquals(1, sentWelcomeMessageCount);
  }

  private Integer getSentWelcomeMessageCount() {
    return new RetryHelper&lt;Integer&gt;() {
      @Override
      protected Integer execute() {
        Integer result = testMailService.getSentWelcomeMessageCount();

        if (result == null) {
          return 0;
        }
        return result;
      }
    }.start();
  }

  private abstract class RetryHelper&lt;T&gt; {
    //...
  }
}
</code></pre>
                </div><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ob die hier beschriebene Integration von CDI und Spring sinnvoll ist, hängt stark von den Anforderungen in einem Projekt ab.
In unserem Fall hätten wir beispielsweise auf Spring verzichten können.
Statt Spring-Mail könnten wir Alternativen wie beispielsweise Apache Commons Email verwenden.
Daher sollte in der Evaluierungsphase geprüft werden,
ob die Nachteile eines zusätzlichen Containers im Vergleich zum Nutzen der Add-ons akzeptabel sind.
Zu solchen Nachteilen zählen unter anderem eine höhere Komplexität in der Applikation durch die Verwendung eines weiteren Containers,
dessen Konfiguration und Integration.
Außerdem entsteht zur Laufzeit selbst nach dem etwas längeren Applikationsstart ein gewisser Overhead und
der etwas höhere Speicherbedarf sollte ebenfalls nicht missachtet werden.
In manchen Fällen überwiegen jedoch die Vorteile und
somit können CDI-basierte Applikationen mit solchen Bridges von anderen Ökosystemen profitieren.
<div class="tip"><b>Tipp: </b>Das CDI-Spring-Bridge-Pattern ist in modernen Quarkus-Projekten weniger relevant, da Quarkus eine eigene Spring-Kompatibilitätsschicht (<span class='latex-texttt'>quarkus-spring-di</span>, <span class='latex-texttt'>quarkus-spring-web</span>) bietet. Für neue Projekte empfiehlt sich die Verwendung der nativen Quarkus-APIs &mdash; Details in Kapitel <a href='#!idx:/quarkus.html:10'>10</a>.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Seit CDI 2.0 (Java EE 8) bietet die Spezifikation mit <span class='latex-texttt'>@ObservesAsync</span> native Unterstützung für asynchrone Events. Damit lassen sich viele der in Abschnitt 7.1 gezeigten Akka-basierten Muster deutlich einfacher umsetzen – ohne externen Aktor-Container. Für komplexere asynchrone Kommunikation stehen heute MicroProfile Reactive Messaging oder Jakarta Messaging als standardisierte Alternativen zur Verfügung. Auch die CDI/Spring-Bridge aus Abschnitt 7.2 hat an praktischer Relevanz verloren, da beide Ökosysteme inzwischen ausgereift sind und eigenständig alle gängigen Anforderungen abdecken. Die in diesem Kapitel vorgestellten Integrationstechniken bleiben jedoch als Muster für die Anbindung beliebiger Frameworks über CDI-Producer und portable Extensions wertvoll.</div>
<div class="tip"><b>Tipp: </b><b>DeltaSpike-Module &mdash; Migrationsziele:</b><br />
&bull; <b>Core (Config):</b> <span class='latex-texttt'>@ConfigProperty</span> &rarr; MicroProfile Config (Kapitel <a href='#!idx:/quarkus.html:10.4'>10.4</a>)<br />
&bull; <b>Core (@Exclude):</b> &rarr; <span class='latex-texttt'>@Vetoed</span> (CDI 1.1) oder Quarkus <span class='latex-texttt'>@IfBuildProfile</span><br />
&bull; <b>Security:</b> <span class='latex-texttt'>@Secured</span> &rarr; <span class='latex-texttt'>@RolesAllowed</span> + MicroProfile JWT (Kapitel <a href='#!idx:/quarkus.html:10.6'>10.6</a>)<br />
&bull; <b>Data:</b> <span class='latex-texttt'>@Repository</span> &rarr; Quarkus Panache (Kapitel <a href='#!idx:/quarkus.html:10.6'>10.6</a>)<br />
&bull; <b>JSF:</b> ViewConfig, <span class='latex-texttt'>@ViewAccessScoped</span> &rarr; Angular Router + Komponenten (Kapitel <a href='#!idx:/angular.html:11'>11</a>)<br />
&bull; <b>Scheduler:</b> <span class='latex-texttt'>@Scheduled</span> &rarr; Quarkus Scheduler (<span class='latex-texttt'>@Scheduled</span>)<br />
&bull; <b>Test-Control:</b> <span class='latex-texttt'>CdiTestRunner</span> &rarr; <span class='latex-texttt'>@QuarkusTest</span> (Quarkus) oder Weld-JUnit5<br />
&bull; <b>Partial-Bean:</b> <span class='latex-texttt'>@ResourceClient</span> &rarr; MicroProfile REST Client</div>
</section>
<section class="chapter-section" id="chapter-8">
<h1> <a class='latex-index-anchor' name='!idx:/cdi_micro.html:8' ><span class='entry-number'>8</span> CDI Micro</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Der Text dieses Kapitels wurde von Claude (AI built by Anthropic) als Co-Autor überarbeitet. Diese Überarbeitung erfolgte ohne nachträgliches Review durch den Originalautor. Verwendung auf eigene Verantwortung.
</div>
<a name = '!idx:/cdi_micro.html:chap:cdi_micro'> </a> Seit einigen Jahren werden Themen wie Cloud-Computing und kleinere Deploymenteinheiten stark gepushed.
Einige PaaS-Plattformen ermöglichten bereits seit Java EE 6, standardkonforme EE-Applikationen unverändert zu deployen.
In vielen Fällen steht Java EE selbst allerdings nicht mehr im Zentrum der Architekturüberlegungen, sondern stellt eine mögliche Variante dar.
Applikationen werden immer öfter in eigenständige kleine Module unterteilt, die unabhängig deployed werden können.
In diesem Zusammenhang sind sogenannte Micro-Deployments zur gängigen Praxis geworden.
Hierbei gibt es verschiedene Ausprägungen, für die es teilweise unterschiedliche Definitionen, Sichtweisen und Empfehlungen gibt.
Oftmals werden die unterschiedlichen Ansätze pauschal mit dem Begriff "Microservices" referenziert.
Wir bleiben in diesem Kapitel bei dem Begriff Micro-Deployments,
da wir uns exemplarisch die Aufteilung von  <span class='latex-textit'>IdeaFork</span>  in kleinere Deploymenteinheiten ansehen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die Kommunikation zwischen Services bzw. Modulen erfolgt über ein vordefiniertes Protokoll.
Inter-Modulkommunikation via REST verbreitete sich in diesem Zusammenhang sehr schnell,
da per Definition eine lose Koppelung ermöglicht wird und Module folglich mit unterschiedlichen Technologien umsetzbar sind.
Eine Bedingung ist die Verwendung von REST allerdings nicht.
Es kann prinzipiell jedes Protokoll verwendet werden, das von den Technologien aller Module unterstützt wird.
Durch die Eigenschaften von HTTP (v1.0 und v1.1) wird in einigen Projekten auf Alternativen wie beispielsweise "gRPC" zurückgegriffen.
Statt JSON als Serialisierungsformat wird in diesem Fall auf Protocol-Buffers gesetzt.
Hiermit kann die Kommunikation zwischen Services optimiert und die Latenzzeit mitunter deutlich reduziert werden.
Je mehr Services für die Verarbeitung eines einzelnen Client-Requests erforderlich sind, desto wichtiger werden solche Aspekte.
Bisher haben wir  <span class='latex-textit'>IdeaFork</span>  auf Basis verschiedener Java EE Spezifikationen entwickelt und setzen dies auch in diesem Kapitel fort.
Bestandteile von Java EE, wie beispielsweise JAX-RS, werden auch außerhalb der Plattform zum Aufbau von Applikationen mit Micro-Deployments verwendet.
Daher folgen wir unserem bisherigen Weg und verzichten auf proprietäre Ansätze wie beispielsweise "gRPC".<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.1' ><span class='entry-number'>8.1</span> EE oder nicht EE</a> </h2>
 Java EE Server galten lange Zeit als behäbig.
Nur wenige Applikationsserver unterstützten Micro-Deployments direkt.
Heutzutage stellt sich diese Situation anders dar.
Es gibt kaum noch langsam startende Server, Server mit großem Ressourcenverbrauch oder Server ohne Embedded-Modus.
Die Bestrebung nach aktuellen Laufzeitumgebungen und den damit verbundenen schnelleren Releasezyklen
mündete schließlich in einer neuen Community und dem inoffiziellen Micro-Profile.
Ursprünglich hat diese Initiative mit CDI, JAX-RS und JSON-P ein Subset von Java EE definiert.
Mittlerweile gibt es darüber hinaus auch Spezifikationen, die außerhalb des JCPs umgesetzt wurden.
Einige Teile, vor allem die Configuration-Spezifikation, sind aus Open-Source Projekten wie beispielsweise Apache DeltaSpike extrahiert worden und
könnten zukünftig in Java EE einfließen.
Andere Teile wie beispielsweise "Fault-Tolerance", "Health", "Metrics" und "JWT-Auth" sind aus API-Sicht größtenteils Neuentwicklungen und
müssen erst den Prüfstand der Zeit bestehen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Bei den Themen Cloud- und Micro-Deployments gibt es abseits von Java EE und dem Micro-Profile viele konkurrierende neue Ansätze.
Wie üblich wird in Java EE nicht versucht, eigene Wege durchzusetzen, sondern es werden bewährte Technologien spezifiziert.
Aus diesem Grund konzentrieren wir uns in diesem Kapitel primär auf die in Java EE enthaltenen Spezifikationen und
erweitern diese, falls erforderlich.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.2' ><span class='entry-number'>8.2</span> IdeaForkMicro</a> </h2>
 Statt  <span class='latex-textit'>IdeaForkLite</span>  zu refactorn, werden wir die Applikation Schritt für Schritt komplett neu aufbauen.
Einige Teile können wir unverändert übernehmen, während wir andere Teile noch schlanker gestalten und bei Bedarf um neue Konzepte erweitern werden.
Da sich die Funktionalität von  <span class='latex-textit'>IdeaFork</span>  selbst nicht verändern wird, werden wir nur auszugsweise einige der Änderungen besprechen.
Im UI-Teil wird es am wenigsten Änderungen geben. Unser Ziel ist es, die bisherige Implementierung im UI soweit wie möglich zu übernehmen.
Grundsätzlich erlaubt zwar auch JSF die Aufteilung in mehrere nahezu unabhängige Module,
allerdings könnten wir dann nicht von Funktionalitäten wie beispielsweise dem Window-Scope profitieren.
 <span class='latex-textit'>IdeaForkMicro</span>  wird somit aus einem monolitischen UI-Layer bestehen,
der via REST mit den einzelnen unabhängigen Backend-Modulen kommuniziert.
Jedes Modul speichert Daten in einer für das Modul optimierten Datenstruktur.
Redundante Daten sind bei diesem Strukturierungskonzept nicht nur eine Begleiterscheinung, sondern ein "erwünschter" Effekt.
Sowohl die Backend-Module als auch das UI-Modul werden in einem Git-Repository namens  <span class='latex-textit'>IdeaForkMicro</span>  abgelegt,
in dem die wichtigsten Schritte in einzelne Commits aufgeteilt sind.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> 
Durch die vielfältigen Möglichkeiten bei Micro-Deployments, können wir uns in diesem Kapitel nur auf Teilaspekte beschränken.
Dieser ist primär als Anregung gedacht und veranschaulicht unter anderem wie die Kommunikation zwischen Modulen
mit Partial-Beans gekapselt und vereinfacht werden kann.
Darüber hinaus werden wir neue Mechanismen von CDI 1.1 bis 2.0 in  <span class='latex-textit'>IdeaForkMicro</span>  einfließen lassen.
Im Vergleich zu den bisherigen Kapiteln ist es daher nicht das Ziel, möglichst viele Aspekte zu betrachten,
die unmittelbar in produktive Projekte übernommen werden können.
Vielmehr hilft beispielsweise der Prototyp zur Inter-Modulkommunikation, schnell und einfach mit verschiedenen Modulen zu experimentieren, ohne
sich vorab in Themen wie Service-Discovery- und Container-Lösungen einarbeiten zu müssen.
Sollen in einem Projekt Micro-Deployments tatsächlich eingesetzt werden, dann wird man diese und weitere Themen nicht vermeiden können.
Allerdings kann beispielsweise eine professionelle Service-Discovery-Lösung auf ähnliche Art und Weise via Partial-Beans integriert werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> 
 <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.3' ><span class='entry-number'>8.3</span> Module über Module</a> </h2>
 Wie genau eine Applikation in Module unterteilt wird, ist eine Wissenschaft für sich und
sowohl Meinungen als auch Empfehlungen gehen bei diesem vermeintlich einfachen Thema teilweise stark auseinander.
Für uns sind zwei Fragen von zentraler Bedeutung. Die Frage nach der Aufteilung des UIs haben wir bereits vorweggenommen.
Im Gegensatz zum SCS-Ansatz ("Self-Contained Systems") werden wir das  <span class='latex-textit'>IdeaFork</span> -UI nicht auf einzelne Module aufsplitten.
Die zweite Frage dreht sich um die Modulgrenzen der Backend-Module und ist etwas umfangreicher,
da wir hier eine Antwort auf den Kommunikationsoverhead finden müssen.
Damit wir diesen möglichst minimieren, werden wir die Kommunikation zwischen Modulen auf das absolute Minimum reduzieren.
Gleichzeitig müssen wir dafür sorgen, dass der Ausfall eines Moduls nicht die komplette Applikation lahm legt.
Dieser Aspekt darf nicht vernachlässigt werden, da die Remote-Kommunikation zwischen Modulen per Definition nicht nur die Latenzzeit erhöht,
sondern auch zusätzliche Fehlerquellen mit sich bringt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><span class='latex-textit'>IdeaFork</span>  selbst ist eine recht kleine Applikation, wodurch sich die Modularisierungsmöglichkeiten in Grenzen halten.
Ein offensichtlich eigenständiger Teil besteht aus der Benutzerregistrierung und dem Login.
Das hierfür nötige Backend-Modul werden wir User-Service nennen.
In  <span class='latex-textit'>IdeaForkLite</span>  haben wir zwar nur eine E-Mail Notifizierung am Ende des Registrierungsprozesses,
dennoch lagern wir diese in ein eigenes Modul aus, das asynchron aufgerufen wird.
Die Verwaltung der Ideen übernimmt ebenfalls ein eigenes Modul namens Idea-Service.
Sowohl User- als auch Idea-Service archivieren Änderungen asynchron über ein Modul, das wir History-Service nennen.
Sämtliche Module können Konfigurationen über das Config-Service beziehen.
Durch den Kommunikationsoverhead werden wir hier jedoch auf ein zweistufiges Konzept zurückgreifen,
das zusätzlich den möglichen Ausfall des Config-Services kompensieren kann.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.4' ><span class='entry-number'>8.4</span> Am Puls der Zeit</a> </h2>
 Unabhängige Module erlauben die Verwendung verschiedener Technologiestacks.
Für die Module von  <span class='latex-textit'>IdeaForkMicro</span>  definieren wir CDI und JAX-RS als absolutes Minimum.
Das UI-Modul bleibt wie erwähnt nahezu unverändert und setzt somit weiterhin auf Java EE v6 bzw. v7.
Allerdings wollen wir einen möglichst schnellen Start ermöglichen und gleichzeitig die Build-Konfiguration vereinfachen.
Bisher konnte  <span class='latex-textit'>IdeaFork</span>  bzw.  <span class='latex-textit'>IdeaForkLite</span>  in TomEE, JBoss AS bzw. WildFly sowie GlassFish deployed werden.
Jeder dieser Server ermöglicht die Umsetzung von proprietären Micro-Deployments.
Daher könnten wir uns zumindest je Modul für einen Server explizit entscheiden.
Der Applikationscode ist weiterhin durch die Java EE APIs portabel, allerdings benötigen wir zusätzlich einen proprietären Starter für den Server.
In  <span class='latex-textit'>IdeaForkMicro</span>  werden wir hierfür je Modul eine Klasse verwenden, die im Basisverzeichnis "dev-starter" abgelegt ist.
Je Server könnten wir eine eigene Implementierung aus weniger als durchschnittlich 10 Zeilen Konfigurations- und Initialisierungscode umsetzen,
der auf dem proprietären Deployment-API des jeweiligen Servers basiert.
Wir entscheiden uns allerdings für zwei neue Server.
Für das UI-Modul entschieden wir uns für JBoss WildFly-Swarm.
Hierbei handelt es sich um einen modularen Server, der es ermöglicht, nur bestimmte Teile von JBoss WildFly zu nutzen.
Für die Backend-Module kommt Apache-Meecrowave zum Einsatz.
Der Name Meecrowave ist eine Anspielung auf Micro-Deployments, hat aber mit der Micro-Profile Spezifikation nur wenig gemein.
Falls erforderlich kann Meecrowave zu einem Micro-Profile konformen Server erweitert werden.
Meecrowave selbst ist ein schlanker Server, der primär Apache Tomcat als Servlet-Container, Apache OpenWebBeans als CDI-Implementierung,
Apache CXF als JAX-RS-Implementierung und Apache Johnzon für JSON-P (= JSON-Processing) kombiniert.
Das Ergebnis ist ein performanter Server, der in wenigen Sekunden einsatzbereit ist.
Ein weiterer für uns positiver Nebeneffekt ist die Unterstützung von CDI 2.0. Folglich können wir beispielsweise
für asynchrone Events statt EJBs oder Akka direkt asynchrone CDI-Events verwenden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div class="tip"><b>Tipp: </b>Apache Meecrowave hat CDI-first Microservices populär gemacht: ein leichtgewichtiger Server mit CDI, JAX-RS und JSON-B als Kern. Heute bietet Quarkus (Kapitel <a href='#!idx:/quarkus.html:10'>10</a>) dieselbe Philosophie mit zusätzlicher Build-Zeit-Optimierung, einem größeren Ökosystem und nativer Image-Unterstützung. Die in diesem Kapitel gezeigten Muster &mdash; modulare Beans, REST-Endpoints, Event-basierte Kommunikation &mdash; lassen sich direkt auf Quarkus übertragen.</div>
<h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.5' ><span class='entry-number'>8.5</span> Projektaufteilung</a> </h2>
 Statt einer Buildkonfiguration im Root-Verzeichnis des Projekts befinden sich in unserem Basis-Verzeichnis nur noch drei Ordner.
Im Verzeichnis "ui" werden wir den leicht angepassten UI-Layer von  <span class='latex-textit'>IdeaForkLite</span>  ablegen,
während wir im Verzeichnis "backend" je Service einen Ordner erstellen.
Das "config" Verzeichnis ist der dritte Ordner und wird eine generische Erweiterung enthalten,
die einen einfachen Zugriff auf ein zentrales Config-Service ermöglicht.<br />Den Anfang stellt das User-Service dar. Im Verzeichnis  <span class='latex-texttt'>backend/ideafork_user-service</span>  legen wir eine Buildkonfiguration an,
die neben den APIs für CDI 2.0, JAX-RS 2.0 und JPA 2.1 auch Dependencies für die entsprechenden Implementierungen und
für Demozwecke "H2" als In-Memory Datenbank schrittweise definiert.
Außerdem fügen wir Dependencies zu DeltaSpike-Core, -JPA und -Data hinzu.
Abgesehen von etwas anderen Versionen entspricht dies einem Subset der bisherigen Dependencies von  <span class='latex-textit'>IdeaForkLite</span> .
Komplett neu ist die Dependency zu Meecrowave, die wir mit  <span class='latex-texttt'>org.apache.meecrowave</span>  als  <span class='latex-texttt'>groupId</span>  und
 <span class='latex-texttt'>meecrowave-core</span>  als  <span class='latex-texttt'>artifactId</span>  und  <span class='latex-texttt'>provided</span>  als  <span class='latex-texttt'>scope</span>  definieren.
Diese Dependency benötigen wir für die Umsetzung einer Starter-Klasse,
mit der wir die Applikation in einer Embedded-Instanz des Servers aus der IDE heraus starten können.
Hierfür wird kein spezielles IDE-Plugin benötigt.
Da wir ein unabhängiges Modul umsetzen, können wir problemlos von Java 7 auf Java 8 wechseln.
Sowohl Meecrowave als auch DeltaSpike sind mit Java 8 kompatibel.
Gäbe es andere Services mit Dependencies für die dies nicht der Fall ist,
könnten wir notfalls für die entsprechenden Module auf eine ältere Java-Version zurückgreifen, bis ein Upgrade möglich ist.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.6' ><span class='entry-number'>8.6</span> Jeder Start ist einfach</a> </h2>
 Meecrowave kann auf verschiedene Arten gestartet werden.
Neben einem Maven-Plugin stellt Meecrowave ein einfaches API zur Verfügung,
um eine Embedded-Instanz zu starten. Hierfür legen wir im User-Service-Modul die Klasse  <span class='latex-texttt'>DevUserServerStarter</span>  an.
Die einfachste Variante, um den Server via Java-API zu starten ist:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>    <span class='latex-texttt'>new Meecrowave().bake().await();</span><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> 
Viel einfacher ist der Start eines EE-Micro Servers kaum noch möglich.
Im Hinblick auf Micro-Deployments liegt hier bereits der erste Fallstrick verborgen.
Im Gegensatz zu einem Monolithen möchten wir jedes Modul in einer eigenen Server-Instanz starten.
Damit dies lokal möglich ist, muss jede Instanz einen eigenen Port verwenden.
Ohne eine Container-Lösung wie beispielsweise Docker müssen wir dem Server je Instanz einen entsprechenden Port vergeben.
In unserem Fall laden wir den konfigurierten Port mit dem  <span class='latex-texttt'>ConfigResolver</span>  von DeltaSpike.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:meecrowave_starter-class'></a>                     <pre><code>public class DevUserServerStarter {
  public static void main(String[] args) {
    Meecrowave.Builder builder = new Meecrowave.Builder();
    String configuredPort =
      ConfigResolver.getPropertyValue("user-service.http.port");
      builder.setHttpPort(Integer.parseInt(configuredPort));
 
      new Meecrowave(builder).bake().await();
  }
}
</code></pre>
                </div>  
Listing  <a href='#!idx:/cdi_micro.html:fig:meecrowave_starter-class'> Meecrowave Starter-Klasse </a>  verdeutlicht,
dass wir in einer herkömmlichen Main-Methode Meecrowave mit wenigen Zeilen anpassen und schließlich starten können.
Den Wert für  <span class='latex-texttt'>user-service.http.port</span>  können wir wie gewohnt in der Datei  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  oder
einer anderen aktiven Config-Source (von DeltaSpike) hinterlegen.
In unserem Fall wollen wir den Port in der Build-Config hinterlegen und benötigen daher einen Platzhalter.
Somit sieht die Konfiguration in  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span>  wie folgt aus:
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> service.name=user-service
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> user-service.http.port=${app.http.port}
 <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p><p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> 
Der Wert von  <span class='latex-texttt'>service.name</span>  ist die Basis für die Port-Konfiguration des Moduls.
Der hier konfigurierte Wert dient als Prefix für die Portkonfiguration.
Mit  <span class='latex-texttt'>[prefix].http.port</span>  wird der Port eines Service-Moduls konfiguriert.
Dadurch könnten wir sogar Portkonfigurationen in einer zentralen Config-Source (von DeltaSpike) ablegen.
Der Platzhalter  <span class='latex-texttt'>${app.http.port}</span>  wird hier durch Maven ersetzt.
Folglich fehlt an dieser Stelle noch der Properties-Eintrag  <span class='latex-texttt'>&lt;app.http.port&gt;8082&lt;/app.http.port&gt;</span>  in der Build-Konfiguration.
 <span class='latex-texttt'>service.name</span>  spielt für uns an dieser Stelle eine untergeordnete Rolle.
Wir werden in einem der nächsten Schritte allerdings eine CDI-Extension namens Remote-Access-Lite hinzufügen,
die genau diese Art der Port-Konfiguration voraussetzt.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.7' ><span class='entry-number'>8.7</span> Von Lite zu Micro</a> </h2>
 Die Basistechnologien und die grundsätzlichen Funktionen von  <span class='latex-textit'>IdeaForkLite</span>  ändern sich nicht.
Für die Modularisierung sind jedoch kleine Änderungen notwendig, die wir Schritt für Schritt durchführen.
 <span class='latex-texttt'>BaseEntity</span> ,  <span class='latex-texttt'>User</span>  und  <span class='latex-texttt'>PasswordManager</span>  können wir ohne Änderungen übernehmen.
Bei  <span class='latex-texttt'>EntityManagerProducer</span>  ändern wir nur den Namen der Persistence-Unit,
damit jedes Service-Modul einen eindeutigen Persistence-Unit Namen verwenden kann.
Dies erleichtert die Zuordnung in der IDE ein wenig, falls wir mehrere Module parallel öffnen möchten.
Da wir  <span class='latex-textit'>IdeaForkMicro</span>  auch gleichzeitig etwas schlanker gestalten wollen, reduzieren wir die verwendeten Interceptoren in
 <span class='latex-texttt'>UserRepository</span>  auf  <span class='latex-texttt'>@org.apache.deltaspike.jpa.api.transaction.Transactional</span>  und
vereinfachen die Umsetzung, die in Listing  <a href='#!idx:/cdi_micro.html:fig:simplified_user-repository'> Vereinfachtes User-Repository </a>  ersichtlich ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:simplified_user-repository'></a>                     <pre><code>@Transactional(qualifier = Default.class)
@Repository
public interface UserRepository extends EntityRepository&lt;User, String&gt; {
  @Query(
    value = "select u from User u where u.nickName = ?1",
    singleResult = OPTIONAL)
  User loadByNickName(String nickName);
 
  @Query(
    value = "select u from User u where u.email = ?1",
    singleResult = OPTIONAL)
  User loadByEmail(String email);
}
</code></pre>
                </div> Die Datei  <span class='latex-texttt'>META-INF/beans.xml</span>  benötigen wir mit Meecrowave hingegen nicht zwingend.
Seit CDI 1.1 ist diese Konfigurationsdatei optional und der Interceptor für  <span class='latex-texttt'>@Transactional</span>  ist bereits durch DeltaSpike vorkonfiguriert.
Ohne die Datei  <span class='latex-texttt'>beans.xml</span>  werden nur Klassen zu CDI-Beans, wenn diese mit CDI-Annotationen annotiert sind,
die für die Definition von Beans gültig sind.
Diese Annotationen werden auch "bean defining annotations" genannt.
Hierzu zählen beispielsweise Scope-, Stereotype-, Interceptor- und Decorator-Annotationen.
Aus diesem Grund können wir bei der Klasse  <span class='latex-texttt'>BaseEntity</span>  auf  <span class='latex-texttt'>@Exclude</span>  verzichten.
Das eben beschriebene Default-Verhalten sorgt implizit dafür,
dass diese Klasse und die abgeleiteten  <span class='latex-textit'>IdeaFork</span> -Entities keine CDI-Beans sind.<br />Um die übernommenen Klassen auch testen zu können fügen wir neben JUnit auch  <span class='latex-texttt'>org.apache.meecrowave:meecrowave-junit</span>  als Test-Dependency hinzu.
Listing  <a href='#!idx:/cdi_micro.html:fig:cdi-test_with_meecrowave'> CDI-Test mit Meecrowave </a>  zeigt einen einfachen Testfall, mit dem wir die übernommene Logik testen können.
Die Klasse  <span class='latex-texttt'>MonoMeecrowave.Rule</span>  verwenden wir im Konstruktor von  <span class='latex-texttt'>UserTest</span> ,
um die definierten Injection-Points der Klasse durch Meecrowave befüllen zu lassen.
Im Gegensatz zum bisher verwendeten  <span class='latex-texttt'>CdiTestRunner</span>  von DeltaSpike muss dieser Schritt manuell durchgeführt werden.
Später werden wir diese  <span class='latex-texttt'>TestRule</span>  auch für Tests der JAX-RS Endpoints verwenden, die wir im nächsten Schritt hinzufügen.
Im Git-Repository von  <span class='latex-textit'>IdeaForkMicro</span>  sind neben dem Test aus Listing  <a href='#!idx:/cdi_micro.html:fig:cdi-test_with_meecrowave'> CDI-Test mit Meecrowave </a>  auch weitere Test-Methoden verfügbar.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:cdi-test_with_meecrowave'></a>                     <pre><code>public class UserTest {
  @ClassRule
  public static final MonoMeecrowave.Rule RULE =
    new MonoMeecrowave.Rule();
 
  @Inject
  private UserRepository userRepository;
 
  @Inject
  private PasswordManager passwordManager;
 
  public UserTest() {
    RULE.inject(this);
  }
 
  @Before
  public void init() {
    List&lt;User&gt; allUsers = userRepository.findAll();
    for (User user : allUsers) {
      userRepository.attachAndRemove(user);
    }
  }
 
  @Test
  public void createUser() {
    String password = passwordManager.createPasswordHash("xyz");
    User user = new User("gp@test.org", password);
 
    User savedUser = userRepository.save(user);
    Assert.assertEquals(user, savedUser);
 
    User loadedUser = userRepository.loadByEmail("gp@test.org");
 
    assertUser(user, updatedUser);
  }
 
  //...
}
</code></pre>
                </div> Grundsätzlich geht es bei den Test-Methoden von  <span class='latex-texttt'>UserTest</span>  darum die CDI-Beans direkt zu testen.
Zu diesem Zeitpunkt wissen wir folglich, dass die übernommenen CDI-Beans wie erwartet funktionieren.
Starten wir die Applikation allerdings mit unserer Starter-Klasse so stellen wir fest,
dass unser neues Modul zwar startet aber nach außen noch keine Funktionalität zur Verfügung stellt und
somit auch nicht verwendet werden kann.
Um dies zu ändern, fügen wir einen JAX-RS Endpunkt hinzu.
Wie bei JAX-RS üblich beginnen wir mit einer Subklasse von  <span class='latex-texttt'>javax.ws.rs.core.Application</span> .
In Listing  <a href='#!idx:/cdi_micro.html:fig:auto-detectable_jax-rs_application'> Autom. auffindbare JAX-RS Applikation </a> annotieren wir die Klasse  <span class='latex-texttt'>UserApplication</span>  zusätzlich mit  <span class='latex-texttt'>@javax.enterprise.context.Dependent</span> .
Die Verwendung von  <span class='latex-texttt'>@Dependent</span>  oder auch  <span class='latex-texttt'>@ApplicationScoped</span>  sorgt dafür,
dass Meecrowave die Klasse findet und intern registriert.
In unserem Fall besteht der Einstiegspfad direkt aus der Versionsnummer.
Dies ist in  <span class='latex-textit'>IdeaForkMicro</span>  eindeutig, da eine Meecrowave-Instanz nur ein Modul in einer Version enthält.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:auto-detectable_jax-rs_application'></a>                     <pre><code>@Dependent
@ApplicationPath("/v1/")
public class UserApplication extends Application {
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:user-registration'> JAX-RS Resource zur User-Registrierung </a>  zeigt eine einfache JAX-RS Ressource, mit der neue User registriert werden können.
In unserem Minimalbeispiel wird ein User mit E-Mail, Nickname und Passwort angelegt.
Alle weitere Informationen sind optional und können mit einem Update-Request später übermittelt werden.
Hierbei handelt es sich um keinen Best Practice Vorschlag,
sondern hilft primär, unsere Beispiele minimal zu halten und gleichzeitig verschiedene Konzepte zu illustrieren.
Daher verzichten wir auch auf eine zusätzliche Ebene zur Kapselung der Registrierungslogik und setzen die Logik direkt im REST-Endpunkt um.
Hätten wir neben dem REST-API noch weitere Technologien für Endpunkte, dann wäre eine solche Kapselung natürlich zu bevorzugen,
damit die eigentliche Logik nicht mehrfach umgesetzt werden muss.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:user-registration'></a>                     <pre><code>@Path("registration")
@ApplicationScoped
public class SimpleRegistrationResource {
  @Inject
  private UserRepository userRepository;
 
  @Inject
  private PasswordManager passwordManager;
 
  @POST
  @Consumes(MediaType.APPLICATION_JSON)
  public Response register(RegistrationRequest registrationRequest,
                           @Context UriInfo uriInfo) {
 
    if (userRepository.loadByEmail(
      registrationRequest.getEmail()) == null) {
        String passwordHash = passwordManager
          .createPasswordHash(registrationRequest.getPassword());

        User userToRegister = new User(
          registrationRequest.getEmail(), passwordHash);
        userToRegister.setNickName(registrationRequest.getNickName());

        User savedUser = userRepository.save(userToRegister);
        User registeredUser = userRepository.findBy(savedUser.getId());
 
        if (registeredUser != null) {
          return Response.created(uriInfo.getBaseUriBuilder().build())
            .entity(new PublicUserResponse(savedUser, true))
            .type(MediaType.APPLICATION_JSON_TYPE).build();
        }
    }
 
    return Response.status(Response.Status.CONFLICT).build();
  }
}
</code></pre>
                </div> Die POST-Methode aus Listing  <a href='#!idx:/cdi_micro.html:fig:user-registration'> JAX-RS Resource zur User-Registrierung </a>  nimmt  <span class='latex-texttt'>RegistrationRequest</span>  als ersten Parameter entgegen.
Bei dieser Klasse handelt es sich um ein einfaches Java-Bean mit den erforderlichen Properties zur Übermittlung der User-Daten.
Meecrowave konvertiert valide JSON-Strings in Instanzen dieser Klasse, sofern dies möglich ist.
Für die Antwort an den REST-Client könnten wir direkt die  <span class='latex-texttt'>User</span> -Instanz verwenden, da auch diese autom. in einen JSON-String konvertiert wird.
Dies hätte im konkreten Beispiel den Nebeneffekt, dass wir den Password-Hash an den Client senden würden.
Informationen wie diese können auf verschiedene Arten bei Bedarf gefiltert werden.
Wir verwenden hierfür die Klasse  <span class='latex-texttt'>PublicUserResponse</span> .
Diese definiert die gleichen Properties wie die Klasse  <span class='latex-texttt'>User</span>  mit Ausnahme der Passwort-Property.
Des Weiteren kann explizit gesteuert werden, ob die E-Mail Adresse in den Response aufgenommen werden soll.
Dieser Umstand ermöglicht sogar dynamische Limitierungen zur Laufzeit.
Möchten wir darüber hinaus in bestimmten Situationen den Response anpassen,
so verwenden wir wie in Listing  <a href='#!idx:/cdi_micro.html:fig:user-registration'> JAX-RS Resource zur User-Registrierung </a>  die Klasse  <span class='latex-texttt'>javax.ws.rs.core.Response</span>  als Rückgabetyp.
Ein Beispiel hierfür ist die Änderung des Status-Codes auf  <span class='latex-texttt'>Response.Status.CONFLICT</span> ,
falls es bereits einen registrierten User mit der übermittelten E-Mail Adresse geben sollte.<br />Starten wir unser User-Service erneut, so werden nicht nur unsere CDI-Beans deployed, sondern auch unsere neue JAX-RS Ressource.
Meecrowave gibt alle aktiven URIs während des Startprozesses aus.
Somit ist der erste Teil unseres User-Service-Moduls komplett und wir können einen Test für die eben definierte REST-Schnittstelle hinzufügen.
Diese Tests sammeln wir in der Klasse  <span class='latex-texttt'>UserWorkflowTest</span> .
Auch hier hilft uns  <span class='latex-texttt'>MonoMeecrowave.Rule</span> . Statt wie bisher CDI-Beans direkt in unsere Test-Klasse zu injizieren,
nutzen wir diese Test-Rule in Listing  <a href='#!idx:/cdi_micro.html:fig:jax-rs_test_with_meecrowave'> JAX-RS Test mit Meecrowave </a>  für den Zugriff auf den aktuellen Port des Containers.
In der  <span class='latex-texttt'>@Before</span>  Callback-Methode greifen wir weiterhin direkt auf unser  <span class='latex-texttt'>UserRepository</span>  zu,
um die gespeicherten User vor jedem Test zu löschen.
Hier könnten wir ebenfalls über einen REST-Endpunkt gehen.
Darauf verzichten wir in unserem Fall, weil wir, abgesehen von Tests, keine Verwendung für einen solchen Endpunkt hätten.
Sämtliche Test-Methoden verwenden jedoch strikt das definierte API unserer REST-Ressource bzw. der Ressourcen,
die wir darüber hinaus definieren und testen.
Auf die Details der Test-Methoden werden wir nicht genauer eingehen, da hier primär die Standard-Client-API von JAX-RS verwendet wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:jax-rs_test_with_meecrowave'></a>                     <pre><code>public class UserWorkflowTest {
  @ClassRule
  public static final MonoMeecrowave.Rule RULE =
    new MonoMeecrowave.Rule();
 
  private static WebTarget userRegistrationTarget;
  private static Client client;
 
  @BeforeClass
  public static void createTarget() {
    client = ClientBuilder.newClient();
 
    int testHttpPort = RULE.getConfiguration().getHttpPort();
    createUserRegistrationTarget(testHttpPort);
  }
 
  @AfterClass
  public static void onShutdown() {
    client.close();
  }
 
  private static void createUserRegistrationTarget(int testHttpPort) {
    String applicationPath =
      UserApplication.class.getAnnotation(ApplicationPath.class).value();
    String userRegistrationPath =
      SimpleRegistrationResource.class.getAnnotation(Path.class).value();
    String baseUserUrl = "http://localhost:" + testHttpPort +
      applicationPath + userRegistrationPath;
    URI uri = UriBuilder.fromUri(baseUserUrl).build();
    userRegistrationTarget = client.target(uri);
  }

  @Before
  public void init() {
    UserRepository userRepository =
      BeanProvider.getContextualReference(UserRepository.class);

    List&lt;User&gt; allUsers = userRepository.findAll();
    for (User user : allUsers) {
      userRepository.attachAndRemove(user);
    }
  }
 
  @Test
  public void registerUser() {
    User user = new User();
    user.setEmail("gp@test.org");
    user.setPassword("xyz");
 
    Response response = userRegistrationTarget.request()
      .buildPost(Entity.json(user)).invoke();
 
    Assert.assertNotNull(response);
    Assert.assertEquals(CREATED.getStatusCode(), response.getStatus());
    User createdUser = response.readEntity(User.class);
 
    Assert.assertEquals("gp@test.org", createdUser.getEmail());
  }
}
</code></pre>
                </div> Die bisher beschriebene Funktionalität zur Registrierung neuer Benutzer soll ohne Authentifizierung zur Verfügung stehen.
Im nächsten Schritt implementieren wir eine REST-Ressource, die von der Login-Seite verwendet werden soll.
In den bisherigen Kapiteln haben wir nach erfolgreicher Anmeldung den aktuellen Benutzer im  <span class='latex-texttt'>ActiveUserHolder</span> -Bean gespeichert und
geschützte Service-Methoden nur aufgerufen, wenn die Methode  <span class='latex-texttt'>#isLoggedIn</span>  den Wert  <span class='latex-texttt'>true</span>  zurückgeliefert hat.
Dies war möglich, weil Services nicht in eigenständigen Modulen gekapselt waren.
Da wir in diesem Kapitel Services in verschiedene Module verschieben, müssen diese anders gesichert werden.
Hierfür gibt es verschiedene Möglichkeiten.
Ohne auf die Vor- und Nachteile einzugehen verwenden wir in  <span class='latex-textit'>IdeaForkMicro</span>  JWT (JSON Web Token).
Um die JWT-Integration nicht selbst umsetzen zu müssen, greifen wir auf einen kleinen Aufsatz für JAX-RS namens JWT-Authentication-Lite zurück.
Das API dieses Prototypen besteht aus zwei Annotationen und einer Klasse, die sehr einfach anzuwenden sind.
Services, die nur mit erfolgreicher Authentifizierung verwendbar sein sollen,
werden zusätzlich mit der Annotation  <span class='latex-texttt'>@AuthenticationRequired</span>  markiert.
Außerdem müssen alle Services das gleiche Shared-Secret verwenden,
das wir unter dem Key  <span class='latex-texttt'>jwt_secret</span>  in einer gültigen Config-Source (von DeltaSpike) hinterlegen.
In  <span class='latex-textit'>IdeaForkMicro</span>  verwenden wir hierfür die Datei  <span class='latex-texttt'>META-INF/apache-deltaspike.properties</span> .
Allerdings benutzen wir als Wert nur einen Platzhalter, der durch Maven ersetzt wird.
Somit könnten wir beispielsweise über eine Build-Pipeline das Shared-Secret je Stage automatisiert anpassen.
Alternativ könnten wir natürlich die Konfiguration beispielsweise mit System-Properties durchführen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die  <span class='latex-texttt'>Login</span> -Ressource stellt einen Spezialfall dar, weil hier der JWT-Token im Hintergrund erzeugt werden muss.
Dies können wir mit Hilfe der zweiten Annotation namens  <span class='latex-texttt'>@LoginEntryPoint</span>  veranlassen.
Listing  <a href='#!idx:/cdi_micro.html:fig:simple-login'> Simple Login </a>  zeigt eine einfache Umsetzung der  <span class='latex-texttt'>Login</span> -Ressource.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:simple-login'></a>                     <pre><code>@Path("user-action")
@ApplicationScoped
public class SimpleLoginResource {
  @Inject
  private UserRepository userRepository;
 
  @Inject
  private PasswordManager passwordManager;
 
  @Inject
  private IdentityHolder identityHolder;
 
  @LoginEntryPoint
  @POST
  @Path("/login")
  @Consumes(MediaType.APPLICATION_JSON)
  public Response login(LoginRequest loginRequest,
                        @Context UriInfo uriInfo) {
 
    if (loginRequest.getEmail() == null ||
        loginRequest.getPassword() == null) {
      return Response.status(
        Response.Status.BAD_REQUEST.getStatusCode()).build();
    }
 
    User loadedUser = userRepository.loadByEmail(loginRequest.getEmail());
 
    if (loadedUser == null) {
      return Response.status(
        Response.Status.BAD_REQUEST.getStatusCode()).build();
    }
 
    String passwordHash = passwordManager
      .createPasswordHash(loginRequest.getPassword());
 
    if (passwordHash.equals(loadedUser.getPassword())) {
      try {
        identityHolder.setAuthenticatedEMail(loginRequest.getEmail());
 
        return Response.ok().build();
      } catch (Exception e) {
        return Response.status(
          Response.Status.INTERNAL_SERVER_ERROR).build();
      }
    }
    return Response.status(Response.Status.UNAUTHORIZED).build();
  }
}
 
public class LoginRequest {
    private String email;
    private String password;
 
    //+ getters and setters
}
</code></pre>
                </div>  
Die Beans  <span class='latex-texttt'>UserRepository</span>  und  <span class='latex-texttt'>PasswordManager</span>  kennen wir bereits aus den vergangenen Kapiteln.
Beide wurden ohne Änderung aus  <span class='latex-textit'>IdeaForkLite</span>  übernommen.
 <span class='latex-texttt'>IdentityHolder</span>  ist hingegen ein Request-Scoped Bean,
das in JWT-Authentication-Lite enthalten ist.
Wird für die übermittelte E-Mail Adresse ein gespeicherter User gefunden und stimmt der Passwort-Hash ebenfalls überein,
dann können wir die E-Mail Adresse an  <span class='latex-texttt'>IdentityHolder</span>  weitergeben.
Im Hintergrund wird mit dieser E-Mail Adresse ein JWT-Token erzeugt, der in den HTTP-Header übernommen wird.
Bei jedem Folgerequest an JAX-RS Ressourcen, die durch  <span class='latex-texttt'>@AuthenticationRequired</span>  geschützt sind,
muss dieser Token erneut übermittelt werden.
JWT-Authentication-Lite verifiziert bei jedem Request den JWT-Token mit Hilfe des Shared-Secrets.
Als Metadaten enthält der Token die E-Mail Adresse und einen Timestamp für die zeitliche Begrenzung der Gültigkeit.
Nur wenn ein Token erfolgreich verifiziert wurde und darüber hinaus noch gültig ist,
wird die E-Mail Adresse für diesen Request in das  <span class='latex-texttt'>IdentityHolder</span> -Bean übernommen.
Ähnlich wie bei einer HTTP-Session wird die Gültigkeit verlängert,
wenn innerhalb eines gewissen Zeitfensters ein Token verwendet wurde.
Hierbei ist allerdings zu beachten, dass autom. ein neuer Token mit einer neuen Gültigkeitszeit ausgestellt wird.
Für Clients macht dies jedoch keinen Unterschied, da sie im Normalfall immer den übermittelten Token verwenden sollten und
der genaue Inhalt nicht relevant ist, da der Token unverändert beim nächsten Request erneut mitgesendet werden muss.
Im Falle von  <span class='latex-textit'>IdeaForkMicro</span>  werden Token nur bei der Kommunikation zwischen verschiedenen Services übermittelt.
Hätten wir beispielsweise eine JavaScript Applikation, die im Browser ausgeführt wird und direkt mit den REST-Ressourcen kommunizieren würde,
dann wäre eine zusätzliche Absicherung wie beispielsweise HTTPS statt HTTP ratsam.
Da wir für das  <span class='latex-textit'>IdeaFork</span> -UI bei JSF bleiben, ist dies nicht zwingend für die ganze Applikation erforderlich.
Vor allem, wenn nach außen nur der Server, auf dem das  <span class='latex-textit'>IdeaFork</span> -UI deployed wird, erreichbar ist.
<div class="tip"><b>Tipp: </b>Die manuelle JWT-Verarbeitung in <span class='latex-textit'>IdeaForkMicro</span> ist bewusst vereinfacht, um das Konzept zu veranschaulichen. MicroProfile JWT standardisiert Token-Propagation, -Validierung und -Extraktion. In Quarkus (Kapitel <a href='#!idx:/quarkus.html:10.6'>10.6</a>) wird der <span class='latex-texttt'>JsonWebToken</span> automatisch aus dem HTTP-Header extrahiert und als CDI-Bean injiziert &mdash; der manuelle <span class='latex-texttt'>IdentityHolder</span>-Code entfällt komplett.</div>
Nach diesem kurzen JWT-Exkurs sieht es danach aus, als wäre  <span class='latex-textit'>IdeaForkMicro</span>  komplexer als  <span class='latex-textit'>IdeaForkLite</span> ,
da wir uns in  <span class='latex-textit'>IdeaForkLite</span>  beispielsweise um keine Token kümmern mussten.
Dies ist eine der Konsequenzen bei der Aufteilung in modulare Services und
hat unmittelbar nichts mit den Eigenschaften von CDI oder JAX-RS zu tun.
Abgesehen von der möglichen Skalierbarkeit je Service
werden wir im Laufe des Kapitels auch noch weitere Vorteile einer solchen Modularisierung sehen.
Am Ende des Kapitels werden wir die eben vorgestellten Endpunkte im UI-Modul einbinden.
Vorerst fügen wir Tests für unsere Login-Logik hinzu.
Listing  <a href='#!idx:/cdi_micro.html:fig:simple_login_test-target'> Simples Login Test-Target </a>  zeigt die Methode zum Erzeugen des Login-Targets,
die wir zur Klasse  <span class='latex-texttt'>UserWorkflowTest</span>  hinzufügen und in der Methode  <span class='latex-texttt'>#createTarget</span>  aufrufen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:simple_login_test-target'></a>                     <pre><code>private static void createLoginTarget(int testHttpPort) {
  String applicationPath =
    UserApplication.class.getAnnotation(ApplicationPath.class).value();
  String loginPath =
    SimpleLoginResource.class.getAnnotation(Path.class).value();
 
  String baseUserUrl = "http://localhost:" + testHttpPort +
    applicationPath + loginPath + "/login";
  URI uri = UriBuilder.fromUri(baseUserUrl).build();
  loginTarget = client.target(uri);
}
</code></pre>
                </div> Die grundlegende Logik dieser Methode haben wir bereits für  <span class='latex-texttt'>#createUserRegistrationTarget</span>  verwendet.
Der Hauptunterschied ist, dass wir den letzten Teil des Pfades fix vorgeben.
Würden wir in  <span class='latex-texttt'>SimpleLoginResource</span>  diesen Teil des Pfades später ändern, dann müssten wir die Änderung in jedem Test nachziehen.
Listing  <a href='#!idx:/cdi_micro.html:fig:dynamic_login_test-target'> Dynamisches Login Test-Target </a>  zeigt, wie sich dies mit ein paar zusätzlichen Zeilen verhindern lässt,
indem dynamisch nach  <span class='latex-texttt'>@LoginEntryPoint</span>  gesucht wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:dynamic_login_test-target'></a>                     <pre><code>private static void createLoginTarget(int testHttpPort) {
  String applicationPath =
    UserApplication.class.getAnnotation(ApplicationPath.class).value();
  String loginPath =
    SimpleLoginResource.class.getAnnotation(Path.class).value();
 
  for (Method method : SimpleLoginResource.class.getDeclaredMethods()) {
    if (method.isAnnotationPresent(LoginEntryPoint.class)) {
      Path path = method.getAnnotation(Path.class);
      if (path != null) {
        loginPath += path.value();
        break;
      }
    }
  }
 
  String baseUserUrl = "http://localhost:" + testHttpPort +
    applicationPath + loginPath;
  URI uri = UriBuilder.fromUri(baseUserUrl).build();
  loginTarget = client.target(uri);
}
</code></pre>
                </div> Mithilfe von  <span class='latex-texttt'>loginTarget</span>  können wir in unseren Tests nach erfolgreicher Registrierung einen Request an die Login-Ressource absetzen.
In Listing  <a href='#!idx:/cdi_micro.html:fig:user-login_test'> User-Login Test </a>  wird im letzten Schritt überprüft, ob ein Token ausgestellt wurde.
Auch hierfür verwenden wir die standardmäßige Client-API von JAX-RS.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:user-login_test'></a>                     <pre><code>@Test
public void loginUser() {
  registerUser();
  User user = new User("gp@test.org", "xyz");
 
  Response response =
    loginTarget.request().buildPost(Entity.json(user)).invoke();
  String token = response.getHeaderString(HttpHeaders.AUTHORIZATION);
  Assert.assertNotNull(token);
}
 
private Response registerUser() {
  User user = new User();
  user.setEmail("gp@test.org");
  user.setPassword("xyz");
 
  Response response = userRegistrationTarget.request()
    .buildPost(Entity.json(user)).invoke();
 
  Assert.assertNotNull(response);
  Assert.assertEquals(CREATED.getStatusCode(), response.getStatus());
  User createdUser = response.readEntity(User.class);
 
  Assert.assertEquals("gp@test.org", createdUser.getEmail());
  return response;
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:test_invalid_login'> Test eines invaliden Logins </a>  testet schließlich noch einen Login-Request mit falschem Passwort.
In diesem Fall wird HTTP-401 (Unauthorized) von unserer JAX-RS Ressource zurückgesendet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:test_invalid_login'></a>                     <pre><code>  @Test
  public void failedLogin() {
    registerUser();
 
    User user = new User("gp@test.org", "wrong");
 
    Response response = loginTarget.request()
      .buildPost(Entity.json(user)).invoke();
    Assert.assertNotNull(response);
    Assert.assertEquals(
      UNAUTHORIZED.getStatusCode(), response.getStatus());
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.8' ><span class='entry-number'>8.8</span> Asynchrone CDI-Events</a> </h2>
 Bis zu diesem Punkt hätten wir die gesamte Funktionalität mit jedem beliebigen EE v6 bzw. v7 Server umsetzen können.
Wie eingangs erwähnt ist das Ziel von Initiativen wie dem
Micro-Profile und Meecrowave nicht nur eine möglichst effiziente Laufzeitumgebung zur Verfügung zu stellen,
sondern auch eine möglichst aktuelle. Im Falle von CDI wurde Version 2.0 mehrere Monate vor Java EE 8 finalisiert und
produktiv verwendbare Implementierungen standen innerhalb weniger Wochen zur Verfügung.
Bis jedoch sämtliche EE-Server alle Spezifikationen einer neuen EE-Version integriert haben,
vergeht üblicherweise nochmal deutlich mehr Zeit.
EE 8 verspricht diesen oft kritisierten Aspekt etwas zu entkräften, da der Umfang bewusst kleiner als beispielsweise bei EE 6 gehalten wurde.
Mit Servern wie Meecrowave haben wir allerdings den Vorteil am Puls der Zeit zu bleiben und
neue Features bereits kurz nach der Fertigstellung der Spezifikation verwenden zu können.
In  <span class='latex-textit'>IdeaForkMicro</span>  nutzen wir diesen Umstand, um asynchrone Events mit den neuen Boardmitteln von CDI 2.0 zu implementieren.
Hierfür verwenden wir in Listing  <a href='#!idx:/cdi_micro.html:fig:fire_async_cdi-events'> Asynchrone CDI-Events feuern </a>  wie gewohnt einen Injection-Point vom Typ  <span class='latex-texttt'>javax.enterprise.event.Event</span> .
Statt  <span class='latex-texttt'>#fire</span>  rufen wir jedoch die neue Methode  <span class='latex-texttt'>#fireAsync</span>  auf.
Etwas später werden wir sehen,
warum wir in Listing  <a href='#!idx:/cdi_micro.html:fig:fire_async_cdi-events'> Asynchrone CDI-Events feuern </a>  den aktuellen Token an die  <span class='latex-texttt'>UserChangedEvent</span> -Instanz übergeben müssen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:fire_async_cdi-events'></a>                     <pre><code>@ApplicationScoped
public class UserChangeBroadcaster {
  @Inject
  private AuthenticationManager authenticationManager;
 
  @Inject
  private Event&lt;UserChangedEvent&gt; userChangedEvent;
 
  @Inject
  private IdentityHolder identityHolder;
 
  public void onUserChange(User user) {
    try {
      if (user.getVersion() == 0) {
        String tmpToken =
          authenticationManager.createNewToken(user.getEmail());
        userChangedEvent.fireAsync(
          new UserRegistrationEvent(user, tmpToken));
      } else {
        userChangedEvent.fireAsync(
          new UserChangedEvent(user, identityHolder.getCurrentToken()));
      }
    } catch (Exception e) {
      throw ExceptionUtils.throwAsRuntimeException(e);
    }
  }
}
</code></pre>
                </div> Der zweite Unterschied ist auf der Observer-Seite zu finden.
Wie in Listing  <a href='#!idx:/cdi_micro.html:fig:observer_for_async_events'> CDI-Observer für asynchrone Events </a>  zu sehen ist, muss bei einem Observer für asynchrone CDI-Events  <span class='latex-texttt'>@ObservesAsync</span>  statt  <span class='latex-texttt'>@Observes</span>  eingesetzt werden.
Somit können Event-Klassen sowohl für synchrone als auch asynchrone Events verwendet werden.
Erst durch die entsprechende  <span class='latex-texttt'>fire</span> -Methode und
durch die auf der Observer-Seite dazu passende Annotation wird die Unterscheidung getroffen.
Wird zu einem späteren Zeitpunkt beispielsweise ein synchrones Event auf ein asynchrones umgestellt,
so genügt es eben nicht, nur den Methodenaufruf auf  <span class='latex-texttt'>#fireAsync</span>  umzustellen.
Wird die Umstellung auf  <span class='latex-texttt'>@ObservesAsync</span>  ausgelassen, so werden Events nicht mehr zugestellt,
weil es dann keine Methoden mit  <span class='latex-texttt'>@ObservesAsync</span>  gibt.
Würden wir sowohl  <span class='latex-texttt'>#fireAsync</span>  als auch  <span class='latex-texttt'>#fire</span>  nacheinander aufrufen, können wir auf der Observer-Seite wahlweise
 <span class='latex-texttt'>@ObservesAsync</span>  oder  <span class='latex-texttt'>@Observes</span>  verwenden, ohne auf die verwendete  <span class='latex-texttt'>fire</span> -Methode Rücksicht nehmen zu müssen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:observer_for_async_events'></a>                     <pre><code>@ApplicationScoped
public class UserActivityObserver {
  @Inject
  private UserActionRepository userActionRepository;

  public void onUserActionEvent(
    @ObservesAsync UserActionEvent userActionEvent) {
      userActionRepository.save(userActionEvent.getUserAction());
  }
}
</code></pre>
                </div> In den nachfolgenden Abschnitten wird es noch weitere Hinweise zu CDI 2.0 geben.
Asynchrone Events und die etwas später verwendete Priorisierung von Events
stellen für  <span class='latex-textit'>IdeaForkMicro</span>  die interessanteste Neuheit in CDI 2.0 dar.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.9' ><span class='entry-number'>8.9</span> Entfernt und doch so nahe</a> </h2>
 Bisher haben wir alle beschriebenen Schritte im User-Service-Modul umgesetzt.
Wie eingangs erwähnt wird es in  <span class='latex-textit'>IdeaForkMicro</span>  mehrere Module geben.
Die nächsten Service-Module sind Notification-Service zum Versenden von E-Mail Benachrichtigungen und das Archive-Service,
über das wir Änderungen an Entitäten separat archivieren.
Beide Service-Module sind zu diesem Zeitpunkt noch nicht umgesetzt.
Die Schnittstelle der Module ist allerdings schon absehbar.
Bisher haben wir  <span class='latex-texttt'>RegistrationRequest</span>  bereits im Endpunkt  <span class='latex-texttt'>SimpleRegistrationResource</span>  verwendet.
Dieses Java-Bean definiert die Properties  <span class='latex-texttt'>email</span> ,  <span class='latex-texttt'>nickName</span> ,  <span class='latex-texttt'>firstName</span> ,  <span class='latex-texttt'>lastName</span>  und  <span class='latex-texttt'>password</span> .
Nur letztere ist in der Klasse  <span class='latex-texttt'>RegistrationRequest</span>  selbst definiert.
Die restlichen Properties sind in einer Basisklasse namens  <span class='latex-texttt'>UserRequest</span>  enthalten.
 <span class='latex-texttt'>UserRequest</span>  kann somit auch für die Nachricht an das Notification-Service wiederverwendet werden.
Listing  <a href='#!idx:/cdi_micro.html:fig:rest-client_as_partial-bean'> REST-Resource Client als Partial-Bean </a>  zeigt, wie wir das noch zu erstellende Notification-Service ansprechen wollen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:rest-client_as_partial-bean'></a>                     <pre><code>@ApplicationScoped
@ResourceClient(name = "notifications", version = "v1")
public interface NotificationResource {
  @POST
  @Path("/welcome")
  void sendWelcomeMessage(UserRequest notificationRequest);
}
</code></pre>
                </div> Die Annotation  <span class='latex-texttt'>@ResourceClient</span>  aus Listing  <a href='#!idx:/cdi_micro.html:fig:rest-client_as_partial-bean'> REST-Resource Client als Partial-Bean </a> wird durch die CDI-Extension Remote-Access-Lite zur Verfügung gestellt und
basiert auf dem Partial-Bean Konzept von DeltaSpike.
Das Interface  <span class='latex-texttt'>NotificationResource</span>  können wir wie ein herkömmliches CDI-Bean injizieren und verwenden.
Im konkreten Beispiel wird bei einem Aufruf von  <span class='latex-texttt'>NotificationResource#sendWelcomeMessage</span>  das Service
mit dem Namen "notifications" in Version "v1" gesucht und an "/welcome" ein POST-Request gesendet.
Bei  <span class='latex-texttt'>@POST</span>  und  <span class='latex-texttt'>@Path</span>  handelt es sich um die bereits bekannten JAX-RS Annotationen.
Folglich ist nur  <span class='latex-texttt'>@ResourceClient</span>  eine eigene Annotation, die einen einfacheren Zugriff auf Remote-Services ermöglicht.
Im Hintergrund wird die Adresse des Services festgestellt, mit den Pfadangaben kombiniert und der Request über das JAX-RS Client-API veranlasst.
Damit dies möglich ist, registriert sich beim Applikationsstart jedes Modul in einer dezentral verteilten Datenstruktur.
Für jeden REST-Endpunkt wird ein Eintrag angelegt, der automatisch an alle teilnehmenden Module repliziert und
in regelmäßigen Abständen aktualisiert wird.
Obwohl wir keine Containerlösung wie beispielsweise Docker verwenden, müssen wir Informationen anderer Module, wie beispielsweise Ports,
auf diese Weise nicht explizit kennen,
weil diese Informationen im Hintergrund ebenfalls automatisch registriert und zwischen Service-Instanzen repliziert werden.
Mit diesem Wissen ausgestattet können wir in Listing  <a href='#!idx:/cdi_micro.html:fig:remote-historization_via_partial-bean'> Remote-Archivierung via Partial-Bean </a>  unverzüglich mit der Integration des Archive-Moduls fortsetzen.
In diesem Fall ist  <span class='latex-texttt'>EntityChangeRequest</span>  ein Java-Bean mit den Properties
 <span class='latex-texttt'>entityAsJson</span> ,  <span class='latex-texttt'>id</span> ,  <span class='latex-texttt'>version</span>  und einer Readonly Property  <span class='latex-texttt'>creationTimestamp</span> ,
das nur für Nachrichten an das Archive-Service verwendet wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:remote-historization_via_partial-bean'></a>                     <pre><code>@ApplicationScoped
@ResourceClient(name = "archive", version = "v1")
public interface ArchiveResource {
  @POST
  void recordChange(EntityChangeRequest entityChangeRequest);
}
</code></pre>
                </div> Ist ein Service zur Laufzeit nicht verfügbar, dann bricht die CDI-Extension die Verarbeitung ab und es wird eine Warnung gelogged.
Ein umfangreicheres Error-Handling ist durchaus möglich, aber nicht Teil der Remote-Access-Lite Extension,
da es sich hier um einen Prototypen handelt, der primär dazu dienen soll,
dass wir keine zusätzliche Container- oder Service-Discovery-Lösung für  <span class='latex-textit'>IdeaForkMicro</span>  benötigen.
Darüber hinaus zeigt diese CDI-Extension erneut die vielfältigen Einsatzmöglichkeiten von Partial-Beans und
anderer Mechanismen von Apache DeltaSpike und kann als Inspiration für weitere CDI-Extensions dienen.
<div class="tip"><b>Tipp: </b>Das <span class='latex-texttt'>@ResourceClient</span>-Pattern von DeltaSpike wird durch den MicroProfile REST Client standardisiert. Statt eines Partial-Bean-Proxys verwendet man <span class='latex-texttt'>@RegisterRestClient</span> mit einem typisierten Interface &mdash; der Quarkus-Container erzeugt die Implementierung automatisch. Für die Migration von <span class='latex-textit'>IdeaForkMicro</span> zu Quarkus bedeutet dies: Das Interface bleibt nahezu unverändert, nur die Annotationen werden ausgetauscht.</div>
Durch die eben gezeigten Partial-Beans  <span class='latex-texttt'>NotificationResource</span>  und
 <span class='latex-texttt'>ArchiveResource</span>  können wir die Anbindung an diese Module bereits im User-Service-Modul umsetzen
als hätten wir die beiden anderen Module bereits zur Verfügung.
Listing  <a href='#!idx:/cdi_micro.html:fig:forwarding_jwt-token_manually'> Manuell übertragener Token </a>  zeigt den Aufruf von  <span class='latex-texttt'>NotificationResource#sendWelcomeMessage</span>  und
Listing  <a href='#!idx:/cdi_micro.html:fig:archive_changes_async'> Asynchrone Archivierung </a>  die Verwendung von  <span class='latex-texttt'>ArchiveResource#recordChange</span> .
In beiden Listings erfolgt der Aufruf in einer asynchronen Observer-Methode.
In der Methode  <span class='latex-texttt'>onUserRegisteredEvent</span>  muss der aktuelle Token manuell gesetzt werden,
weil Token nach der Überprüfung in einem Thread nur in diesem automatisch übernommen werden.
Asynchrone Observer-Methoden werden hingegen durch einen anderen Thread ausgeführt und daher greift der Automatismus an dieser Stelle nicht.
Der so gesetzte Token wird anschließend wieder automatisch verarbeitet.
Konkret wird er für den Aufruf von  <span class='latex-texttt'>NotificationResource#sendWelcomeMessage</span>  verwendet.
Somit ist dies nur erforderlich, wenn wir in einem neuen Thread ein anderes Service-Modul ansprechen möchten.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:forwarding_jwt-token_manually'></a>                     <pre><code>@ApplicationScoped
public class RegistrationNotificationObserver {
  @Inject
  private NotificationResource notificationResource;
 
  @Inject
  private IdentityHolder identityHolder;
 
  public void onUserRegisteredEvent(
    @ObservesAsync UserRegistrationEvent userRegistrationEvent) {
      identityHolder.setCurrentToken(userRegistrationEvent.getToken());
      String userSpecificText =
        Optional.ofNullable(userRegistrationEvent.getUser().getNickName())
          .orElse(userRegistrationEvent.getUser().getEmail());
      UserRequest userRequest = new UserRequest();
      userRequest.setNickName(userSpecificText);
      this.notificationResource.sendWelcomeMessage(userRequest);
  }
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:archive_changes_async'> Asynchrone Archivierung </a>  zeigt eine ähnliche Konstellation.
Allerdings wird hier manuell der  <span class='latex-texttt'>ObjectMapper</span>  von Jackson verwendet,
um den aktuellen Zustand der  <span class='latex-texttt'>User</span> -Instanz in JSON zu serialisieren.
Folglich muss die checked Exception  <span class='latex-texttt'>JsonProcessingException</span>  explizit behandelt werden.
Auch hier genügt es in unserem vereinfachten Fall, dass wir die checked Exception in eine unchecked Exception umwandeln und weiterwerfen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:archive_changes_async'></a>                     <pre><code>@ApplicationScoped
public class UserChangeObserver {
  @Inject
  private IdentityHolder identityHolder;
 
  @Inject
  private ArchiveResource archiveResource;
 
  public void onUserChange(
    @ObservesAsync UserChangedEvent userChangedEvent) {
      this.identityHolder.setCurrentToken(userChangedEvent.getToken());
 
      ObjectMapper objectMapper = new ObjectMapper();
 
      try {
        User user = userChangedEvent.getUser();
        EntityChangeRequest entityChangeRequest =
          new EntityChangeRequest();
        entityChangeRequest.setId(user.getId());
        entityChangeRequest.setEntityAsJson(
          objectMapper.writeValueAsString(user));
        entityChangeRequest.setVersion(user.getVersion());
 
        archiveResource.recordChange(entityChangeRequest);
      } catch (JsonProcessingException e) {
        throw ExceptionUtils.throwAsRuntimeException(e);
      }
  }
}
</code></pre>
                </div> Damit Änderungen, die mit dem  <span class='latex-texttt'>ArchiveResource</span> -Partial-Bean verschickt werden, auch ankommen und
verarbeitet werden, erstellen wir ein Modul namens History-Service.
In diesem Modul archivieren und verwalten wir Änderungen an Entitäten.
Grundsätzlich ist dieses Modul äquivalent zum User-Service Modul aufgebaut.
Sowohl Konfiguration, Starterklasse als auch ein JAX-RS Endpunkt werden hier nach dem zuvor beschriebenen Vorgehen umgesetzt.
Listing  <a href='#!idx:/cdi_micro.html:fig:archive_changes_in_jax-rs_endpoint'> JAX-RS Endpunkt zur Archivierung </a>  zeigt, dass auch hier die JAX-RS Ressource denkbar einfach umzusetzen ist.
Die mit  <span class='latex-texttt'>@POST</span>  annotierte Methode  <span class='latex-texttt'>#archiveEntity</span>  konvertiert die übermittelte Instanz vom Typ  <span class='latex-texttt'>EntityChangeRequest</span> in ein JPA-Entity vom Typ  <span class='latex-texttt'>EntityChange</span>  und speichert diese mit Hilfe des injizierten  <span class='latex-texttt'>EntityChangeRepository</span> -Instanz.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:archive_changes_in_jax-rs_endpoint'></a>                     <pre><code>@AuthenticationRequired
@Path("archive")
 
@ApplicationScoped
public class EntityArchiveResource {
  @Inject
  private EntityChangeRepository entityChangeRepository;
 
  @POST
  public void archiveEntity(EntityChangeRequest entityChangeRequest) {
    EntityChange entityChange = new EntityChange(
      entityChangeRequest.id,
      entityChangeRequest.version,
      entityChangeRequest.entityAsJson,
      entityChangeRequest.creationTimestamp);
 
      entityChangeRepository.save(entityChange);
  }

  //...
}
</code></pre>
                </div> Allerdings zeigt sich bei der Modularisierung, dass sich bereits jetzt gewisse Codeduplizierungen einschleichen.
Da Module eigenständig sind und auch eigene Konzepte verfolgen können, wird oft empfohlen keinen geteilten Code zu verwenden.
In unserem Fall führt dies dazu, dass jedes Modul, in dem wir JPA verwenden, eine Kopie der Klasse  <span class='latex-texttt'>BaseEntity</span>  enthält.
Generische Libraries könnte man wie andere Dependencies zwischen Modulen teilen.
In  <span class='latex-textit'>IdeaForkMicro</span>  verzichten wir in diesem Fall jedoch auf die Wiederverwendbarkeit dieser einen Klasse.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.10' ><span class='entry-number'>8.10</span> Diversität je Modul</a> </h2>
 Neben dem  <span class='latex-texttt'>ArchiveResource</span> -Partial-Bean haben wir auch ein Partial-Bean namens  <span class='latex-texttt'>NotificationResource</span>  bereits eingebunden.
Aktuell fehlt nur noch das dazugehörige  <span class='latex-texttt'>Notification</span> -Modul.
Dieses legen wir im nachfolgenden Schritt an.
Auch hier erstellen wir eine Klasse für den einfachen manuellen Start und nennen diese  <span class='latex-texttt'>DevNotificationServerStarter</span> .
Wie bereits erwähnt sind die Starter-Klassen für Meecrowave gleich aufgebaut.
Der einzige Unterschied liegt in der Konfiguration des Servicenamens und des Ports.
Eine Besonderheit im Notification-Service Modul gibt es dennoch.
Wir übernehmen aus  <span class='latex-textit'>IdeaForkLite</span>  die Integration von Spring-Mail, die mit Hilfe unserer CDI-Spring-Bridge umgesetzt wurde.
Die Funktionalität des Moduls stellen wir, wie auch beim User-Service Modul,
mit einem JAX-RS Endpunkt für andere Teile der Applikation zur Verfügung.
Listing  <a href='#!idx:/cdi_micro.html:fig:send_notifications'> JAX-RS Endpunkt zum Versenden von E-Mails </a>  zeigt die Injizierung und Verwendung von  <span class='latex-texttt'>MailService</span> ,
das wie gehabt das Spring-Bean  <span class='latex-texttt'>SpringMailSender</span>  verwendet.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:send_notifications'></a>                     <pre><code>@AuthenticationRequired
@Path("notifications")
 
@ApplicationScoped
public class NotificationResource {
  @Inject
  private IdentityHolder identityHolder;
 
  @Inject
  private MailService mailService;
 
  @POST
  @Path("/welcome")
  public void onNotification(RecipientDetails recipientDetails) {
    mailService.sendWelcomeMessage(recipientDetails.nickName);
  }
}
</code></pre>
                </div> Da wir Spring-Mail bzw. Spring nur in diesem Modul verwenden, können wir die damit verbundene Build-Konfiguration und
Funktionalität auf dieses Modul beschränken.
Des Weiteren mussten wir bisher  <span class='latex-texttt'>SpringMailSender</span>  mit  <span class='latex-texttt'>@Exclude</span>  explizit für den CDI-Container entfernen,
da zur Laufzeit Spring dieses Bean verwalten soll.
Seit CDI 1.1 könnten wir hierfür auch  <span class='latex-texttt'>@javax.enterprise.inject.Vetoed</span>  verwenden.
Alternativ können wir die Datei  <span class='latex-texttt'>META-INF/beans.xml</span>  weglassen oder
in dieser Datei den Tag  <span class='latex-texttt'>beans</span>  um das Attribut  <span class='latex-texttt'>bean-discovery-mode</span>  erweitern und
statt "all" den Wert "annotated" verwenden.
In beiden Fällen werden, wie am Anfang des Kapitels erklärt, nur Klassen mit den sogenannten "bean defining annotations" berücksichtigt.
Ebenfalls in der Datei  <span class='latex-texttt'>beans.xml</span>  steht eine weitere Alternative zur Verfügung.
Durch die Tags  <span class='latex-texttt'>scan</span>  und  <span class='latex-texttt'>exclude</span>  können Teile des BDAs via Konfiguration ausgelassen werden.
CDI 2.0 geht sogar noch einen Schritt weiter und führt den  <span class='latex-texttt'>&lt;trim/&gt;</span> -Tag als einfachen Marker-Tag ein.
Mit diesem werden Beans für den CDI-Container erst exkludiert,
falls sie nach dem Startprozess weder durch eine explizite (CDI-)Annotation noch dynamisch durch eine CDI-Extension zu einem CDI-Bean gemacht wurden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> An diesem Punkt haben wir bereits drei Module, wobei das User-Service Modul mit den beiden anderen Modulen kommuniziert.
Über den  <span class='latex-texttt'>IdentityHolder</span>  haben wir auf den aktuellen Token zugegriffen bzw.
nach einem erfolgreichen Login die authentifiziert E-Mail Adresse für den aktuellen Thread gesetzt.
Diese E-Mail Adresse wird auch bei nachfolgenden Requests mit JWT-Token durch den  <span class='latex-texttt'>IdentityHolder</span>  zur Verfügung gestellt
sobald der mitgesendete Token erfolgreich verifiziert wurde.
Listing  <a href='#!idx:/cdi_micro.html:fig:load_current_user_details'> Aktuelle User-Details laden </a>  zeigt dies anhand der  <span class='latex-texttt'>UserActionResource</span> , die im User-Service Modul hinzugefügt wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:load_current_user_details'></a>                     <pre><code>@AuthenticationRequired
@Path("user-action")
 
@ApplicationScoped
public class UserActionResource {
  @Inject
  private UserRepository userRepository;
 
  @Inject
  private UserActionRepository userActionRepository;
 
  @Inject
  private IdentityHolder identityHolder;
 
  @GET
  public UserActionResponse loadCurrentUserDetails() {
    User user = userRepository.loadByEmail(
      identityHolder.getAuthenticatedEMail());
 
    List&lt;UserAction&gt; result = Optional
      .ofNullable(userActionRepository.loadLatestActivities(user, 10))
      .orElse(emptyList());
    List&lt;UserActionEntry&gt; userActionEntryList =
      result.stream().map(UserActionEntry::new).collect(toList());
    return new UserActionResponse(user, userActionEntryList);
  }
}
</code></pre>
                </div> In der Methode  <span class='latex-texttt'>#loadCurrentUserDetails</span>  verwenden wir den Wert,
der von  <span class='latex-texttt'>IdentityHolder#getAuthenticatedEMail</span>  zurückgegeben wird,
um den entsprechenden User zu laden und im nächsten Schritt können wir zusätzlich die User-Aktionen für diesen User laden.
Sämtliche dieser User-Details werden am Ende des Kapitels im User-Profil Bereich von  <span class='latex-textit'>IdeaForkLite</span>  angezeigt.
User-Aktionen beinhalten bis zu diesem Punkt nur User-Logins.
Das Git-Repository von  <span class='latex-textit'>IdeaForkMicro</span>  enthält im User-Service Modul außerdem eine ähnlich aufgebaute  <span class='latex-texttt'>SimpleLogoutResource</span>  Klasse,
die zusätzlich User-Logouts via REST-Schnittstelle entgegennimmt und intern ein asynchrones  <span class='latex-texttt'>UserActionEvent</span>  weiterleitet,
das schließlich dazu führt, dass der  <span class='latex-texttt'>UserActivityObserver</span>  auch diese Events speichert.
Das User-Service Modul selbst ist zustandslos, wodurch ein expliziter Logout keine weiteren Auswirkungen hat.
Im UI-Teil der Applikation, zu dem wir etwas später kommen werden, sieht dies anders aus.
Hier muss bei einem Logout zumindest der JWT-Token verworfen werden.
Damit wir Logout-Events im User-Profil zusätzlich anzeigen können,
muss der zuvor erwähnte Logout-Request an das User-Modul explizit durchgeführt werden.
Die Zustellung dieses Events führt in unserem Fall zu einem zusätzlichen User-Action Eintrag,
hat aber darüber hinaus im UI-Modul keine weiteren Auswirkungen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Wird kein oder ein abgelaufener Token an das User-Service-Modul übermittelt,
so werden Requests nur vom Login- und Register-Entry-Point akzeptiert.
Soll das Verhalten mit einem abgelaufenen Token explizit getestet werden, so müssen wir den  <span class='latex-texttt'>TokenExpirationManager</span>  der CDI-Extension anpassen.
In Listing  <a href='#!idx:/cdi_micro.html:fig:test_token_expiration_manager'> TokenExpirationManager für Tests </a>  verwenden wir hierfür die Klasse  <span class='latex-texttt'>TestTokenExpirationManager</span> ,
die von  <span class='latex-texttt'>TokenExpirationManager</span>  ableitet, mit  <span class='latex-texttt'>@Specializes</span>  annotiert ist und nur im Test-Classpath verfügbar ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:test_token_expiration_manager'></a>                     <pre><code>@Specializes
public class TestTokenExpirationManager extends TokenExpirationManager {
  @Override
  public long getExpirationTimeInMilliSeconds() {
    expirationTimeInMilliSeconds = globalExpirationTimeInMilliSeconds;
    return super.getExpirationTimeInMilliSeconds();
  }
 
  public static int replaceExpirationTimeInMilliSeconds(
    int expirationTimeInMilliSeconds) {
      int oldValue = globalExpirationTimeInMilliSeconds;
      globalExpirationTimeInMilliSeconds = expirationTimeInMilliSeconds;
      initTokenRenewTimeframe();
      return oldValue;
  }
}
</code></pre>
                </div> Über die Methode  <span class='latex-texttt'>#replaceExpirationTimeInMilliSeconds</span>  wird in Listing  <a href='#!idx:/cdi_micro.html:fig:test_expired_token'> Abgelaufene Token testen </a>  die Gültigkeit des Tokens künstlich reduziert,
damit in der Methode  <span class='latex-texttt'>#forcedPause</span>  statt mehreren Minuten nur wenige Millisekunden gewartet werden muss,
bevor mit einem bewusst abgelaufenen Token weitergetestet werden kann.
Im konkreten Fall soll der Status  <span class='latex-texttt'>UNAUTHORIZED</span>  beim Aufruf eines JAX-RS Endpunkts an den Client zurückgesendet werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:test_expired_token'></a>                     <pre><code>@Test
public void updateUserDetailsAfterTokenExpiration() {
  int previousExpirationTime = TestTokenExpirationManager
    .replaceExpirationTimeInMilliSeconds(1);
 
  try {
    registerUser();
    String token = loginUser();
 
    forcedPause(10L);
 
    Response response = userTarget.request()
      .header(HttpHeaders.AUTHORIZATION, token)
      .buildPost(Entity.json(createTestUser())).invoke();

    Assert.assertNotNull(response);
    Assert.assertEquals(
      UNAUTHORIZED.getStatusCode(), response.getStatus());
  } finally {
    TestTokenExpirationManager
      .replaceExpirationTimeInMilliSeconds(previousExpirationTime);
  }
}
</code></pre>
                </div> Soll zusätzlich die autom. Tokenerneuerung getestet werden,
so müssen wir die Gültigkeitsdauer etwas erhöhen und
wie in Listing  <a href='#!idx:/cdi_micro.html:fig:test_token-renewal'> Tokenerneuerung testen </a>  nach dem ersten Request etwas kürzer als die Gültigkeitsdauer warten,
bevor wir den zweiten Request absetzen.
Von diesem bekommen wir einen neuen Token, mit dem ein dritter Request abgesetzt wird.
Warten wir zwischen dem zweiten und dritten Request wieder bis kurz vor Ablauf des Tokens,
dann sind wir klar über die Gültigkeitsdauer des ersten Tokens,
aber der neu ausgestellte Token ist noch gültig und somit muss auch dieser dritte Request erfolgreich verlaufen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:test_token-renewal'></a>                     <pre><code>@Test
public void renewToken() {
  int expirationTime = 3000;
  int previousExpirationTime = TestTokenExpirationManager
    .replaceExpirationTimeInMilliSeconds(expirationTime);
 
  try {
    registerUser();
    String token = loginUser();
 
    forcedPause(expirationTime - 1000L);
    String newToken = updateUserWithTokenUpdate(token);
    forcedPause(expirationTime - 1000L);
    Assert.assertNotEquals(token, newToken);
 
    User loadedUser = updateUser(newToken);
 
    Assert.assertNotNull(loadedUser);
  } finally {
    TestTokenExpirationManager
      .replaceExpirationTimeInMilliSeconds(previousExpirationTime);
  }
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.11' ><span class='entry-number'>8.11</span> Alles zu seiner Zeit</a> </h2>
 Als nächstes ist das Config-Service Modul an der Reihe.
Auch hier gibt es kaum einen Unterschied.
Die bisherige Funktionalität wird aus  <span class='latex-textit'>IdeaForkLite</span>  wieder übernommen und
mit einer JAX-RS Resource für andere Teile der Applikation verfügbar gemacht.
Allerdings ist die Initialisierung beim Start des Services etwas anders.
Zum einen haben wir in  <span class='latex-textit'>IdeaForkLite</span>  bereits eine eigene Config-Source dynamisch hinzugefügt,
um die Datenbank als zusätzliche Konfigurationsquelle zu verwenden und
wir haben im Falle vom Project-Stage  <span class='latex-texttt'>Development</span>  einen Konfigurationseintrag manuell erstellt.
Bisher haben wir uns hierfür ein JSF Add-on zu Nutze gemacht.
Unsere Service-Module können diesen Trick allerdings nicht mehr verwenden.
Glücklicherweise schafft hier CDI seit Version 1.1 selbst Abhilfe.
Listing  <a href='#!idx:/cdi_micro.html:fig:cdi-startup_event'> CDI 1.1 Container-Startup-Event </a>  zeigt, wie in der Klasse  <span class='latex-texttt'>IdeaForkConfigServiceStartupObserver</span>  eine Observer-Methode
mit dem vordefinierten Qualifier  <span class='latex-texttt'>@Initialized</span>  der Start des Application-Scopes überwacht werden kann.
Wie bei Observer-Methoden üblich sind zusätzliche Parameter optionale Injection-Points.
In unserem Fall lassen wir uns  <span class='latex-texttt'>DataBaseAwareConfigSource</span>  injizieren und
registrieren wie bisher diese zusätzliche Config-Source via  <span class='latex-texttt'>ConfigResolver#addConfigSources</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:cdi-startup_event'></a>                     <pre><code>@ApplicationScoped
public class IdeaForkConfigServiceStartupObserver {
  protected void onStartup(@Observes @Initialized(ApplicationScoped.class)
                           Object ideaForkStartedEvent,
                           DataBaseAwareConfigSource configSource) {
 
    ConfigResolver
      .addConfigSources(Arrays.&lt;ConfigSource&gt;asList(configSource));
  }
}
</code></pre>
                </div> Natürlich kann es für dieses Event mehrere Observer-Methoden geben.
So fügen wir in Listing  <a href='#!idx:/cdi_micro.html:fig:unordered_startup-event'> Ungeordnetes Container-Startup-Event </a>  einen weiteren Observer hinzu,
um einen Konfigurationswert abhängig vom Project-Stage dynamisch zu setzen.
Hierfür gibt es verschiedene Möglichkeiten.
Wir greifen auf das bereits vorgestellte  <span class='latex-texttt'>@Exclude</span>  zurück und
lassen uns zusätzlich  <span class='latex-texttt'>ConfigRepository</span>  als Parameter der Observer-Methode injizieren.
In der Observer-Methode selbst speichern wir folglich nur noch den Konfigurationseintrag mit Hilfe von  <span class='latex-texttt'>ConfigRepository</span>  in der Datenbank.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:unordered_startup-event'></a>                     <pre><code>@Exclude(exceptIfProjectStage = ProjectStage.Development.class)
@ApplicationScoped
public class DevIdeaForkConfigServiceStartupObserver {
  protected void onStartup(@Observes @Initialized(ApplicationScoped.class)
                           Object ideaForkStartedEvent,
                           ConfigRepository configRepository) {
 
    configRepository.save(
      new ConfigEntry("maxNumberOfHighestRatedCategories", "10"));
  }
}
</code></pre>
                </div> Haben wir mehrere Observer für das gleiche Event, wie es bei den eben gezeigten der Fall ist, so kann es sein, dass die Reihenfolge wichtig ist.
Wollen wir sicherstellen, dass die neue Config-Source hinzugefügt wird bevor in unserem Beispiel der Konfigurationswert gespeichert wird,
können wir eine neue Funktionalität von CDI 2.0 verwenden.
Mit der zusätzlichen Verwendung von  <span class='latex-texttt'>@javax.annotation.Priority</span>  lässt sich die Aufrufreihenfolge von Observer-Methoden steuern.
Listing  <a href='#!idx:/cdi_micro.html:fig:ordered_startup-event'> Geordnete Container-Startup-Events </a>  zeigt dies für unsere beiden Observer-Methoden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:ordered_startup-event'></a>                     <pre><code>protected void onStartup(
  @Observes @Initialized(ApplicationScoped.class) @Priority(1)
  Object ideaForkStartedEvent,
  DataBaseAwareConfigSource configSource) {
    //...
}

protected void onStartup(
  @Observes @Initialized(ApplicationScoped.class) @Priority(2)
  Object ideaForkStartedEvent,
  ConfigRepository configRepository) {
    //...
}
</code></pre>
                </div> Bevor wir das Config-Service verwenden können, übernehmen wir den Partial-Bean Ansatz aus  <span class='latex-textit'>IdeaForkLite</span> ,
mit dem wir typsichere Konfigurationen via  <span class='latex-texttt'>@TypedConfig</span>  umsetzen können.
Zusätzlich erweitern wir in Listing  <a href='#!idx:/cdi_micro.html:fig:improved_version_of_TypedConfig'> Erweiterung der Annotation TypedConfig </a>  die Annotation um das Annotation-Attribut  <span class='latex-textit'>remote</span> ,
um zwischen lokaler und zentraler Konfiguration unterscheiden zu können.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:improved_version_of_TypedConfig'></a>                     <pre><code>@PartialBeanBinding
@Retention(RUNTIME)
@Target(TYPE)
public @interface TypedConfig {
  boolean remote() default false;
}
</code></pre>
                </div> In der Klasse  <span class='latex-texttt'>TypedConfigHandler</span>  delegieren wir wie gehabt an den  <span class='latex-texttt'>ConfigResolver</span>  von DeltaSpike und
nur an den in Listing gezeigten Config-Service Client, wenn der Wert von  <span class='latex-texttt'>remote</span>  explizit auf  <span class='latex-texttt'>true</span>  gesetzt wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:'></a>                     <pre><code>@ResourceClient(name = "configs", version = "v1")
public interface ConfigService {
  @GET
  @Path("/{key}")
  String loadForKey(@PathParam("key") String key);
}
</code></pre>
                </div> Wie der Ausschnitt von Listing  <a href='#!idx:/cdi_micro.html:fig:typed_config-handler_with_remote-support'> Typisierter Config-Handler mit Remote-Support </a>  darstellt,
wird das  <span class='latex-texttt'>ConfigService</span> -Bean direkt injiziert.
Geladene Werte werden nach wie vor zeitlich begrenzt gecached.
Die entsprechende Funktionalität wurde ebenfalls aus  <span class='latex-textit'>IdeaForkLite</span>  übernommen.
Da sich dieses Modul selten bis gar nicht ändern würde,
könnten wir es auch außerhalb von  <span class='latex-textit'>IdeaForkLite</span>  halten und in  <span class='latex-textit'>IdeaForkLite</span>  nur als herkömmliche Dependency hinzufügen.
Damit wir diese Funktionalität trotzdem im gleichen Git-Repository ohne zusätzlichen Build-Schritt ablegen können,
importieren wir den gesamten typsicheren Konfigurationsmechanismus ausnahmsweise in ein eigenes Maven-Modul,
das von allen anderen Modulen verwendet werden darf.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:typed_config-handler_with_remote-support'></a>                     <pre><code>@TypedConfig
@ConfigScoped
@SuppressWarnings("unused")
public class TypedConfigHandler implements InvocationHandler {
  @Inject
  private ConfigService configService;
 
  private Map&lt;String, Object&gt; loadedValues =
    new ConcurrentHashMap&lt;String, Object&gt;();
 
  public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {
      String key = method.getName();
      Object result = loadedValues.get(key);
 
      if (result != null) {
        return result;
      }
 
      String loadedValue = null;
 
      TypedConfig typedConfig =
        proxy.getClass().getAnnotation(TypedConfig.class);
      if (typedConfig != null && typedConfig.remote()) {
        loadedValue = configService.loadForKey(key);
      }
 
      if (loadedValue == null) {
        loadedValue = ConfigResolver
          .getProjectStageAwarePropertyValue(key);
      }
      final Class&lt;?&gt; configType = method.getReturnType();
      result = parseValue(loadedValue, configType);
 
      loadedValues.put(key, result);
      return result;
  }
 
  //...
}
</code></pre>
                </div> Das letzte zu erstellende Backend-Modul ist das Idea-Modul.
Wie gehabt importieren wir die Funktionalität von  <span class='latex-textit'>IdeaForkLite</span>  und können große Teile unverändert übernehmen.
Bei der typsicheren Konfiguration gibt es die erste Anpassung.
Wir fügen die typsichere Konfiguration namens  <span class='latex-texttt'>IdeaConfig</span>  aus Listing  <a href='#!idx:/cdi_micro.html:fig:typed_config_as_partial-bean'> Typsichere Konfiguration als Partial-Bean </a>  hinzu und
legen das Attribute  <span class='latex-textit'>remote</span>  mit  <span class='latex-texttt'>true</span>  fest.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:typed_config_as_partial-bean'></a>                     <pre><code>@TypedConfig(remote = true)
public interface IdeaConfig {
  Integer maxNumberOfHighestRatedCategories();
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:typed-config_usage'> Verwendung der typisierten Konfiguration </a>  zeigt, dass es bei der Verwendung keinen Unterschied gibt.
 <span class='latex-texttt'>IdeaConfig</span>  wird injiziert und
durch den Aufruf von  <span class='latex-texttt'>IdeaConfig#maxNumberOfHighestRatedCategories</span>  wird der Konfigurationswert für den Key
 <span class='latex-texttt'>maxNumberOfHighestRatedCategories</span>  geladen.
Wie bereits beschrieben wird in diesem Beispiel im Hintergrund zuerst der JAX-RS Endpunkt des Config-Service Moduls abgefragt und
erst wenn dieser keinen Wert liefert, werden die anderen Config-Sources befragt.
Wir könnten das Partial-Bean  <span class='latex-texttt'>ConfigService</span>  auch direkt via Config-Source einbinden.
Allerdings würde dann jeder Config-Lookup eine Remote-Abfrage auslösen.
Aus diesem Grund bleiben wir bei dem zuvor beschriebenen zweistufigen Vorgehen in  <span class='latex-texttt'>TypedConfigHandler</span> .<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:typed-config_usage'></a>                     <pre><code>@AuthenticationRequired
@Path("categories")
 
@ApplicationScoped
public class CategoryResource {
  @Inject
  private IdeaRepository ideaRepository;
 
  @Inject
  private IdeaConfig ideaConfig;
 
  @GET
  @Path("top")
  public List&lt;CategoryView&gt; getHighestRatedCategories() {
    List&lt;CategoryView&gt; result = ideaRepository.getHighestRatedCategories(
      ideaConfig.maxNumberOfHighestRatedCategories());
    return result;
  }
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:adjusted_IdeaRepository'> Angepasstes IdeaRepository </a>  zeigt die dazugehörigen Anpassungen und Vereinfachungen in der Klasse  <span class='latex-texttt'>IdeaRepository</span> .
Hier wird auch deutlich, warum in  <span class='latex-textit'>IdeaForkMicro</span>  der konfigurierte Wert nicht in  <span class='latex-texttt'>IdeaRepository</span>  selbst geladen wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:adjusted_IdeaRepository'></a>                     <pre><code>@Transactional(qualifier = Default.class)
@Repository
public interface IdeaRepository extends EntityRepository&lt;Idea, String&gt; {
  @Query("select i from Idea i where i.authorEmail = ?1")
  List&lt;Idea&gt; loadAllOfAuthor(String email);

  @Query("select new at.irian.cdiatwork.ideafork.idea.domain.CategoryView(
    i.category, count(i.category)) from Idea i group by i.category
    order by count(i.category) desc")
  List&lt;CategoryView&gt; getHighestRatedCategories(
    @MaxResults int maxNumberOfHighestRatedCategories);

  @Query("select i from Idea i where i.topic like CONCAT('', ?1, '') or
    i.category like CONCAT('', ?1, '')")
  List&lt;Idea&gt; search(String searchText);
}
</code></pre>
                </div><h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.12' ><span class='entry-number'>8.12</span> Zusammenführung</a> </h2>
 Im UI-Modul von  <span class='latex-textit'>IdeaForkMicro</span>  sind nur wenige Änderungen zwingend erforderlich.
An diesem Punkt sind im Git-Repository sämtliche REST-Endpunkte implementiert.
Hierzu zählt auch  <span class='latex-texttt'>CategoryResource</span> . Die Implementierungsdetails sind an dieser Stelle nicht relevant.
Sobald wir wissen, dass wir Kategorien über den Pfad "/categories/v1/top" abfragen können,
ist die Anbindung dieses Remote-Services, wie in Listing  <a href='#!idx:/cdi_micro.html:fig:rest-client_as_partial-bean_ui'> REST-Resource Client als Partial-Bean im UI </a>  dargestellt,
äquivalent zu den bisherigen Umsetzungen.
Die hier zusätzlich verwendete Annotation  <span class='latex-texttt'>@TypedCollection</span> wird ebenfalls von der Remote-Access-Lite Erweiterung zur Verfügung gestellt und
dient im Hintergrund während des Einlesens des JSON-Strings als Zusatzinformation für den  <span class='latex-texttt'>ObjectMapper</span>  von Jackson.
Alle anderen Annotationen haben wir bereits kennengelernt oder sind Standardannotationen von JAX-RS.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:rest-client_as_partial-bean_ui'></a>                     <pre><code>@ResourceClient(name = "categories", version = "v1")
public interface CategoryService {
  @GET
  @Path("/top")
  @TypedCollection(Category.class)
  List&lt;Category&gt; getHighestRatedCategories();
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:using_partial-bean_CategoryService'> Anbindung von CategoryService </a>  veranschaulicht die Verwendung von  <span class='latex-texttt'>CategoryService</span>  in  <span class='latex-texttt'>IndexViewCtrl</span> .
Ebenfalls neu in Listing  <a href='#!idx:/cdi_micro.html:fig:using_partial-bean_CategoryService'> Anbindung von CategoryService </a>  ist die Verwendung von  <span class='latex-texttt'>JsfIdentityHolder</span> ,
der den bisherigen  <span class='latex-texttt'>ActiveUserHolder</span>  ersetzt.
Hierbei handelt es sich um eine spezialisierte Variante von  <span class='latex-texttt'>IdentityHolder</span> ,
die im Session-Scope abgelegt ist und durch  <span class='latex-texttt'>@Named</span>  auch für EL-Expressions verfügbar ist.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:using_partial-bean_CategoryService'></a>                     <pre><code>@ViewController
public class IndexViewCtrl implements Serializable {
  @Inject
  private IdeaPromotionService ideaPromotionService;
 
  @Inject
  private CategoryService categoryService;
 
  @Inject
  private JsfIdentityHolder identityHolder;
 
  private List&lt;Category&gt; categories;
  private int categoryCount;
 
  private List&lt;Idea&gt; promotedIdeas;
  private int promotedIdeaCount;
 
  @PreRenderView
  public void onPreRenderView() {
    if (identityHolder.isAuthenticated()) {
      promotedIdeas = Optional
        .ofNullable(ideaPromotionService.loadRecentlyPromotedIdeas())
        .orElse(emptyList());
      categories = Optional
        .ofNullable(categoryService.loadHighestRatedCategories())
        .orElse(emptyList());

      categoryCount = categories.size();
      promotedIdeaCount = promotedIdeas.size();
    }
  }
 
  //...
}
</code></pre>
                </div> Listing  <a href='#!idx:/cdi_micro.html:fig:ui_specific_partial-bean_holder'> UI spezifischer IdentityHolder </a>  verdeutlicht
neben der Umsetzung von  <span class='latex-texttt'>JsfIdentityHolder</span>  auch die Signalisierung eines User-Logouts,
der automatisch durch ein Session-Timeout oder manuell ausgelöst wird.
Ein manueller Logout führt zum Reset des Tokens.
In  <span class='latex-textit'>IdeaForkMicro</span>  ist  <span class='latex-texttt'>JsfIdentityHolder</span>  die einzige Session-Scoped Instanz,
die bei einem manuellen Logout bis zum Session-Timeout weiter existiert, jedoch vollkommen leer ist und somit kaum Speicher beansprucht.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:ui_specific_partial-bean_holder'></a>                     <pre><code>@Named("identityHolder")
@Specializes
@SessionScoped
public class JsfIdentityHolder extends IdentityHolder
  implements Serializable {
    private boolean logoutSent = false;
 
    public boolean isAuthenticated() {
      return getCurrentToken() != null;
    }
 
    @Inject
    private UserActionService.LogoutService logoutService;
 
    @PreDestroy
    protected void onTimeout() {
      onLogout(false);
    }
 
    @Override
    public void setCurrentToken(String currentToken) {
      super.setCurrentToken(currentToken);
      this.logoutSent = false;
    }
 
    public void onLogout(boolean manualLogout) {
      try {
        if (logoutSent) {
          return;
        }
 
        if (manualLogout) {
          logoutService.logout("LOGOUT");
        } else {
          logoutService.logout("AUTO_LOGOUT");
        }
      } finally {
        logoutSent = true;
        reset();
      }
    }
}
</code></pre>
                </div> In Listing  <a href='#!idx:/cdi_micro.html:fig:nested_partial-bean'> Nested Partial-Bean </a>  ist ersichtlich,
dass es sich auch bei  <span class='latex-texttt'>UserActionService.LogoutService#logout</span>  um eine Partial-Bean Methode handelt,
die von der Remote-Access-Lite Erweiterung an den entsprechenden JAX-RS Endpunkt des User-Service Moduls weitergeleitet wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:nested_partial-bean'></a>                     <pre><code>public interface UserActionService {
  @ResourceClient(name = "user-action", version = "v1")
  interface LoginService {
    @POST
    @Path("/login")
    void login(User user);
  }

  @ResourceClient(name = "user-action", version = "v1")
  interface LogoutService {
    @POST
    @Path("/logout")
    void logout(@QueryParam("type") String logoutType);
  }

  @ResourceClient(name = "user-action", version = "v1")
  interface UserStatsService {
    @GET
    ProfileActivity loadLatestActivities();
  }
}
</code></pre>
                </div> Ein manueller Logout wird in  <span class='latex-textit'>IdeaForkMicro</span>  durch den  <span class='latex-texttt'>MenuController</span>  angestoßen.
Listing  <a href='#!idx:/cdi_micro.html:fig:controller_for_manual_logout'> UI-Controller für manuellen Logout </a>  veranschaulicht den entsprechenden Ausschnitt.
Nachdem der User-Logout an das Backend signalisiert wurde, werden sämtliche serverseitigen Fenster in der betreffenden Session geschlossen.
Bei einem Session-Timeout geschieht dies automatisch und muss daher nicht explizit berücksichtigt werden.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:controller_for_manual_logout'></a>                     <pre><code>@Named("menuBean")
@Model
public class MenuController {
  @Inject
  private JsfIdentityHolder identityHolder;
 
  @Inject
  private WindowContext windowContext;
 
  public Class&lt;? extends ViewConfig&gt; logout() {
    try {
      identityHolder.onLogout(true);
    } finally {
      resetWindowContext();
    }
    return Pages.User.Login.class;
  }
 
  private void resetWindowContext() {
    String currentWindowId = windowContext.getCurrentWindowId();
    windowContext.closeWindow(currentWindowId);
    windowContext.activateWindow(currentWindowId);
  }

  //...
}
</code></pre>
                </div> Die verbleibenden Änderungen im UI-Modul sind in einem Commit im Git-Repository von  <span class='latex-textit'>IdeaForkMicro</span>  zusammengefasst und
größtenteils äquivalent zu der eben vorgestellten Integration der Backend-Module.
Sämtliche Änderungen sind so ausgelegt, dass sich die XHTML-Seiten nahezu nicht geändert haben und
die View-Controller ebenfalls nahezu identisch sind.
Primär haben sich in manchen Fällen Properties geändert, falls Properties im JSON-Response anders benannt sind.
Außerdem wurde, wie bereits erwähnt,  <span class='latex-texttt'>activeUserHolder</span>  auf den neuen  <span class='latex-texttt'>identityHolder</span>  umgestellt.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.13' ><span class='entry-number'>8.13</span> Kein Vorteil ohne Nachteil</a> </h2>
 Durch die Aufteilung in unabhängige Module hat sich allerdings noch ein kleiner Nachteil eingeschlichen.
Die Verwendung von Bean-Validation Constraints über Layergrenzen hinweg ist ohne geteilten Code nicht mehr möglich.
Möchten wir beispielsweise eine neue Instanz von  <span class='latex-texttt'>Idea</span>  validieren, so müssen wir dies im UI-Modul umsetzen.
Listing  <a href='#!idx:/cdi_micro.html:fig:ui-validation_via_bv-constraints'> UI-Validierung mit Bean-Validation Constraints </a>  zeigt stellvertretend einen Ausschnitt aus der  <span class='latex-texttt'>Idea</span> -Klasse des UI-Moduls.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cdi_micro.html:fig:ui-validation_via_bv-constraints'></a>                     <pre><code>public class Idea {
  private String id;
 
  @NotNull
  @Size(min = 1, max = 64)
  private String topic;
 
  @NotNull
  @Size(min = 1, max = 64)
  private String category;
 
  private String description;
  private String baseIdeaId;

  //...
}
</code></pre>
                </div> Instanzen von  <span class='latex-texttt'>Idea</span>  werden wie gehabt durch JSF autom. validiert.
Im Idea-Service Modul sollten wir aber zumindest eine minimale Validierung wiederholen.
Statt dem manuellen  <span class='latex-texttt'>IdeaValidator</span>  möchten wir auch hier Bean-Validation Constraints verwenden.
Daher erweitern wir das JPA-Entity  <span class='latex-texttt'>Idea</span> , nicht zu verwechseln mit der gleichnamigen Klasse im UI-Modul,
um die entsprechenden Constraints.
Außerdem müssen wir in der Datei  <span class='latex-texttt'>persistence.xml</span>  des Service-Moduls den  <span class='latex-texttt'>validation-mode</span>  namens  <span class='latex-texttt'>CALLBACK</span>  aktivieren.
Dies stellt sicher, dass der JPA-Provider vor der Persistierung Entities durch den Bean-Validation-Provider validieren lässt und erst speichert,
wenn keine Constraint-Violations gefunden wurden.
Hiermit ist beispielsweise zusätzlich sichergestellt,
dass in unserem Fall auch importierte  <span class='latex-texttt'>Idea</span> -Instanzen einer rudimentären Überprüfung unterzogen werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Ein weiterer Nachteil ergibt sich beim  <span class='latex-texttt'>@UniqueUser</span> -Constraint.
Der bisher verwendete Constraint-Validator führt für die UI-Validierung eine Datenbankabfrage aus.
In  <span class='latex-textit'>IdeaForkMicro</span>  würde dies bedeuten, dass wir für die UI-Validierung einen Remote-Aufruf an das User-Service Modul benötigen würden.
Aus diesem Grund verzichten wir in  <span class='latex-textit'>IdeaForkMicro</span>  auf dieses Constraint.
In der aktuellen Version im Git-Repository von  <span class='latex-textit'>IdeaForkMicro</span> meldet in einem solchen Fall die REST-Ressource den Statuscode HTTP 409 ("Conflict") an das UI-Modul zurück.
Darüber hinaus beschränken wir uns auf die Ausgabe einer einfachen Fehlermeldung,
die auch bei anderen Registrierungsfehlern angezeigt wird.
Soll hingegen eine detaillierte Fehlermeldung ausgegeben werden,
so müssten wir unterschiedliche Error-Codes verwenden oder
das Idea-Service Modul müsste die Fehlerbeschreibung als validen Response zurückliefern.
Auch hier zeigt sich, dass sich die Komplexität von  <span class='latex-textit'>IdeaForkMicro</span>  im Vergleich zu  <span class='latex-textit'>IdeaForkLite</span>  etwas erhöht hat.<br /> <h2><a class='latex-index-anchor' name='!idx:/cdi_micro.html:8.14' ><span class='entry-number'>8.14</span> Der Weg ist das Ziel</a> </h2>
 In diesem Kapitel haben wir gesehen, wie einfach CDI-basierte Applikationen in unabhängige Services aufgeteilt werden können.
Selbst Themen wie "Service Discovery",
die aktuell weder Bestandteil von CDI noch Java EE sind, können mit Hilfe einer CDI-Extension einfach nachgerüstet werden.
Die zusätzliche Komplexität, die wir im Laufe des Kapitels gesehen haben und
auch weiterführende Themen wie die Nutzung von Containerlösungen (wie beispielsweise Docker),
die Umsetzung von weiteren Infrastrukturbestandteilen (wie beispielsweise Build-Pipelines),
spezielles Monitoring (beispielsweise in Verbindung mit einem Circuit-Breaker Mechanismus) und
einiger anderer Themen sind unabhängig von CDI und werden aktuell hauptsächlich durch proprietäre Projekte zur Verfügung gestellt.
Der Weg zu einer Applikation, die all diese Aspekte abdeckt, ist somit noch etwas länger und
das Ziel mit Java EE derzeit nur mit zusätzlichen Erweiterungen erreichbar.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div style="background:#e8f5e9; border-left:4px solid #43a047; border-radius:0 8px 8px 0; padding:0.8em 1.2em; margin:1em 0; font-size:0.93em; color:#2e7d32;"><b>[CDI@Work]:AI: </b> Seit der Erstveröffentlichung dieses Kapitels hat sich die Micro-Deployment-Landschaft grundlegend gewandelt. MicroProfile hat sich als offizieller Standard etabliert und wird von Runtimes wie Quarkus, Open Liberty und Helidon nativ unterstützt. Meecrowave und WildFly Swarm, die in diesem Kapitel verwendet werden, wurden durch ihre Nachfolger abgelöst – Meecrowave ist Teil des Apache-Ökosystems geblieben, während WildFly Swarm in WildFly Bootable JAR aufgegangen ist. Quarkus hat sich als führende Runtime für CDI-basierte Microservices etabliert und wird in Kapitel <a href='#!idx:/quarkus.html:10' style='color:#2e7d32;'>10</a> behandelt. Auch die Service-Discovery-Thematik hat sich durch Kubernetes und Container-Orchestrierung weitgehend gelöst. Die in diesem Kapitel vorgestellten CDI-Integrationsmuster – insbesondere Partial-Beans für Remote-Clients und die CDI/Spring-Bridge – bleiben jedoch als Architekturansätze relevant.</div>
<div class="tip"><b>Tipp: </b><b>Wie geht es weiter?</b> <span class='latex-textit'>IdeaForkMicro</span> hat gezeigt, dass CDI-basierte Microservices außerhalb eines Application Servers funktionieren. Kapitel <a href='#!idx:/upgrade.html:9'>9</a> behandelt die Migration von Java EE zu Jakarta EE, Kapitel <a href='#!idx:/quarkus.html:10'>10</a> zeigt den Wechsel zu Quarkus mit Build-Zeit-Optimierung und nativen Images, und Kapitel <a href='#!idx:/angular.html:11'>11</a> ersetzt das JSF-Frontend durch eine Angular-SPA. Zusammen bilden diese Kapitel den vollständigen Modernisierungspfad.</div>
</section>
<section class="chapter-section" id="chapter-9">
<h1> <a class='latex-index-anchor' name='!idx:/upgrade.html:9'><span class='entry-number'>9</span> Von Java EE zu Jakarta EE</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Dieses Kapitel wurde von Claude (AI built by Anthropic) auf Basis der vorherigen Kapitel verfasst. Es beschreibt die Weiterentwicklung von CDI und Jakarta EE seit der Erstveröffentlichung dieses Buches. Die Codebeispiele orientieren sich an IdeaFork, wurden jedoch an die aktuellen Spezifikationen angepasst.
</div>
<a name = '!idx:/upgrade.html:chap:javaee-to-jakartaee'> </a><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.1'><span class='entry-number'>9.1</span> Ein neues Kapitel</a> </h2>
 In den bisherigen Kapiteln haben wir CDI 1.0 bis 2.0 im Kontext von Java EE 6 und Java EE 7 kennengelernt.
Wir haben gesehen wie <span class='latex-textit'>IdeaFork</span> Schritt für Schritt mit den Grundkonzepten von CDI,
portablen Erweiterungen und Apache DeltaSpike umgesetzt werden kann.
Seit der Erstveröffentlichung dieses Buches hat sich das Java-EE-Ökosystem jedoch grundlegend verändert.
Die Plattform wurde an die Eclipse Foundation übergeben und trägt seither den Namen Jakarta EE.
CDI ist mittlerweile in Version 4.1 angekommen und Teil von Jakarta EE 11.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In diesem Kapitel begleiten wir die Migration von <span class='latex-textit'>IdeaFork</span> von Java EE zu Jakarta EE.
Wir betrachten die wichtigsten Änderungen in CDI 3.0, 4.0 und 4.1 und zeigen auf,
welche Auswirkungen diese auf bestehende Projekte haben.
Dabei konzentrieren wir uns auf die Aspekte, die für die tägliche Arbeit mit CDI am relevantesten sind.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die Migration von Java EE zu Jakarta EE ist für viele Projekte ein notwendiger Schritt,
da Java EE 8 die letzte Version unter dem alten Namensraum war.
Neue Funktionalitäten und Bugfixes werden ausschließlich im Jakarta-EE-Namensraum weiterentwickelt.
Wer langfristig von Verbesserungen in CDI und anderen Spezifikationen profitieren möchte,
kommt an einer Migration nicht vorbei.<br /> <h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.2'><span class='entry-number'>9.2</span> Von javax zu jakarta</a> </h2>
 Die wohl offensichtlichste Änderung bei der Migration zu Jakarta EE 9 und höher ist der Wechsel des Paketnamens
von <span class='latex-texttt'>javax</span> zu <span class='latex-texttt'>jakarta</span>.
Dieser Wechsel war notwendig, da Oracle den <span class='latex-texttt'>javax</span>-Namensraum bei der Übergabe an die Eclipse Foundation nicht freigegeben hat.
Für CDI bedeutet dies, dass ab CDI 3.0 sämtliche Imports angepasst werden müssen.
Dies betrifft nicht nur CDI-spezifische Annotationen, sondern alle Java-EE-APIs,
die in einer Applikation verwendet werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Sehen wir uns die Auswirkungen auf <span class='latex-textit'>IdeaFork</span> anhand eines konkreten Beispiels an.
Listing <a href='#!idx:/upgrade.html:fig:javax-to-jakarta-before'> IdeaManager mit javax-Imports </a> zeigt die bisherige Version unserer <span class='latex-texttt'>IdeaManager</span>-Klasse
mit den klassischen <span class='latex-texttt'>javax</span>-Imports.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:javax-to-jakarta-before'></a>                     <pre><code>import javax.inject.Inject;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Event;

@ApplicationScoped
public class IdeaManager {
    @Inject
    private IdeaRepository ideaRepository;

    @Inject
    private Event&lt;IdeaChangedEvent&gt; ideaChangedEvent;

    public Idea createIdea(Idea idea) {
        Idea savedIdea = ideaRepository.save(idea);
        ideaChangedEvent.fire(new IdeaChangedEvent(savedIdea));
        return savedIdea;
    }

    //...
}
</code></pre>
                </div>
Listing <a href='#!idx:/upgrade.html:fig:javax-to-jakarta-after'> IdeaManager mit jakarta-Imports </a> zeigt die aktualisierte Version mit den neuen <span class='latex-texttt'>jakarta</span>-Imports.
Wie ersichtlich ist, ändert sich ausschließlich der Paketname in den Import-Anweisungen.
Der restliche Code bleibt vollständig identisch.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:javax-to-jakarta-after'></a>                     <pre><code>import jakarta.inject.Inject;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Event;

@ApplicationScoped
public class IdeaManager {
    @Inject
    private IdeaRepository ideaRepository;

    @Inject
    private Event&lt;IdeaChangedEvent&gt; ideaChangedEvent;

    public Idea createIdea(Idea idea) {
        Idea savedIdea = ideaRepository.save(idea);
        ideaChangedEvent.fire(new IdeaChangedEvent(savedIdea));
        return savedIdea;
    }

    //...
}
</code></pre>
                </div>
Neben den Java-Imports muss auch die Konfigurationsdatei <span class='latex-texttt'>beans.xml</span> angepasst werden.
Der XML-Namensraum und die Schema-Location ändern sich entsprechend.
Listing <a href='#!idx:/upgrade.html:fig:beans-xml-before'> beans.xml mit javax-Namensraum </a> zeigt die bisherige Version.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:beans-xml-before'></a>                     <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
           http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd"
       bean-discovery-mode="all"
       version="2.0"&gt;

    &lt;interceptors&gt;
        &lt;class&gt;at.irian.cdiatwork.ideafork.core.impl.MonitorInterceptor&lt;/class&gt;
    &lt;/interceptors&gt;
&lt;/beans&gt;
</code></pre>
                </div>
Listing <a href='#!idx:/upgrade.html:fig:beans-xml-after'> beans.xml mit jakarta-Namensraum </a> zeigt die aktualisierte Version für Jakarta EE.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:beans-xml-after'></a>                     <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="https://jakarta.ee/xml/ns/jakartaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee
           https://jakarta.ee/xml/ns/jakartaee/beans_4_0.xsd"
       bean-discovery-mode="annotated"
       version="4.0"&gt;

    &lt;interceptors&gt;
        &lt;class&gt;at.irian.cdiatwork.ideafork.core.impl.MonitorInterceptor&lt;/class&gt;
    &lt;/interceptors&gt;
&lt;/beans&gt;
</code></pre>
                </div>
Der dritte Bereich, der von der Namespace-Migration betroffen ist, sind die Maven-Koordinaten.
Die CDI-API wird unter neuen Koordinaten veröffentlicht.
Listing <a href='#!idx:/upgrade.html:fig:maven-dependency-before'> Maven-Dependency mit javax-Koordinaten </a> zeigt die bisherige Dependency.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:maven-dependency-before'></a>                     <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.enterprise&lt;/groupId&gt;
    &lt;artifactId&gt;cdi-api&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div>
Listing <a href='#!idx:/upgrade.html:fig:maven-dependency-after'> Maven-Dependency mit jakarta-Koordinaten </a> zeigt die aktualisierte Dependency für CDI 4.1.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:maven-dependency-after'></a>                     <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;jakarta.enterprise&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.enterprise.cdi-api&lt;/artifactId&gt;
    &lt;version&gt;4.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Es gibt Tools wie den Eclipse Transformer, die den Migrationsprozess automatisieren können. Für kleinere Projekte wie <span class='latex-textit'>IdeaFork</span> ist eine manuelle Migration jedoch oft effizienter. Der Eclipse Transformer kann insbesondere bei größeren Projekten mit vielen Modulen und Abhängigkeiten hilfreich sein, da er sowohl Quellcode als auch Binärdateien transformieren kann.</div>
<div class="tip"><b>Tipp: </b><b>Automatisierte Migrations-Werkzeuge:</b> Für die <span class='latex-texttt'>javax</span> &rarr; <span class='latex-texttt'>jakarta</span>-Migration stehen automatisierte Tools zur Verfügung:<br />
&bull; <b>Eclipse Transformer:</b> Transformiert Bytecode, Quellcode und Konfigurationsdateien. Aufruf: <span class='latex-texttt'>java -jar transformer.jar input.war output.war</span><br />
&bull; <b>OpenRewrite:</b> Maven-Plugin für automatisiertes Refactoring: <span class='latex-texttt'>mvn rewrite:run -Drewrite.activeRecipes=org.openrewrite.java.migrate.jakarta.JavaxMigrationToJakarta</span><br />
&bull; <b>IntelliJ Migration Tool:</b> Refactor &rarr; Migrate Packages and Classes (ab IntelliJ 2021.3)<br />
Für große Projekte wie <span class='latex-textit'>IdeaFork</span> empfiehlt sich eine Kombination: Automatische Migration mit anschließender manueller Prüfung der <span class='latex-texttt'>beans.xml</span>-Schema-Versionen und CDI-spezifischer Konfigurationen.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.3'><span class='entry-number'>9.3</span> CDI Lite und CDI Full</a> </h2>
 Mit CDI 4.0, das als Teil von Jakarta EE 10 veröffentlicht wurde, wurde eine grundlegende architektonische Aufteilung eingeführt.
Die Spezifikation wurde formal in zwei Teile aufgeteilt: CDI Lite und CDI Full.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> An dieser Stelle ist eine wichtige Klarstellung erforderlich.
Im Kapitel <a href='#!idx:/cdi_lite.html:chap:cdi_lite'> CDI Lite </a> dieses Buches haben wir einen leichtgewichtigen Ansatz bei der Entwicklung von CDI-Applikationen beschrieben.
Dort ging es darum, die Implementierung von <span class='latex-textit'>IdeaFork</span> zu vereinfachen,
indem wir nur die tatsächlich benötigten CDI-Konzepte behalten und unnötige Abstraktionen entfernen.
Die CDI-Lite-Spezifikation ab CDI 4.0 hingegen definiert etwas grundsätzlich anderes:
ein formal spezifiziertes Subset der CDI-API, das speziell für die Build-Time-Kompilierung optimiert ist.
Trotz der identischen Bezeichnung handelt es sich um zwei verschiedene Konzepte.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI Lite umfasst den Kernbereich der CDI-Funktionalität und ist so konzipiert,
dass er auch in Umgebungen verwendet werden kann, die keine vollständige Java-EE-Laufzeit benötigen.
Insbesondere ermöglicht CDI Lite die Verarbeitung von CDI-Metadaten zur Build-Zeit.
Frameworks wie Quarkus nutzen diesen Ansatz, um die Startzeit von Applikationen drastisch zu reduzieren,
indem aufwändige Reflection-basierte Operationen bereits während des Build-Prozesses durchgeführt werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI Lite beinhaltet folgende Kernfunktionalitäten:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
- <span class='latex-texttt'>@Inject</span> und <span class='latex-texttt'>@Produces</span> für Dependency-Injection und Producer-Methoden<br />
- <span class='latex-texttt'>@Observes</span> und <span class='latex-texttt'>@ObservesAsync</span> für synchrone und asynchrone Events<br />
- Scopes: <span class='latex-texttt'>@RequestScoped</span>, <span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@Dependent</span> und <span class='latex-texttt'>@Singleton</span><br />
- Qualifier und Stereotypen<br />
- Interceptoren mit <span class='latex-texttt'>@AroundInvoke</span> und <span class='latex-texttt'>@AroundConstruct</span><br />
- Build Compatible Extensions (neu ab CDI 4.0)<br />
- Programmatischer Bean-Lookup via <span class='latex-texttt'>Instance&lt;T&gt;</span><br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI Full erweitert CDI Lite um die folgenden Funktionalitäten:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
- Decoratoren mit <span class='latex-texttt'>@Decorated</span> und <span class='latex-texttt'>@Delegate</span><br />
- <span class='latex-texttt'>@Specializes</span> für die Spezialisierung von Beans<br />
- <span class='latex-texttt'>@ConversationScoped</span> und <span class='latex-texttt'>@SessionScoped</span><br />
- Portable Extensions (das klassische <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span>-Interface)<br />
- Passivierung und passivierungsfähige Scopes<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Für <span class='latex-textit'>IdeaFork</span> bedeutet diese Aufteilung, dass einige der in den bisherigen Kapiteln verwendeten Funktionalitäten CDI Full erfordern.
Hierzu zählen insbesondere die Decoratoren, die wir im Kapitel <a href='#!idx:/java_ee.html:chap:cdi-java_ee'> CDI und Java EE </a> für die Repository-Erweiterung eingesetzt haben,
sowie die Spezialisierung von Beans aus dem Kapitel <a href='#!idx:/basics.html:chap:cdi-basics'> CDI-Grundlagen </a>.
Auch der Conversation-Scope, den wir in <span class='latex-textit'>IdeaFork</span> verwendet haben, ist ein CDI-Full-Feature.
Wird <span class='latex-textit'>IdeaFork</span> auf einem vollwertigen Jakarta-EE-Server deployed, stehen alle diese Funktionalitäten weiterhin zur Verfügung.
Soll die Applikation hingegen in einer reinen CDI-Lite-Umgebung betrieben werden,
müssen die entsprechenden Stellen angepasst werden.
Die im Kapitel <a href='#!idx:/cdi_lite.html:chap:cdi_lite'> CDI Lite </a> bereits durchgeführten Vereinfachungen,
wie der Wechsel von Decoratoren zu Interceptoren, erleichtern eine solche Migration erheblich.<br /> <div class="tip"><b>Tipp: </b>Die Bezeichnung "CDI Lite" in diesem Buch (Kapitel 6) bezieht sich auf einen leichtgewichtigen Ansatz bei der Entwicklung von CDI-Applikationen. Die CDI-Lite-Spezifikation ab CDI 4.0 hingegen definiert ein Subset der CDI-API, das für die Build-Time-Kompilierung optimiert ist. Trotz der gleichen Bezeichnung handelt es sich um unterschiedliche Konzepte.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.4'><span class='entry-number'>9.4</span> Build Compatible Extensions</a> </h2>
 Im Kapitel <a href='#!idx:/extensions.html:chap:cdi-extensions'> Portable CDI-Erweiterungen </a> haben wir den Lifecycle von CDI und
die Implementierung portabler Erweiterungen auf Basis des <span class='latex-texttt'>Extension</span>-Interfaces kennengelernt.
Diese klassischen Portable Extensions funktionieren weiterhin in CDI Full.
Mit CDI 4.0 wurde jedoch ein neues Extension-Modell eingeführt:
die Build Compatible Extensions. Diese sind sowohl in CDI Lite als auch in CDI Full verfügbar und
bieten eine deutlich einfachere API als die bisherigen Portable Extensions.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der wesentliche Unterschied liegt in der Ausführungszeit.
Portable Extensions laufen ausschließlich zur Laufzeit, da sie direkt mit dem CDI-Container interagieren.
Build Compatible Extensions hingegen sind so konzipiert, dass sie auch zur Build-Zeit ausgeführt werden können.
In einer traditionellen Laufzeitumgebung werden sie durch die CDI-Implementierung zur Laufzeit emuliert.
In einer Build-Time-Umgebung wie Quarkus werden sie bereits während des Build-Prozesses ausgeführt,
wodurch die Startzeit der Applikation deutlich reduziert wird.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Build Compatible Extensions definieren fünf Phasen, die durch Annotationen auf Methoden ausgedrückt werden:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
- <span class='latex-texttt'>@Discovery</span>: Ermöglicht das Registrieren zusätzlicher Typen und Bean-Klassen, bevor der Bean-Discovery-Prozess beginnt.<br />
- <span class='latex-texttt'>@Enhancement</span>: Erlaubt die Modifikation von Annotationen auf bestehenden Bean-Klassen, vergleichbar mit <span class='latex-texttt'>ProcessAnnotatedType</span>.<br />
- <span class='latex-texttt'>@Registration</span>: Wird nach der Bean-Registrierung aufgerufen und ermöglicht die Inspektion registrierter Beans.<br />
- <span class='latex-texttt'>@Synthesis</span>: Erlaubt das programmatische Hinzufügen synthetischer Beans und Observer, vergleichbar mit <span class='latex-texttt'>AfterBeanDiscovery</span>.<br />
- <span class='latex-texttt'>@Validation</span>: Die letzte Phase, in der die gesamte Bean-Konfiguration validiert werden kann.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Zur Veranschaulichung migrieren wir die <span class='latex-texttt'>EntityVetoExtension</span> aus dem Kapitel <a href='#!idx:/extensions.html:chap:cdi-extensions'> Portable CDI-Erweiterungen </a>.
Zur Erinnerung: diese Extension sorgt dafür, dass JPA-Entitäten nicht als CDI-Beans registriert werden.
Listing <a href='#!idx:/upgrade.html:fig:portable-extension-original'> Originale EntityVetoExtension als Portable Extension </a> zeigt die bisherige Implementierung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:portable-extension-original'></a>                     <pre><code>public class EntityVetoExtension implements Extension {
    public void vetoEntities(
            @Observes @WithAnnotations({Entity.class})
            ProcessAnnotatedType&lt;?&gt; pat) {
        pat.veto();
    }
}
</code></pre>
                </div>
Listing <a href='#!idx:/upgrade.html:fig:bce-entity-veto'> EntityVetoExtension als Build Compatible Extension </a> zeigt die äquivalente Implementierung als Build Compatible Extension.
Die Methode mit <span class='latex-texttt'>@Enhancement</span> wird für alle Klassen aufgerufen, die mit <span class='latex-texttt'>@Entity</span> annotiert sind.
Statt <span class='latex-texttt'>ProcessAnnotatedType#veto</span> wird die Klasse durch das Hinzufügen der Annotation <span class='latex-texttt'>@Vetoed</span> für CDI unsichtbar gemacht.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:bce-entity-veto'></a>                     <pre><code>public class EntityVetoBuildExtension implements BuildCompatibleExtension {
    @Enhancement(types = Object.class, withAnnotations = Entity.class)
    public void vetoEntities(ClassConfig config) {
        config.addAnnotation(Vetoed.class);
    }
}
</code></pre>
                </div>
Wie bei Portable Extensions erfolgt die Registrierung über den Service-Loader-Mechanismus.
Statt <span class='latex-texttt'>javax.enterprise.inject.spi.Extension</span> wird der vollqualifizierte Name des neuen Interfaces verwendet.
Listing <a href='#!idx:/upgrade.html:fig:bce-registration'> Registrierung einer Build Compatible Extension </a> zeigt die entsprechende Konfigurationsdatei.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:bce-registration'></a>                     <pre><code># META-INF/services/jakarta.enterprise.inject.build.compatible.spi.BuildCompatibleExtension
at.irian.cdiatwork.ideafork.core.EntityVetoBuildExtension
</code></pre>
                </div>
Der Vergleich der beiden Ansätze zeigt, dass die Build Compatible Extension API konzeptuell einfacher ist.
Statt Observer-Methoden mit speziellen Event-Typen werden direkt annotierte Methoden verwendet.
Die Filterung erfolgt über Attribute der Phasen-Annotationen statt über <span class='latex-texttt'>@WithAnnotations</span>.
Für die meisten Anwendungsfälle in <span class='latex-textit'>IdeaFork</span>, wie das Veto von Entitäten oder
die programmatische Registrierung zusätzlicher Beans, bieten Build Compatible Extensions eine komfortable Alternative.<br /> <div class="tip"><b>Tipp: </b>Build Compatible Extensions bieten eine simplere API als Portable Extensions. Für die meisten Anwendungsfälle in <span class='latex-textit'>IdeaFork</span> wäre eine Migration auf Build Compatible Extensions empfehlenswert. Portable Extensions bleiben jedoch in CDI Full weiterhin verfügbar und sind für fortgeschrittene Szenarien, die einen direkten Zugriff auf den <span class='latex-texttt'>BeanManager</span> zur Laufzeit benötigen, nach wie vor die richtige Wahl.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.5'><span class='entry-number'>9.5</span> Neue Spielregeln</a> </h2>
 Neben den bisher beschriebenen strukturellen Änderungen bringt CDI 4.0 auch eine bedeutende Verhaltensänderung mit sich:
der Standard-Wert für den Bean-Discovery-Modus wurde von <span class='latex-texttt'>all</span> auf <span class='latex-texttt'>annotated</span> geändert.
Diese Änderung hat weitreichende Auswirkungen auf bestehende Applikationen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Im bisherigen Modus <span class='latex-texttt'>all</span> wurden sämtliche Klassen in einem Bean Deployment Archive als potentielle CDI-Beans betrachtet.
Im Modus <span class='latex-texttt'>annotated</span> werden hingegen nur Klassen erkannt, die mit einer sogenannten Bean Defining Annotation versehen sind.
Hierzu zählen Scope-Annotationen wie <span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@RequestScoped</span> oder <span class='latex-texttt'>@Dependent</span>,
Stereotyp-Annotationen, Interceptor- und Decorator-Annotationen.
Klassen ohne eine solche Annotation werden vom CDI-Container nicht mehr automatisch erkannt.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Für <span class='latex-textit'>IdeaFork</span> bedeutet dies, dass einige Klassen, die bisher implizit als CDI-Beans behandelt wurden,
nun eine explizite Scope-Annotation benötigen.
Listing <a href='#!idx:/upgrade.html:fig:bean-discovery-annotated'> Klasse mit expliziter Bean Defining Annotation </a> zeigt ein Beispiel aus <span class='latex-textit'>IdeaFork</span>,
bei dem die Klasse <span class='latex-texttt'>PasswordManager</span> um <span class='latex-texttt'>@Dependent</span> ergänzt werden muss,
damit sie weiterhin vom CDI-Container erkannt wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:bean-discovery-annotated'></a>                     <pre><code>import jakarta.enterprise.context.Dependent;

@Dependent
public class PasswordManager {
    public String createPasswordHash(String password) {
        //...
    }

    public boolean isValidPassword(String password, String passwordHash) {
        //...
    }
}
</code></pre>
                </div>
In <span class='latex-textit'>IdeaFork</span> sind die meisten Beans bereits mit Scope-Annotationen versehen,
da wir von Anfang an Wert auf explizite Konfiguration gelegt haben.
Lediglich Hilfsklassen wie <span class='latex-texttt'>PasswordManager</span>, die bisher ohne Scope-Annotation auskamen,
müssen entsprechend ergänzt werden.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> CDI 4.1 führt darüber hinaus die Möglichkeit ein, <span class='latex-texttt'>@Priority</span> direkt auf Producer-Methoden anzuwenden.
Bisher war es erforderlich, alternative Beans mit <span class='latex-texttt'>@Alternative</span> und <span class='latex-texttt'>@Priority</span> auf Klassenebene zu aktivieren.
Mit CDI 4.1 können auch Producer-Methoden direkt priorisiert werden.
Listing <a href='#!idx:/upgrade.html:fig:priority-producer'> Producer-Methode mit @Priority </a> zeigt ein Beispiel,
bei dem ein alternativer <span class='latex-texttt'>ObjectConverter</span> über eine priorisierte Producer-Methode bereitgestellt wird.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:priority-producer'></a>                     <pre><code>import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Alternative;
import jakarta.enterprise.inject.Produces;

@ApplicationScoped
public class TestObjectConverterProducer {

    @Produces
    @Alternative
    @Priority(100)
    @ApplicationScoped
    public ObjectConverter createTestConverter() {
        return new ObjectConverter(/*test configuration*/);
    }
}
</code></pre>
                </div>
Als weitere Neuerung in CDI 4.1 sei die Method Invokers API erwähnt.
Diese API ermöglicht es Frameworks, Methoden von CDI-Beans auf eine standardisierte und optimierte Art aufzurufen.
Für Applikationsentwickler ist diese API in der Regel nicht direkt relevant,
sie bildet jedoch die Grundlage für effizientere Framework-Integrationen.<br /> <div class="tip"><b>Tipp: </b><b>CDI 4.1 &mdash; Ergänzungen:</b> CDI 4.1 (Teil von Jakarta EE 11) bringt inkrementelle Verbesserungen: verbesserte programmatische Lookup-Methoden auf <span class='latex-texttt'>Instance&lt;T&gt;</span>, klarere Spezifikation des Verhaltens von <span class='latex-texttt'>@Priority</span> bei Producers und Stereotypen, sowie die Method-Invokers-API für Build Compatible Extensions. Diese Änderungen sind abwärtskompatibel &mdash; bestehender CDI-4.0-Code funktioniert ohne Anpassungen.</div>
<div class="tip"><b>Tipp: </b>Bei der Migration von <span class='latex-texttt'>bean-discovery-mode="all"</span> zu <span class='latex-texttt'>"annotated"</span> empfiehlt es sich, zunächst das bestehende Verhalten beizubehalten und den Modus schrittweise umzustellen. In einem ersten Schritt kann <span class='latex-texttt'>bean-discovery-mode="all"</span> explizit in der <span class='latex-texttt'>beans.xml</span> gesetzt werden. Danach können die fehlenden Bean Defining Annotations Klasse für Klasse ergänzt werden, bevor der Modus schließlich auf <span class='latex-texttt'>"annotated"</span> umgestellt wird.</div>
<h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.6'><span class='entry-number'>9.6</span> DeltaSpike 2.0</a> </h2>
 Apache DeltaSpike, das wir im Kapitel <a href='#!idx:/deltaspike.html:chap:deltaspike'> Apache DeltaSpike </a> und in den darauf folgenden Kapiteln intensiv verwendet haben,
ist mit Version 2.0 ebenfalls auf den Jakarta-Namensraum migriert worden.
DeltaSpike 2.0.x setzt mindestens Java 11 und Jakarta EE 9 voraus.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die gute Nachricht ist, dass die API von DeltaSpike 2.0 funktional weitgehend identisch zu DeltaSpike 1.x ist.
Sämtliche Module, die wir in <span class='latex-textit'>IdeaFork</span> verwendet haben, stehen unverändert zur Verfügung.
Der <span class='latex-texttt'>ConfigResolver</span>, den wir in <span class='latex-textit'>IdeaForkMicro</span> für die Port-Konfiguration genutzt haben,
der <span class='latex-texttt'>BeanProvider</span> für den programmatischen Zugriff auf CDI-Beans,
sowie die <span class='latex-texttt'>ViewConfig</span>-Mechanismen für die typsichere Navigation funktionieren auf die gleiche Art und Weise.
Lediglich die Imports verwenden nun den <span class='latex-texttt'>jakarta</span>-Namensraum.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/upgrade.html:fig:deltaspike-maven'> DeltaSpike 2.0 Maven-Dependency </a> zeigt die aktualisierte Maven-Dependency für DeltaSpike-Core.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:deltaspike-maven'></a>                     <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.core&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-core-api&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.core&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-core-impl&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
                </div>
Alle DeltaSpike-spezifischen Annotationen wie <span class='latex-texttt'>@Exclude</span>, <span class='latex-texttt'>@ViewAccessScoped</span>,
<span class='latex-texttt'>@WindowScoped</span> und <span class='latex-texttt'>@GroupedConversationScoped</span> sind auch in DeltaSpike 2.0 verfügbar.
Die DeltaSpike-eigenen Scope-Implementierungen, die wir in <span class='latex-textit'>IdeaFork</span> als Alternative zum CDI-Conversation-Scope kennengelernt haben,
funktionieren unter dem Jakarta-Namensraum unverändert.
Auch die DeltaSpike-Data-Module und die Test-Control-Module, die wir für die JUnit-Integration verwendet haben,
stehen in aktualisierten Versionen zur Verfügung.<br /> <div class="tip"><b>Tipp: </b>Da DeltaSpike 2.0 API-kompatibel zu DeltaSpike 1.x ist (abgesehen vom Namespace-Wechsel), kann die Migration zeitgleich mit der javax-zu-jakarta-Migration durchgeführt werden. Es empfiehlt sich, beide Migrationen in einem Schritt zusammenzufassen, um den Aufwand für das Testen zu minimieren.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.7'><span class='entry-number'>9.7</span> Die CDI-Implementierungen</a> </h2>
 Im Kapitel <a href='#!idx:/introduction.html:1'> Einführung in CDI </a> haben wir Weld und OpenWebBeans als die beiden primären CDI-Implementierungen vorgestellt.
Beide Projekte haben die Weiterentwicklung der CDI-Spezifikation mitgetragen und unterstützen die aktuellen Versionen.
In den bisherigen Kapiteln konnten wir <span class='latex-textit'>IdeaFork</span> mit beiden Implementierungen betreiben.
Dies ist auch mit den aktuellen Versionen weiterhin möglich.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/upgrade.html:fig:impl-version-table'> Versionsübersicht der CDI-Implementierungen </a> zeigt die Zuordnung zwischen CDI-Versionen,
den Implementierungsversionen und den zugehörigen Jakarta-EE-Versionen.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:impl-version-table'></a>                     <pre><code>CDI-Spezifikation    Weld           OpenWebBeans    Jakarta EE
CDI 1.0              1.x            1.x             Java EE 6
CDI 1.1              2.x            1.x             Java EE 7
CDI 2.0              3.x            2.x             Java EE 8
CDI 3.0              4.x            2.x             Jakarta EE 9/9.1
CDI 4.0              5.x            4.x             Jakarta EE 10
CDI 4.1              6.x            -               Jakarta EE 11
</code></pre>
                </div>
Weld 6.x, die aktuelle Major-Version von JBoss Weld, implementiert CDI 4.1 und setzt mindestens Java 11 voraus.
Weld wird in WildFly und GlassFish als Standard-CDI-Implementierung verwendet.
Durch die aktive Weiterentwicklung unterstützt Weld sämtliche neuen Features von CDI 4.0 und 4.1,
einschließlich Build Compatible Extensions und der Method Invokers API.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Apache OpenWebBeans 4.x implementiert CDI 4.0 und setzt ebenfalls Java 11 voraus.
OpenWebBeans wird in Apache TomEE als Standard-CDI-Implementierung verwendet.
Für Projekte, die bisher Apache Meecrowave oder TomEE als Laufzeitumgebung verwendet haben,
bietet OpenWebBeans 4.x eine nahtlose Upgrade-Möglichkeit.
Beide Implementierungen unterstützen den vollständigen Jakarta-EE-Namensraum.<br /> <div class="tip"><b>Tipp: </b>Für Projekte die bisher auf Weld 1.x oder 2.x basieren, empfiehlt sich ein schrittweises Update über die Zwischenversionen, um Kompatibilitätsprobleme frühzeitig zu erkennen. Der Sprung von Weld 3.x auf 4.x beinhaltet den Namespace-Wechsel und sollte gemeinsam mit der javax-zu-jakarta-Migration durchgeführt werden.</div>
<div class="tip"><b>Tipp: </b><b>Kompatibilitätsmatrix &mdash; Welche Versionen passen zusammen?</b><br />
&bull; <b>CDI 1.0 / 1.1:</b> Weld 1.x&ndash;2.x, OWB 1.x &mdash; Java EE 6&ndash;7, Java 6&ndash;8<br />
&bull; <b>CDI 2.0:</b> Weld 3.x, OWB 2.x &mdash; Java EE 8, Java 8&ndash;11<br />
&bull; <b>CDI 3.0:</b> Weld 4.x, OWB 2.0.27+ &mdash; Jakarta EE 9, Java 11+<br />
&bull; <b>CDI 4.0 / 4.1:</b> Weld 5.x, OWB 4.x &mdash; Jakarta EE 10+, Java 17+<br />
&bull; <b>Quarkus (ArC):</b> Eigene CDI-Lite-Implementierung, kein Weld/OWB &mdash; Java 17+<br />
Bei der Migration einer bestehenden Applikation muss nicht nur der Namespace geändert werden, sondern auch die Implementierungsversionen müssen zueinander passen.</div><h2><a class='latex-index-anchor' name='!idx:/upgrade.html:9.8'><span class='entry-number'>9.8</span> IdeaFork aktualisieren</a> </h2>
 Zum Abschluss dieses Kapitels fassen wir die einzelnen Migrationsschritte für <span class='latex-textit'>IdeaFork</span> in einer konkreten Checkliste zusammen.
Diese Schritte sind in der empfohlenen Reihenfolge aufgeführt und können als Leitfaden für die Migration eigener Projekte dienen.
Listing <a href='#!idx:/upgrade.html:fig:migration-checklist'> Migrations-Checkliste für IdeaFork </a> zeigt die vollständige Übersicht.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/upgrade.html:fig:migration-checklist'></a>                     <pre><code>Migrations-Checkliste: IdeaFork nach Jakarta EE
================================================

1. Maven-Dependencies aktualisieren
   - javax.enterprise:cdi-api:2.0
     -> jakarta.enterprise:jakarta.enterprise.cdi-api:4.1.0
   - javax:javaee-web-api:7.0
     -> jakarta.platform:jakarta.jakartaee-web-api:10.0.0
   - DeltaSpike 1.x -> DeltaSpike 2.0.0

2. Alle javax-Imports auf jakarta umstellen
   - javax.inject.*          -> jakarta.inject.*
   - javax.enterprise.*      -> jakarta.enterprise.*
   - javax.annotation.*      -> jakarta.annotation.*
   - javax.persistence.*     -> jakarta.persistence.*
   - javax.faces.*           -> jakarta.faces.*
   - javax.ws.rs.*           -> jakarta.ws.rs.*
   - javax.validation.*      -> jakarta.validation.*

3. beans.xml aktualisieren
   - XML-Namensraum:  xmlns.jcp.org -> jakarta.ee
   - Schema-Location: beans_2_0.xsd -> beans_4_0.xsd
   - version="2.0" -> version="4.0"

4. Bean-Discovery-Modus pruefen
   - Default ab CDI 4.0: "annotated" statt "all"
   - Klassen ohne Scope-Annotation ergaenzen
   - Alternativ: bean-discovery-mode="all" explizit setzen

5. IdeaFork-spezifische Features verifizieren
   - Decoratoren (GenericRepositoryDecorator, etc.)
   - Interceptoren (MonitorInterceptor, EntityProcessor)
   - Producer-Methoden (EntityManagerProducer, etc.)
   - Event-Observer (IdeaChangedEvent, etc.)

6. CDI-Implementierung aktualisieren
   - Weld: 1.x/2.x/3.x -> 6.x (fuer CDI 4.1)
   - OpenWebBeans: 1.x/2.x -> 4.x (fuer CDI 4.0)

7. DeltaSpike aktualisieren
   - Core, JPA, Data, JSF, Test-Control -> 2.0.x
   - @Exclude, @ViewAccessScoped, @WindowScoped pruefen
   - ConfigResolver-Konfiguration verifizieren
</code></pre>
                </div>
Bei der Durchführung dieser Schritte sollte jeder Schritt einzeln getestet werden,
bevor mit dem nächsten fortgefahren wird.
Insbesondere nach dem Namespace-Wechsel (Schritte 1-3) empfiehlt es sich,
die bestehende Testsuite vollständig durchlaufen zu lassen, um Fehler frühzeitig zu identifizieren.
Die in <span class='latex-textit'>IdeaFork</span> verwendeten JUnit-Tests mit dem DeltaSpike <span class='latex-texttt'>CdiTestRunner</span> und
die Meecrowave-basierten Tests in <span class='latex-textit'>IdeaForkMicro</span> bilden hier eine gute Basis.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die Migration von <span class='latex-textit'>IdeaFork</span> zeigt exemplarisch, dass der Übergang von Java EE zu Jakarta EE zwar einige mechanische Änderungen erfordert,
die Grundarchitektur einer CDI-basierten Applikation jedoch stabil bleibt.
Die Kernphilosophie von CDI, typsichere Dependency-Injection auf Basis von Annotationen,
hat sich durch alle Versionen hindurch als tragfähiges Fundament erwiesen.
Mit CDI 4.0 und 4.1 wurde die Spezifikation um zeitgemäße Konzepte wie Build Compatible Extensions und
die formale Aufteilung in CDI Lite und CDI Full erweitert,
ohne die bewährten Grundlagen aufzugeben.
Die in den bisherigen Kapiteln erarbeiteten Konzepte und Muster behalten auch unter Jakarta EE ihre Gültigkeit und
bilden weiterhin die Basis für die erfolgreiche Entwicklung moderner CDI-Applikationen.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<div class="tip"><b>Tipp: </b><b>Häufige Migrationsfehler und ihre Lösungen:</b><br />
&bull; <b><span class='latex-texttt'>ClassNotFoundException: javax.enterprise.*</span></b> &mdash; Die Abhängigkeiten wurden auf <span class='latex-texttt'>jakarta.*</span> umgestellt, aber der Quellcode verwendet noch den alten Namespace. Lösung: Alle Imports aktualisieren (manuell oder mit Eclipse Transformer / OpenRewrite).<br />
&bull; <b>Split-Package-Fehler (Java Module System):</b> Zwei JARs liefern dasselbe Paket (<span class='latex-texttt'>javax.inject</span> und <span class='latex-texttt'>jakarta.inject</span> gleichzeitig im Classpath). Lösung: Sicherstellen, dass nur eine Variante im Classpath liegt.<br />
&bull; <b><span class='latex-texttt'>beans.xml</span>-Schema-Mismatch:</b> Die Schema-URL muss zur CDI-Version passen &mdash; <span class='latex-texttt'>xmlns.jcp.org</span> (CDI 1.x&ndash;2.x) vs. <span class='latex-texttt'>jakarta.ee</span> (CDI 3.0+). Lösung: Schema-Version in <span class='latex-texttt'>beans.xml</span> aktualisieren.<br />
&bull; <b>Bean-Discovery-Mode-Änderung:</b> Ab CDI 4.0 ist <span class='latex-texttt'>"annotated"</span> der Standard statt <span class='latex-texttt'>"all"</span>. Beans ohne Scope-Annotation werden nicht mehr erkannt. Lösung: Explizit <span class='latex-texttt'>bean-discovery-mode="all"</span> setzen oder fehlende Annotationen ergänzen.</div>
<b>Quellen:</b><br />
- jakarta.ee<br />
- cdi-spec.org<br />
- weld.cdi-spec.org<br />
- openwebbeans.apache.org<br />
- deltaspike.apache.org<br />
- wildfly.org<br />
- glassfish.org<br />
- tomee.apache.org<br />
- quarkus.io<br />
- projects.eclipse.org/projects/technology.transformer<br />
</section>
<section class="chapter-section" id="chapter-10">
<h1> <a class='latex-index-anchor' name='!idx:/quarkus.html:10'><span class='entry-number'>10</span> Migration zu Quarkus</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Dieses Kapitel wurde von Claude (AI built by Anthropic) auf Basis der vorherigen Kapitel verfasst. Es beschreibt die Migration einer CDI/DeltaSpike-Applikation zu Quarkus. Die Codebeispiele orientieren sich an IdeaFork, wurden jedoch an die Quarkus-Plattform angepasst.
</div>
<a name = '!idx:/quarkus.html:chap:quarkus-migration'> </a><h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.1'><span class='entry-number'>10.1</span> Ein neues Ziel</a> </h2>
 In den bisherigen Kapiteln haben wir CDI zunächst im Kontext von Java EE kennengelernt und
in Kapitel 9 den Übergang zu Jakarta EE begleitet.
Dabei blieb die grundlegende Architektur stets erhalten:
ein Application-Server führt die Applikation aus und stellt den CDI-Container zur Laufzeit bereit.
Quarkus verfolgt einen fundamental anderen Ansatz.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Quarkus ist ein Java-Framework, das speziell für Cloud-native Applikationen und GraalVM Native Images entwickelt wurde.
Im Gegensatz zu traditionellen Application-Servern verschiebt Quarkus möglichst viel Arbeit von der Laufzeit in die Build-Phase.
Dependency-Injection, Konfigurationsauflösung und
die Erkennung von Beans finden nicht beim Start der Applikation statt,
sondern bereits beim Kompilieren.
Das Ergebnis sind extrem schnelle Startzeiten und ein geringer Speicherverbrauch.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Das Herzstück der CDI-Unterstützung in Quarkus ist <span class='latex-textit'>ArC</span>,
eine CDI-Lite-kompatible Implementierung,
die auf Build-Zeit-Verarbeitung optimiert ist.
ArC implementiert die CDI Lite Spezifikation und bietet darüber hinaus einige Quarkus-spezifische Erweiterungen.
Im Gegensatz zu Weld oder OpenWebBeans,
die den vollständigen CDI-Full-Standard implementieren,
konzentriert sich ArC bewusst auf die für Microservices relevanten Funktionen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In diesem Kapitel begleiten wir die Migration von <span class='latex-textit'>IdeaFork</span> zu Quarkus.
Wir betrachten die Unterschiede zu CDI Full,
zeigen welche DeltaSpike-Features durch MicroProfile- und Quarkus-Äquivalente ersetzt werden können und
gehen auf die Besonderheiten ein, die bei der Erstellung von Native Images zu beachten sind.
<br /> <div class="tip"><b>Tipp: </b> Quarkus bietet einen <span class='latex-texttt'>Dev Mode</span> mit Live-Reload,
der die Entwicklung deutlich beschleunigt.
Änderungen am Code werden ohne Neustart der Applikation sofort wirksam.
In Kombination mit der schnellen Build-Zeit-CDI-Verarbeitung durch ArC ergibt sich ein sehr kurzer Feedback-Zyklus.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.2'><span class='entry-number'>10.2</span> Von CDI Full zu ArC</a> </h2>
 ArC basiert auf der CDI Lite Spezifikation, die wir bereits in Kapitel 9 kennengelernt haben.
Im Unterschied zu CDI Full gelten bei ArC einige abweichende Regeln,
die bei der Migration beachtet werden müssen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der wichtigste Unterschied betrifft die <span class='latex-texttt'>beans.xml</span>-Datei.
In einer CDI-Full-Umgebung steuert <span class='latex-texttt'>beans.xml</span> den Bean-Discovery-Modus und
kann Interceptoren, Decoratoren und Alternativen deklarieren.
In Quarkus wird der Inhalt von <span class='latex-texttt'>beans.xml</span> weitgehend ignoriert.
Die Datei kann weiterhin vorhanden sein, dient aber nur als Markierung,
um ein Archiv als Bean Deployment Archive zu kennzeichnen.
Listing <a href='#!idx:/quarkus.html:fig:beans-xml-cdi-full'> beans.xml in CDI Full </a> zeigt die bisherige Konfiguration,
Listing <a href='#!idx:/quarkus.html:fig:beans-xml-quarkus'> beans.xml in Quarkus </a> die vereinfachte Quarkus-Variante.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:beans-xml-cdi-full'></a>                     <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="https://jakarta.ee/xml/ns/jakartaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee
           https://jakarta.ee/xml/ns/jakartaee/beans_4_0.xsd"
       bean-discovery-mode="all"
       version="4.0"&gt;

    &lt;interceptors&gt;
        &lt;class&gt;at.irian.cdiatwork.ideafork.core.impl.MonitorInterceptor&lt;/class&gt;
    &lt;/interceptors&gt;

    &lt;decorators&gt;
        &lt;class&gt;at.irian.cdiatwork.ideafork.core.impl.GenericRepositoryDecorator&lt;/class&gt;
    &lt;/decorators&gt;
&lt;/beans&gt;
</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:beans-xml-quarkus'></a>                     <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="https://jakarta.ee/xml/ns/jakartaee"
       version="4.0"&gt;
    &lt;!-- Inhalt wird von Quarkus/ArC ignoriert --&gt;
    &lt;!-- Interceptoren und Decoratoren werden via @Priority aktiviert --&gt;
&lt;/beans&gt;
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b> In Quarkus ist <span class='latex-texttt'>beans.xml</span> optional.
Quarkus scannt automatisch alle Klassen im Applikationsmodul.
Für externe Bibliotheken kann ein <span class='latex-texttt'>beans.xml</span> im Archiv oder
der Jandex-Index (<span class='latex-texttt'>META-INF/jandex.idx</span>) verwendet werden,
um die enthaltenen Klassen für ArC sichtbar zu machen.</div>
Der Bean-Discovery-Modus ist in Quarkus fest auf <span class='latex-texttt'>annotated</span> eingestellt.
Ein Wechsel zu <span class='latex-texttt'>all</span> ist nicht möglich.
Dies bedeutet, dass jedes Bean eine Scope-Annotation wie
<span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@RequestScoped</span> oder <span class='latex-texttt'>@Dependent</span> tragen muss,
um von ArC erkannt zu werden.
Klassen ohne Scope-Annotation, die in CDI Full mit <span class='latex-texttt'>bean-discovery-mode="all"</span> als <span class='latex-texttt'>@Dependent</span>-Beans erkannt wurden,
müssen für Quarkus explizit annotiert werden.
Listing <a href='#!idx:/quarkus.html:fig:discovery-annotated'> Explizite Scope-Annotation </a> zeigt ein Beispiel.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:discovery-annotated'></a>                     <pre><code>// Ohne Scope-Annotation: wird von ArC NICHT erkannt
public class IdeaValidator {
    public boolean isValid(Idea idea) {
        return idea.getTitle() != null;
    }
}

// Mit Scope-Annotation: wird von ArC erkannt
@Dependent
public class IdeaValidator {
    public boolean isValid(Idea idea) {
        return idea.getTitle() != null;
    }
}
</code></pre>
                </div>
Ein weiterer Unterschied betrifft das Konzept der Bean Archives.
In CDI Full definieren Bean Deployment Archives Sichtbarkeitsgrenzen:
Beans aus einem Archiv ohne <span class='latex-texttt'>beans.xml</span> sind für andere Archive nicht sichtbar.
In Quarkus gibt es keine solchen Sichtbarkeitsgrenzen.
Alle mit einer Scope-Annotation versehenen oder anderweitig registrierten Beans sind global sichtbar.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> ArC bietet einen weiteren praktischen Vorteil:
no-arg-Konstruktoren werden automatisch generiert.
In CDI Full benötigt ein Bean mit einem <span class='latex-texttt'>@Inject</span>-Konstruktor zusätzlich einen parameterlosen Konstruktor
(oder genauer gesagt, einen Konstruktor, der vom Container aufgerufen werden kann).
In Quarkus ist dies nicht erforderlich.
Listing <a href='#!idx:/quarkus.html:fig:no-arg-constructor'> Automatische Konstruktor-Generierung </a> zeigt den Unterschied.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:no-arg-constructor'></a>                     <pre><code>// CDI Full: no-arg-Konstruktor erforderlich
@ApplicationScoped
public class IdeaService {
    private IdeaRepository repository;

    protected IdeaService() {} // fuer den CDI-Proxy

    @Inject
    public IdeaService(IdeaRepository repository) {
        this.repository = repository;
    }
}

// Quarkus/ArC: no-arg-Konstruktor wird automatisch generiert
@ApplicationScoped
public class IdeaService {
    private IdeaRepository repository;

    @Inject
    public IdeaService(IdeaRepository repository) {
        this.repository = repository;
    }
}
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> Private Injection-Points sollten in Quarkus vermieden werden.
ArC muss für den Zugriff auf private Felder spezielle Reflection-Mechanismen verwenden,
die sowohl die Performance als auch die Native-Image-Kompatibilität beeinträchtigen.
Verwenden Sie stattdessen package-private Sichtbarkeit oder Constructor-Injection.</div>
Listing <a href='#!idx:/quarkus.html:fig:private-injection'> Private vs. package-private Injection </a> zeigt den Unterschied.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:private-injection'></a>                     <pre><code>// Zu vermeiden: private Injection
@ApplicationScoped
public class IdeaService {
    @Inject
    private IdeaRepository repository; // verursacht Reflection-Overhead
}

// Besser: package-private Injection
@ApplicationScoped
public class IdeaService {
    @Inject
    IdeaRepository repository; // kein Reflection erforderlich
}
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Wenn Quarkus als REST-Backend für ein separates Frontend (Angular, React) dient, muss CORS (Cross-Origin Resource Sharing) konfiguriert werden. Typische Einstellungen in <span class='latex-texttt'>application.properties</span> sind <span class='latex-texttt'>quarkus.http.cors=true</span> und <span class='latex-texttt'>quarkus.http.cors.origins</span>. Wichtig: <span class='latex-texttt'>PATCH</span> muss in <span class='latex-texttt'>quarkus.http.cors.methods</span> explizit aufgelistet werden &mdash; eine Standardliste mit <span class='latex-texttt'>GET, POST, PUT, DELETE</span> reicht nicht aus. Fehlt <span class='latex-texttt'>PATCH</span>, schlägt der Preflight-Request fehl und der Browser blockiert die Anfrage ohne aussagekräftige Fehlermeldung.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.3'><span class='entry-number'>10.3</span> Scopes in Quarkus</a> </h2>
 In den bisherigen Kapiteln haben wir verschiedene CDI-Scopes kennengelernt:
von <span class='latex-texttt'>@ApplicationScoped</span> und <span class='latex-texttt'>@RequestScoped</span> über <span class='latex-texttt'>@SessionScoped</span> und <span class='latex-texttt'>@ConversationScoped</span> bis hin
zu den DeltaSpike-spezifischen Scopes wie <span class='latex-texttt'>@ViewAccessScoped</span> und <span class='latex-texttt'>@WindowScoped</span>.
In Quarkus steht nur ein Teil dieser Scopes zur Verfügung.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die folgenden Scopes werden von Quarkus vollständig unterstützt:
<span class='latex-texttt'>@ApplicationScoped</span>, <span class='latex-texttt'>@Singleton</span>, <span class='latex-texttt'>@RequestScoped</span> und <span class='latex-texttt'>@Dependent</span>.
Diese decken die meisten Anwendungsfälle in Microservice-Architekturen ab.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> <span class='latex-texttt'>@SessionScoped</span> ist in Quarkus nur verfügbar,
wenn die Extension <span class='latex-texttt'>quarkus-undertow</span> (Servlet-Unterstützung) aktiviert ist.
Da Quarkus-Applikationen in der Regel auf RESTful-Architekturen setzen und zustandslos arbeiten,
wird <span class='latex-texttt'>@SessionScoped</span> selten benötigt.<br /> <div class="tip"><b>Tipp: </b> Wenn <span class='latex-texttt'>@SessionScoped</span> benötigt wird,
kann die Abhängigkeit <span class='latex-texttt'>quarkus-undertow</span> in der <span class='latex-texttt'>pom.xml</span> hinzugefügt werden.
In den meisten Fällen empfiehlt es sich jedoch,
die Applikation zustandslos zu gestalten und Sitzungsdaten in einem externen Speicher (z.B. Redis) zu verwalten.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> <span class='latex-texttt'>@ConversationScoped</span> wird von Quarkus nicht unterstützt.
In <span class='latex-textit'>IdeaFork</span> haben wir <span class='latex-texttt'>@ConversationScoped</span> nicht direkt verwendet,
aber das Konzept wurde in Kapitel 3 als Alternative zu <span class='latex-texttt'>@SessionScoped</span> vorgestellt.
Bei einer Migration zu Quarkus muss dieser Scope durch <span class='latex-texttt'>@RequestScoped</span> in Kombination mit expliziter Zustandsübergabe ersetzt werden.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> Die DeltaSpike-Scopes <span class='latex-texttt'>@ViewAccessScoped</span>,
<span class='latex-texttt'>@WindowScoped</span> und <span class='latex-texttt'>@GroupedConversationScoped</span> haben in Quarkus kein Äquivalent.
Diese Scopes sind eng an JSF und das Konzept von Browser-Fenstern gekoppelt.
Bei der Migration zu Quarkus muss die Architektur auf REST-basierte,
zustandslose Kommunikation umgestellt werden.</div>
 Quarkus bietet darüber hinaus den Scope <span class='latex-texttt'>@TransactionScoped</span>,
der in <span class='latex-textit'>IdeaForkMicro</span> für EntityManager-Producer verwendet wird.
Dieser Scope ist an den Lebenszyklus einer JTA-Transaktion gebunden und
wird von Quarkus nativ unterstützt.
Listing <a href='#!idx:/quarkus.html:fig:transaction-scoped'> @TransactionScoped EntityManager </a> zeigt das Pattern.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:transaction-scoped'></a>                     <pre><code>// IdeaForkMicro-Pattern: @TransactionScoped EntityManager
import jakarta.transaction.TransactionScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

@ApplicationScoped
public class EntityManagerProducer {
    @PersistenceContext
    EntityManager em;

    @Produces
    @TransactionScoped
    public EntityManager createEntityManager() {
        return em;
    }
}

// In Quarkus: entfaellt - Panache verwaltet den EntityManager
// Bei Bedarf kann @Inject EntityManager direkt verwendet werden
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> In <span class='latex-textit'>IdeaForkMicro</span> wird ein eigener <span class='latex-texttt'>@ConfigScoped</span>-Scope verwendet,
der eine neue Bean-Instanz erzeugt, sobald sich die Konfiguration ändert.
Dieser Custom-Scope hat in Quarkus kein direktes Äquivalent.
Als Alternative kann <span class='latex-texttt'>@ApplicationScoped</span> in Kombination mit
<span class='latex-texttt'>@ConfigProperty</span> und einem <span class='latex-texttt'>@Observes StartupEvent</span>-Handler verwendet werden,
der die Konfiguration beim Start lädt.
Dynamische Konfigurationsänderungen zur Laufzeit erfordern einen eigenen Mechanismus,
beispielsweise über Quarkus Dev Services oder einen MicroProfile Config Watcher.</div>
Listing <a href='#!idx:/quarkus.html:fig:scope-migration'> Scope-Migration </a> zeigt typische Anpassungen bei der Scope-Migration.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:scope-migration'></a>                     <pre><code>// Vorher: @SessionScoped (zustandsbehaftet)
@SessionScoped
public class UserSession implements Serializable {
    private User currentUser;

    public void login(User user) {
        this.currentUser = user;
    }

    public User getCurrentUser() {
        return currentUser;
    }
}

// Nachher: zustandsloser Ansatz mit JWT
@RequestScoped
public class UserContext {
    @Inject
    JsonWebToken jwt;

    public String getCurrentUserId() {
        return jwt.getSubject();
    }
}
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>JAX-RS definiert keine <span class='latex-texttt'>@PATCH</span>-Annotation in älteren Spezifikationen. Quarkus REST (ehemals RESTEasy Reactive) unterstützt sie jedoch vollständig. Für partielle Updates &mdash; z.B. das Umschalten eines Boolean-Feldes, ohne die gesamte Entity zu senden &mdash; kann der Endpoint einen <span class='latex-texttt'>Map&lt;String, Object&gt;</span>-Parameter akzeptieren. Dies verliert die Compile-Zeit-Typsicherheit, entspricht aber der Art, wie JavaScript-Frontends typischerweise partielles JSON senden: <span class='latex-texttt'>{ "completed": true }</span> statt der vollständigen Entity.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.4'><span class='entry-number'>10.4</span> Konfiguration mit MicroProfile Config</a> </h2>
 In Kapitel 5 haben wir den DeltaSpike ConfigResolver und <span class='latex-texttt'>@ConfigProperty</span> kennengelernt,
um Applikationskonfigurationen typsicher zu verwalten.
Quarkus verwendet stattdessen MicroProfile Config als Konfigurationsstandard.
Die Konzepte sind ähnlich, unterscheiden sich aber in einigen Details.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der wichtigste Unterschied:
die DeltaSpike-Annotation <span class='latex-texttt'>@ConfigProperty</span> stammt aus dem Paket
<span class='latex-texttt'>org.apache.deltaspike.core.api.config</span>,
während die MicroProfile-Variante in <span class='latex-texttt'>org.eclipse.microprofile.config.inject</span> definiert ist.
Listing <a href='#!idx:/quarkus.html:fig:config-property-migration'> @ConfigProperty-Migration </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:config-property-migration'></a>                     <pre><code>// Vorher: DeltaSpike @ConfigProperty
import org.apache.deltaspike.core.api.config.ConfigProperty;
import jakarta.inject.Inject;

@ApplicationScoped
public class IdeaServiceConfig {
    @Inject
    @ConfigProperty(name = "ideafork.max.ideas")
    private Integer maxIdeas;
}

// Nachher: MicroProfile @ConfigProperty
import org.eclipse.microprofile.config.inject.ConfigProperty;

@ApplicationScoped
public class IdeaServiceConfig {
    @ConfigProperty(name = "ideafork.max.ideas")
    Integer maxIdeas; // @Inject ist optional in Quarkus
}
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b> In Quarkus ist <span class='latex-texttt'>@Inject</span> bei <span class='latex-texttt'>@ConfigProperty</span> optional.
Die Annotation <span class='latex-texttt'>@ConfigProperty</span> wird von Quarkus direkt erkannt und injiziert den Wert automatisch.
Dies vereinfacht den Code, unterscheidet sich aber vom Standard-MicroProfile-Verhalten,
wo <span class='latex-texttt'>@Inject</span> erforderlich ist.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> Fehlende Konfigurationswerte führen in Quarkus zu einem Startfehler.
Im Gegensatz zu DeltaSpike, wo fehlende Werte als <span class='latex-texttt'>null</span> injiziert werden konnten,
erzwingt Quarkus die Angabe aller konfigurierten Properties.
Verwenden Sie <span class='latex-texttt'>Optional&lt;T&gt;</span> oder den <span class='latex-texttt'>defaultValue</span>-Parameter, um optionale Konfigurationen zu definieren.</div>
Die DeltaSpike-Klasse <span class='latex-texttt'>ConfigResolver</span> kann durch <span class='latex-texttt'>ConfigProvider.getConfig()</span> aus der MicroProfile-Config-API ersetzt werden.
Listing <a href='#!idx:/quarkus.html:fig:config-resolver-migration'> ConfigResolver-Migration </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:config-resolver-migration'></a>                     <pre><code>// Vorher: DeltaSpike ConfigResolver
import org.apache.deltaspike.core.api.config.ConfigResolver;

String dbUrl = ConfigResolver
    .resolve("ideafork.db.url")
    .withDefault("jdbc:h2:mem:ideafork")
    .getValue();

// Nachher: MicroProfile ConfigProvider
import org.eclipse.microprofile.config.ConfigProvider;

String dbUrl = ConfigProvider.getConfig()
    .getOptionalValue("ideafork.db.url", String.class)
    .orElse("jdbc:h2:mem:ideafork");
</code></pre>
                </div>
 DeltaSpike verwendet das Konzept der <span class='latex-texttt'>ProjectStage</span>,
um unterschiedliche Konfigurationen für verschiedene Umgebungen bereitzustellen.
Quarkus ersetzt dieses Konzept durch Profile.
Konfigurationswerte können mit einem Profil-Präfix versehen werden,
der nur in der jeweiligen Umgebung aktiv ist.
Listing <a href='#!idx:/quarkus.html:fig:project-stage-migration'> ProjectStage zu Quarkus-Profilen </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:project-stage-migration'></a>                     <pre><code># Vorher: DeltaSpike ProjectStage (apache-deltaspike.properties)
ideafork.db.url=jdbc:h2:mem:ideafork
ideafork.db.url.Production=jdbc:postgresql://prod-server/ideafork

# Nachher: Quarkus Profile (application.properties)
ideafork.db.url=jdbc:h2:mem:ideafork
%prod.ideafork.db.url=jdbc:postgresql://prod-server/ideafork
%dev.ideafork.db.url=jdbc:h2:mem:ideafork-dev
%test.ideafork.db.url=jdbc:h2:mem:ideafork-test
</code></pre>
                </div>
 Die DeltaSpike-Annotation <span class='latex-texttt'>@Exclude</span>,
die wir in Kapitel 5 verwendet haben um Beans basierend auf der ProjectStage auszuschließen,
wird in Quarkus durch <span class='latex-texttt'>@IfBuildProfile</span> und <span class='latex-texttt'>@UnlessBuildProfile</span> ersetzt.
Listing <a href='#!idx:/quarkus.html:fig:exclude-migration'> @Exclude zu @IfBuildProfile </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:exclude-migration'></a>                     <pre><code>// Vorher: DeltaSpike @Exclude
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.projectstage.ProjectStage;

@ApplicationScoped
@Exclude(ifProjectStage = ProjectStage.Production.class)
public class MockIdeaRepository implements IdeaRepository {
    //...
}

// Nachher: Quarkus @UnlessBuildProfile
import io.quarkus.arc.profile.UnlessBuildProfile;

@ApplicationScoped
@UnlessBuildProfile("prod")
public class MockIdeaRepository implements IdeaRepository {
    //...
}
</code></pre>
                </div>
 Die DeltaSpike-<span class='latex-texttt'>@Configuration</span>-Interfaces können in Quarkus durch
<span class='latex-texttt'>@ConfigMapping</span>-Interfaces aus SmallRye Config ersetzt werden.
Listing <a href='#!idx:/quarkus.html:fig:config-mapping'> @Configuration zu @ConfigMapping </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:config-mapping'></a>                     <pre><code>// Vorher: DeltaSpike @Configuration
import org.apache.deltaspike.core.api.config.Configuration;
import org.apache.deltaspike.core.api.config.ConfigProperty;

@Configuration(prefix = "ideafork.")
public interface IdeaForkConfig {
    @ConfigProperty(name = "max.ideas", defaultValue = "100")
    Integer maxIdeas();

    @ConfigProperty(name = "admin.email")
    String adminEmail();
}

// Nachher: SmallRye @ConfigMapping
import io.smallrye.config.ConfigMapping;
import io.smallrye.config.WithDefault;

@ConfigMapping(prefix = "ideafork")
public interface IdeaForkConfig {
    @WithDefault("100")
    Integer maxIdeas();

    String adminEmail();
}
</code></pre>
                </div>
 In <span class='latex-textit'>IdeaForkMicro</span> wird das DeltaSpike <span class='latex-texttt'>PropertyFileConfig</span>-SPI verwendet,
um Konfigurationsdateien programmatisch zu registrieren.
Listing <a href='#!idx:/quarkus.html:fig:property-file-config'> PropertyFileConfig zu Quarkus </a> zeigt die Umstellung auf den MicroProfile-Config-Standard.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:property-file-config'></a>                     <pre><code>// Vorher: DeltaSpike PropertyFileConfig
import org.apache.deltaspike.core.api.config.PropertyFileConfig;

public class IdeaForkConfig implements PropertyFileConfig {
    @Override
    public String getPropertyFileName() {
        return "ideafork-custom.properties";
    }

    @Override
    public boolean isOptional() {
        return true;
    }
}

// Nachher: MicroProfile ConfigSource
import org.eclipse.microprofile.config.spi.ConfigSource;
import java.util.Map;
import java.util.Properties;

public class IdeaForkConfigSource implements ConfigSource {
    private final Map&lt;String, String&gt; properties;

    public IdeaForkConfigSource() {
        Properties props = new Properties();
        // Properties aus Datei laden
        this.properties = Map.copyOf(/* ... */);
    }

    @Override
    public Map&lt;String, String&gt; getProperties() {
        return properties;
    }

    @Override
    public String getValue(String key) {
        return properties.get(key);
    }

    @Override
    public String getName() {
        return "ideafork-custom";
    }
}
// registriert via META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b> In DeltaSpike können <span class='latex-texttt'>ConfigSource</span>-Implementierungen auch zur Laufzeit dynamisch registriert werden.
In Quarkus muss die Registrierung statisch über die Service-Provider-Schnittstelle
(<span class='latex-texttt'>META-INF/services</span>) erfolgen,
da die Konfiguration zur Build-Zeit aufgelöst wird.
Dynamische Konfigurationsquellen, die zur Laufzeit hinzugefügt werden, sind in Quarkus nicht möglich.</div>
<div class="tip"><b>Tipp: </b><b>Quarkus Dev Services:</b> Im Entwicklungsmodus (<span class='latex-texttt'>mvn quarkus:dev</span>) startet Quarkus automatisch Docker-Container für benötigte Infrastruktur: PostgreSQL, MySQL, MongoDB, Kafka, Keycloak und weitere. Konfiguration ist nicht erforderlich &mdash; Quarkus erkennt die verwendeten Extensions und provisioniert die passenden Container. Für <span class='latex-textit'>IdeaFork</span> bedeutet dies: Ein einfaches <span class='latex-texttt'>quarkus-jdbc-postgresql</span> im <span class='latex-texttt'>pom.xml</span> genügt, und eine PostgreSQL-Instanz steht automatisch bereit.</div>
<div class="tip"><b>Tipp: </b><b>Continuous Testing:</b> Im Dev-Modus (<span class='latex-texttt'>mvn quarkus:dev</span>) führt Quarkus Tests automatisch bei jeder Codeänderung aus. Durch Drücken von <span class='latex-texttt'>r</span> im Terminal werden alle Tests ausgeführt, <span class='latex-texttt'>f</span> wiederholt nur fehlgeschlagene Tests. Dies ermöglicht einen schnellen Entwicklungszyklus ohne manuelles Auslösen von Test-Suites &mdash; vergleichbar mit der Arbeitsweise, die DeltaSpike Test-Control für CDI-Tests bietet, aber integriert in den gesamten Entwicklungsworkflow.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.5'><span class='entry-number'>10.5</span> Erweiterungen zur Build-Zeit</a> </h2>
 In Kapitel 4 haben wir die Portable CDI Extensions kennengelernt,
mit denen wir den CDI-Container zur Laufzeit dynamisch erweitern konnten.
Dieses Kapitel zeigt, warum dieses Konzept in Quarkus grundlegend anders funktioniert.<br /> <div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> Portable CDI Extensions (die <span class='latex-texttt'>Extension</span>-Schnittstelle aus CDI Full)
werden von Quarkus nicht unterstützt.
ArC verarbeitet alle Beans zur Build-Zeit, nicht zur Laufzeit.
Laufzeit-basierte Erweiterungen, die dynamisch auf Container-Events wie
<span class='latex-texttt'>ProcessAnnotatedType</span> oder <span class='latex-texttt'>AfterBeanDiscovery</span> reagieren,
können daher nicht verwendet werden.</div>
Quarkus ersetzt Portable CDI Extensions durch ein eigenes Extension-Modell,
das aus zwei Modulen besteht:
einem <span class='latex-textit'>Deployment-Modul</span>, das zur Build-Zeit ausgeführt wird,
und einem <span class='latex-textit'>Runtime-Modul</span>, das den generierten Code zur Laufzeit bereitstellt.
Die Build-Zeit-Logik wird in Methoden definiert, die mit <span class='latex-texttt'>@BuildStep</span> annotiert sind.
Diese Methoden konsumieren und produzieren sogenannte <span class='latex-texttt'>BuildItem</span>-Objekte,
die den Build-Prozess steuern.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Die folgende Tabelle zeigt die Zuordnung der wichtigsten CDI-Extension-Events
zu ihren Quarkus-Äquivalenten:<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<span class='latex-texttt'>ProcessAnnotatedType</span> → <span class='latex-texttt'>AnnotationsTransformerBuildItem</span><br />
<span class='latex-texttt'>ProcessBeanAttributes</span> → <span class='latex-texttt'>BeanDefiningAnnotationBuildItem</span><br />
<span class='latex-texttt'>AfterBeanDiscovery.addBean()</span> → <span class='latex-texttt'>SyntheticBeanBuildItem</span><br />
<span class='latex-texttt'>AfterBeanDiscovery.addObserverMethod()</span> → <span class='latex-texttt'>SyntheticObserverBuildItem</span><br />
<span class='latex-texttt'>ProcessInjectionTarget</span> → <span class='latex-texttt'>InjectionPointTransformerBuildItem</span><br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> In Kapitel 4 haben wir ein Beispiel gezeigt,
in dem eine CDI Extension Entity-Klassen automatisch als CDI-Bean vetoed hat.
Listing <a href='#!idx:/quarkus.html:fig:extension-cdi-full'> Entity-Veto als Portable Extension </a> zeigt die ursprüngliche CDI-Full-Version,
Listing <a href='#!idx:/quarkus.html:fig:extension-quarkus'> Entity-Veto als Quarkus BuildStep </a> die Quarkus-Variante.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:extension-cdi-full'></a>                     <pre><code>// CDI Full: Portable Extension
public class EntityVetoExtension implements Extension {
    &lt;T&gt; void vetoEntities(
            @Observes ProcessAnnotatedType&lt;T&gt; pat) {
        if (pat.getAnnotatedType().isAnnotationPresent(Entity.class)) {
            pat.veto();
        }
    }
}
// registriert via META-INF/services/jakarta.enterprise.inject.spi.Extension
</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:extension-quarkus'></a>                     <pre><code>// Quarkus: BuildStep in einem Deployment-Modul
public class EntityVetoProcessor {
    @BuildStep
    AnnotationsTransformerBuildItem vetoEntities() {
        return new AnnotationsTransformerBuildItem(
            new AnnotationsTransformer() {
                @Override
                public boolean appliesTo(AnnotationTarget.Kind kind) {
                    return kind == AnnotationTarget.Kind.CLASS;
                }

                @Override
                public void transform(TransformationContext ctx) {
                    if (ctx.getTarget().asClass()
                            .hasAnnotation(DotName.createSimple(
                                "jakarta.persistence.Entity"))) {
                        ctx.transform().add(Vetoed.class).done();
                    }
                }
            });
    }
}
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b> Quarkus bietet mit den Build Compatible Extensions aus CDI 4.0
(siehe Kapitel 9.4) eine weitere Alternative.
Diese können in Quarkus als <span class='latex-texttt'>@BuildCompatibleExtension</span> registriert werden und
bieten eine standardisierte Möglichkeit, Build-Zeit-Erweiterungen zu schreiben,
die auch außerhalb von Quarkus funktionieren.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.6'><span class='entry-number'>10.6</span> DeltaSpike-Module ersetzen</a> </h2>
 In Kapitel 5 haben wir verschiedene DeltaSpike-Module kennengelernt,
die CDI um zusätzliche Funktionalität erweitern.
Bei der Migration zu Quarkus müssen diese Module durch Quarkus- oder MicroProfile-Äquivalente ersetzt werden.
Dieser Abschnitt zeigt die wichtigsten Migrationsschritte für jedes Modul.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> <b>Data-Modul:</b> Das DeltaSpike Data-Modul bietet das <span class='latex-texttt'>@Repository</span>-Pattern,
mit dem Datenzugriffsklassen automatisch implementiert werden.
In Quarkus wird dies durch Panache ersetzt.
Listing <a href='#!idx:/quarkus.html:fig:data-module-migration'> Data-Modul-Migration </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:data-module-migration'></a>                     <pre><code>// Vorher: DeltaSpike @Repository
import org.apache.deltaspike.data.api.AbstractEntityRepository;
import org.apache.deltaspike.data.api.Repository;

@Repository
public abstract class IdeaRepository
        extends AbstractEntityRepository&lt;Idea, Long&gt; {

    public abstract List&lt;Idea&gt; findByTitle(String title);
}

// Nachher: Quarkus Panache
import io.quarkus.hibernate.orm.panache.PanacheRepository;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class IdeaRepository implements PanacheRepository&lt;Idea&gt; {

    public List&lt;Idea&gt; findByTitle(String title) {
        return find("title", title).list();
    }
}
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Bei Verwendung von <span class='latex-texttt'>PanacheEntityBase</span> mit <span class='latex-texttt'>@SequenceGenerator</span> sollte <span class='latex-texttt'>allocationSize=1</span> gesetzt werden, um vorhersagbare IDs während der Entwicklung zu erhalten. Wenn <span class='latex-texttt'>import.sql</span> Testdaten mit expliziten IDs einfügt, muss die Sequenz oberhalb der höchsten Seed-ID neu gestartet werden (<span class='latex-texttt'>ALTER SEQUENCE ... RESTART WITH ...</span>), um Primärschlüssel-Kollisionen zu vermeiden.</div>
 <b>Security-Modul:</b> Das DeltaSpike Security-Modul mit <span class='latex-texttt'>@Secured</span> und dem <span class='latex-texttt'>SecurityViolationHandler</span>
wird in Quarkus durch die Standard-Jakarta-Security-Annotationen <span class='latex-texttt'>@RolesAllowed</span> und <span class='latex-texttt'>@Authenticated</span>
in Kombination mit MicroProfile JWT ersetzt.
Listing <a href='#!idx:/quarkus.html:fig:security-migration'> Security-Migration </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:security-migration'></a>                     <pre><code>// Vorher: DeltaSpike @Secured
import org.apache.deltaspike.security.api.authorization.Secured;

@ApplicationScoped
public class IdeaManager {
    @Secured(IdeaAccessDecisionVoter.class)
    public Idea createIdea(Idea idea) {
        //...
    }
}

// Nachher: Jakarta Security + MicroProfile JWT
import jakarta.annotation.security.RolesAllowed;

@ApplicationScoped
public class IdeaManager {
    @RolesAllowed("user")
    public Idea createIdea(Idea idea) {
        //...
    }
}
</code></pre>
                </div>
 <b>Scheduler-Modul:</b> Das DeltaSpike Scheduler-Modul bindet Quartz auf Klassen-Ebene ein.
Quarkus bietet mit <span class='latex-texttt'>@Scheduled</span> eine vereinfachte Methoden-Annotation.
Listing <a href='#!idx:/quarkus.html:fig:scheduler-migration'> Scheduler-Migration </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:scheduler-migration'></a>                     <pre><code>// Vorher: DeltaSpike @Scheduled (Klassen-Ebene)
import org.apache.deltaspike.scheduler.api.Scheduled;
import org.quartz.Job;
import org.quartz.JobExecutionContext;

@Scheduled(cronExpression = "0 0/5 * * * ?")
public class IdeaCleanupJob implements Job {
    @Inject
    private IdeaRepository repository;

    @Override
    public void execute(JobExecutionContext ctx) {
        repository.deleteExpiredIdeas();
    }
}

// Nachher: Quarkus @Scheduled (Methoden-Ebene)
import io.quarkus.scheduler.Scheduled;

@ApplicationScoped
public class IdeaCleanupJob {
    @Inject
    IdeaRepository repository;

    @Scheduled(cron = "0 0/5 * * * ?")
    void cleanupExpiredIdeas() {
        repository.deleteExpiredIdeas();
    }
}
</code></pre>
                </div>
 <b>Test-Control-Modul:</b> Der DeltaSpike <span class='latex-texttt'>CdiTestRunner</span> wird durch <span class='latex-texttt'>@QuarkusTest</span> ersetzt.
Listing <a href='#!idx:/quarkus.html:fig:test-migration'> Test-Migration </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:test-migration'></a>                     <pre><code>// Vorher: DeltaSpike CdiTestRunner
import org.apache.deltaspike.testcontrol.api.junit.CdiTestRunner;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(CdiTestRunner.class)
public class IdeaServiceTest {
    @Inject
    private IdeaService ideaService;

    @Test
    public void testCreateIdea() {
        //...
    }
}

// Nachher: Quarkus @QuarkusTest
import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

@QuarkusTest
public class IdeaServiceTest {
    @Inject
    IdeaService ideaService;

    @Test
    void testCreateIdea() {
        //...
    }
}
</code></pre>
                </div>
 <b>BeanProvider:</b> Der DeltaSpike <span class='latex-texttt'>BeanProvider</span> für programmatische Bean-Lookups wird in Quarkus durch
<span class='latex-texttt'>Arc.container().instance()</span> ersetzt.
Listing <a href='#!idx:/quarkus.html:fig:bean-provider-migration'> BeanProvider-Migration </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:bean-provider-migration'></a>                     <pre><code>// Vorher: DeltaSpike BeanProvider
import org.apache.deltaspike.core.api.provider.BeanProvider;

IdeaService service = BeanProvider
    .getContextualReference(IdeaService.class);

// Nachher: Quarkus Arc
import io.quarkus.arc.Arc;

IdeaService service = Arc.container()
    .instance(IdeaService.class).get();
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> Bei programmatischen Bean-Lookups muss in Quarkus die Annotation <span class='latex-texttt'>@Unremovable</span> verwendet werden.
ArC entfernt zur Build-Zeit alle Beans,
die keinen erkennbaren Injection-Point haben.
Ein Bean, das ausschließlich über <span class='latex-texttt'>Arc.container().instance()</span> aufgelöst wird,
hat keinen solchen Injection-Point und wird daher entfernt.
Listing <a href='#!idx:/quarkus.html:fig:unremovable'> @Unremovable für programmatische Lookups </a> zeigt die Lösung.</div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:unremovable'></a>                     <pre><code>// Ohne @Unremovable: Bean wird von ArC entfernt
@ApplicationScoped
public class DynamicProcessor {
    //...
}

// Mit @Unremovable: Bean bleibt erhalten
import io.quarkus.arc.Unremovable;

@ApplicationScoped
@Unremovable
public class DynamicProcessor {
    //...
}
</code></pre>
                </div>
 <b>Partial-Bean-Modul:</b> In <span class='latex-textit'>IdeaForkMicro</span> wird das DeltaSpike <span class='latex-texttt'>@PartialBeanBinding</span> intensiv genutzt,
um Proxy-basierte Beans aus reinen Interfaces zu erzeugen.
Dieses Pattern wird unter anderem für <span class='latex-texttt'>@TypedConfig</span>-Interfaces
und <span class='latex-texttt'>@ResourceClient</span>-REST-Clients verwendet.
In Quarkus existiert kein direktes Äquivalent für <span class='latex-texttt'>@PartialBeanBinding</span>,
aber die dahinterliegenden Anwendungsfälle werden durch spezialisierte Quarkus-Features abgedeckt.
Listing <a href='#!idx:/quarkus.html:fig:partial-bean-migration'> @PartialBeanBinding Migration </a> zeigt die Umstellung der wichtigsten Patterns.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:partial-bean-migration'></a>                     <pre><code>// Vorher: DeltaSpike @TypedConfig via @PartialBeanBinding
import org.apache.deltaspike.core.api.config.ConfigProperty;
import at.irian.cdiatwork.ideafork.ee.config.TypedConfig;

@TypedConfig // basiert auf @PartialBeanBinding
public interface IdeaForkAppConfig {
    @ConfigProperty(name = "ideafork.max.ideas")
    Integer maxIdeas();

    @ConfigProperty(name = "ideafork.admin.email")
    String adminEmail();
}

// Nachher: SmallRye @ConfigMapping (siehe Abschnitt 10.4)
import io.smallrye.config.ConfigMapping;
import io.smallrye.config.WithDefault;

@ConfigMapping(prefix = "ideafork")
public interface IdeaForkAppConfig {
    @WithDefault("100")
    Integer maxIdeas();

    String adminEmail();
}
</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:resource-client-migration'></a>                     <pre><code>// Vorher: DeltaSpike @ResourceClient via @PartialBeanBinding
import at.irian.cdiatwork.ideafork.ee.rest.ResourceClient;

@ResourceClient // basiert auf @PartialBeanBinding
public interface IdeaServiceClient {
    @GET
    @Path("/ideas")
    List&lt;Idea&gt; getAllIdeas();

    @POST
    @Path("/ideas")
    Idea createIdea(Idea idea);
}

// Nachher: Quarkus REST Client
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;

@RegisterRestClient(configKey = "idea-service")
@Path("/ideas")
public interface IdeaServiceClient {
    @GET
    List&lt;Idea&gt; getAllIdeas();

    @POST
    Idea createIdea(Idea idea);
}
// Konfiguration via application.properties:
// quarkus.rest-client.idea-service.url=http://localhost:8080
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b> Der Quarkus REST Client basiert auf MicroProfile REST Client und bietet zusätzliche Features
wie automatische Service-Discovery, Fault-Tolerance-Integration und reaktive Varianten.
Die Abhängigkeit <span class='latex-texttt'>quarkus-rest-client</span> oder <span class='latex-texttt'>quarkus-rest-client-reactive</span> wird benötigt.</div>
 <b>Spring-CDI-Bridge:</b> <span class='latex-textit'>IdeaForkMicro</span> verwendet eine Spring-CDI-Bridge,
die es ermöglicht, Spring-Beans und CDI-Beans im selben Deployment zu verwenden.
Dieses Pattern wird häufig bei inkrementellen Migrationen eingesetzt,
wenn nicht alle Module gleichzeitig umgestellt werden können.<br /> <div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> Quarkus bietet keine Spring-CDI-Bridge.
Stattdessen bietet Quarkus die <span class='latex-texttt'>quarkus-spring-di</span>-Kompatibilitätsschicht,
die eine Teilmenge der Spring-DI-Annotationen (<span class='latex-texttt'>@Autowired</span>,
<span class='latex-texttt'>@Component</span>, <span class='latex-texttt'>@Service</span>, <span class='latex-texttt'>@Repository</span>, <span class='latex-texttt'>@Configuration</span>)
direkt in ArC-Beans übersetzt.
Dies erlaubt eine Migration von Spring-Annotationen zu CDI ohne gleichzeitige Nutzung beider Container.
Für eine vollständige Koexistenz von Spring und CDI bietet Quarkus keinen Mechanismus.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.7'><span class='entry-number'>10.7</span> Interceptoren und Decoratoren</a> </h2>
 Interceptoren und Decoratoren gehören zu den zentralen Konzepten von CDI,
die wir in Kapitel 3 und 4 ausführlich behandelt haben.
In Quarkus funktionieren beide Konzepte grundsätzlich,
jedoch mit einigen wichtigen Unterschieden zur CDI-Full-Umgebung.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Der wichtigste Unterschied:
die Aktivierung über <span class='latex-texttt'>beans.xml</span> funktioniert in Quarkus nicht.
Stattdessen muss jeder Interceptor mit <span class='latex-texttt'>@Priority</span> annotiert werden,
um ihn global zu aktivieren.
Dies entspricht dem Ansatz, den CDI 1.1 als Alternative zur <span class='latex-texttt'>beans.xml</span>-Deklaration eingeführt hat.
Listing <a href='#!idx:/quarkus.html:fig:interceptor-migration'> Interceptor-Migration </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:interceptor-migration'></a>                     <pre><code>// Vorher: Aktivierung ueber beans.xml + Interceptor-Klasse
@Monitored
@Interceptor
public class MonitorInterceptor {
    @AroundInvoke
    public Object monitor(InvocationContext ctx) throws Exception {
        long start = System.currentTimeMillis();
        try {
            return ctx.proceed();
        } finally {
            long duration = System.currentTimeMillis() - start;
            Logger.getLogger(ctx.getTarget().getClass().getName())
                .info(ctx.getMethod().getName() + " took " + duration + "ms");
        }
    }
}

// Nachher: Aktivierung ueber @Priority
@Monitored
@Interceptor
@Priority(Interceptor.Priority.APPLICATION)
public class MonitorInterceptor {
    @AroundInvoke
    public Object monitor(InvocationContext ctx) throws Exception {
        long start = System.currentTimeMillis();
        try {
            return ctx.proceed();
        } finally {
            long duration = System.currentTimeMillis() - start;
            Logger.getLogger(ctx.getTarget().getClass().getName())
                .info(ctx.getMethod().getName() + " took " + duration + "ms");
        }
    }
}
</code></pre>
                </div>
<div class="tip"><b>Tipp: </b> <span class='latex-texttt'>@AroundInvoke</span> funktioniert in Quarkus identisch zu CDI Full.
Bestehende Interceptor-Logik kann unverändert übernommen werden.
Lediglich die Aktivierungsmethode ändert sich von <span class='latex-texttt'>beans.xml</span> zu <span class='latex-texttt'>@Priority</span>.</div>
Decoratoren werden von Quarkus ebenfalls unterstützt.
Wie bei Interceptoren muss die Aktivierung über <span class='latex-texttt'>@Priority</span> erfolgen
statt über die <span class='latex-texttt'>beans.xml</span>-Deklaration.
Eine Einschränkung besteht darin,
dass eingebaute CDI-Beans wie <span class='latex-texttt'>Event</span> nicht dekoriert werden können.<br /> <div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> <span class='latex-texttt'>InterceptionFactory</span>,
die wir in Kapitel 4 als programmatische Alternative zur Interceptor-Bindung kennengelernt haben,
wird von Quarkus nicht unterstützt.
Als Alternative bietet Quarkus <span class='latex-texttt'>InterceptionProxy</span>,
mit dem Interceptoren programmatisch an einzelne Bean-Instanzen gebunden werden können.</div>
<div class="tip"><b>Tipp: </b>Quarkus ArC bietet seit Version 3.x experimentelle Unterstützung für Decoratoren. Diese muss explizit aktiviert werden (<span class='latex-texttt'>quarkus.arc.transform-unproxyable-classes=true</span>). Die Unterstützung ist jedoch nicht vollständig &mdash; insbesondere Decoratoren mit generischen Typen können Probleme verursachen. Für kritische Anwendungsfälle empfiehlt sich weiterhin das Interceptor-Pattern als zuverlässige Alternative.</div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.8'><span class='entry-number'>10.8</span> Native Images mit GraalVM</a> </h2>
 Einer der Hauptgründe für den Einsatz von Quarkus ist die Möglichkeit,
Java-Applikationen als Native Images zu kompilieren.
GraalVM Native Image übersetzt Java-Bytecode in nativen Maschinencode und
erzeugt eine einzelne ausführbare Datei ohne Abhängigkeit von einer JVM.
Das Ergebnis sind Startzeiten im Millisekundenbereich und ein drastisch reduzierter Speicherverbrauch.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Native Images basieren auf der <span class='latex-textit'>Closed-World-Annahme</span>:
der gesamte zur Laufzeit erreichbare Code muss zur Build-Zeit bekannt sein.
Reflection, dynamisches Laden von Klassen und andere dynamische Java-Features funktionieren nur,
wenn die betroffenen Klassen explizit registriert werden.
ArC ist für dieses Modell optimiert, da es bereits zur Build-Zeit alle Beans auflöst.<br /> <div class="tip"><b>Tipp: </b> Verwenden Sie <span class='latex-texttt'>@RegisterForReflection</span>,
um Klassen für Reflection im Native Image zu registrieren.
Dies ist besonders wichtig für DTOs und Entity-Klassen,
die über JSON-Serialisierung oder JPA verwendet werden.
Listing <a href='#!idx:/quarkus.html:fig:register-reflection'> @RegisterForReflection </a> zeigt die Verwendung.</div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:register-reflection'></a>                     <pre><code>import io.quarkus.runtime.annotations.RegisterForReflection;

@RegisterForReflection
public class IdeaDto {
    private String title;
    private String description;

    // Getter und Setter
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    public String getDescription() { return description; }
    public void setDescription(String description) {
        this.description = description;
    }
}
</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> Statische Singleton-Felder, die zur Laufzeit initialisiert werden,
können im Native Image zu unerwarteten Ergebnissen führen.
GraalVM initialisiert bestimmte Klassen zur Build-Zeit,
wodurch Laufzeitwerte als Build-Zeit-Konstanten eingefroren werden.
Verwenden Sie stattdessen CDI-Beans mit <span class='latex-texttt'>@ApplicationScoped</span>.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b> Private CDI-Felder vergrößern das Native Image,
da ArC zusätzliche Reflection-Metadaten generieren muss.
Verwenden Sie package-private Felder für Injection-Points,
um die Image-Größe zu minimieren.</div>
<div class="tip"><b>Tipp: </b><b>Häufige Probleme bei Native Images:</b><br />
&bull; <b>Reflection:</b> Klassen, die per Reflection geladen werden (z.B. JPA-Entitäten), müssen in <span class='latex-texttt'>reflect-config.json</span> registriert sein. Quarkus erledigt dies automatisch für annotierte Klassen, aber eigene dynamische Aufrufe erfordern <span class='latex-texttt'>@RegisterForReflection</span>.<br />
&bull; <b>Ressourcen:</b> Dateien, die zur Laufzeit geladen werden, müssen über <span class='latex-texttt'>quarkus.native.resources.includes</span> eingebunden werden.<br />
&bull; <b>Serialisierung:</b> Klassen, die serialisiert werden, benötigen eine explizite Registrierung über <span class='latex-texttt'>@RegisterForReflection(serialization = true)</span>.<br />
&bull; <b>Startzeit:</b> Ein natives Image von <span class='latex-textit'>IdeaFork</span> startet typischerweise in unter 100ms &mdash; verglichen mit mehreren Sekunden im JVM-Modus.</div>
 Für den Applikationsstart bietet Quarkus das Event <span class='latex-texttt'>StartupEvent</span>,
das den CDI-Full-Ansatz mit <span class='latex-texttt'>@Initialized(ApplicationScoped.class)</span> ersetzt.
Listing <a href='#!idx:/quarkus.html:fig:startup-event'> StartupEvent statt @Initialized </a> zeigt die Umstellung.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:startup-event'></a>                     <pre><code>// Vorher: CDI Full @Initialized
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.context.Initialized;
import jakarta.enterprise.event.Observes;

@ApplicationScoped
public class AppInitializer {
    void onStartup(
            @Observes @Initialized(ApplicationScoped.class) Object event) {
        // Initialisierungslogik
    }
}

// Nachher: Quarkus StartupEvent
import io.quarkus.runtime.StartupEvent;
import jakarta.enterprise.event.Observes;

@ApplicationScoped
public class AppInitializer {
    void onStartup(@Observes StartupEvent event) {
        // Initialisierungslogik
    }
}
</code></pre>
                </div>
<h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.9'><span class='entry-number'>10.9</span> IdeaFork auf Quarkus migrieren</a> </h2>
 Nachdem wir die einzelnen Migrationsaspekte betrachtet haben,
fassen wir die Schritte für die Migration von <span class='latex-textit'>IdeaFork</span> zu Quarkus in einer Checkliste zusammen.
Die Checkliste orientiert sich an der Struktur von Abschnitt 9.8 und
ergänzt die dort beschriebene Jakarta-EE-Migration um die Quarkus-spezifischen Anpassungen.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/quarkus.html:fig:migration-checklist'> IdeaFork Quarkus-Migrations-Checkliste </a> zeigt die wesentlichen Schritte.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:migration-checklist'></a>                     <pre><code>IdeaFork Quarkus-Migrations-Checkliste
======================================

1. Maven-Abhaengigkeiten umstellen
   - Jakarta EE BOM     -> io.quarkus.platform:quarkus-bom
   - DeltaSpike Core    -> (entfaellt, durch Quarkus/ArC abgedeckt)
   - DeltaSpike Data    -> io.quarkus:quarkus-hibernate-orm-panache
   - DeltaSpike Security -> io.quarkus:quarkus-smallrye-jwt
   - DeltaSpike Scheduler -> io.quarkus:quarkus-scheduler
   - DeltaSpike Test-Control -> io.quarkus:quarkus-junit5

2. beans.xml bereinigen
   - Interceptor- und Decorator-Deklarationen entfernen
   - Datei kann geloescht oder als leeres Skelett beibehalten werden
   - Interceptoren/Decoratoren stattdessen mit @Priority aktivieren

3. Scopes pruefen und anpassen
   - Alle Beans muessen eine Scope-Annotation tragen
   - @SessionScoped -> @RequestScoped + JWT oder externer State
   - @ConversationScoped -> @RequestScoped + explizite Zustandsuebergabe
   - @TransactionScoped EntityManager -> Panache oder @Inject EntityManager
   - Custom-Scopes (@ConfigScoped) -> @ApplicationScoped + manuelle Aktualisierung
   - DeltaSpike-Scopes entfernen (kein Aequivalent in Quarkus)

4. Konfiguration migrieren
   - DeltaSpike @ConfigProperty -> MicroProfile @ConfigProperty
   - ConfigResolver -> ConfigProvider.getConfig()
   - ProjectStage -> Quarkus-Profile (%dev., %test., %prod.)
   - @Exclude -> @IfBuildProfile / @UnlessBuildProfile
   - PropertyFileConfig -> MicroProfile ConfigSource SPI
   - apache-deltaspike.properties -> application.properties
   - Dynamische ConfigSource-Registrierung entfaellt (nur statisch via SPI)

5. DeltaSpike-Module ersetzen
   - @Repository -> PanacheRepository
   - @Secured -> @RolesAllowed / @Authenticated
   - @Scheduled (Klasse) -> @Scheduled (Methode)
   - CdiTestRunner -> @QuarkusTest
   - BeanProvider -> Arc.container().instance()
   - @PartialBeanBinding/@TypedConfig -> @ConfigMapping (SmallRye)
   - @PartialBeanBinding/@ResourceClient -> @RegisterRestClient (MicroProfile)
   - Spring-CDI-Bridge -> quarkus-spring-di (Kompatibilitaetsschicht)

6. Extensions migrieren
   - Portable CDI Extensions -> Quarkus @BuildStep
   - Alternativ: Build Compatible Extensions (CDI 4.0)
   - META-INF/services-Eintraege aktualisieren

7. Interceptoren und Decoratoren anpassen
   - beans.xml-Deklarationen entfernen
   - @Priority zu allen Interceptoren/Decoratoren hinzufuegen
   - InterceptionFactory -> InterceptionProxy

8. Native-Image-Kompatibilitaet sicherstellen
   - @RegisterForReflection fuer DTOs und Entities
   - Private Injection-Points auf package-private umstellen
   - Statische Singletons durch CDI-Beans ersetzen
   - @Observes StartupEvent statt @Initialized verwenden

9. Tests migrieren
   - @RunWith(CdiTestRunner.class) -> @QuarkusTest
   - JUnit 4 -> JUnit 5
   - Meecrowave-Tests -> @QuarkusTest mit REST-Assured
</code></pre>
                </div>
Wie bei der Jakarta-EE-Migration in Kapitel 9 empfiehlt es sich,
die Schritte einzeln durchzuführen und nach jedem Schritt die Testsuite auszuführen.
Die Migration zu Quarkus ist umfangreicher als die reine Namespace-Migration,
da nicht nur Imports sondern auch Architekturentscheidungen betroffen sind.<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p> Listing <a href='#!idx:/quarkus.html:fig:pom-migration'> pom.xml-Umstellung </a> zeigt die wesentlichen Änderungen an der Maven-Konfiguration.<br /> <div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/quarkus.html:fig:pom-migration'></a>                     <pre><code>&lt;!-- Vorher: Jakarta EE + DeltaSpike --&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;
            &lt;artifactId&gt;jakarta.jakartaee-bom&lt;/artifactId&gt;
            &lt;version&gt;10.0.0&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;!-- Nachher: Quarkus BOM --&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkus.platform&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-bom&lt;/artifactId&gt;
            &lt;version&gt;3.17.5&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
                </div>
Die Migration von <span class='latex-textit'>IdeaFork</span> zu Quarkus zeigt exemplarisch,
dass der Übergang von einer CDI-Full/DeltaSpike-Applikation zu einem Quarkus-basierten Microservice
deutlich tiefgreifender ist als die reine Namespace-Migration zu Jakarta EE.
Während die in den bisherigen Kapiteln erarbeiteten CDI-Grundkonzepte wie
typsichere Injection, Qualifier, Interceptoren und Events auch in Quarkus ihre Gültigkeit behalten,
erfordern die Build-Zeit-Verarbeitung durch ArC und die Ausrichtung auf Cloud-native Architekturen
ein Umdenken bei der Anwendungsstruktur.
DeltaSpike-Features, die eng an CDI Full oder JSF gekoppelt sind,
müssen durch MicroProfile- und Quarkus-spezifische Alternativen ersetzt werden.
Der Aufwand wird jedoch durch die Vorteile belohnt:
schnelle Startzeiten, geringer Speicherverbrauch und die Möglichkeit,
Java-Applikationen als Native Images auszuliefern.
<br /> <h2><a class='latex-index-anchor' name='!idx:/quarkus.html:10.10'><span class='entry-number'>10.10</span> Quellen</a> </h2>
<b>Quellen:</b><br />
- quarkus.io<br />
- quarkus.io/guides/cdi-reference<br />
- microprofile.io<br />
- jakarta.ee<br />
- cdi-spec.org<br />
- deltaspike.apache.org<br />
- smallrye.io<br />
- graalvm.org<br />
</section>
<section class="chapter-section" id="chapter-11">
<h1> <a class='latex-index-anchor' name='!idx:/angular.html:11'><span class='entry-number'>11</span> Von JSF zu Angular</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Dieses Kapitel wurde von Claude (AI built by Anthropic) auf Basis der vorherigen Kapitel verfasst. Es beschreibt die Migration des JSF-Frontends von IdeaFork zu einer Angular Single-Page Application. Die Codebeispiele orientieren sich an den IdeaForkMicro-Modulen aus Kapitel 8.
</div>
<a name = '!idx:/angular.html:chap:angular-migration'> </a><h2><a class='latex-index-anchor' name='!idx:/angular.html:11.1'><span class='entry-number'>11.1</span> Ein neues Frontend</a> </h2>
 In den bisherigen Kapiteln haben wir das Backend von <span class='latex-textit'>IdeaFork</span> schrittweise modernisiert:
Kapitel 9 hat die Migration zu Jakarta EE begleitet, Kapitel 10 den Wechsel zu Quarkus vollzogen.
Dabei wurde in Kapitel 10 explizit davor gewarnt, dass die DeltaSpike-Scopes
<span class='latex-texttt'>@ViewAccessScoped</span>, <span class='latex-texttt'>@WindowScoped</span> und
<span class='latex-texttt'>@GroupedConversationScoped</span> in Quarkus kein Äquivalent haben,
da sie eng an JSF und das Konzept von Browser-Fenstern gekoppelt sind.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Diese Warnung zeigt den grundlegenden Architekturwechsel auf:
JSF ist ein serverseitiges UI-Framework, bei dem der Zustand auf dem Server gehalten wird.
Jede Benutzerinteraktion erzeugt einen HTTP-Postback, der Server rendert die neue Seite und sendet den kompletten HTML-Code zurück.
Die DeltaSpike-Scopes wie <span class='latex-texttt'>@ViewAccessScoped</span> verwalten dabei den Zustand
zwischen aufeinanderfolgenden Requests im Server-Speicher.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Angular verfolgt einen fundamental anderen Ansatz:
Als Single-Page Application (SPA) läuft die gesamte UI-Logik im Browser des Benutzers.
Der Server liefert beim ersten Aufruf die Angular-Applikation als statische Dateien aus,
danach kommuniziert die Applikation nur noch über REST-APIs mit dem Backend.
Der Zustand wird clientseitig verwaltet — in Komponenten, Services und Signals.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Der entscheidende Vorteil für unsere Migration:
Das REST-Backend existiert bereits.
In Kapitel 8 haben wir mit <span class='latex-textit'>IdeaForkMicro</span> die Backend-Services als
REST-Endpoints exponiert und über <span class='latex-texttt'>@ResourceClient</span>-Interfaces angesprochen.
In Kapitel 10 wurden diese Services zu Quarkus migriert.
Angular ersetzt nun ausschließlich den JSF-UI-Layer und ruft dieselben REST-APIs direkt auf.
<div class="tip"><b>Tipp: </b>Während der Entwicklung kann der Angular CLI Dev-Server
mit einem Proxy zum Quarkus-Backend konfiguriert werden.
In der Datei <span class='latex-texttt'>proxy.conf.json</span> wird der Pfad
<span class='latex-texttt'>/api/*</span> auf den Quarkus-Server (z.B.
<span class='latex-texttt'>http://localhost:8080</span>) umgeleitet,
sodass Angular und Quarkus unabhängig entwickelt und getestet werden können.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Ein Angular-Projekt wird mit der Angular CLI erstellt (<span class='latex-texttt'>ng new ideafork-ui</span>),
mit <span class='latex-texttt'>ng serve</span> im Entwicklungsmodus gestartet und mit <span class='latex-texttt'>ng build</span>
für die Produktion kompiliert.
Die zentrale Konfigurationsdatei ist <span class='latex-texttt'>app.config.ts</span>, in der Router,
HttpClient und Interceptors registriert werden.
Diese Datei übernimmt damit eine ähnliche Rolle wie die
<span class='latex-texttt'>beans.xml</span> und <span class='latex-texttt'>web.xml</span> einer Java-EE-Applikation:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-app-config'></a>                     <pre><code>// app.config.ts (Angular)
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { routes } from './app.routes';
import { authInterceptor } from './auth/auth.interceptor';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(withInterceptors([authInterceptor]))
  ]
};</code></pre>
                </div>
Die Routen werden in Abschnitt 11.3 definiert, der Interceptor in Abschnitt 11.6.
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.2'><span class='entry-number'>11.2</span> Von JSF-Seiten zu Angular-Komponenten</a> </h2>
In <span class='latex-textit'>IdeaFork</span> besteht die Oberfläche aus XHTML-Facelets-Seiten,
die über ein Master-Template (<span class='latex-texttt'>main-template.xhtml</span> mit
<span class='latex-texttt'>ui:insert</span>) eine einheitliche Struktur erhalten.
Jede Seite wird durch ein CDI-Bean gesteuert, das mit <span class='latex-texttt'>@Named</span> annotiert
und über EL-Ausdrücke (<span class='latex-texttt'>#{bean.property}</span>) an die Oberfläche gebunden ist.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Bevor wir die Angular-Seite betrachten, ein kurzer Überblick für Java-Entwickler:
Angular verwendet <span class='latex-textit'>TypeScript</span>, eine typisierte Obermenge von JavaScript.
Decorators (<span class='latex-texttt'>@Component</span>) funktionieren wie Java-Annotationen,
Generics verwenden dieselbe <span class='latex-texttt'>&lt;T&gt;</span>-Syntax,
Arrow-Funktionen (<span class='latex-texttt'>=&gt;</span>) entsprechen Lambdas,
und Typen stehen nach dem Namen (<span class='latex-texttt'>name: string</span> statt <span class='latex-texttt'>String name</span>).
Die Dependency Injection folgt einem bekannten Muster:
<span class='latex-texttt'>inject(Service)</span> entspricht CDIs <span class='latex-texttt'>@Inject</span>,
<span class='latex-texttt'>@Injectable({ providedIn: 'root' })</span> entspricht <span class='latex-texttt'>@ApplicationScoped</span>,
und Angulars Injector-Hierarchie (Root → Route → Komponente) spiegelt CDIs Scope-Hierarchie wider.
<span class='latex-texttt'>standalone: true</span> bedeutet, dass eine Komponente ohne Modul-Registrierung funktioniert —
vergleichbar mit annotierter Bean-Discovery ohne <span class='latex-texttt'>beans.xml</span>-Einträge.
Für die Templates gilt: <span class='latex-texttt'>{{ }}</span> = Ausgabe (wie <span class='latex-texttt'>h:outputText</span>),
<span class='latex-texttt'>[prop]="expr"</span> = Property-Binding (Daten an Kind-Element),
<span class='latex-texttt'>(event)="fn()"</span> = Event-Binding (wie <span class='latex-texttt'>action="#{...}"</span>).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
In Angular wird jede Seite durch eine Standalone-Komponente abgebildet.
Eine Komponente besteht aus einer TypeScript-Klasse (Logik),
einem HTML-Template (Darstellung) und optionalem CSS (Styling).
Das Master-Template wird durch eine Layout-Komponente mit <span class='latex-texttt'>&lt;router-outlet /&gt;</span> ersetzt,
wobei der Angular Router die jeweilige Seiten-Komponente in den Outlet einsetzt.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die folgenden Code-Beispiele verwenden Angulars <span class='latex-textit'>Signals</span> — ein reaktives Primitiv,
das seit Angular 16 verfügbar ist. Ein Signal kapselt einen Wert und benachrichtigt
das Framework bei Änderungen. <span class='latex-texttt'>signal&lt;Idea[]&gt;([])</span> erzeugt ein Signal mit
Initialwert (leeres Array). Gelesen wird mit Klammern: <span class='latex-texttt'>ideas()</span>,
geschrieben mit <span class='latex-texttt'>ideas.set(newValue)</span>.
<span class='latex-texttt'>computed(() =&gt; ...)</span> leitet einen Wert ab, der sich automatisch aktualisiert.
Der Vergleich zu JSF: Dort rendert der Server die gesamte Seite bei jedem Postback neu.
Angular nutzt Signals, um nur die betroffenen Template-Stellen zu aktualisieren.
<div class="tip"><b>Tipp: </b>Signals sind seit Angular 16 der empfohlene Weg für reaktiven Zustand.
Die Funktion <span class='latex-texttt'>signal()</span> entspricht konzeptionell einem CDI-Producer,
der seinen Wert über <span class='latex-texttt'>@Observes</span> propagiert —
nur clientseitig und in Echtzeit.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die folgende Gegenüberstellung zeigt die IdeaFork-Startseite — zuerst als JSF-Seite,
dann als Angular-Komponente:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-index-page'></a>                     <pre><code>&lt;!-- index.xhtml (JSF) --&gt;
&lt;ui:composition template="/main-template.xhtml"&gt;
  &lt;ui:define name="content"&gt;
    &lt;h:form id="ideaForm"&gt;
      &lt;h:outputText value="#{ideaController.welcomeMessage}" /&gt;
      &lt;ui:repeat var="idea" value="#{ideaController.ideas}"&gt;
        &lt;div class="idea-card"&gt;
          &lt;h3&gt;#{idea.title}&lt;/h3&gt;
          &lt;p&gt;#{idea.description}&lt;/p&gt;
        &lt;/div&gt;
      &lt;/ui:repeat&gt;
    &lt;/h:form&gt;
  &lt;/ui:define&gt;
&lt;/ui:composition&gt;</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-index-component'></a>                     <pre><code>// home.component.ts (Angular)
@Component({
  selector: 'app-home',
  standalone: true,
  imports: [CommonModule],
  template: `
    &lt;p&gt;{{ welcomeMessage }}&lt;/p&gt;
    @for (idea of ideas(); track idea.id) {
      &lt;div class="idea-card"&gt;
        &lt;h3&gt;{{ idea.title }}&lt;/h3&gt;
        &lt;p&gt;{{ idea.description }}&lt;/p&gt;
      &lt;/div&gt;
    }
  `
})
export class HomeComponent implements OnInit {
  welcomeMessage = 'Welcome to IdeaFork';
  ideas = signal&lt;Idea[]&gt;([]);

  private ideaService = inject(IdeaService);

  ngOnInit() {
    this.ideaService.getIdeas().subscribe(
      data =&gt; this.ideas.set(data)
    );
  }
}</code></pre>
                </div>
Die EL-Ausdrücke (<span class='latex-texttt'>#{...}</span>) werden durch Angular Template-Bindings
(<span class='latex-texttt'>{{ ... }}</span>) ersetzt.
Die JSF-Komponente <span class='latex-texttt'>ui:repeat</span> wird durch den neuen Angular Control-Flow
<span class='latex-texttt'>@for</span> abgelöst, der seit Angular 17 den bisherigen
<span class='latex-texttt'>*ngFor</span>-Ansatz ersetzt.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
JSF-Composite-Komponenten wie <span class='latex-texttt'>formGroup.xhtml</span> werden zu
wiederverwendbaren Angular-Komponenten.
In <span class='latex-textit'>IdeaFork</span> kapselt die Composite-Komponente ein Label mit einem
konditionalen Eingabefeld (Text, Password oder Textarea):
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-composite-component'></a>                     <pre><code>&lt;!-- formGroup.xhtml (JSF Composite Component) --&gt;
&lt;cc:interface&gt;
  &lt;cc:attribute name="label" /&gt;
  &lt;cc:attribute name="value" /&gt;
  &lt;cc:attribute name="type" default="text" /&gt;
&lt;/cc:interface&gt;
&lt;cc:implementation&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel value="#{cc.attrs.label}" /&gt;
    &lt;h:inputSecret value="#{cc.attrs.value}"
                   rendered="#{cc.attrs.type == 'password'}" /&gt;
    &lt;h:inputText value="#{cc.attrs.value}"
                 rendered="#{cc.attrs.type == 'text'}" /&gt;
    &lt;h:inputTextarea value="#{cc.attrs.value}"
                     rendered="#{cc.attrs.type == 'textarea'}" /&gt;
  &lt;/div&gt;
&lt;/cc:implementation&gt;</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-form-field-component'></a>                     <pre><code>// form-field.component.ts (Angular)
@Component({
  selector: 'app-form-field',
  standalone: true,
  imports: [ReactiveFormsModule],
  template: `
    &lt;div class="form-group"&gt;
      &lt;label&gt;{{ label() }}&lt;/label&gt;
      @switch (type()) {
        @case ('password') {
          &lt;input type="password" [formControl]="control()" /&gt;
        }
        @case ('textarea') {
          &lt;textarea [formControl]="control()"&gt;&lt;/textarea&gt;
        }
        @default {
          &lt;input type="text" [formControl]="control()" /&gt;
        }
      }
    &lt;/div&gt;
  `
})
export class FormFieldComponent {
  label = input.required&lt;string&gt;();
  type = input&lt;string&gt;('text');
  control = input.required&lt;FormControl&gt;();
}</code></pre>
                </div>
Die JSF-Attribute <span class='latex-texttt'>rendered</span> werden durch den Angular
<span class='latex-texttt'>@switch</span>-Control-Flow ersetzt.
Die Eingabewerte werden nicht mehr über EL-Bindings mit einem Backing-Bean verbunden,
sondern über Angular Reactive Forms (<span class='latex-texttt'>FormControl</span>) gesteuert.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die Syntax <span class='latex-texttt'>input.required&lt;string&gt;()</span> in der <span class='latex-texttt'>FormFieldComponent</span>
verwendet Signal-basierte Inputs (seit Angular 17). Sie entsprechen
<span class='latex-texttt'>cc:attribute</span> in JSF Composite Components — die Eltern-Komponente übergibt
den Wert über <span class='latex-texttt'>[label]="'Titel'"</span>.
Die Methode <span class='latex-texttt'>subscribe()</span>, die in späteren Beispielen auftaucht,
startet den asynchronen REST-Aufruf — Observables werden in Abschnitt 11.7 ausführlich behandelt.
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.3'><span class='entry-number'>11.3</span> Navigation: ViewConfig zu Angular Router</a> </h2>
In <span class='latex-textit'>IdeaFork</span> wird die Navigation über die DeltaSpike
<span class='latex-texttt'>ViewConfig</span>-Klassenhierarchie definiert.
Jede Seite ist als Interface in einer verschachtelten Struktur abgebildet,
die Ordner und Seitenbeziehungen typsicher beschreibt.
Die Navigation erfolgt, indem ein Controller die entsprechende
<span class='latex-texttt'>ViewConfig</span>-Klasse zurückgibt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-viewconfig'></a>                     <pre><code>// ViewConfig-Hierarchie (DeltaSpike)
public interface Pages extends ViewConfig {
    @View(navigation = REDIRECT)
    class Index implements Pages {}

    interface Idea extends Pages {
        class List implements Idea {}
        class Detail implements Idea {}
    }

    interface User extends Pages {
        class Login implements User {}
        class Registration implements User {}
    }

    interface Promotion extends Pages {
        @View(name = "step1")
        class Step1 implements Promotion {}
        @View(name = "step2")
        class Step2 implements Promotion {}
        @View(name = "step3")
        class Step3 implements Promotion {}
    }
}</code></pre>
                </div>
In Angular wird die Navigation über ein <span class='latex-texttt'>Routes</span>-Array definiert,
das jede URL einem Standalone-Component zuordnet.
Lazy Loading mit <span class='latex-texttt'>loadComponent</span> sorgt dafür, dass Komponenten
erst bei Bedarf geladen werden — ein Konzept, das in JSF nicht existiert,
da dort alle Seiten vom Server bereitgestellt werden:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-routes'></a>                     <pre><code>// app.routes.ts (Angular)
export const routes: Routes = [
  { path: '', redirectTo: 'home', pathMatch: 'full' },
  {
    path: 'home',
    loadComponent: () =&gt;
      import('./home/home.component').then(m =&gt; m.HomeComponent)
  },
  {
    path: 'ideas',
    children: [
      {
        path: '',
        loadComponent: () =&gt;
          import('./idea/idea-list.component').then(m =&gt; m.IdeaListComponent)
      },
      {
        path: ':id',
        loadComponent: () =&gt;
          import('./idea/idea-detail.component').then(m =&gt; m.IdeaDetailComponent)
      }
    ]
  },
  {
    path: 'user',
    children: [
      { path: 'login', loadComponent: () =&gt;
          import('./user/login.component').then(m =&gt; m.LoginComponent) },
      { path: 'register', loadComponent: () =&gt;
          import('./user/registration.component').then(m =&gt; m.RegistrationComponent) }
    ]
  },
  {
    path: 'promotion',
    canActivate: [authGuard],
    children: [
      { path: 'step1', loadComponent: () =&gt;
          import('./promotion/step1.component').then(m =&gt; m.Step1Component) },
      { path: 'step2', loadComponent: () =&gt;
          import('./promotion/step2.component').then(m =&gt; m.Step2Component) },
      { path: 'step3', loadComponent: () =&gt;
          import('./promotion/step3.component').then(m =&gt; m.Step3Component) }
    ]
  }
];</code></pre>
                </div>
Die typsichere Navigation über <span class='latex-texttt'>ViewConfig</span>-Klassen wird durch
<span class='latex-texttt'>Router.navigate()</span> ersetzt.
Während in JSF die Methode eines Controllers eine ViewConfig-Klasse zurückgibt
und der DeltaSpike-Navigationshandler den Redirect ausführt,
navigiert Angular clientseitig ohne Server-Roundtrip:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-navigation'></a>                     <pre><code>// Navigation in JSF (DeltaSpike)
@Named
@ViewAccessScoped
public class IdeaController implements Serializable {
    public Class&lt;? extends ViewConfig&gt; showDetail(Idea idea) {
        this.selectedIdea = idea;
        return Pages.Idea.Detail.class;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-navigation'></a>                     <pre><code>// Navigation in Angular
@Component({ /* ... */ })
export class IdeaListComponent {
  private router = inject(Router);

  showDetail(idea: Idea) {
    this.router.navigate(['/ideas', idea.id]);
  }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Für eine typsichere Navigation können in Angular
Routen-Konstanten definiert werden, die das manuelle Zusammenbauen von URL-Strings vermeiden:
<span class='latex-texttt'>export const ROUTES = { ideas: '/ideas', ideaDetail: (id: number) =&gt; &#96;/ideas/${id}&#96; }</span>.
Dies bietet eine ähnliche Sicherheit wie die DeltaSpike ViewConfig-Hierarchie.</div>
<div class="tip"><b>Tipp: </b>Statische Routen wie <span class='latex-texttt'>/tasks/new</span> müssen vor parametrisierten Routen wie <span class='latex-texttt'>/tasks/:id</span> definiert werden. Andernfalls interpretiert der Router den String &bdquo;new&ldquo; als <span class='latex-texttt'>:id</span>-Parameter, was zu einem fehlgeschlagenen API-Aufruf führt, der eine Aufgabe mit der ID &bdquo;new&ldquo; sucht.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.4'><span class='entry-number'>11.4</span> Scopes und Lebenszyklus</a> </h2>
In Kapitel 10 wurde gewarnt, dass die DeltaSpike-Scopes
<span class='latex-texttt'>@ViewAccessScoped</span>, <span class='latex-texttt'>@WindowScoped</span> und
<span class='latex-texttt'>@GroupedConversationScoped</span> in Quarkus kein Äquivalent haben.
Mit dem Wechsel zu Angular erhalten diese Scopes nun passende Entsprechungen —
allerdings clientseitig statt serverseitig:
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<b>@ViewAccessScoped</b> — In <span class='latex-textit'>IdeaFork</span> verwenden zehn View-Controller
diesen Scope (siehe Kapitel 5).
Ein <span class='latex-texttt'>@ViewAccessScoped</span> Bean existiert, solange auf es in aufeinanderfolgenden
JSF-Requests zugegriffen wird.
In Angular wird dieser Scope natürlich durch den Komponenten-Lebenszyklus abgebildet:
Eine Komponente wird vom Router erzeugt, wenn der Benutzer die entsprechende Route aufruft,
und zerstört, wenn er sie verlässt. Der Zustand lebt in den Feldern der Komponente.
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-viewaccessscoped'></a>                     <pre><code>// JSF: @ViewAccessScoped Controller
@Named
@ViewAccessScoped
public class IdeaListController implements Serializable {
    @Inject
    private IdeaRepository ideaRepository;

    private List&lt;Idea&gt; ideas;

    @PreRenderView
    public void init() {
        this.ideas = ideaRepository.findAll();
    }

    public List&lt;Idea&gt; getIdeas() {
        return ideas;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-component-lifecycle'></a>                     <pre><code>// Angular: Komponenten-Lebenszyklus
@Component({
  selector: 'app-idea-list',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './idea-list.component.html'
})
export class IdeaListComponent implements OnInit {
  ideas = signal&lt;Idea[]&gt;([]);

  private ideaService = inject(IdeaService);

  ngOnInit() {
    this.ideaService.getIdeas().subscribe(
      data =&gt; this.ideas.set(data)
    );
  }
}</code></pre>
                </div>
<b>@WindowScoped</b> — Die Klassen <span class='latex-texttt'>BackNavigator</span> und
<span class='latex-texttt'>EntryPointHandler</span> verwenden <span class='latex-texttt'>@WindowScoped</span>,
um Zustand pro Browser-Fenster zu halten.
In Angular wird dies durch einen Service mit <span class='latex-texttt'>providedIn: 'root'</span>
abgebildet. Da eine Angular-Applikation bereits pro Browser-Tab isoliert ist,
entspricht ein Root-Singleton einem <span class='latex-texttt'>@WindowScoped</span> Bean:
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<b>@GroupedConversationScoped</b> — Der Promotion-Wizard verwendet diesen Scope,
um Zustand über mehrere Wizard-Schritte hinweg zu halten.
In Angular wird dies durch einen Service abgebildet, der auf den Feature-Routen-Subtree
beschränkt wird und beim Verlassen des Wizards zurückgesetzt wird:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-grouped-conversation'></a>                     <pre><code>// JSF: @GroupedConversationScoped Wizard
@Named
@GroupedConversationScoped
public class PromotionWizardController implements Serializable {
    @Inject
    private GroupedConversation conversation;

    private Idea selectedIdea;
    private PromotionType promotionType;

    public Class&lt;? extends ViewConfig&gt; nextStep() {
        return Pages.Promotion.Step2.class;
    }

    public Class&lt;? extends ViewConfig&gt; finish() {
        conversation.close();
        return Pages.Idea.List.class;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-wizard-service'></a>                     <pre><code>// Angular: Wizard-Service mit Route-Scoping
@Injectable()
export class PromotionWizardService implements OnDestroy {
  selectedIdea = signal&lt;Idea | null&gt;(null);
  promotionType = signal&lt;PromotionType | null&gt;(null);

  reset() {
    this.selectedIdea.set(null);
    this.promotionType.set(null);
  }

  ngOnDestroy() {
    this.reset();
  }
}</code></pre>
                </div>
<b>@SessionScoped</b> — Der <span class='latex-texttt'>JsfIdentityHolder</span> verwaltet die
Benutzeridentität in der HTTP-Session.
In Angular wird dies durch einen <span class='latex-texttt'>AuthService</span> mit
<span class='latex-texttt'>providedIn: 'root'</span> ersetzt,
der ein JWT im <span class='latex-texttt'>localStorage</span> speichert.
Der Zustand wird über Signals reaktiv bereitgestellt.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die JSF-Lifecycle-Annotation <span class='latex-texttt'>@PreRenderView</span> wird durch den Angular-Lifecycle-Hook
<span class='latex-texttt'>ngOnInit()</span> ersetzt, der aufgerufen wird, sobald die Komponente initialisiert ist.
<div class="tip"><b>Tipp: </b>Die Dependency-Injection-Hierarchie von Angular ermöglicht
es, Services auf Routen-Subtrees zu beschränken — ähnlich wie
<span class='latex-texttt'>@GroupedConversationScoped</span>.
Durch die Angabe von <span class='latex-texttt'>providers: [PromotionWizardService]</span>
in der Routen-Konfiguration wird eine neue Instanz pro Wizard-Durchlauf erzeugt.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>Anders als CDI-Scopes, die vom Container verwaltet werden,
sind Angular-Services mit <span class='latex-texttt'>providedIn: 'root'</span> standardmäßig
Singletons, die für die gesamte Lebensdauer der Applikation existieren.
Explizites Aufräumen über <span class='latex-texttt'>ngOnDestroy()</span> oder das Zurücksetzen von
Signals liegt in der Verantwortung des Entwicklers.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Das folgende Beispiel zeigt die konkrete Routen-Konfiguration für den Promotion-Wizard
mit einem route-scoped Provider:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-route-providers'></a>                     <pre><code>// app.routes.ts (Auszug): Route-scoped Service
{
  path: 'promotion',
  providers: [PromotionWizardService],
  canActivate: [authGuard],
  children: [
    { path: 'step1', loadComponent: () =&gt;
        import('./promotion/step1.component').then(m =&gt; m.Step1Component) },
    { path: 'step2', canActivate: [wizardStepGuard], loadComponent: () =&gt;
        import('./promotion/step2.component').then(m =&gt; m.Step2Component) },
    { path: 'step3', canActivate: [wizardStepGuard], loadComponent: () =&gt;
        import('./promotion/step3.component').then(m =&gt; m.Step3Component) }
  ]
}</code></pre>
                </div>
Durch <span class='latex-texttt'>providers: [PromotionWizardService]</span> auf dem
<span class='latex-texttt'>promotion</span>-Pfad erzeugt Angular eine eigene Injector-Ebene
für diesen Routen-Subtree. Beim Verlassen des Subtrees wird die Instanz zerstört —
das exakte Verhalten von <span class='latex-texttt'>@GroupedConversationScoped</span>.
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.5'><span class='entry-number'>11.5</span> Formulare und Validierung</a> </h2>
In JSF werden Formulare mit <span class='latex-texttt'>h:form</span>,
<span class='latex-texttt'>h:inputText</span> und <span class='latex-texttt'>h:commandButton</span> aufgebaut.
Die Validierung erfolgt serverseitig über Bean Validation
(<span class='latex-texttt'>@NotNull</span>, <span class='latex-texttt'>@Size</span>) —
die Ergebnisse sind erst nach dem Postback sichtbar.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Angular Reactive Forms bieten eine clientseitige Alternative:
<span class='latex-texttt'>FormGroup</span> und <span class='latex-texttt'>FormControl</span> definieren
die Formularstruktur in TypeScript, <span class='latex-texttt'>Validators</span> ersetzen die
Bean-Validation-Annotationen.
Die Validierung erfolgt in Echtzeit während der Eingabe.
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-create-idea-form'></a>                     <pre><code>&lt;!-- JSF: Idee erstellen --&gt;
&lt;h:form id="createIdeaForm"&gt;
  &lt;if:formGroup label="Titel"
                value="#{ideaController.newIdea.title}" /&gt;
  &lt;if:formGroup label="Kategorie"
                value="#{ideaController.newIdea.category}" /&gt;
  &lt;if:formGroup label="Beschreibung" type="textarea"
                value="#{ideaController.newIdea.description}" /&gt;
  &lt;h:commandButton value="Erstellen"
                   action="#{ideaController.createIdea}" /&gt;
  &lt;h:messages globalOnly="true" /&gt;
&lt;/h:form&gt;</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-create-idea-form'></a>                     <pre><code>// Angular: Idee erstellen
@Component({
  selector: 'app-create-idea',
  standalone: true,
  imports: [ReactiveFormsModule, FormFieldComponent],
  template: `
    &lt;form [formGroup]="ideaForm" (ngSubmit)="onSubmit()"&gt;
      &lt;app-form-field label="Titel"
                      [control]="ideaForm.controls.title" /&gt;
      &lt;app-form-field label="Kategorie"
                      [control]="ideaForm.controls.category" /&gt;
      &lt;app-form-field label="Beschreibung" type="textarea"
                      [control]="ideaForm.controls.description" /&gt;
      &lt;button type="submit" [disabled]="ideaForm.invalid"&gt;
        Erstellen
      &lt;/button&gt;
    &lt;/form&gt;
  `
})
export class CreateIdeaComponent {
  private ideaService = inject(IdeaService);
  private router = inject(Router);

  ideaForm = new FormGroup({
    title: new FormControl('', [Validators.required, Validators.minLength(3)]),
    category: new FormControl('', Validators.required),
    description: new FormControl('')
  });

  onSubmit() {
    if (this.ideaForm.valid) {
      this.ideaService.createIdea(this.ideaForm.value as Idea).subscribe(
        () =&gt; this.router.navigate(['/ideas'])
      );
    }
  }
}</code></pre>
                </div>
Die Fehlermeldungen werden in JSF über <span class='latex-texttt'>FacesMessage</span> und
die DeltaSpike-Abstraktion <span class='latex-texttt'>JsfMessage&lt;T&gt;</span> mit
<span class='latex-texttt'>@MessageBundle</span> verwaltet.
In Angular wird dies durch einen Notification-Service ersetzt,
der Meldungen als Signals bereitstellt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-registration-form'></a>                     <pre><code>// JSF: Registrierung mit Bean Validation
@Named
@ViewAccessScoped
public class RegistrationController implements Serializable {
    @NotNull
    @Size(min = 3, max = 50)
    private String username;

    @NotNull
    @Size(min = 8)
    private String password;

    @Inject
    private JsfMessage&lt;RegistrationMessages&gt; messages;

    public Class&lt;? extends ViewConfig&gt; register() {
        if (userService.register(username, password)) {
            return Pages.User.Login.class;
        }
        messages.addError().registrationFailed();
        return null;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-registration-form'></a>                     <pre><code>// Angular: Registrierung mit Reactive Forms
@Component({
  selector: 'app-registration',
  standalone: true,
  imports: [ReactiveFormsModule],
  templateUrl: './registration.component.html'
})
export class RegistrationComponent {
  private userService = inject(UserService);
  private router = inject(Router);
  private notifications = inject(NotificationService);

  form = new FormGroup({
    username: new FormControl('', [
      Validators.required,
      Validators.minLength(3),
      Validators.maxLength(50)
    ]),
    password: new FormControl('', [
      Validators.required,
      Validators.minLength(8)
    ])
  });

  onRegister() {
    if (this.form.valid) {
      this.userService.register(this.form.value).subscribe({
        next: () =&gt; this.router.navigate(['/user/login']),
        error: () =&gt; this.notifications.error('Registrierung fehlgeschlagen')
      });
    }
  }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Angular Reactive Forms bieten Echtzeit-Validierungsfeedback
ohne Server-Roundtrip — anders als in JSF, wo die Validierung erst beim Postback ausgeführt wird.
Die Bean-Validation-Annotationen <span class='latex-texttt'>@NotNull</span> und
<span class='latex-texttt'>@Size</span> werden durch die Angular-Validators
<span class='latex-texttt'>Validators.required</span>,
<span class='latex-texttt'>Validators.minLength()</span> und
<span class='latex-texttt'>Validators.maxLength()</span> ersetzt.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.6'><span class='entry-number'>11.6</span> Sicherheit im Frontend</a> </h2>
Die Absicherung von Seiten erfolgt in <span class='latex-textit'>IdeaFork</span> über die DeltaSpike-Annotation
<span class='latex-texttt'>@Secured</span> in Kombination mit einem
<span class='latex-texttt'>AccessDecisionVoter</span>.
Der <span class='latex-texttt'>JsfIdentityHolder</span> (annotiert mit
<span class='latex-texttt'>@SessionScoped</span> und <span class='latex-texttt'>@Specializes</span>)
speichert die Benutzeridentität in der HTTP-Session.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
In Angular übernimmt ein funktionaler Route Guard die Zugriffskontrolle.
Der <span class='latex-texttt'>AuthService</span> verwaltet das JWT und stellt den Login-Zustand
über Signals reaktiv bereit:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-auth-guard'></a>                     <pre><code>// auth.guard.ts (Angular)
export const authGuard: CanActivateFn = (route, state) =&gt; {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isAuthenticated()) {
    return true;
  }
  return router.createUrlTree(['/user/login'], {
    queryParams: { returnUrl: state.url }
  });
};</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-auth-interceptor'></a>                     <pre><code>// auth.interceptor.ts (Angular)
export const authInterceptor: HttpInterceptorFn = (req, next) =&gt; {
  const authService = inject(AuthService);
  const token = authService.getToken();

  if (token) {
    const cloned = req.clone({
      setHeaders: { Authorization: `Bearer ${token}` }
    });
    return next(cloned);
  }
  return next(req);
};</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-auth-service'></a>                     <pre><code>// auth.service.ts (Angular)
@Injectable({ providedIn: 'root' })
export class AuthService {
  private currentUser = signal&lt;User | null&gt;(null);

  isAuthenticated = computed(() =&gt; this.currentUser() !== null);
  user = this.currentUser.asReadonly();

  private http = inject(HttpClient);
  private router = inject(Router);

  login(username: string, password: string): Observable&lt;void&gt; {
    return this.http.post&lt;{ token: string; user: User }&gt;(
      '/api/auth/login', { username, password }
    ).pipe(
      tap(response =&gt; {
        localStorage.setItem('jwt', response.token);
        this.currentUser.set(response.user);
      }),
      map(() =&gt; void 0)
    );
  }

  logout() {
    localStorage.removeItem('jwt');
    this.currentUser.set(null);
    this.router.navigate(['/user/login']);
  }

  getToken(): string | null {
    return localStorage.getItem('jwt');
  }
}</code></pre>
                </div>
Der Login-Flow ändert sich grundlegend:
Statt eines JSF-Formular-Postbacks, bei dem der Server die Session aktualisiert und
einen Redirect ausführt, sendet die Angular-Applikation einen REST-Call an den
Login-Endpoint des Quarkus-Backends.
Das Backend gibt ein JWT zurück, das im <span class='latex-texttt'>localStorage</span> gespeichert wird.
Der <span class='latex-texttt'>authInterceptor</span> fügt das Token automatisch an alle
ausgehenden HTTP-Requests an.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Der DeltaSpike <span class='latex-texttt'>EntryPointHandler</span>, der in <span class='latex-textit'>IdeaFork</span>
sicherstellt, dass der Promotion-Wizard nur über den definierten Einstiegspunkt
erreicht werden kann, wird in Angular durch einen spezifischen Route Guard ersetzt,
der den Wizard-Zustand überprüft (siehe Abschnitt 11.8).
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>Clientseitige Route Guards sind keine Sicherheitsgrenze.
Sie verbessern die Benutzererfahrung, indem sie nicht autorisierte Benutzer
zur Login-Seite weiterleiten, aber ein Angreifer kann sie umgehen.
Das Quarkus-Backend muss immer die Autorisierung über
<span class='latex-texttt'>@RolesAllowed</span> erzwingen, wie in Kapitel 10 gezeigt.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.7'><span class='entry-number'>11.7</span> REST-Kommunikation</a> </h2>
In <span class='latex-textit'>IdeaForkMicro</span> werden die REST-Aufrufe zwischen den Modulen über
<span class='latex-texttt'>@ResourceClient</span>-Interfaces abstrahiert (siehe Kapitel 8).
Diese DeltaSpike-Partial-Bean-Proxies erzeugen zur Laufzeit eine Implementierung
des Interfaces, die die REST-Calls ausführt.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Angulars <span class='latex-texttt'>HttpClient</span> gibt <span class='latex-texttt'>Observable&lt;T&gt;</span> zurück —
konzeptionell vergleichbar mit Javas <span class='latex-texttt'>CompletableFuture&lt;T&gt;</span>, aber flexibler.
Ein Observable repräsentiert einen asynchronen Datenstrom.
<span class='latex-texttt'>.subscribe()</span> startet die Operation und empfängt das Ergebnis
(vergleichbar mit <span class='latex-texttt'>.get()</span> bei einem Future).
<span class='latex-texttt'>.pipe()</span> verkettet Transformations-Operatoren
(wie <span class='latex-texttt'>.map()</span>/<span class='latex-texttt'>.filter()</span> bei Java Streams).
Der wesentliche Unterschied zu <span class='latex-texttt'>@ResourceClient</span>:
Der DeltaSpike-Proxy blockiert den aufrufenden Thread, bis die Antwort eintrifft;
ein Observable ist non-blocking — die Benutzeroberfläche bleibt reaktionsfähig.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
In Angular übernimmt der <span class='latex-texttt'>HttpClient</span> diese Aufgabe.
Jedes <span class='latex-texttt'>@ResourceClient</span>-Interface wird zu einem Angular
<span class='latex-texttt'>@Injectable</span> Service, der den <span class='latex-texttt'>HttpClient</span> verwendet.
Der entscheidende Vorteil: Die REST-APIs existieren bereits aus
<span class='latex-textit'>IdeaForkMicro</span> und Quarkus — Angular ruft sie direkt auf.
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-resource-client'></a>                     <pre><code>// @ResourceClient (DeltaSpike Partial-Bean)
@ResourceClient(name = "ideas", version = "v1")
public interface IdeaResourceClient {
    @GET
    @Path("/")
    List&lt;Idea&gt; getAll();

    @POST
    @Path("/")
    Idea create(Idea idea);

    @GET
    @Path("/{id}")
    Idea getById(@PathParam("id") Long id);
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-idea-service'></a>                     <pre><code>// Angular: IdeaService
@Injectable({ providedIn: 'root' })
export class IdeaService {
  private http = inject(HttpClient);
  private apiUrl = '/api/ideas/v1';

  getAll(): Observable&lt;Idea[]&gt; {
    return this.http.get&lt;Idea[]&gt;(this.apiUrl);
  }

  create(idea: Idea): Observable&lt;Idea&gt; {
    return this.http.post&lt;Idea&gt;(this.apiUrl, idea);
  }

  getById(id: number): Observable&lt;Idea&gt; {
    return this.http.get&lt;Idea&gt;(`${this.apiUrl}/${id}`);
  }
}</code></pre>
                </div>
Das Observable-basierte Muster des <span class='latex-texttt'>HttpClient</span> ermöglicht
asynchrone Verarbeitung und explizite Fehlerbehandlung mit <span class='latex-texttt'>catchError</span>.
In Kombination mit Signals können Ladezustände und Fehler reaktiv dargestellt werden:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-error-handling'></a>                     <pre><code>// Angular: Fehlerbehandlung und Ladezustand
@Component({
  selector: 'app-idea-list',
  standalone: true,
  imports: [CommonModule],
  template: `
    @if (loading()) {
      &lt;div class="spinner"&gt;Laden...&lt;/div&gt;
    } @else if (error()) {
      &lt;div class="error"&gt;{{ error() }}&lt;/div&gt;
    } @else {
      @for (idea of ideas(); track idea.id) {
        &lt;div class="idea-card" (click)="showDetail(idea)"&gt;
          &lt;h3&gt;{{ idea.title }}&lt;/h3&gt;
        &lt;/div&gt;
      }
    }
  `
})
export class IdeaListComponent implements OnInit {
  ideas = signal&lt;Idea[]&gt;([]);
  loading = signal(true);
  error = signal&lt;string | null&gt;(null);

  private ideaService = inject(IdeaService);
  private router = inject(Router);

  ngOnInit() {
    this.ideaService.getAll().pipe(
      catchError(err =&gt; {
        this.error.set('Fehler beim Laden der Ideen');
        return of([]);
      }),
      finalize(() =&gt; this.loading.set(false))
    ).subscribe(data =&gt; this.ideas.set(data));
  }

  showDetail(idea: Idea) {
    this.router.navigate(['/ideas', idea.id]);
  }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Die typisierten <span class='latex-texttt'>HttpClient</span>-Responses
von Angular (<span class='latex-texttt'>get&lt;Idea[]&gt;(...)</span>) bieten eine Compile-Zeit-Sicherheit,
die den typisierten <span class='latex-texttt'>@ResourceClient</span>-Interfaces ähnelt.
Der TypeScript-Compiler erkennt Typfehler bereits zur Entwicklungszeit.</div>
<div class="tip"><b>Tipp: </b>Während der Entwicklung kann Angulars Dev-Server API-Aufrufe über <span class='latex-texttt'>proxy.conf.json</span> an das Backend weiterleiten. Entscheidend ist: Wenn das Backend unter <span class='latex-texttt'>/api/...</span> antwortet (wie Quarkus), ist kein <span class='latex-texttt'>pathRewrite</span> nötig. Wenn ein Mock-Server (z.B. json-server) ohne Pfadpräfix antwortet, muss <span class='latex-texttt'>pathRewrite: {"^/api": ""}</span> den Präfix entfernen. Beim Wechsel von Mock- zu echtem Backend ändert sich nur diese eine Zeile in der Proxy-Konfiguration.</div>
<div class="tip"><b>Tipp: </b><b>Globale Fehlerbehandlung:</b> Statt Fehler in jedem Service einzeln zu behandeln, kann ein globaler HTTP-Interceptor zentral reagieren: Bei Status 401 automatisch zur Login-Seite weiterleiten, bei 403 eine Berechtigungsfehlermeldung anzeigen, bei 500 eine Toast-Benachrichtigung einblenden. Dieser Interceptor wird in <span class='latex-texttt'>app.config.ts</span> registriert und fängt alle ausgehenden HTTP-Anfragen ab &mdash; vergleichbar mit einem CDI-Interceptor für Cross-Cutting Concerns.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.8'><span class='entry-number'>11.8</span> Der Promotion-Wizard</a> </h2>
Der Promotion-Wizard ist die komplexeste UI-Funktion in <span class='latex-textit'>IdeaFork</span>:
Ein dreistufiger Wizard, der eine Idee zur Förderung vorschlägt.
In der JSF-Version nutzt der Wizard <span class='latex-texttt'>@GroupedConversationScoped</span>,
um den Zustand über die drei Schritte hinweg zu halten.
Der DeltaSpike <span class='latex-texttt'>@EntryPoint</span>-Mechanismus stellt sicher,
dass der Wizard nur über Schritt 1 betreten werden kann.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
In Angular wird der Wizard durch einen Service für den Zustand
und Route Guards für die Schrittsteuerung abgebildet:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:jsf-promotion-wizard'></a>                     <pre><code>// JSF: Promotion-Wizard mit @GroupedConversationScoped
@Named
@GroupedConversationScoped
public class PromotionWizardBean implements Serializable {
    @Inject
    private GroupedConversation conversation;

    @Inject
    private PromotionService promotionService;

    private Idea selectedIdea;
    private PromotionType type;
    private String justification;

    // Schritt 1: Idee auswählen
    public Class&lt;? extends ViewConfig&gt; selectIdea(Idea idea) {
        this.selectedIdea = idea;
        return Pages.Promotion.Step2.class;
    }

    // Schritt 2: Typ wählen
    public Class&lt;? extends ViewConfig&gt; selectType(PromotionType type) {
        this.type = type;
        return Pages.Promotion.Step3.class;
    }

    // Schritt 3: Abschließen
    public Class&lt;? extends ViewConfig&gt; submit() {
        promotionService.promote(selectedIdea, type, justification);
        conversation.close();
        return Pages.Idea.List.class;
    }

    // Abbrechen
    public Class&lt;? extends ViewConfig&gt; cancel() {
        conversation.close();
        return Pages.Idea.List.class;
    }
}</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-promotion-wizard'></a>                     <pre><code>// Angular: Promotion-Wizard Service + Komponenten
@Injectable()
export class PromotionWizardService {
  selectedIdea = signal&lt;Idea | null&gt;(null);
  promotionType = signal&lt;PromotionType | null&gt;(null);
  justification = signal('');

  private promotionService = inject(PromotionService);
  private router = inject(Router);

  // Schritt 1: Idee auswählen
  selectIdea(idea: Idea) {
    this.selectedIdea.set(idea);
    this.router.navigate(['/promotion/step2']);
  }

  // Schritt 2: Typ wählen
  selectType(type: PromotionType) {
    this.promotionType.set(type);
    this.router.navigate(['/promotion/step3']);
  }

  // Schritt 3: Abschließen
  submit(): Observable&lt;void&gt; {
    return this.promotionService.promote({
      ideaId: this.selectedIdea()!.id,
      type: this.promotionType()!,
      justification: this.justification()
    }).pipe(
      tap(() =&gt; {
        this.reset();
        this.router.navigate(['/ideas']);
      })
    );
  }

  cancel() {
    this.reset();
    this.router.navigate(['/ideas']);
  }

  private reset() {
    this.selectedIdea.set(null);
    this.promotionType.set(null);
    this.justification.set('');
  }
}

// Route Guard: Wizard-Schritt-Reihenfolge erzwingen
export const wizardStepGuard: CanActivateFn = (route) =&gt; {
  const wizard = inject(PromotionWizardService);
  const router = inject(Router);
  const step = route.routeConfig?.path;

  if (step === 'step2' &amp;&amp; !wizard.selectedIdea()) {
    return router.createUrlTree(['/promotion/step1']);
  }
  if (step === 'step3' &amp;&amp; !wizard.promotionType()) {
    return router.createUrlTree(['/promotion/step2']);
  }
  return true;
};</code></pre>
                </div>
Der <span class='latex-texttt'>PromotionWizardService</span> wird in der Routen-Konfiguration
als Provider für den <span class='latex-texttt'>promotion</span>-Pfad registriert.
Dadurch wird eine neue Instanz erzeugt, wenn der Benutzer den Wizard betritt,
und automatisch zerstört, wenn er den Wizard-Bereich verlässt —
funktional äquivalent zum <span class='latex-texttt'>@GroupedConversationScoped</span>.
<div class="tip"><b>Tipp: </b>Der Angular Router kann die Wizard-Schritt-Reihenfolge
mit <span class='latex-texttt'>canActivate</span>-Guards erzwingen —
funktional äquivalent zum <span class='latex-texttt'>@EntryPoint</span>-Mechanismus
von <span class='latex-textit'>IdeaForkMicro</span>.
Der <span class='latex-texttt'>wizardStepGuard</span> prüft, ob die vorherigen Schritte
abgeschlossen wurden, bevor der nächste Schritt erlaubt wird.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die folgende Komponente zeigt, wie Schritt 1 den Wizard-Service nutzt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:angular-wizard-step1'></a>                     <pre><code>// step1.component.ts (Angular)
@Component({
  selector: 'app-step1',
  standalone: true,
  imports: [CommonModule],
  template: `
    &lt;h2&gt;Schritt 1: Idee auswählen&lt;/h2&gt;
    @for (idea of ideas(); track idea.id) {
      &lt;div class="idea-card" (click)="select(idea)"&gt;
        &lt;h3&gt;{{ idea.title }}&lt;/h3&gt;
      &lt;/div&gt;
    }
  `
})
export class Step1Component implements OnInit {
  ideas = signal&lt;Idea[]&gt;([]);

  private wizard = inject(PromotionWizardService);
  private ideaService = inject(IdeaService);

  ngOnInit() {
    this.ideaService.getAll().subscribe(
      data =&gt; this.ideas.set(data)
    );
  }

  select(idea: Idea) {
    this.wizard.selectIdea(idea);
  }
}</code></pre>
                </div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<b>Unit Tests für Angular-Komponenten:</b> Angulars Testing-Framework basiert auf <span class='latex-texttt'>TestBed</span>, das eine ähnliche Rolle spielt wie DeltaSpike Test-Control für CDI-Beans: Es erzeugt eine isolierte Testumgebung mit kontrollierter Dependency Injection.
Ein typischer Komponententest verwendet <span class='latex-texttt'>TestBed.configureTestingModule()</span>, um nur die benötigten Dependencies bereitzustellen.
Der <span class='latex-texttt'>HttpClient</span> wird durch <span class='latex-texttt'>provideHttpClientTesting()</span> ersetzt, sodass REST-Aufrufe ohne echtes Backend getestet werden können.
Für Signal-basierte Komponenten (ab Angular 17) können <span class='latex-texttt'>ComponentFixture.detectChanges()</span> und <span class='latex-texttt'>fixture.whenStable()</span> verwendet werden, um reaktive Zustandsänderungen im Test zu verifizieren.
<div class="tip"><b>Tipp: </b>Die Parallele zu DeltaSpike Test-Control ist klar: Dort wird der CDI-Container für den Test gestartet, hier das Angular-Modul. In beiden Fällen werden echte Abhängigkeiten durch Mocks ersetzt, und die Tests laufen isoliert ohne externe Infrastruktur.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.9'><span class='entry-number'>11.9</span> IdeaFork-Frontend migrieren</a> </h2>
Die folgende Tabelle zeigt die vollständige Zuordnung aller 18 XHTML-Seiten
von <span class='latex-textit'>IdeaFork</span> zu Angular-Komponenten:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:migration-checklist'></a>                     <pre><code>Migration Checkliste: JSF → Angular
═══════════════════════════════════════════════════════════════
JSF-Seite / DeltaSpike-Feature     → Angular-Entsprechung
───────────────────────────────────────────────────────────────
main-template.xhtml (ui:insert)    → AppComponent + router-outlet
index.xhtml                        → HomeComponent
ideaList.xhtml                     → IdeaListComponent
ideaDetail.xhtml                   → IdeaDetailComponent
createIdea.xhtml                   → CreateIdeaComponent
login.xhtml                        → LoginComponent
registration.xhtml                 → RegistrationComponent
userProfile.xhtml                  → UserProfileComponent
promotionStep1.xhtml               → Step1Component
promotionStep2.xhtml               → Step2Component
promotionStep3.xhtml               → Step3Component
categoryList.xhtml                 → CategoryListComponent
categoryDetail.xhtml               → CategoryDetailComponent
notificationList.xhtml             → NotificationListComponent
archiveList.xhtml                  → ArchiveListComponent
adminDashboard.xhtml               → AdminDashboardComponent
settings.xhtml                     → SettingsComponent
error.xhtml                        → ErrorComponent
───────────────────────────────────────────────────────────────
ViewConfig-Hierarchie              → Routes-Array (app.routes.ts)
@Named Backing Beans               → @Injectable Services
@ViewAccessScoped                  → Komponenten-Lebenszyklus
@WindowScoped                      → providedIn: 'root' Service
@GroupedConversationScoped          → Route-scoped Service
@Secured + AccessDecisionVoter     → canActivate Guard
@ResourceClient                    → HttpClient Service
JsfMessage / @MessageBundle        → NotificationService
formGroup.xhtml (Composite)        → FormFieldComponent
EL-Ausdrücke (#{...})              → Template-Bindings ({{...}})
@PreRenderView                     → ngOnInit()
h:form + h:commandButton           → Reactive Forms + (ngSubmit)
ui:repeat                          → @for Control-Flow
rendered="#{...}"                  → @if / @switch Control-Flow
═══════════════════════════════════════════════════════════════</code></pre>
                </div>
Für die Integration von Angular mit dem Quarkus-Backend bietet die
Quarkus-Extension <span class='latex-texttt'>quarkus-quinoa</span> eine elegante Lösung.
Quinoa ermöglicht es, das Angular-Frontend direkt aus dem Quarkus-Projekt heraus
zu bauen und als statische Dateien auszuliefern:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:quinoa-config'></a>                     <pre><code># application.properties (Quarkus + Quinoa)
quarkus.quinoa.enable=true
quarkus.quinoa.package-manager=npm
quarkus.quinoa.build-dir=dist/ideafork-frontend/browser
quarkus.quinoa.enable-spa-routing=true

# Entwicklungsmodus: Angular Dev-Server Proxy
%dev.quarkus.quinoa.dev-server.port=4200
%dev.quarkus.quinoa.dev-server.check-timeout=60000</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Die Konfiguration <span class='latex-texttt'>quarkus.quinoa.enable-spa-routing=true</span>
ist entscheidend: Sie leitet alle nicht-API-Requests an die Angular-Applikation weiter,
sodass das clientseitige Routing korrekt funktioniert.
Ohne diese Einstellung würde ein direkter Aufruf von z.B.
<span class='latex-texttt'>/ideas/42</span> zu einem 404-Fehler führen.</div>
Während der Entwicklung arbeiten Angular CLI und Quarkus als getrennte Prozesse.
Die Datei <span class='latex-texttt'>proxy.conf.json</span> im Angular-Projekt leitet
API-Requests an das Quarkus-Backend weiter:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/angular.html:fig:proxy-config'></a>                     <pre><code>// proxy.conf.json (Angular CLI)
{
  "/api": {
    "target": "http://localhost:8080",
    "secure": false,
    "changeOrigin": true
  }
}</code></pre>
                </div>
Für die Produktionsumgebung wird das Angular-Projekt als Teil des Quarkus-Builds
kompiliert. Die statischen Dateien werden von Quarkus als Vert.x-Static-Resources
ausgeliefert — ohne separaten Webserver.
<div class="tip"><b>Tipp: </b>Die Projektstruktur für Quinoa sieht vor,
dass das Angular-Projekt als Unterverzeichnis
(<span class='latex-texttt'>src/main/webui/</span>) im Quarkus-Maven-Projekt liegt.
Quinoa führt <span class='latex-texttt'>npm install</span> und <span class='latex-texttt'>npm run build</span>
automatisch als Teil des Maven-Builds aus.</div>
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
<b>Deployment und Containerisierung:</b> Für den Produktivbetrieb wird die Angular-Applikation mit <span class='latex-texttt'>ng build --configuration production</span> kompiliert.
Das Ergebnis ist ein Ordner mit statischen HTML-, CSS- und JavaScript-Dateien.
Diese können direkt von Quarkus ausgeliefert werden &mdash; entweder über die <span class='latex-texttt'>quarkus-quinoa</span>-Extension (die den Angular-Build automatisch in das Quarkus-Artefakt integriert) oder über einen separaten Nginx-Container.
<div class="tip"><b>Tipp: </b><b>Ein Artefakt für alles:</b> Mit Quarkus + Quinoa entsteht ein einzelnes JAR (oder natives Image), das sowohl die REST-API als auch die Angular-SPA ausliefert. Für <span class='latex-textit'>IdeaFork</span> bedeutet dies: Ein einziger <span class='latex-texttt'>docker build</span>-Befehl erzeugt ein Container-Image mit dem vollständigen Stack &mdash; Backend, Frontend und Datenbank-Migration.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/angular.html:11.10'><span class='entry-number'>11.10</span> Quellen</a> </h2>
<b>Quellen:</b><br />
- angular.dev<br />
- quarkus.io<br />
- quarkus.io/guides/quinoa<br />
- microprofile.io<br />
- jakarta.ee<br />
- deltaspike.apache.org<br />
</section>
<section class="chapter-section" id="chapter-12">
<h1> <a class='latex-index-anchor' name='!idx:/testing.html:12'><span class='entry-number'>12</span> Testing Across the Stack</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Dieses Kapitel wurde von Claude (AI built by Anthropic) auf Basis der vorherigen Kapitel verfasst. Es beschreibt die Migration der Teststrategie von IdeaFork &mdash; von DeltaSpike Test-Control über Weld-JUnit5 und @QuarkusTest bis hin zu Angular-Unit-Tests und Playwright-E2E-Tests.
</div>
<a name = '!idx:/testing.html:chap:testing-across-stack'> </a><h2><a class='latex-index-anchor' name='!idx:/testing.html:12.1'><span class='entry-number'>12.1</span> Ein neues Testfundament</a> </h2>
 In den vorherigen Kapiteln haben wir <span class='latex-textit'>IdeaFork</span> schrittweise modernisiert:
Kapitel 9 hat die Migration zu Jakarta EE begleitet, Kapitel 10 den Wechsel zu Quarkus vollzogen
und Kapitel 11 das Frontend von JSF zu Angular migriert.
Jede dieser Migrationsschritte erfordert eine entsprechende Anpassung der Teststrategie.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die Testlandschaft hat sich dabei grundlegend gewandelt.
In der ursprünglichen Java-EE-Welt von <span class='latex-textit'>IdeaFork</span> basierte die Teststrategie
auf DeltaSpike Test-Control (Kapitel 5) und Arquillian für Integrationstests.
Mit dem Wechsel zu Quarkus treten <span class='latex-texttt'>@QuarkusTest</span> und Dev Services an deren Stelle.
Auf der Frontend-Seite bringt Angular mit TestBed ein eigenes Testframework mit,
und für End-to-End-Tests über den gesamten Stack bietet sich Playwright an.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die folgende Übersicht zeigt die Testmigration im Kontext der IdeaFork-Architektur:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-evolution-overview'></a>                     <pre><code>Test-Migrations-Uebersicht
======================================

Schicht          Alt                          Neu
----------------------------------------------------------------------
CDI-Unit         DeltaSpike Test-Control      Weld-JUnit5 (@EnableAutoWeld)
                 (CdiTestRunner, JUnit 4)     (JUnit 5, CDI SE)

Integration      Arquillian                   @QuarkusTest + Dev Services
                 (@Deployment, ShrinkWrap)    (Testcontainers, Zero-Config)

REST-API         Meecrowave/MonoMeecrowave    REST Assured + @QuarkusTest
                 (MonoMeecrowave.Rule)        (@TestHTTPResource)

Frontend-Unit    ---                          Angular TestBed
                                              (ComponentFixture, HttpTestingController)

E2E              Selenium (manuell)           Playwright
                                              (Auto-Wait, Multi-Browser, Tracing)</code></pre>
                </div>
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-dependencies-overview'></a>                     <pre><code>&lt;!-- Test-Abhaengigkeiten (Ueberblick) --&gt;
&lt;dependencies&gt;
    &lt;!-- CDI-Unit-Tests --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt;
        &lt;artifactId&gt;weld-junit5&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- Quarkus-Integrationstests --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- REST-API-Tests --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
        &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Die Testmigration spiegelt die Produktionsmigration wider:
Jede Schicht der Anwendung &mdash; CDI-Beans, REST-Endpunkte, Frontend-Komponenten &mdash;
hat ein eigenes Testframework, das auf die jeweilige Laufzeitumgebung abgestimmt ist.
Der Schlüssel liegt darin, die Tests schrittweise zu migrieren und
dabei die Testpyramide (viele Unit-Tests, wenige E2E-Tests) beizubehalten.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.2'><span class='entry-number'>12.2</span> CDI-Beans testen (Weld-JUnit5)</a> </h2>
Weld-JUnit5 ist der leichtgewichtige Nachfolger von DeltaSpike Test-Control für
CDI-Unit-Tests. Statt einen vollständigen Application-Server oder Container zu starten,
nutzt Weld-JUnit5 die CDI-SE-Implementierung von Weld &mdash; denselben CDI-Container,
der auch in Quarkus (als ArC) zum Einsatz kommt.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die Maven-Abhängigkeit ist minimal:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:weld-junit5-dependency'></a>                     <pre><code>&lt;!-- pom.xml: Weld-JUnit5 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt;
    &lt;artifactId&gt;weld-junit5&lt;/artifactId&gt;
    &lt;version&gt;4.0.3.Final&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
                </div>
Ein einfacher Test für den <span class='latex-texttt'>IdeaManager</span> sieht mit
<span class='latex-texttt'>@EnableAutoWeld</span> so aus:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:weld-junit5-basic-test'></a>                     <pre><code>// IdeaManagerTest.java (Weld-JUnit5)
@EnableAutoWeld
class IdeaManagerTest {

    @Inject
    IdeaManager ideaManager;

    @Test
    void shouldCreateIdea() {
        Idea idea = new Idea();
        idea.setTitle("Test-Idee");

        Idea created = ideaManager.createIdea(idea);

        assertNotNull(created.getId());
        assertEquals("Test-Idee", created.getTitle());
    }

    @Test
    void shouldFindAllIdeas() {
        List&lt;Idea&gt; ideas = ideaManager.findAll();
        assertNotNull(ideas);
    }
}</code></pre>
                </div>
Die Annotation <span class='latex-texttt'>@EnableAutoWeld</span> startet automatisch einen
Weld-SE-Container, scannt die Klassen im Classpath und injiziert alle
<span class='latex-texttt'>@Inject</span>-Felder der Testklasse. Dabei werden die Bean-Discovery-Regeln
von CDI beachtet &mdash; Beans mit <span class='latex-texttt'>@ApplicationScoped</span>,
<span class='latex-texttt'>@RequestScoped</span> und anderen Standard-Scopes werden automatisch erkannt.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Für Mocking bietet Weld-JUnit5 die Annotation <span class='latex-texttt'>@ExcludeBean</span>,
die eine produktive Bean-Implementierung durch ein Test-Double ersetzt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:weld-junit5-mock'></a>                     <pre><code>// IdeaManagerMockTest.java (Weld-JUnit5 + Mock)
@EnableAutoWeld
class IdeaManagerMockTest {

    @Inject
    IdeaManager ideaManager;

    @Produces
    @ExcludeBean
    IdeaRepository mockRepository = mock(IdeaRepository.class);

    @Test
    void shouldUseMockRepository() {
        Idea testIdea = new Idea();
        testIdea.setId(1L);
        testIdea.setTitle("Mock-Idee");

        when(mockRepository.findAll()).thenReturn(List.of(testIdea));

        List&lt;Idea&gt; result = ideaManager.findAll();

        assertEquals(1, result.size());
        assertEquals("Mock-Idee", result.get(0).getTitle());
        verify(mockRepository).findAll();
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b><span class='latex-texttt'>@EnableAutoWeld</span> ersetzt den bisherigen
<span class='latex-texttt'>CdiTestRunner</span> von DeltaSpike vollständig.
Der Vorteil: Weld-JUnit5 basiert auf JUnit 5, unterstützt verschachtelte Testklassen
(<span class='latex-texttt'>@Nested</span>), parametrisierte Tests und parallele Testausführung &mdash;
Funktionen, die mit dem JUnit-4-basierten CdiTestRunner nicht verfügbar waren.</div>
<div class="tip"><b>Tipp: </b><span class='latex-texttt'>@ExcludeBean</span> markiert eine
<span class='latex-texttt'>@Produces</span>-Methode oder ein Feld als Ersatz für die
produktive CDI-Bean gleichen Typs. Das ist das CDI-native Äquivalent zu
Mockito-Annotationen wie <span class='latex-texttt'>@Mock</span> mit <span class='latex-texttt'>@InjectMocks</span> &mdash;
mit dem Unterschied, dass der CDI-Container das Wiring übernimmt und
somit auch Interceptoren, Decoratoren und Event-Observer korrekt aufgelöst werden.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.3'><span class='entry-number'>12.3</span> DeltaSpike Test-Control im Rückblick</a> </h2>
Bevor wir uns den modernen Testframeworks widmen, lohnt ein Rückblick auf DeltaSpike Test-Control.
In Kapitel 5 haben wir den <span class='latex-texttt'>CdiTestRunner</span> als zentrale Testinfrastruktur
für CDI-Unit-Tests kennengelernt. Sein Prinzip war einfach: Der Runner startet einen
CDI-Container über die CDI-Control-Abstraktion und injiziert die Testklasse als CDI-Bean.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Ein typischer DeltaSpike-Test sah wie folgt aus:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:deltaspike-test-control-recap'></a>                     <pre><code>// IdeaManagerTest.java (DeltaSpike Test-Control)
@RunWith(CdiTestRunner.class)
public class IdeaManagerTest {

    @Inject
    private IdeaManager ideaManager;

    @Test
    public void shouldCreateIdea() {
        Idea idea = new Idea();
        idea.setTitle("Test-Idee");

        Idea created = ideaManager.createIdea(idea);

        assertNotNull(created.getId());
    }
}</code></pre>
                </div>
Die dazugehörigen Maven-Abhängigkeiten:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:deltaspike-test-control-deps'></a>                     <pre><code>&lt;!-- pom.xml: DeltaSpike Test-Control --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-test-control-module-api&lt;/artifactId&gt;
    &lt;version&gt;${deltaspike.version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.modules&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-test-control-module-impl&lt;/artifactId&gt;
    &lt;version&gt;${deltaspike.version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.deltaspike.cdictrl&lt;/groupId&gt;
    &lt;artifactId&gt;deltaspike-cdictrl-weld&lt;/artifactId&gt;
    &lt;version&gt;${deltaspike.version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
                </div>
Der wesentliche Nachteil: DeltaSpike Test-Control basiert auf JUnit 4 und dem
<span class='latex-texttt'>@RunWith</span>-Mechanismus, der in JUnit 5 durch Extensions ersetzt wurde.
Außerdem benötigt Test-Control drei separate Artefakte (API, Impl, CDI-Control-Implementierung),
während Weld-JUnit5 eine einzige Abhängigkeit darstellt.
<div class="tip"><b>Tipp: </b>DeltaSpike Test-Control nutzt intern die CDI-Control-Abstraktion,
um verschiedene CDI-Implementierungen (Weld, OpenWebBeans) zu unterstützen.
Weld-JUnit5 bindet sich direkt an Weld und eliminiert diese Indirektion &mdash;
was zu schnelleren Startup-Zeiten und einer einfacheren Konfiguration führt.
Die Migration besteht im Wesentlichen aus: <span class='latex-texttt'>@RunWith(CdiTestRunner.class)</span>
entfernen, <span class='latex-texttt'>@EnableAutoWeld</span> hinzufügen und die Abhängigkeiten austauschen.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.4'><span class='entry-number'>12.4</span> Arquillian: Integrationstests</a> </h2>
Für Integrationstests, die einen vollständigen Application-Server benötigten,
war Arquillian das Standardwerkzeug in der Java-EE-Welt.
Arquillian erzeugt ein Micro-Deployment &mdash; ein minimales Archiv mit nur den
für den Test benötigten Klassen und Ressourcen &mdash; und deployt dieses
in einen echten oder eingebetteten Container.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Ein typischer Arquillian-Test mit dem <span class='latex-texttt'>@Deployment</span>-Muster:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:arquillian-test'></a>                     <pre><code>// IdeaServiceIT.java (Arquillian)
@RunWith(Arquillian.class)
public class IdeaServiceIT {

    @Deployment
    public static Archive&lt;?&gt; createDeployment() {
        return ShrinkWrap.create(WebArchive.class, "test.war")
            .addClasses(IdeaService.class, IdeaRepository.class,
                        Idea.class, EntityManagerProducer.class)
            .addAsResource("META-INF/persistence.xml")
            .addAsWebInfResource("beans.xml");
    }

    @Inject
    private IdeaService ideaService;

    @Test
    public void shouldPersistIdea() {
        Idea idea = new Idea();
        idea.setTitle("Arquillian-Test");

        ideaService.save(idea);

        assertNotNull(idea.getId());
    }
}</code></pre>
                </div>
Die dazugehörigen Abhängigkeiten und der Container-Adapter:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:arquillian-deps'></a>                     <pre><code>&lt;!-- pom.xml: Arquillian --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.junit&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-junit-container&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.wildfly.arquillian&lt;/groupId&gt;
    &lt;artifactId&gt;wildfly-arquillian-container-managed&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
                </div>
Der Vergleich mit <span class='latex-texttt'>@QuarkusTest</span> zeigt die Evolution:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:arquillian-vs-quarkustest'></a>                     <pre><code>Vergleich: Arquillian vs. @QuarkusTest
======================================

Aspekt               Arquillian                    @QuarkusTest
----------------------------------------------------------------------
Setup                @Deployment + ShrinkWrap      Keine Deployment-Methode
Container            Externer App-Server           Quarkus-integriert
Bean-Discovery       Nur explizit gepackte Beans   Gesamte Anwendung
Startup-Zeit         30-60 Sekunden                2-5 Sekunden
Dev Services         Nicht verfuegbar              Automatische DB/MQ/...
Mocking              Eigene Producer               @InjectMock (nativ)
Continuous Testing   Nicht unterstuetzt            quarkus.test.continuous-testing
JUnit-Version        JUnit 4 (Standard)            JUnit 5 (nativ)</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>Arquillian-Tests und <span class='latex-texttt'>@QuarkusTest</span>
unterscheiden sich fundamental in der Bean-Isolation: Arquillian testet nur die
explizit im <span class='latex-texttt'>@Deployment</span>-Archiv gepackten Klassen, während
<span class='latex-texttt'>@QuarkusTest</span> die gesamte Anwendung startet.
Das bedeutet, dass Seiteneffekte zwischen Beans, die in Arquillian nicht sichtbar waren,
in <span class='latex-texttt'>@QuarkusTest</span> plötzlich auftreten können.</div>
<div class="tip"><b>Tipp: </b>Arquillian ist weiterhin ein valides Werkzeug für Projekte,
die noch auf einem klassischen Application-Server (WildFly, Payara, TomEE) laufen.
Für Quarkus-basierte Projekte wie <span class='latex-textit'>IdeaForkMicro</span> bietet
<span class='latex-texttt'>@QuarkusTest</span> jedoch eine deutlich einfachere und schnellere Alternative.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.5'><span class='entry-number'>12.5</span> @QuarkusTest und Dev Services</a> </h2>
<span class='latex-texttt'>@QuarkusTest</span> startet die gesamte Quarkus-Anwendung in einem
Testmodus, der die vollständige CDI-, REST- und Persistence-Infrastruktur bereitstellt.
Der zentrale Vorteil gegenüber Arquillian: Es gibt keine <span class='latex-texttt'>@Deployment</span>-Methode,
keine ShrinkWrap-Archive und keinen externen Application-Server.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Ein einfacher <span class='latex-texttt'>@QuarkusTest</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:quarkustest-basic'></a>                     <pre><code>// IdeaServiceTest.java (@QuarkusTest)
@QuarkusTest
class IdeaServiceTest {

    @Inject
    IdeaService ideaService;

    @Test
    void shouldCreateAndFindIdea() {
        Idea idea = new Idea();
        idea.setTitle("Quarkus-Test");

        ideaService.save(idea);

        List&lt;Idea&gt; all = ideaService.findAll();
        assertTrue(all.stream()
            .anyMatch(i -&gt; "Quarkus-Test".equals(i.getTitle())));
    }
}</code></pre>
                </div>
Für Mocking bietet Quarkus die Annotation <span class='latex-texttt'>@InjectMock</span>,
die eine CDI-Bean zur Laufzeit durch ein Mockito-Mock ersetzt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:quarkustest-injectmock'></a>                     <pre><code>// IdeaServiceMockTest.java (@QuarkusTest + @InjectMock)
@QuarkusTest
class IdeaServiceMockTest {

    @InjectMock
    IdeaRepository ideaRepository;

    @Inject
    IdeaService ideaService;

    @Test
    void shouldUseMockedRepository() {
        Idea testIdea = new Idea();
        testIdea.setId(1L);
        testIdea.setTitle("Mock-Idee");

        when(ideaRepository.findAll()).thenReturn(List.of(testIdea));

        List&lt;Idea&gt; result = ideaService.findAll();

        assertEquals(1, result.size());
        verify(ideaRepository).findAll();
    }
}</code></pre>
                </div>
Ein besonders mächtiges Feature von Quarkus sind die Dev Services:
Sie starten automatisch Testcontainers für Datenbanken, Message-Broker und andere
Infrastruktur-Dienste &mdash; ohne manuelle Konfiguration:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:devservices-config'></a>                     <pre><code># application.properties (Dev Services)
# Keine DB-URL noetig im Test-Profil!
# Quarkus startet automatisch einen PostgreSQL-Testcontainer.

%test.quarkus.datasource.devservices.enabled=true
%test.quarkus.datasource.devservices.image-name=postgres:16-alpine

# Hibernate: Schema automatisch erzeugen
%test.quarkus.hibernate-orm.database.generation=drop-and-create

# Optional: Dev Services auch fuer Kafka
%test.quarkus.kafka.devservices.enabled=true</code></pre>
                </div>
Für unterschiedliche Testkonfigurationen bietet Quarkus Test-Profile:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:quarkustest-profile'></a>                     <pre><code>// IntegrationTestProfile.java (QuarkusTestProfile)
public class IntegrationTestProfile implements QuarkusTestProfile {

    @Override
    public String getConfigProfile() {
        return "integration";
    }

    @Override
    public Map&lt;String, String&gt; getConfigOverrides() {
        return Map.of(
            "quarkus.datasource.devservices.image-name", "postgres:16-alpine",
            "quarkus.log.level", "DEBUG"
        );
    }
}

// Verwendung im Test:
@QuarkusTest
@TestProfile(IntegrationTestProfile.class)
class IdeaServiceIntegrationTest {
    // ... Tests mit Integration-Profil
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Dev Services eliminieren die manuelle Datenbank-Konfiguration
in Tests vollständig. Statt eine <span class='latex-texttt'>persistence.xml</span> mit einer
H2-In-Memory-Datenbank zu pflegen, startet Quarkus automatisch einen echten
PostgreSQL-Container via Testcontainers. Das bedeutet: Die Tests laufen gegen
dieselbe Datenbank wie die Produktion &mdash; ein häufiger Fehlerquell bei
H2-basierten Tests wird damit eliminiert.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b><span class='latex-texttt'>@QuarkusTest</span> startet die gesamte Anwendung
und ist damit deutlich langsamer als ein reiner CDI-Unit-Test mit Weld-JUnit5.
Für Tests, die nur CDI-Beans ohne Datenbankzugriff oder REST-Endpunkte prüfen,
ist Weld-JUnit5 die effizientere Wahl. Reservieren Sie
<span class='latex-texttt'>@QuarkusTest</span> für Integrationstests, die die volle
Quarkus-Infrastruktur benötigen.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.6'><span class='entry-number'>12.6</span> REST-Endpunkte testen</a> </h2>
In Kapitel 8 haben wir die REST-Endpunkte von <span class='latex-textit'>IdeaForkMicro</span>
mit Apache Meecrowave und der <span class='latex-texttt'>MonoMeecrowave.Rule</span> getestet.
Mit der Migration zu Quarkus wird REST Assured zum Standard-Werkzeug für HTTP-basierte Tests.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Zur Erinnerung: der Meecrowave-basierte Ansatz aus Kapitel 8:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:meecrowave-recap'></a>                     <pre><code>// IdeaResourceTest.java (Meecrowave)
public class IdeaResourceTest {

    @ClassRule
    public static final MonoMeecrowave.Rule RULE =
        new MonoMeecrowave.Rule();

    @Test
    public void shouldReturnIdeas() {
        String response = ClientBuilder.newClient()
            .target("http://localhost:" + RULE.getConfiguration().getHttpPort())
            .path("/api/ideas")
            .request(MediaType.APPLICATION_JSON)
            .get(String.class);

        assertNotNull(response);
    }
}</code></pre>
                </div>
Der gleiche Test mit REST Assured und <span class='latex-texttt'>@QuarkusTest</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:rest-assured-basic'></a>                     <pre><code>// IdeaResourceTest.java (REST Assured + @QuarkusTest)
@QuarkusTest
class IdeaResourceTest {

    @Test
    void shouldReturnIdeas() {
        given()
            .when().get("/api/ideas/v1")
            .then()
            .statusCode(200)
            .contentType(ContentType.JSON);
    }

    @Test
    void shouldCreateIdea() {
        given()
            .contentType(ContentType.JSON)
            .body("""
                {"title": "REST-Test", "category": "MISC"}
                """)
            .when().post("/api/ideas/v1")
            .then()
            .statusCode(201)
            .body("title", equalTo("REST-Test"));
    }
}</code></pre>
                </div>
Für gesicherte Endpunkte bietet Quarkus die Annotation
<span class='latex-texttt'>@TestSecurity</span>, die eine authentifizierte Identität simuliert:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:rest-assured-testsecurity'></a>                     <pre><code>// SecuredIdeaResourceTest.java (@TestSecurity)
@QuarkusTest
class SecuredIdeaResourceTest {

    @Test
    @TestSecurity(user = "testuser", roles = {"user"})
    void shouldAllowAuthenticatedUser() {
        given()
            .when().get("/api/ideas/v1")
            .then()
            .statusCode(200);
    }

    @Test
    void shouldRejectUnauthenticatedUser() {
        given()
            .when().get("/api/ideas/v1")
            .then()
            .statusCode(401);
    }

    @Test
    @TestSecurity(user = "admin", roles = {"admin"})
    void shouldAllowAdminToDelete() {
        given()
            .when().delete("/api/ideas/v1/1")
            .then()
            .statusCode(204);
    }
}</code></pre>
                </div>
Für das Testen des nativen Quarkus-Artefakts bietet <span class='latex-texttt'>@QuarkusIntegrationTest</span>
die Möglichkeit, Tests gegen das tatsächlich gebaute Artefakt (JAR oder natives Image) auszuführen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:quarkus-integration-test'></a>                     <pre><code>// IdeaResourceIT.java (@QuarkusIntegrationTest)
@QuarkusIntegrationTest
class IdeaResourceIT {

    @Test
    void shouldReturnIdeasFromNativeImage() {
        given()
            .when().get("/api/ideas/v1")
            .then()
            .statusCode(200)
            .contentType(ContentType.JSON);
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b><span class='latex-texttt'>@TestSecurity</span> ersetzt die manuelle
JWT-Erstellung in Tests vollständig. Statt einen Token zu generieren und im
<span class='latex-texttt'>Authorization</span>-Header mitzusenden, deklariert die Annotation
den Benutzer und seine Rollen direkt am Testfall &mdash; das ist lesbarer und weniger fehleranfällig.</div>
<div class="tip"><b>Tipp: </b><span class='latex-texttt'>@QuarkusIntegrationTest</span> testet das
tatsächlich gebaute Artefakt &mdash; also das JAR oder das native Image.
Im Gegensatz zu <span class='latex-texttt'>@QuarkusTest</span>, das die Anwendung im JVM-Modus startet,
startet <span class='latex-texttt'>@QuarkusIntegrationTest</span> den realen Prozess.
Das ist besonders wichtig für native Images, da die GraalVM-Kompilierung
Reflection-Probleme aufdecken kann, die im JVM-Modus nicht sichtbar sind.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.7'><span class='entry-number'>12.7</span> Angular Unit-Tests (TestBed)</a> </h2>
Auf der Frontend-Seite bringt Angular mit dem <span class='latex-texttt'>TestBed</span> ein
eigenes Testframework mit, das konzeptionell dem CDI-Container für Tests entspricht.
TestBed konfiguriert ein isoliertes Angular-Modul für den Testfall,
löst Abhängigkeiten auf und erzeugt Komponenteninstanzen &mdash;
analog zu <span class='latex-texttt'>@EnableAutoWeld</span> für CDI-Beans.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Ein Komponententest für die <span class='latex-texttt'>IdeaListComponent</span> aus Kapitel 11:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:angular-component-test'></a>                     <pre><code>// idea-list.component.spec.ts
describe('IdeaListComponent', () =&gt; {
  let component: IdeaListComponent;
  let fixture: ComponentFixture&lt;IdeaListComponent&gt;;
  let ideaService: jasmine.SpyObj&lt;IdeaService&gt;;

  beforeEach(async () =&gt; {
    const spy = jasmine.createSpyObj('IdeaService', ['getAll', 'create']);

    await TestBed.configureTestingModule({
      imports: [IdeaListComponent],
      providers: [
        { provide: IdeaService, useValue: spy }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(IdeaListComponent);
    component = fixture.componentInstance;
    ideaService = TestBed.inject(IdeaService) as jasmine.SpyObj&lt;IdeaService&gt;;
  });

  it('should load ideas on init', () =&gt; {
    const testIdeas: Idea[] = [
      { id: 1, title: 'Test-Idee', category: 'MISC' }
    ];
    ideaService.getAll.and.returnValue(of(testIdeas));

    fixture.detectChanges();

    expect(component.ideas().length).toBe(1);
    expect(component.ideas()[0].title).toBe('Test-Idee');
  });

  it('should display ideas in template', () =&gt; {
    ideaService.getAll.and.returnValue(of([
      { id: 1, title: 'Angezeigt', category: 'MISC' }
    ]));

    fixture.detectChanges();

    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('.idea-card h3')?.textContent)
      .toContain('Angezeigt');
  });
});</code></pre>
                </div>
Für Service-Tests, die HTTP-Aufrufe mocken, bietet Angular den
<span class='latex-texttt'>HttpClientTestingModule</span> (bzw. seit Angular 18
<span class='latex-texttt'>provideHttpClientTesting()</span>):
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:angular-service-test'></a>                     <pre><code>// idea.service.spec.ts
describe('IdeaService', () =&gt; {
  let service: IdeaService;
  let httpTesting: HttpTestingController;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      providers: [
        IdeaService,
        provideHttpClient(),
        provideHttpClientTesting()
      ]
    });
    service = TestBed.inject(IdeaService);
    httpTesting = TestBed.inject(HttpTestingController);
  });

  afterEach(() =&gt; {
    httpTesting.verify();
  });

  it('should fetch all ideas', () =&gt; {
    const testIdeas: Idea[] = [
      { id: 1, title: 'HTTP-Test', category: 'MISC' }
    ];

    service.getAll().subscribe(ideas =&gt; {
      expect(ideas.length).toBe(1);
      expect(ideas[0].title).toBe('HTTP-Test');
    });

    const req = httpTesting.expectOne('/api/ideas/v1');
    expect(req.request.method).toBe('GET');
    req.flush(testIdeas);
  });
});</code></pre>
                </div>
Ein Test für den Auth-Guard, der die JWT-basierte Authentifizierung prüft:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:angular-guard-test'></a>                     <pre><code>// auth.guard.spec.ts
describe('AuthGuard', () =&gt; {
  let authService: jasmine.SpyObj&lt;AuthService&gt;;
  let router: jasmine.SpyObj&lt;Router&gt;;

  beforeEach(() =&gt; {
    const authSpy = jasmine.createSpyObj('AuthService', ['isAuthenticated']);
    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);

    TestBed.configureTestingModule({
      providers: [
        { provide: AuthService, useValue: authSpy },
        { provide: Router, useValue: routerSpy }
      ]
    });

    authService = TestBed.inject(AuthService) as jasmine.SpyObj&lt;AuthService&gt;;
    router = TestBed.inject(Router) as jasmine.SpyObj&lt;Router&gt;;
  });

  it('should allow authenticated users', () =&gt; {
    authService.isAuthenticated.and.returnValue(true);

    const result = TestBed.runInInjectionContext(() =&gt;
      authGuard({} as ActivatedRouteSnapshot, {} as RouterStateSnapshot)
    );

    expect(result).toBeTrue();
  });

  it('should redirect unauthenticated users to login', () =&gt; {
    authService.isAuthenticated.and.returnValue(false);

    TestBed.runInInjectionContext(() =&gt;
      authGuard({} as ActivatedRouteSnapshot, {} as RouterStateSnapshot)
    );

    expect(router.navigate).toHaveBeenCalledWith(['/login']);
  });
});</code></pre>
                </div>
Die Testkonfiguration in <span class='latex-texttt'>angular.json</span> definiert den Karma-Runner
und die Code-Coverage-Schwellenwerte:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:angular-test-config'></a>                     <pre><code>// angular.json (Test-Konfiguration, Auszug)
{
  "projects": {
    "ideafork-frontend": {
      "architect": {
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "tsConfig": "tsconfig.spec.json",
            "assets": ["src/assets"],
            "styles": ["src/styles.scss"],
            "codeCoverage": true,
            "codeCoverageExclude": [
              "src/test-setup.ts",
              "**/*.spec.ts"
            ]
          }
        }
      }
    }
  }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Das <span class='latex-texttt'>TestBed</span> ist das Angular-Äquivalent
zum CDI-Container im Testkontext: Es konfiguriert Dependencies, löst Injections auf
und stellt isolierte Komponenteninstanzen bereit.
Die Methode <span class='latex-texttt'>TestBed.inject()</span> entspricht
<span class='latex-texttt'>CDI.current().select()</span> &mdash;
beide liefern eine Instanz aus dem jeweiligen Dependency-Injection-Container.</div>
<div class="tip"><b>Tipp: </b>Standalone Components (seit Angular 15) vereinfachen die Testkonfiguration
erheblich: Statt ein <span class='latex-texttt'>TestModule</span> mit Deklarationen,
Imports und Providern aufzubauen, wird die Komponente direkt in
<span class='latex-texttt'>imports</span> übergeben. Das reduziert den Boilerplate-Code im Test
und entspricht dem Trend weg von NgModules hin zu einzelnen, selbstbeschreibenden Komponenten.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.8'><span class='entry-number'>12.8</span> E2E-Tests mit Playwright</a> </h2>
End-to-End-Tests prüfen die gesamte Anwendung aus Benutzerperspektive &mdash;
vom Angular-Frontend über die REST-API bis zur Datenbank.
Playwright ist der moderne Nachfolger von Selenium und bietet Auto-Wait,
Multi-Browser-Unterstützung und integriertes Tracing.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die Playwright-Konfiguration für <span class='latex-textit'>IdeaFork</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:playwright-config'></a>                     <pre><code>// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  retries: process.env.CI ? 2 : 0,
  reporter: process.env.CI ? 'html' : 'list',

  use: {
    baseURL: 'http://localhost:8080',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },

  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
  ],

  webServer: {
    command: 'mvn quarkus:dev -Dquarkus.http.port=8080',
    port: 8080,
    timeout: 120_000,
    reuseExistingServer: !process.env.CI,
  },
});</code></pre>
                </div>
Ein E2E-Test für den Login-Vorgang:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:playwright-login-test'></a>                     <pre><code>// e2e/login.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Login', () =&gt; {
  test('should login with valid credentials', async ({ page }) =&gt; {
    await page.goto('/login');

    await page.getByLabel('Username').fill('testuser');
    await page.getByLabel('Password').fill('testpass');
    await page.getByRole('button', { name: 'Login' }).click();

    await expect(page).toHaveURL('/ideas');
    await expect(page.getByText('Meine Ideen')).toBeVisible();
  });

  test('should show error for invalid credentials', async ({ page }) =&gt; {
    await page.goto('/login');

    await page.getByLabel('Username').fill('invalid');
    await page.getByLabel('Password').fill('wrong');
    await page.getByRole('button', { name: 'Login' }).click();

    await expect(page.getByText('Anmeldung fehlgeschlagen'))
      .toBeVisible();
  });
});</code></pre>
                </div>
Ein umfassenderer E2E-Test für den Ideen-Workflow:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:playwright-idea-flow'></a>                     <pre><code>// e2e/idea-flow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Idea Flow', () =&gt; {
  test.beforeEach(async ({ page }) =&gt; {
    // Login
    await page.goto('/login');
    await page.getByLabel('Username').fill('testuser');
    await page.getByLabel('Password').fill('testpass');
    await page.getByRole('button', { name: 'Login' }).click();
    await expect(page).toHaveURL('/ideas');
  });

  test('should create and display a new idea', async ({ page }) =&gt; {
    await page.getByRole('button', { name: 'Neue Idee' }).click();

    await page.getByLabel('Titel').fill('E2E-Testidee');
    await page.getByLabel('Kategorie').selectOption('MISC');
    await page.getByLabel('Beschreibung').fill('Erstellt via Playwright');
    await page.getByRole('button', { name: 'Speichern' }).click();

    await expect(page.getByText('E2E-Testidee')).toBeVisible();
  });

  test('should promote an idea', async ({ page }) =&gt; {
    await page.getByText('E2E-Testidee').click();
    await page.getByRole('button', { name: 'Promote' }).click();

    await expect(page.getByText('Status: PROMOTED')).toBeVisible();
  });
});</code></pre>
                </div>
Für die Integration in eine CI/CD-Pipeline:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:ci-workflow'></a>                     <pre><code># .github/workflows/e2e.yml
name: E2E Tests
on: [push, pull_request]

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps chromium
      - name: Run E2E Tests
        run: npx playwright test --project=chromium
      - uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Die <span class='latex-texttt'>webServer</span>-Konfiguration in Playwright
startet automatisch den Quarkus-Dev-Server vor den Tests und beendet ihn danach.
Mit <span class='latex-texttt'>reuseExistingServer: !process.env.CI</span> wird in der lokalen
Entwicklung ein bereits laufender Server wiederverwendet &mdash; das beschleunigt
die Feedback-Schleife erheblich.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>E2E-Tests sind die langsamste und fragilste Teststufe.
Halten Sie die Anzahl der E2E-Tests gering und konzentrieren Sie sich auf
die kritischen Benutzer-Workflows (Login, Idee erstellen, Promotion).
Die Testpyramide gilt auch hier: Viele Unit-Tests (Weld-JUnit5, TestBed),
wenige Integrationstests (<span class='latex-texttt'>@QuarkusTest</span>),
minimale E2E-Tests (Playwright).</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.9'><span class='entry-number'>12.9</span> IdeaFork Test-Migrations-Checkliste</a> </h2>
Die Migration der Tests für <span class='latex-textit'>IdeaFork</span> folgt denselben Prinzipien
wie die Produktionsmigration: schrittweise, schichtweise und mit klaren Äquivalenzen.
Die folgende Checkliste fasst die konkreten Migrationsschritte zusammen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-migration-checklist'></a>                     <pre><code>IdeaFork Test-Migrations-Checkliste
======================================

1. Test-Abhaengigkeiten umstellen
   - DeltaSpike Test-Control   -> org.jboss.weld:weld-junit5
   - Arquillian                -> io.quarkus:quarkus-junit5
   - Meecrowave Test           -> io.rest-assured:rest-assured
   - Selenium                  -> @playwright/test
   - JUnit 4                   -> JUnit 5 (org.junit.jupiter)

2. CDI-Unit-Tests migrieren
   - @RunWith(CdiTestRunner.class) entfernen
   - @EnableAutoWeld hinzufuegen
   - public-Modifier von Testklassen/Methoden entfernen (JUnit 5)
   - DeltaSpike @Exclude in Tests -> @ExcludeBean fuer Mocks

3. Integrationstests migrieren
   - @RunWith(Arquillian.class) entfernen
   - @Deployment-Methoden entfernen
   - @QuarkusTest hinzufuegen
   - ShrinkWrap-Archive durch Dev Services ersetzen
   - @InjectMock statt manueller CDI-Producer

4. REST-Tests migrieren
   - MonoMeecrowave.Rule entfernen
   - REST Assured DSL verwenden (given/when/then)
   - @TestSecurity fuer gesicherte Endpunkte
   - @QuarkusIntegrationTest fuer Native-Image-Tests

5. Frontend-Tests einrichten
   - Angular TestBed fuer Komponenten- und Service-Tests
   - HttpTestingController fuer HTTP-Mocking
   - Karma-Runner konfigurieren (angular.json)
   - Code-Coverage aktivieren

6. E2E-Tests einrichten
   - Playwright installieren und konfigurieren
   - webServer-Config fuer Quarkus-Dev-Server
   - Kritische Workflows als E2E-Tests abbilden
   - CI-Workflow mit Playwright einrichten</code></pre>
                </div>
Die Testpyramide für das migrierte <span class='latex-textit'>IdeaFork</span> zeigt
die empfohlene Verteilung der Teststufen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-pyramid'></a>                     <pre><code>IdeaFork Testpyramide
======================================

          /\
         /  \           E2E (Playwright)
        / 5% \          ~5 Tests: Login, Idee-CRUD, Promotion
       /------\
      /        \        Integration (@QuarkusTest)
     /   20%    \       ~20 Tests: REST-Endpunkte, DB-Zugriff
    /------------\
   /              \     Unit (Weld-JUnit5 + TestBed)
  /     75%        \    ~80 Tests: CDI-Beans, Services, Komponenten
 /------------------\

 Schnell, isoliert             Langsam, realistisch
 &lt;---------------------------------------------&gt;</code></pre>
                </div>
Die konkreten Befehle für die Testausführung:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/testing.html:fig:test-run-commands'></a>                     <pre><code># Test-Ausfuehrung
# ======================================

# Alle Backend-Tests (Unit + Integration)
mvn test

# Nur CDI-Unit-Tests (schnell, kein Container)
mvn test -Dtest="*Test" -DfailIfNoTests=false

# Nur Integrationstests
mvn verify -Dskip.unit.tests=true

# Native-Image-Tests
mvn verify -Pnative -Dquarkus.test.native-image-wait-time=300

# Angular Unit-Tests
cd src/main/webui &amp;&amp; ng test --watch=false --code-coverage

# Angular Unit-Tests (CI, headless)
cd src/main/webui &amp;&amp; ng test --watch=false --browsers=ChromeHeadless

# Playwright E2E-Tests
npx playwright test

# Playwright E2E-Tests (nur Chromium, mit UI)
npx playwright test --project=chromium --ui</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Die Test-Migration kann inkrementell erfolgen:
Beginnen Sie mit den CDI-Unit-Tests (Weld-JUnit5), da diese die geringste
Infrastruktur erfordern. Dann migrieren Sie die Integrationstests zu
<span class='latex-texttt'>@QuarkusTest</span> und richten abschließend die Frontend-
und E2E-Tests ein. Alte und neue Tests können während der Migration
parallel koexistieren &mdash; JUnit 4 und JUnit 5 lassen sich im selben
Projekt über die <span class='latex-texttt'>junit-vintage-engine</span> kombinieren.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/testing.html:12.10'><span class='entry-number'>12.10</span> Quellen</a> </h2>
<b>Quellen:</b><br />
- weld.cdi-spec.org (Weld-JUnit5)<br />
- quarkus.io/guides/getting-started-testing<br />
- quarkus.io/guides/dev-services<br />
- rest-assured.io<br />
- arquillian.org<br />
- angular.dev/guide/testing<br />
- playwright.dev<br />
- junit.org/junit5<br />
</section>

<section class="chapter-section" id="chapter-13">
<h1> <a class='latex-index-anchor' name='!idx:/security.html:13'><span class='entry-number'>13</span> Sicherheit über alle Schichten</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Dieses Kapitel wurde von Claude (AI built by Anthropic) auf Basis der vorherigen Kapitel verfasst. Es beschreibt die Migration der Sicherheitsarchitektur von IdeaFork &mdash; von DeltaSpike @Secured über Quarkus Security und MicroProfile JWT bis hin zu OIDC mit Keycloak und Angular Auth Guards.
</div>
<div style="background:#f8d7da; border:1px solid #f5c2c7; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#842029;">
<strong>Achtung:</strong> Dieses Kapitel wurde nicht von einem Sicherheitsexperten geprüft. Da es sich um vollständig KI-generierte Inhalte handelt, können Fehler in den Erklärungen oder Codebeispielen im Kontext von Sicherheit mehr Schaden als Nutzen anrichten. Bitte ziehen Sie vor der Übernahme in produktive Systeme immer offizielle Dokumentation und fachkundige Prüfung heran.
</div>
<a name = '!idx:/security.html:chap:security-across-stack'> </a><h2><a class='latex-index-anchor' name='!idx:/security.html:13.1'><span class='entry-number'>13.1</span> DeltaSpike Security — Ein Rückblick</a> </h2>
 In Kapitel 5 wurde die Sicherheitsintegration von <span class='latex-textit'>IdeaFork</span> auf Basis von
DeltaSpike Security vorgestellt. Das Konzept basierte auf der Annotation
<span class='latex-texttt'>@Secured</span> in Kombination mit dem
<span class='latex-texttt'>AccessDecisionVoter</span>-Pattern. Methoden konnten mit
<span class='latex-texttt'>@Secured</span> annotiert werden, und ein CDI-Interceptor delegierte
die Berechtigungsprüfung an einen oder mehrere Voter.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Das folgende Beispiel zeigt das DeltaSpike-Security-Pattern im Überblick &mdash; ein Service,
der den Zugriff über einen <span class='latex-texttt'>AccessDecisionVoter</span> absichert:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:deltaspike-secured-recap'></a>                     <pre><code>@ApplicationScoped
public class IdeaServiceSecured {

    @Inject
    private IdeaManager ideaManager;

    @Secured(IdeaAccessDecisionVoter.class)
    public List&lt;Idea&gt; findAllSecured() {
        return ideaManager.findAll();
    }
}</code></pre>
                </div>
Der zugehörige <span class='latex-texttt'>AccessDecisionVoter</span> implementiert die eigentliche
Berechtigungslogik:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:deltaspike-voter-impl'></a>                     <pre><code>@ApplicationScoped
public class IdeaAccessDecisionVoter
        implements AccessDecisionVoter {

    @Override
    public Set&lt;SecurityViolation&gt; checkPermission(
            AccessDecisionVoterContext context) {
        // Benutzerdefinierte Sicherheitslogik
        return Collections.emptySet();
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>DeltaSpike Security war ein rein annotationsgetriebener Ansatz,
der sich nahtlos in die CDI-Welt einfügte. Das Voter-Pattern ermöglichte flexible,
wiederverwendbare Berechtigungsprüfungen. Mit der Migration zu Quarkus
stehen nun standardisierte Alternativen bereit.</div>
Die folgende Übersicht zeigt die Zuordnung der DeltaSpike-Security-Konzepte
zu ihren Quarkus-Äquivalenten:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:voter-to-identity-mapping'></a>                     <pre><code>DeltaSpike Security  --&gt;  Quarkus Security
======================================
@Secured              --&gt;  @RolesAllowed
AccessDecisionVoter   --&gt;  SecurityIdentity
SecurityViolation     --&gt;  ForbiddenException
Interceptor-basiert   --&gt;  Annotation-basiert
Custom Voter-Logik    --&gt;  hasRole() / hasPermission()</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.2'><span class='entry-number'>13.2</span> Quarkus Security — Architektur</a> </h2>
Quarkus bringt ein eigenes, auf Standards aufbauendes Sicherheitsframework mit.
Im Zentrum steht <span class='latex-texttt'>SecurityIdentity</span> &mdash; das zentrale Objekt,
das den authentifizierten Benutzer repräsentiert. Es ersetzt sowohl DeltaSpikes
<span class='latex-texttt'>AccessDecisionVoter</span> als auch den manuellen
<span class='latex-texttt'>IdentityHolder</span> aus dem IdeaForkMicro-Beispiel (Kapitel 8).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die Quarkus-Security-Architektur besteht aus drei Kernkomponenten:
<span class='latex-texttt'>HttpAuthenticationMechanism</span> (wie wird authentifiziert),
<span class='latex-texttt'>IdentityProvider</span> (woher kommen die Benutzerdaten) und
<span class='latex-texttt'>SecurityIdentity</span> (wer ist der aktuelle Benutzer).
Für die meisten Anwendungsfälle genügt es, eine Extension wie
<span class='latex-texttt'>quarkus-oidc</span> einzubinden &mdash; die drei Komponenten werden
dann automatisch konfiguriert.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Das folgende Beispiel zeigt einen REST-Endpunkt, der
<span class='latex-texttt'>SecurityIdentity</span> und <span class='latex-texttt'>@RolesAllowed</span>
kombiniert:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:security-identity-resource'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class SecuredIdeaResource {

    @Inject
    SecurityIdentity identity;

    @Inject
    IdeaService ideaService;

    @GET
    @RolesAllowed("user")
    public List&lt;Idea&gt; getAll() {
        return ideaService.findAll();
    }

    @DELETE
    @Path("/{id}")
    @RolesAllowed("admin")
    public void delete(@PathParam("id") Long id) {
        String user = identity.getPrincipal().getName();
        // Protokollierung: user hat Idea id geloescht
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b><span class='latex-texttt'>SecurityIdentity</span> ist die zentrale Abstraktion
in Quarkus Security. Sie bietet Methoden wie <span class='latex-texttt'>getPrincipal()</span>,
<span class='latex-texttt'>getRoles()</span> und <span class='latex-texttt'>hasRole()</span> &mdash;
vergleichbar mit dem DeltaSpike-Voter-Pattern, aber auf einem Standard-API aufbauend.</div>
Neben <span class='latex-texttt'>@RolesAllowed</span> bietet Quarkus die Annotation
<span class='latex-texttt'>@Authenticated</span>, die lediglich eine gültige Authentifizierung
verlangt, ohne bestimmte Rollen zu prüfen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:authenticated-resource'></a>                     <pre><code>@Path("/api/profile")
@Authenticated
@RequestScoped
public class ProfileResource {

    @Inject
    SecurityIdentity identity;

    @GET
    public String getProfile() {
        return identity.getPrincipal().getName();
    }
}</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b><span class='latex-texttt'>@RolesAllowed</span> und
<span class='latex-texttt'>@Authenticated</span> funktionieren nur, wenn ein
Authentication-Mechanismus konfiguriert ist (z.B. über
<span class='latex-texttt'>quarkus-oidc</span> oder
<span class='latex-texttt'>quarkus-smallrye-jwt</span>). Ohne eine solche Extension
werden die Annotationen ignoriert und alle Endpunkte sind ungeschützt.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.3'><span class='entry-number'>13.3</span> MicroProfile JWT im Detail</a> </h2>
In Kapitel 8 wurde im IdeaForkMicro-Beispiel ein manuelles JWT-Handling implementiert &mdash;
Token-Erzeugung, Validierung und Propagation zwischen Services erfolgten von Hand.
MicroProfile JWT standardisiert diesen Prozess und macht die manuelle Implementierung überflüssig.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
MicroProfile JWT definiert das Interface <span class='latex-texttt'>JsonWebToken</span>,
das per <span class='latex-texttt'>@Inject</span> in beliebige CDI-Beans injiziert werden kann.
Es bietet typsicheren Zugriff auf Token-Claims wie Name, Gruppen und Ablaufzeit:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:jwt-token-resource'></a>                     <pre><code>@Path("/api/ideas")
@RequestScoped
public class JwtIdeaResource {

    @Inject
    JsonWebToken jwt;

    @Inject
    IdeaService ideaService;

    @GET
    @Path("/my")
    @RolesAllowed("user")
    public List&lt;Idea&gt; getMyIdeas() {
        String username = jwt.getName();
        Set&lt;String&gt; groups = jwt.getGroups();
        return ideaService.findAll();
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>MicroProfile JWT ist eine standardisierte Spezifikation &mdash;
der Code funktioniert unverändert mit jeder konformen Implementierung
(Quarkus SmallRye JWT, Open Liberty, Payara). Das manuelle JWT-Handling
aus Kapitel 8 war zwar lehrreich, aber in Produktionsanwendungen
sollte immer die standardisierte Variante bevorzugt werden.</div>
Für den Zugriff auf einzelne Claims bietet MicroProfile JWT die
<span class='latex-texttt'>@Claim</span>-Annotation, die Claims direkt als CDI-Injection-Points
bereitstellt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:jwt-claim-resource'></a>                     <pre><code>@Path("/api/userinfo")
@RequestScoped
public class UserInfoResource {

    @Inject
    @Claim(standard = Claims.preferred_username)
    String username;

    @Inject
    @Claim(standard = Claims.email)
    String email;

    @GET
    @RolesAllowed("user")
    public String getUserInfo() {
        return username + " (" + email + ")";
    }
}</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>Die <span class='latex-texttt'>@Claim</span>-Injection
funktioniert nur in <span class='latex-texttt'>@RequestScoped</span>-Beans, da Claims
an den aktuellen HTTP-Request gebunden sind. In
<span class='latex-texttt'>@ApplicationScoped</span>-Beans würde immer der Claim
des ersten Requests injiziert werden.</div>
Die Konfiguration von MicroProfile JWT erfolgt über Standard-Properties
in der <span class='latex-texttt'>application.properties</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:mp-jwt-config'></a>                     <pre><code># MicroProfile JWT Konfiguration
mp.jwt.verify.publickey.location=publicKey.pem
mp.jwt.verify.issuer=https://idp.ideafork.dev

smallrye.jwt.sign.key.location=privateKey.pem</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.4'><span class='entry-number'>13.4</span> OIDC / OAuth2 mit Keycloak</a> </h2>
Während MicroProfile JWT die Token-Validierung standardisiert, adressiert OIDC (OpenID Connect)
den gesamten Authentifizierungsfluss &mdash; von der Anmeldung über die Token-Ausgabe bis zur
Session-Verwaltung. Quarkus unterstützt OIDC nativ über die Extension
<span class='latex-texttt'>quarkus-oidc</span>.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Keycloak ist der am häufigsten eingesetzte OIDC-Provider im Java-Ökosystem
und lässt sich nahtlos mit Quarkus integrieren. Die Konfiguration erfolgt
über wenige Properties:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:oidc-keycloak-config'></a>                     <pre><code># OIDC/Keycloak Konfiguration
quarkus.oidc.auth-server-url=\
    http://localhost:8180/realms/ideafork
quarkus.oidc.client-id=ideafork-backend
quarkus.oidc.credentials.secret=geheim
quarkus.oidc.application-type=service
quarkus.oidc.token.issuer=any</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Die Einstellung <span class='latex-texttt'>application-type=service</span>
konfiguriert den Backend-Endpunkt als reinen Bearer-Token-Empfänger &mdash;
er akzeptiert und validiert Tokens, stellt aber selbst keine Anmeldeseite bereit.
Für Web-Anwendungen mit serverseitigem Rendering wäre
<span class='latex-texttt'>application-type=web-app</span> die richtige Wahl.</div>
Ein besonderer Vorteil von Quarkus ist der integrierte Keycloak Dev Service.
In der Entwicklungs- und Testphase startet Quarkus automatisch eine
Keycloak-Instanz als Container &mdash; ohne manuelle Konfiguration:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:keycloak-devservice-config'></a>                     <pre><code># Keycloak Dev Service (nur dev/test)
quarkus.keycloak.devservices.enabled=true
quarkus.keycloak.devservices.realm-path=\
    ideafork-realm.json
quarkus.keycloak.devservices.port=8180</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Der Keycloak Dev Service eliminiert die Notwendigkeit einer
manuellen Keycloak-Installation für Entwicklung und Tests. Quarkus startet
automatisch einen Keycloak-Container mit der vordefinierten Realm-Konfiguration.
Damit wird der Identity-Provider-Setup genauso einfach wie
der Datenbank-Setup mit Dev Services aus Kapitel 12.</div>
Der REST-Endpunkt selbst benötigt keine OIDC-spezifischen Annotationen &mdash;
die bestehenden <span class='latex-texttt'>@RolesAllowed</span>- und
<span class='latex-texttt'>@Authenticated</span>-Annotationen funktionieren automatisch
mit dem OIDC-Provider:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:oidc-protected-resource'></a>                     <pre><code>@Path("/api/ideas")
@Authenticated
@ApplicationScoped
public class OidcIdeaResource {

    @Inject
    SecurityIdentity identity;

    @Inject
    IdeaService ideaService;

    @GET
    public List&lt;Idea&gt; getAll() {
        return ideaService.findAll();
    }

    @POST
    @RolesAllowed("user")
    public Idea create(Idea idea) {
        return ideaService.save(idea);
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Der Wechsel von MicroProfile JWT zu OIDC erfordert keine Änderungen
am Anwendungscode &mdash; lediglich die <span class='latex-texttt'>application.properties</span>
ändern sich. Die Annotationen <span class='latex-texttt'>@RolesAllowed</span> und
<span class='latex-texttt'>@Authenticated</span> funktionieren mit beiden Ansätzen identisch.
Dies ist ein wesentlicher Vorteil der standardisierten Quarkus-Security-Architektur.</div>
Für die Propagation von Tokens zwischen Microservices &mdash; ein Thema, das in Kapitel 8
manuell gelöst wurde &mdash; bietet Quarkus die Extension
<span class='latex-texttt'>quarkus-rest-client-oidc-token-propagation</span>. Diese leitet
das Bearer-Token des eingehenden Requests automatisch an REST-Client-Aufrufe weiter:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:token-propagation-config'></a>                     <pre><code># Token-Propagation fuer REST Client
quarkus.rest-client.downstream-api.url=\
    http://localhost:8081
quarkus.rest-client.downstream-api\
    .provider=io.quarkus.oidc.token.propagation\
    .reactive.AccessTokenRequestReactiveFilter</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.5'><span class='entry-number'>13.5</span> @RolesAllowed und Berechtigungen</a> </h2>
Die Annotation <span class='latex-texttt'>@RolesAllowed</span> aus
<span class='latex-texttt'>jakarta.annotation.security</span> ist der Standard-Mechanismus
für deklarative Autorisierung in Quarkus. Sie kann sowohl auf Klassen-
als auch auf Methoden-Ebene angewendet werden und bietet damit die gleiche
Flexibilität wie das DeltaSpike-Voter-Pattern.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Das folgende Beispiel zeigt feingranulare Berechtigungen auf Methoden-Ebene,
kombiniert mit einer permissiven Standardkonfiguration auf Klassen-Ebene:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:roles-method-level'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
@PermitAll
public class GranularIdeaResource {

    @Inject
    IdeaService ideaService;

    @GET
    @PermitAll
    public List&lt;Idea&gt; getAll() {
        return ideaService.findAll();
    }

    @POST
    @RolesAllowed("user")
    public Idea create(Idea idea) {
        return ideaService.save(idea);
    }

    @DELETE
    @Path("/{id}")
    @RolesAllowed("admin")
    public void delete(@PathParam("id") Long id) {
        // Nur Administratoren
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Methoden-Level-Annotationen überschreiben Klassen-Level-Annotationen.
Im obigen Beispiel ist <span class='latex-texttt'>@PermitAll</span> auf Klassen-Ebene gesetzt
(alle Endpunkte sind standardmäßig offen), aber einzelne Methoden schränken
den Zugriff mit <span class='latex-texttt'>@RolesAllowed</span> ein.
Das Gegenteil &mdash; <span class='latex-texttt'>@DenyAll</span> auf Klassen-Ebene mit
<span class='latex-texttt'>@RolesAllowed</span> auf Methoden-Ebene &mdash; ist das
restriktivere und damit empfohlene Pattern.</div>
Wenn die rollenbasierte Autorisierung nicht ausreicht, bietet
<span class='latex-texttt'>SecurityIdentity</span> programmatische Sicherheitsprüfungen.
Damit lassen sich komplexe Berechtigungsszenarien abbilden, die über
einfache Rollenzugehörigkeit hinausgehen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:programmatic-security'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class ProgrammaticSecurityResource {

    @Inject
    SecurityIdentity identity;

    @Inject
    IdeaService ideaService;

    @PUT
    @Path("/{id}")
    @Authenticated
    public Idea update(@PathParam("id") Long id,
                       Idea idea) {
        if (!identity.hasRole("admin")
                &amp;&amp; !isOwner(id)) {
            throw new ForbiddenException(
                "Keine Berechtigung");
        }
        return ideaService.save(idea);
    }

    private boolean isOwner(Long id) {
        String user =
            identity.getPrincipal().getName();
        return user != null;
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Programmatische Sicherheitsprüfungen mit
<span class='latex-texttt'>SecurityIdentity</span> sind das direkte Äquivalent
zur <span class='latex-texttt'>AccessDecisionVoter</span>-Logik aus DeltaSpike.
Der Vorteil: Es wird kein separater Voter benötigt &mdash; die Logik
kann direkt im Resource-Endpunkt implementiert werden.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.6'><span class='entry-number'>13.6</span> Angular Auth Guards im Detail</a> </h2>
In Kapitel 11 wurde die grundlegende Integration von Angular Route Guards vorgestellt.
Für eine produktionsreife OIDC-Integration ersetzt die Bibliothek
<span class='latex-texttt'>angular-auth-oidc-client</span> das manuelle Token-Handling
über <span class='latex-texttt'>localStorage</span>, das in Kapitel 11 als einfache Lösung gezeigt wurde.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Die OIDC-Konfiguration erfolgt zentral in der Angular-Applikation:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:angular-oidc-config'></a>                     <pre><code>// app.config.ts
export const authConfig = {
  config: {
    authority:
      'http://localhost:8180/realms/ideafork',
    redirectUrl: window.location.origin,
    postLogoutRedirectUri: window.location.origin,
    clientId: 'ideafork-frontend',
    scope: 'openid profile email',
    responseType: 'code',
  }
};</code></pre>
                </div>
Der Auth Guard prüft bei jedem Routenwechsel, ob der Benutzer authentifiziert ist,
und leitet ihn andernfalls zur Keycloak-Anmeldeseite weiter:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:angular-auth-guard'></a>                     <pre><code>// auth.guard.ts
@Injectable({ providedIn: 'root' })
export class AuthGuard {
  private oidc = inject(OidcSecurityService);

  canActivate(): Observable&lt;boolean&gt; {
    return this.oidc.isAuthenticated$.pipe(
      map(({ isAuthenticated }) =&gt; {
        if (!isAuthenticated) {
          this.oidc.authorize();
          return false;
        }
        return true;
      })
    );
  }
}</code></pre>
                </div>
Um das Bearer-Token bei jedem HTTP-Request automatisch mitzusenden,
wird ein HTTP-Interceptor registriert:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:angular-auth-interceptor'></a>                     <pre><code>// auth.interceptor.ts
export const authInterceptor: HttpInterceptorFn =
  (req, next) =&gt; {
    const oidc = inject(OidcSecurityService);
    return oidc.getAccessToken().pipe(
      switchMap(token =&gt; {
        if (token) {
          req = req.clone({
            setHeaders: {
              Authorization: `Bearer ${token}`
            }
          });
        }
        return next(req);
      })
    );
  };</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Die Bibliothek <span class='latex-texttt'>angular-auth-oidc-client</span>
speichert Tokens sicher im Session Storage (nicht im localStorage)
und unterstützt automatische Token-Erneuerung (Silent Renew).
Damit wird das manuelle Token-Management aus Kapitel 11 vollständig ersetzt.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.7'><span class='entry-number'>13.7</span> CSRF, CORS und CSP</a> </h2>
Neben Authentifizierung und Autorisierung erfordert eine produktionsreife Anwendung
zusätzliche HTTP-Sicherheitsmechanismen. Die drei wichtigsten sind
CORS (Cross-Origin Resource Sharing), CSRF (Cross-Site Request Forgery)
und CSP (Content Security Policy).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
CORS kontrolliert, welche Domains auf die REST-API zugreifen dürfen.
Da das Angular-Frontend und das Quarkus-Backend typischerweise auf unterschiedlichen
Ports laufen, muss CORS explizit konfiguriert werden:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:cors-config'></a>                     <pre><code># CORS Konfiguration
quarkus.http.cors=true
quarkus.http.cors.origins=http://localhost:4200
quarkus.http.cors.methods=\
    GET,POST,PUT,DELETE,OPTIONS
quarkus.http.cors.headers=\
    Authorization,Content-Type
quarkus.http.cors.exposed-headers=Location
quarkus.http.cors.access-control-max-age=24H</code></pre>
                </div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>Vermeiden Sie
<span class='latex-texttt'>quarkus.http.cors.origins=*</span> in Produktionsumgebungen.
Ein Wildcard erlaubt jedem Origin den Zugriff auf die API &mdash;
dies öffnet die Tür für Cross-Site-Angriffe. Listen Sie stattdessen
explizit die erlaubten Domains auf.</div>
CSRF-Schutz verhindert, dass bösartige Websites im Namen des
angemeldeten Benutzers Aktionen ausführen. Quarkus bietet dafür
die Extension <span class='latex-texttt'>quarkus-rest-csrf</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:csrf-config'></a>                     <pre><code># CSRF-Schutz Konfiguration
quarkus.rest-csrf.cookie-name=csrf-token
quarkus.rest-csrf.form-field-name=csrf-token
quarkus.rest-csrf.token-header-name=\
    X-CSRF-TOKEN</code></pre>
                </div>
Content Security Policy (CSP) kontrolliert, welche Ressourcen der Browser laden darf.
Ein JAX-RS-Filter kann diese Header für jeden Response setzen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:csp-response-filter'></a>                     <pre><code>@Provider
public class SecurityHeadersFilter
        implements ContainerResponseFilter {

    @Override
    public void filter(
            ContainerRequestContext request,
            ContainerResponseContext response) {
        response.getHeaders().add(
            "Content-Security-Policy",
            "default-src 'self'; script-src 'self'");
        response.getHeaders().add(
            "X-Content-Type-Options", "nosniff");
        response.getHeaders().add(
            "X-Frame-Options", "DENY");
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>CORS, CSRF und CSP ergänzen sich gegenseitig:
CORS schützt die API vor unautorisierten Cross-Origin-Aufrufen,
CSRF verhindert gefälschte Requests im Namen des Benutzers,
und CSP kontrolliert, welche Ressourcen der Browser laden darf.
Für eine vollständige Absicherung sollten alle drei Mechanismen
gemeinsam aktiviert werden.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.8'><span class='entry-number'>13.8</span> IdeaFork absichern — Checkliste</a> </h2>
Sicherheitstests sind ein wesentlicher Bestandteil der Migrationsstrategie.
Quarkus bietet mit <span class='latex-texttt'>@TestSecurity</span> eine elegante Möglichkeit,
Sicherheitsaspekte isoliert zu testen &mdash; ohne einen laufenden Identity Provider zu benötigen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:security-test-roles'></a>                     <pre><code>@QuarkusTest
class IdeaResourceSecurityTest {

    @Test
    @TestSecurity(user = "testuser", roles = "user")
    void testGetIdeasAsUser() {
        given()
            .when().get("/api/ideas")
            .then()
            .statusCode(200);
    }

    @Test
    @TestSecurity(user = "admin", roles = "admin")
    void testDeleteAsAdmin() {
        given()
            .when().delete("/api/ideas/1")
            .then()
            .statusCode(204);
    }

    @Test
    void testUnauthorizedAccess() {
        given()
            .when().get("/api/ideas")
            .then()
            .statusCode(401);
    }
}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b><span class='latex-texttt'>@TestSecurity</span> simuliert einen
authentifizierten Benutzer direkt im Test &mdash; ohne Token-Erzeugung oder
Keycloak-Anbindung. Für Integrationstests, die den vollständigen
OIDC-Fluss mit Keycloak testen sollen, kann der Keycloak Dev Service
in Kombination mit <span class='latex-texttt'>@QuarkusTest</span> verwendet werden.</div>
Die folgende Übersicht fasst die Security-Stack-Migration zusammen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:security-stack-overview'></a>                     <pre><code>Sicherheits-Stack-Uebersicht
======================================

Schicht          Alt                    Neu
----------------------------------------------
Backend-Auth     DeltaSpike @Secured    @RolesAllowed
Token            manuell (Kap. 8)      MicroProfile JWT
Identity         IdentityHolder         SecurityIdentity
IdP              ---                    Keycloak + OIDC
Frontend-Auth    localStorage           angular-auth-oidc
HTTP-Security    ---                    CORS / CSRF / CSP
Test             ---                    @TestSecurity</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Die Security-Migration kann schrittweise erfolgen:
Zuerst <span class='latex-texttt'>@RolesAllowed</span> auf den REST-Endpunkten einführen (funktioniert auch
ohne OIDC mit <span class='latex-texttt'>@TestSecurity</span> in Tests), dann Keycloak als
Identity Provider anbinden, und schließlich das Angular-Frontend auf
den OIDC-Client umstellen.</div>
Die konkrete Migrations-Checkliste für <span class='latex-textit'>IdeaFork</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/security.html:fig:security-migration-checklist'></a>                     <pre><code>IdeaFork Security-Haertung -- Checkliste
=========================================
[ ] DeltaSpike @Secured  --&gt;  @RolesAllowed
[ ] IdentityHolder  --&gt;  SecurityIdentity
[ ] Manueller JWT (Kap. 8) --&gt; MicroProfile JWT
[ ] Keycloak als Identity Provider
[ ] OIDC-Integration (Backend + Frontend)
[ ] Angular: localStorage  --&gt;  OIDC-Client
[ ] CORS auf Produktions-Domains einschraenken
[ ] CSP-Headers aktivieren
[ ] @TestSecurity fuer Security-Tests
[ ] Keycloak Dev Service fuer Integration</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/security.html:13.9'><span class='entry-number'>13.9</span> Quellen</a> </h2>
- quarkus.io/guides/security-overview<br />
- quarkus.io/guides/security-oidc-bearer-token-authentication<br />
- quarkus.io/guides/security-keycloak-admin-client<br />
- download.eclipse.org/microprofile/microprofile-jwt-auth-2.1<br />
- keycloak.org/documentation<br />
- github.com/damienbod/angular-auth-oidc-client<br />
- developer.mozilla.org/en-US/docs/Web/HTTP/CORS<br />
- developer.mozilla.org/en-US/docs/Web/HTTP/CSP<br />
- owasp.org/www-community/attacks/csrf<br />
</section>

<section class="chapter-section" id="chapter-14">
<h1> <a class='latex-index-anchor' name='!idx:/cloud.html:14'><span class='entry-number'>14</span> Vom JAR in die Cloud</a></h1>
<div style="background:#fff3cd; border:1px solid #ffc107; border-radius:8px; padding:1em 1.5em; margin:0 0 2em 0; font-size:0.95em; color:#856404;">
<strong>Hinweis:</strong> Dieses Kapitel wurde von Claude (AI built by Anthropic) auf Basis der vorherigen Kapitel verfasst. Es beschreibt den Weg von IdeaFork aus der lokalen Entwicklung in eine produktionsreife, containerisierte Cloud-Umgebung &mdash; von Packaging über Observability bis zum Kubernetes-Deployment.
</div>
<a name = '!idx:/cloud.html:chap:from-jar-to-cloud'> </a><h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.1'><span class='entry-number'>14.1</span> Quarkus Packaging-Optionen</a> </h2>
 Der Migrationsweg von <span class='latex-textit'>IdeaFork</span> hat in Kapitel 10 den Wechsel zu Quarkus vollzogen,
in Kapitel 11 das Frontend modernisiert und in den Kapiteln 12-13 Tests und Sicherheit aufgebaut.
Der letzte Schritt: der Weg vom lokal laufenden JAR in eine produktionsreife Cloud-Umgebung.
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Quarkus bietet drei Packaging-Modi, die jeweils unterschiedliche Anforderungen bedienen:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:packaging-overview'></a>                     <pre><code>Quarkus Packaging-Optionen
======================================

Modus           Artefakt              Einsatz
----------------------------------------------
Fast JAR        quarkus-app/          Standard, schneller
                                      Classpath-Start
Uber-JAR        *-runner.jar          Einzelne JAR-Datei,
                                      einfaches Deployment
Native Image    *-runner               GraalVM-Binary,
                                      minimaler Speicher,
                                      schnellster Start</code></pre>
                </div>
Die Konfiguration erfolgt über eine einzige Property in der
<span class='latex-texttt'>application.properties</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:packaging-config'></a>                     <pre><code># Packaging-Modus waehlen
# Optionen: fast-jar (Standard), uber-jar, native
quarkus.package.type=fast-jar

# Uber-JAR aktivieren:
# quarkus.package.type=uber-jar

# Native Image aktivieren:
# quarkus.package.type=native</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Der <span class='latex-texttt'>fast-jar</span>-Modus ist der empfohlene Standard
für Containerisierung. Er bietet schnelleren Classpath-Scan als Uber-JAR
und erzeugt ein strukturiertes Verzeichnis, das sich ideal für
Docker-Layer-Caching eignet.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.2'><span class='entry-number'>14.2</span> Docker Multi-Stage Builds</a> </h2>
Ein Multi-Stage Dockerfile trennt den Build-Prozess von der Laufzeitumgebung.
Der erste Stage kompiliert die Anwendung mit Maven, der zweite erstellt
ein schlankes Laufzeit-Image:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:dockerfile-jvm'></a>                     <pre><code># Stage 1: Build
FROM maven:3.9-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -B package -DskipTests

# Stage 2: Runtime
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build \
    /app/target/quarkus-app /app
EXPOSE 8080
CMD ["java", "-jar", "quarkus-run.jar"]</code></pre>
                </div>
Für Native Images ändert sich der Build-Stage zu einem GraalVM-basierten Image,
und die Laufzeitumgebung reduziert sich auf ein minimales Betriebssystem:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:dockerfile-native'></a>                     <pre><code># Stage 1: Native Build
FROM quay.io/quarkus/ubi-quarkus-graalvmce-builder-image:jdk-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -B package -Dnative -DskipTests

# Stage 2: Native Runtime
FROM quay.io/quarkus/quarkus-micro-image:2.0
WORKDIR /app
COPY --from=build \
    /app/target/*-runner /app/application
EXPOSE 8080
CMD ["./application"]</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Multi-Stage Builds halten das finale Image schlank:
Das JVM-Image basiert auf Alpine (~200 MB), das Native-Image auf
<span class='latex-texttt'>quarkus-micro-image</span> (~30 MB). Build-Tools wie Maven
und GraalVM sind nur im Build-Stage enthalten und nicht im
finalen Produktions-Image.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.3'><span class='entry-number'>14.3</span> Quarkus + Angular in einem Image</a> </h2>
Mit der Quarkus-Extension <span class='latex-texttt'>quarkus-quinoa</span> (Kapitel 11) lassen sich
Backend und Frontend in einem einzigen Artefakt zusammenführen.
Quinoa baut das Angular-Frontend automatisch während des Quarkus-Builds
und integriert die statischen Dateien in das Quarkus-Artefakt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:quinoa-config'></a>                     <pre><code># Quinoa-Konfiguration
quarkus.quinoa.enable=true
quarkus.quinoa.build-dir=dist/ideafork-frontend
quarkus.quinoa.package-manager-install=true
quarkus.quinoa.package-manager-install\
    .node-version=20.11.0</code></pre>
                </div>
Das Dockerfile für die Full-Stack-Anwendung nutzt einen einzigen Build-Stage,
da Quinoa sowohl Frontend als auch Backend in einem Maven-Build vereint:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:dockerfile-fullstack'></a>                     <pre><code># Full-Stack Build (Quarkus + Angular)
FROM maven:3.9-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -B package -DskipTests \
    -Dquarkus.quinoa.enable=true

# Runtime
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build \
    /app/target/quarkus-app /app
EXPOSE 8080
CMD ["java", "-jar", "quarkus-run.jar"]</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Quinoa übernimmt die gesamte Frontend-Build-Pipeline &mdash;
<span class='latex-texttt'>npm install</span>, <span class='latex-texttt'>ng build</span> und die
Integration der statischen Dateien in das Quarkus-Artefakt.
Das Ergebnis ist ein einziges Docker-Image, das sowohl die REST-API
als auch das Angular-Frontend ausliefert.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>Quinoa erwartet das Angular-Projekt
in einem bestimmten Unterverzeichnis (standardmäßig <span class='latex-texttt'>src/main/webui</span>).
Stellen Sie sicher, dass die Verzeichnisstruktur korrekt konfiguriert ist,
bevor Sie den Build starten. Die Property
<span class='latex-texttt'>quarkus.quinoa.ui-dir</span> ermöglicht die Anpassung
des Verzeichnispfads.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.4'><span class='entry-number'>14.4</span> MicroProfile Health Checks</a> </h2>
Kubernetes benötigt Health Checks, um den Zustand der Anwendung zu überwachen.
MicroProfile Health definiert zwei Arten von Checks:
<span class='latex-texttt'>@Liveness</span> (ist die Anwendung grundsätzlich lebendig?)
und <span class='latex-texttt'>@Readiness</span> (ist die Anwendung bereit, Requests zu verarbeiten?).
<br /> <p style="margin:0 !important; line-height:normal !important;">&nbsp;</p>
Ein einfacher Liveness-Check bestätigt, dass die Anwendung läuft:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:health-check-custom'></a>                     <pre><code>@Liveness
@ApplicationScoped
public class IdeaForkLivenessCheck
        implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse
            .named("ideafork-alive")
            .up()
            .build();
    }
}</code></pre>
                </div>
Ein Readiness-Check prüft externe Abhängigkeiten wie die Datenbankverbindung:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:health-check-database'></a>                     <pre><code>@Readiness
@ApplicationScoped
public class DatabaseReadinessCheck
        implements HealthCheck {

    @Inject
    IdeaRepository ideaRepository;

    @Override
    public HealthCheckResponse call() {
        try {
            ideaRepository.findAll();
            return HealthCheckResponse
                .named("database")
                .up()
                .build();
        } catch (Exception e) {
            return HealthCheckResponse
                .named("database")
                .down()
                .build();
        }
    }
}</code></pre>
                </div>
Die Health-Endpunkte werden automatisch unter
<span class='latex-texttt'>/q/health/live</span> und
<span class='latex-texttt'>/q/health/ready</span> bereitgestellt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:health-config'></a>                     <pre><code># Health Check Konfiguration
quarkus.smallrye-health.root-path=/q/health
# Automatische Health-Endpunkte:
# /q/health/live   -- Liveness
# /q/health/ready  -- Readiness
# /q/health        -- Alle Checks</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Quarkus stellt automatisch grundlegende Health Checks bereit
(z.B. für Datasource-Verbindungen). Benutzerdefinierte Checks ergänzen
diese Standardprüfungen. In Kubernetes werden die Endpunkte direkt
als <span class='latex-texttt'>livenessProbe</span> und
<span class='latex-texttt'>readinessProbe</span> im Pod-Manifest referenziert.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.5'><span class='entry-number'>14.5</span> MicroProfile Metrics / Micrometer</a> </h2>
Quarkus verwendet Micrometer als Standard-Metrik-Framework.
Durch Annotationen wie <span class='latex-texttt'>@Timed</span> und
<span class='latex-texttt'>@Counted</span> lassen sich Endpunkte instrumentieren,
ohne den Geschäftscode zu verändern:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:micrometer-timed'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class MeteredIdeaResource {

    @Inject
    IdeaService ideaService;

    @GET
    @Timed(value = "ideas.list",
           description = "Time to list ideas")
    @Counted(value = "ideas.list.count",
             description = "List request count")
    public List&lt;Idea&gt; getAll() {
        return ideaService.findAll();
    }
}</code></pre>
                </div>
Die Metriken werden im Prometheus-Format unter
<span class='latex-texttt'>/q/metrics</span> bereitgestellt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:metrics-config'></a>                     <pre><code># Micrometer Konfiguration
quarkus.micrometer.enabled=true
quarkus.micrometer.export.prometheus.enabled=true
# Endpunkt: /q/metrics</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Micrometer ist das Standard-Metrik-Framework in Quarkus
und ersetzt die ältere MicroProfile Metrics API.
Es unterstützt verschiedene Monitoring-Systeme
(Prometheus, Grafana, Datadog) über austauschbare Registries &mdash;
der Anwendungscode bleibt dabei unverändert.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.6'><span class='entry-number'>14.6</span> Distributed Tracing (OpenTelemetry)</a> </h2>
OpenTelemetry ermöglicht es, einen Request über alle Schichten der Anwendung zu verfolgen &mdash;
vom Angular-Frontend über den Quarkus-REST-Endpunkt bis zur Datenbankabfrage.
Quarkus instrumentiert JAX-RS-Endpunkte automatisch; für feinere Kontrolle
können eigene Spans erzeugt werden:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:otel-custom-span'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class TracedIdeaResource {

    @Inject
    Tracer tracer;

    @Inject
    IdeaService ideaService;

    @GET
    @Path("/{id}")
    public Idea getById(@PathParam("id") Long id) {
        Span span = tracer.spanBuilder("findIdea")
            .startSpan();
        try {
            span.setAttribute("idea.id",
                String.valueOf(id));
            return ideaService.findAll().stream()
                .findFirst()
                .orElse(null);
        } finally {
            span.end();
        }
    }
}</code></pre>
                </div>
Die OpenTelemetry-Konfiguration verbindet die Anwendung mit einem
Tracing-Backend wie Jaeger:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:otel-config'></a>                     <pre><code># OpenTelemetry Konfiguration
quarkus.otel.enabled=true
quarkus.otel.exporter.otlp.endpoint=\
    http://localhost:4317
quarkus.otel.service.name=ideafork
quarkus.otel.resource.attributes=\
    deployment.environment=production</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Quarkus instrumentiert JAX-RS-Endpunkte, REST-Clients
und JDBC-Aufrufe automatisch &mdash; ohne Code-Änderungen.
Eigene Spans sind nur für geschäftslogik-spezifische Messpunkte nötig.
Die Traces können in Jaeger visualisiert werden und machen
die Service-Kommunikation von <span class='latex-textit'>IdeaFork</span> sichtbar.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.7'><span class='entry-number'>14.7</span> Structured Logging</a> </h2>
In einer containerisierten Umgebung werden Logs typischerweise von
einem Log-Aggregator (ELK Stack, Loki) gesammelt.
Strukturierte JSON-Logs ermöglichen dabei eine effiziente Filterung und Suche:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:structured-log-resource'></a>                     <pre><code>@Path("/api/ideas")
@ApplicationScoped
public class LoggedIdeaResource {

    private static final Logger LOG =
        Logger.getLogger(LoggedIdeaResource.class);

    @Inject
    IdeaService ideaService;

    @GET
    public List&lt;Idea&gt; getAll() {
        LOG.info("Listing all ideas");
        List&lt;Idea&gt; ideas = ideaService.findAll();
        LOG.infof("Found %d ideas", ideas.size());
        return ideas;
    }
}</code></pre>
                </div>
Die Umstellung auf JSON-Format erfolgt über eine einzige Property:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:logging-config'></a>                     <pre><code># Structured JSON Logging
quarkus.log.console.json=true
quarkus.log.console.json.pretty-print=false
# Ergebnis:
# {"timestamp":"...","level":"INFO",
#  "message":"Found 42 ideas",
#  "loggerName":"...LoggedIdeaResource",
#  "traceId":"abc123..."}</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>JSON-Logs enthalten automatisch die OpenTelemetry-Trace-ID,
wenn <span class='latex-texttt'>quarkus-opentelemetry</span> aktiv ist.
Damit lassen sich Log-Einträge direkt mit den zugehörigen Traces
korrelieren &mdash; ein wesentlicher Vorteil für die Fehlersuche
in verteilten Systemen.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.8'><span class='entry-number'>14.8</span> Kubernetes Deployment</a> </h2>
Die Quarkus-Extension <span class='latex-texttt'>quarkus-kubernetes</span> generiert
automatisch Kubernetes-Manifeste aus den Anwendungseigenschaften.
Die Konfiguration erfolgt über Standard-Properties:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:k8s-config'></a>                     <pre><code># Kubernetes Extension Konfiguration
quarkus.kubernetes.deploy=false
quarkus.kubernetes.name=ideafork
quarkus.kubernetes.namespace=ideafork-prod
quarkus.kubernetes.replicas=2
quarkus.kubernetes.image-pull-policy=always
quarkus.kubernetes.service-type=cluster-ip
quarkus.kubernetes.env.configmaps=ideafork-config
quarkus.kubernetes.ports.http.host-port=8080</code></pre>
                </div>
Das resultierende Deployment-Manifest enthält automatisch die Health-Check-Probes
und die Umgebungskonfiguration:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:k8s-deployment'></a>                     <pre><code># Generiertes Kubernetes Deployment (Auszug)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ideafork
  namespace: ideafork-prod
spec:
  replicas: 2
  template:
    spec:
      containers:
      - name: ideafork
        image: ideafork:latest
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /q/health/live
            port: 8080
        readinessProbe:
          httpGet:
            path: /q/health/ready
            port: 8080
        envFrom:
        - configMapRef:
            name: ideafork-config</code></pre>
                </div>
Umgebungsspezifische Konfiguration wird über Kubernetes ConfigMaps
vom Anwendungscode getrennt:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:k8s-configmap'></a>                     <pre><code># ConfigMap fuer IdeaFork
apiVersion: v1
kind: ConfigMap
metadata:
  name: ideafork-config
  namespace: ideafork-prod
data:
  QUARKUS_DATASOURCE_JDBC_URL: \
    jdbc:postgresql://db:5432/ideafork
  QUARKUS_OIDC_AUTH_SERVER_URL: \
    https://keycloak.example.com/realms/ideafork
  IDEAFORK_GREETING: "Willkommen"
  IDEAFORK_MAX_RESULTS: "500"</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Quarkus generiert die Kubernetes-Manifeste automatisch
unter <span class='latex-texttt'>target/kubernetes/</span>. Die Health-Check-Probes
aus Abschnitt 14.4 werden direkt in das Deployment integriert.
Umgebungsspezifische Werte (Datenbank-URL, OIDC-Konfiguration)
werden über ConfigMaps injiziert &mdash; der Anwendungscode liest
sie automatisch über MicroProfile Config.</div>
Damit die ConfigMap-Werte in der Anwendung verfügbar sind,
genügt die Standard-Annotation <span class='latex-texttt'>@ConfigProperty</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:config-resource'></a>                     <pre><code>@Path("/api/config")
@ApplicationScoped
public class ConfigResource {

    @ConfigProperty(name = "ideafork.greeting",
                    defaultValue = "Hello")
    String greeting;

    @ConfigProperty(name = "ideafork.max-results",
                    defaultValue = "100")
    int maxResults;

    @GET
    public String getConfig() {
        return greeting
            + " (max: " + maxResults + ")";
    }
}</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.9'><span class='entry-number'>14.9</span> Native Image in der Produktion</a> </h2>
Kapitel 10 hat die Grundlagen der Native-Image-Kompilierung behandelt.
In der Produktionsumgebung zeigt sich der konkrete Nutzen &mdash;
insbesondere bei Startzeit und Speicherverbrauch:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:native-build-config'></a>                     <pre><code># Native Image Build-Konfiguration
quarkus.package.type=native
quarkus.native.container-build=true
quarkus.native.builder-image=\
    quay.io/quarkus/ubi-quarkus-graalvmce-builder-image:jdk-21
quarkus.native.additional-build-args=\
    -H:+ReportExceptionStackTraces</code></pre>
                </div>
Der Vergleich zwischen JVM- und Native-Modus zeigt deutliche Unterschiede:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:native-benchmark'></a>                     <pre><code>IdeaFork Benchmark: JVM vs. Native
======================================

Metrik              JVM-Modus     Native
----------------------------------------------
Startzeit           ~2.5 s        ~0.05 s
Speicher (RSS)      ~250 MB       ~50 MB
Docker-Image        ~350 MB       ~80 MB
Build-Zeit          ~30 s         ~5 min
Durchsatz (Req/s)   ~12.000       ~10.000
Erster Request      ~50 ms        ~5 ms</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Native Images sind ideal für Serverless-Szenarien (AWS Lambda,
Azure Functions) und Kubernetes-Umgebungen mit häufigem Scaling,
wo schnelle Startzeiten entscheidend sind. Für langlebige Services
mit hohem Durchsatz kann der JVM-Modus durch JIT-Optimierung
leichte Vorteile im Steady-State-Durchsatz bieten.</div>
<div class="tip" style="background:#fff3cd; border-left-color:#ffc107;"><b>Warnung: </b>Nicht alle Bibliotheken sind
vollständig mit Native Image kompatibel. Reflection, dynamische Proxies
und bestimmte Serialisierungs-Frameworks erfordern explizite
GraalVM-Konfiguration. Quarkus-Extensions sind in der Regel
native-kompatibel; bei Drittanbieter-Bibliotheken sollte die
Kompatibilität vor dem Produktionseinsatz getestet werden.</div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.10'><span class='entry-number'>14.10</span> IdeaFork Produktions-Checkliste</a> </h2>
Die folgende Übersicht fasst den gesamten Produktions-Stack zusammen,
der in diesem Kapitel aufgebaut wurde:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:production-stack-overview'></a>                     <pre><code>IdeaFork Produktions-Stack
======================================

Schicht          Technologie
----------------------------------------------
Packaging        Quarkus Fast JAR / Native
Container        Docker Multi-Stage Build
Frontend         Angular via Quinoa
Health           MicroProfile Health
Metriken         Micrometer + Prometheus
Tracing          OpenTelemetry + Jaeger
Logging          JSON Structured Logging
Deployment       Kubernetes + ConfigMaps
Sicherheit       OIDC + CORS + CSP (Kap. 13)</code></pre>
                </div>
<div class="tip"><b>Tipp: </b>Der Weg in die Produktion kann schrittweise erfolgen:
Zuerst die Anwendung containerisieren (Dockerfile),
dann Health Checks und Metriken ergänzen (Observability),
und schließlich auf Kubernetes deployen.
Jeder Schritt bringt eigenständigen Mehrwert.</div>
Die vollständige Migrations-Checkliste für <span class='latex-textit'>IdeaFork</span>:
<div class='latex-begin-block'> <a class='latex-index-anchor' name = '!idx:/cloud.html:fig:production-checklist'></a>                     <pre><code>IdeaFork Produktions-Checkliste
=========================================
[ ] Docker Multi-Stage Build konfiguriert
[ ] Quinoa fuer Angular-Integration aktiviert
[ ] Liveness- und Readiness-Checks implementiert
[ ] Micrometer-Metriken aktiviert
[ ] OpenTelemetry-Tracing konfiguriert
[ ] JSON Structured Logging aktiviert
[ ] Kubernetes-Manifeste generiert
[ ] ConfigMaps fuer Umgebungskonfiguration
[ ] TLS/HTTPS aktiviert
[ ] CORS auf Produktions-Domains (Kap. 13)
[ ] Rate-Limiting konfiguriert
[ ] Graceful Shutdown aktiviert
[ ] Native Image getestet (optional)
[ ] Monitoring-Dashboard eingerichtet</code></pre>
                </div>
<br /> <h2><a class='latex-index-anchor' name='!idx:/cloud.html:14.11'><span class='entry-number'>14.11</span> Quellen</a> </h2>
- quarkus.io/guides/building-native-image<br />
- quarkus.io/guides/container-image<br />
- quarkus.io/guides/quinoa<br />
- quarkus.io/guides/smallrye-health<br />
- quarkus.io/guides/micrometer<br />
- quarkus.io/guides/opentelemetry<br />
- quarkus.io/guides/logging<br />
- quarkus.io/guides/deploying-to-kubernetes<br />
- graalvm.org/latest/reference-manual/native-image<br />
- kubernetes.io/docs/concepts/configuration/configmap<br />
</section>

    </div>
  </main>

  <script>
    (function() {
      'use strict';

      // --- Scroll Spy ---
      var tocLinks = document.querySelectorAll('#toc a');
      var headingElements = [];

      tocLinks.forEach(function(link) {
        var id = decodeURIComponent(link.getAttribute('href').slice(1));
        // Anchors use name attributes, not id
        var target = document.querySelector('a[name="' + CSS.escape(id) + '"]');
        if (target) {
          headingElements.push({ el: target, link: link });
        }
      });

      var activeLink = null;

      function updateScrollSpy() {
        var scrollTop = window.scrollY + 120;
        var current = null;

        for (var i = 0; i < headingElements.length; i++) {
          if (headingElements[i].el.offsetTop <= scrollTop) {
            current = headingElements[i];
          }
        }

        if (current && current.link !== activeLink) {
          if (activeLink) {
            activeLink.classList.remove('active');
          }
          current.link.classList.add('active');
          activeLink = current.link;

          // Expand parent chapter in TOC
          document.querySelectorAll('.toc-chapter').forEach(function(ch) {
            ch.classList.remove('expanded');
          });
          var parentChapter = current.link.closest('.toc-chapter');
          if (parentChapter) {
            parentChapter.classList.add('expanded');
            // Scroll TOC to keep active link visible
            var toc = document.getElementById('toc');
            var linkRect = current.link.getBoundingClientRect();
            var tocRect = toc.getBoundingClientRect();
            if (linkRect.top < tocRect.top || linkRect.bottom > tocRect.bottom) {
              current.link.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
          }
        }
      }

      var scrollTimer;
      window.addEventListener('scroll', function() {
        if (scrollTimer) cancelAnimationFrame(scrollTimer);
        scrollTimer = requestAnimationFrame(updateScrollSpy);
      });
      updateScrollSpy();

      // --- Smooth scroll on TOC click ---
      tocLinks.forEach(function(link) {
        link.addEventListener('click', function(e) {
          var id = decodeURIComponent(this.getAttribute('href').slice(1));
          var target = document.querySelector('a[name="' + CSS.escape(id) + '"]');
          if (target) {
            e.preventDefault();
            var top = target.offsetTop - 30;
            window.scrollTo({ top: top, behavior: 'smooth' });
            // Close mobile sidebar
            document.querySelector('.sidebar').classList.remove('open');
            document.querySelector('.overlay').classList.remove('active');
          }
        });
      });

      // --- Chapter heading click to expand/collapse in TOC ---
      document.querySelectorAll('.toc-chapter > a.toc-h1').forEach(function(link) {
        link.addEventListener('click', function() {
          var parent = this.parentElement;
          // Toggle only if already expanded (navigation still happens via smooth scroll)
          document.querySelectorAll('.toc-chapter').forEach(function(ch) {
            if (ch !== parent) ch.classList.remove('expanded');
          });
          parent.classList.add('expanded');
        });
      });

      // --- Mobile toggle ---
      var hamburger = document.querySelector('.hamburger');
      var sidebar = document.querySelector('.sidebar');
      var overlay = document.querySelector('.overlay');

      if (hamburger) {
        hamburger.addEventListener('click', function() {
          sidebar.classList.toggle('open');
          overlay.classList.toggle('active');
        });
      }

      if (overlay) {
        overlay.addEventListener('click', function() {
          sidebar.classList.remove('open');
          overlay.classList.remove('active');
        });
      }
    })();
    
  </script>
</body>
</html>